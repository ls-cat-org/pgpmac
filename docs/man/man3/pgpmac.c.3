.TH "pgpmac.c" 3 "Fri Dec 14 2012" "LS-CAT PGPMAC" \" -*- nroff -*-
.ad l
.nh
.SH NAME
pgpmac.c \- 
.PP
Main for the pgpmac project\&.  

.SH SYNOPSIS
.br
.PP
\fC#include 'pgpmac\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBstdinService\fP (struct pollfd *evt)"
.br
.RI "\fIHandle keyboard input\&. \fP"
.ti -1c
.RI "void \fBpgpmac_printf\fP (char *fmt,\&.\&.\&.)"
.br
.RI "\fITerminal output routine ala printf\&. \fP"
.ti -1c
.RI "int \fBmain\fP (int argc, char **argv)"
.br
.RI "\fIOur main routine\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "WINDOW * \fBterm_output\fP"
.br
.RI "\fIplace to print stuff out \fP"
.ti -1c
.RI "WINDOW * \fBterm_input\fP"
.br
.RI "\fIplace to put the cursor \fP"
.ti -1c
.RI "WINDOW * \fBterm_status\fP"
.br
.RI "\fIshutter, lamp, air, etc status \fP"
.ti -1c
.RI "WINDOW * \fBterm_status2\fP"
.br
.RI "\fIshutter, lamp, air, etc status \fP"
.ti -1c
.RI "pthread_mutex_t \fBncurses_mutex\fP"
.br
.RI "\fIallow more than one thread access to the screen \fP"
.ti -1c
.RI "static struct pollfd \fBstdinfda\fP"
.br
.RI "\fIHandle input from the keyboard\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Main for the pgpmac project\&. 

\fBDate:\fP
.RS 4
2012 
.RE
.PP
\fBAuthor:\fP
.RS 4
Keith Brister 
.RE
.PP
\fBCopyright:\fP
.RS 4
All Rights Reserved 
.RE
.PP

.PP
Definition in file \fBpgpmac\&.c\fP\&.
.SH "Function Documentation"
.PP 
.SS "int main (intargc, char **argv)"

.PP
Our main routine\&. \fBParameters:\fP
.RS 4
\fIargc\fP Number of arguments 
.br
\fIargv\fP Vector of argument strings 
.RE
.PP

.PP
Definition at line 349 of file pgpmac\&.c\&.
.PP
.nf
           {
  static nfds_t nfds;

  static struct pollfd fda[3], *fdp;    // input for poll: room for postgres, pmac, and stdin
  static int nfd = 0;                   // number of items in fda
  static int pollrtn = 0;
  static struct option long_options[] = {
    { 'i-vars', 0, NULL, 'i'},
    { 'm-vars', 0, NULL, 'm'},
    { NULL,     0, NULL, 0}
  };
  int c;
  int ivars, mvars;
  mvars=0;
  ivars=0;

  int i;                                // standard loop counter

  while( 1) {
    c=getopt_long( argc, argv, 'im', long_options, NULL);
    if( c == -1)
      break;

    switch( c) {
    case 'i':
      ivars=1;
      break;

    case 'm':
      mvars=1;
      break;

    }
  }

  stdinfda\&.fd = 0;
  stdinfda\&.events = POLLIN;

  initscr();                            // Start ncurses
  raw();                                // Line buffering disabled, control chars trapped
  keypad( stdscr, TRUE);                // Why is F1 nifty?
  refresh();

  pthread_mutex_init( &ncurses_mutex, NULL);    // don't lock this mutex yet because we are not multi-threaded until the '_run' functions

  //
  // Since the modules reference objects in other modules it is important
  // that everyone is initiallized before anyone runs
  //
  lslogging_init();
  lsevents_init();
  lsredis_init( 'MD2-21-ID-E', 'redis\\\&.kvseq|stns\\\&.2\\\&.(\&.+)', 'stns\&.2');
  lstimer_init();
  lspmac_init( ivars, mvars);
  lspg_init();
  //  lsupdate_init();
  lskvs_init();
  md2cmds_init();

  term_status = newwin( LS_DISPLAY_WINDOW_HEIGHT, LS_DISPLAY_WINDOW_WIDTH, 3*LS_DISPLAY_WINDOW_HEIGHT, 0*LS_DISPLAY_WINDOW_WIDTH);
  box( term_status, 0, 0);
  wnoutrefresh( term_status);
                                                      
  term_status2 = newwin( LS_DISPLAY_WINDOW_HEIGHT, LS_DISPLAY_WINDOW_WIDTH, 3*LS_DISPLAY_WINDOW_HEIGHT, 1*LS_DISPLAY_WINDOW_WIDTH);
  box( term_status2, 0, 0);
  wnoutrefresh( term_status2);
                                                      
  term_output = newwin( 20, 5*LS_DISPLAY_WINDOW_WIDTH, 4*LS_DISPLAY_WINDOW_HEIGHT, 0);
  scrollok( term_output, 1);                          
  wnoutrefresh( term_output);                         
                                                      
  term_input  = newwin( 3, 5*LS_DISPLAY_WINDOW_WIDTH, 20+4*LS_DISPLAY_WINDOW_HEIGHT, 0);
  box( term_input, 0, 0);                             
  mvwprintw( term_input, 1, 1, 'PMAC> ');             
  nodelay( term_input, TRUE);                         
  keypad( term_input, TRUE);                          
  wnoutrefresh( term_input);                          
                                                      
  doupdate();                                         

  lslogging_run();
  lsevents_run();
  lsredis_run();
  lstimer_run();
  lspmac_run();
  lspg_run();
  //  lsupdate_run();
  md2cmds_run();

  while( 1) {
    //
    // Big loop
    //

    nfd = 0;

    //
    // keyboard
    //
    memcpy( &(fda[nfd++]), &stdinfda, sizeof( struct pollfd));
    

    if( nfd == 0) {
      //
      // No connectons yet\&.  Wait a bit and try again\&.
      //
      sleep( 10);
      //
      // go try to connect again
      //
      continue;
    }


    pollrtn = poll( fda, nfd, 10);

    for( i=0; pollrtn>0 && i<nfd; i++) {
      if( fda[i]\&.revents) {
        pollrtn--;
        if( fda[i]\&.fd == 0) {
          stdinService( &fda[i]);
        }
      }
    }
  }
}
.fi
.SS "void pgpmac_printf (char *fmt, \&.\&.\&.)"

.PP
Terminal output routine ala printf\&. \fBParameters:\fP
.RS 4
\fIfmt\fP Printf style formating string 
.RE
.PP

.PP
Definition at line 326 of file pgpmac\&.c\&.
.PP
.nf
                     {
  va_list arg_ptr;

  pthread_mutex_lock( &ncurses_mutex);

  va_start( arg_ptr, fmt);
  vwprintw( term_output, fmt, arg_ptr);
  va_end( arg_ptr);

  wnoutrefresh( term_output);
  wnoutrefresh( term_input);
  doupdate();

  pthread_mutex_unlock( &ncurses_mutex);

}
.fi
.SS "void stdinService (struct pollfd *evt)"

.PP
Handle keyboard input\&. \fBParameters:\fP
.RS 4
\fIevt\fP The pollfd object that caused this call 
.RE
.PP

.PP
Definition at line 254 of file pgpmac\&.c\&.
.PP
.nf
                    {
  static char cmds[1024];
  static char cntrlcmd[2];
  static char cmds_on = 0;
  int ch;


  for( ch=wgetch(term_input); ch != ERR; ch=wgetch(term_input)) {
    // wprintw( term_output, '%04x\n', ch);
    // wnoutrefresh( term_output);

    switch( ch) {
    case KEY_F(1):
      endwin();
      exit(0);
      break;

    case 0x0001:        // Control-A
    case 0x0002:        // Control-B
    case 0x0003:        // Control-C
    case 0x0004:        // Control-D
    case 0x0005:        // Control-E
    case 0x0006:        // Control-F
    case 0x0007:        // Control-G
    case 0x000b:        // Control-K
    case 0x000f:        // Control-O
    case 0x0010:        // Control-P
    case 0x0011:        // Control-Q
    case 0x0012:        // Control-R
    case 0x0013:        // Control-Q
    case 0x0016:        // Control-V
      cntrlcmd[0] = ch;
      cntrlcmd[1] = 0;
      lspmac_SockSendline( cntrlcmd);
      //      PmacSockSendControlCharPrint( ch);
      break;

    case KEY_BACKSPACE:
      cmds[cmds_on] = 0;
      cmds_on == 0 ? 0 : cmds_on--;
      break;
      
    case KEY_ENTER:
    case 0x000a:
      if( cmds_on > 0 && strlen( cmds) > 0) {
        lspmac_SockSendline( cmds);
      }
      memset( cmds, 0, sizeof(cmds));
      cmds_on = 0;
      break;
      
    default:
      if( cmds_on < sizeof( cmds)-1) {
        cmds[cmds_on++] = ch;
        cmds[cmds_on] = 0;
      }
      break;
    }
    
    mvwprintw( term_input, 1, 1, 'PMAC> %s', cmds);
    wclrtoeol( term_input);
    box( term_input, 0, 0);
    wnoutrefresh( term_input);
    doupdate();

  }
}
.fi
.SH "Variable Documentation"
.PP 
.SS "pthread_mutex_t ncurses_mutex"

.PP
allow more than one thread access to the screen 
.PP
Definition at line 242 of file pgpmac\&.c\&.
.SS "struct pollfd stdinfda\fC [static]\fP"

.PP
Handle input from the keyboard\&. 
.PP
Definition at line 248 of file pgpmac\&.c\&.
.SS "WINDOW* term_input"

.PP
place to put the cursor 
.PP
Definition at line 238 of file pgpmac\&.c\&.
.SS "WINDOW* term_output"

.PP
place to print stuff out 
.PP
Definition at line 237 of file pgpmac\&.c\&.
.SS "WINDOW* term_status"

.PP
shutter, lamp, air, etc status 
.PP
Definition at line 239 of file pgpmac\&.c\&.
.SS "WINDOW* term_status2"

.PP
shutter, lamp, air, etc status 
.PP
Definition at line 240 of file pgpmac\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for LS-CAT PGPMAC from the source code\&.
