<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LS-CAT PGPMAC: lspg.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lspg.c File Reference</h1>
<p>Postgresql support for the LS-CAT pgpmac project.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="pgpmac_8h_source.html">pgpmac.h</a>&quot;</code><br/>

<p><a href="lspg_8c_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlspgQueryQueueStruct.html">lspgQueryQueueStruct</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store each query along with it's callback function.  <a href="structlspgQueryQueueStruct.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlspg__wait__for__detector__struct.html">lspg_wait_for_detector_struct</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object that implements detector / spindle timing We use database locks for exposure control and this implements the md2 portion of this handshake.  <a href="structlspg__wait__for__detector__struct.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlspg__lock__diffractometer__struct.html">lspg_lock_diffractometer_struct</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object used to impliment locking the diffractometer Critical to exposure timing.  <a href="structlspg__lock__diffractometer__struct.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlspg__lock__detector__struct.html">lspg_lock_detector_struct</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">lock detector object Implements detector lock for exposure control  <a href="structlspg__lock__detector__struct.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlspg__seq__run__prep__struct.html">lspg_seq_run_prep_struct</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data collection running object.  <a href="structlspg__seq__run__prep__struct.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#af443092447378c73bf93aa143576aba4">LS_PG_STATE_INIT</a>&nbsp;&nbsp;&nbsp;-4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ae7ea5876846b5f04c419aee22d3c0aa1">LS_PG_STATE_INIT_POLL</a>&nbsp;&nbsp;&nbsp;-3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#accda8c3a598dc7f5b107b04986d8ab50">LS_PG_STATE_RESET</a>&nbsp;&nbsp;&nbsp;-2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ac70a1141f3b138055ea7143bd493187c">LS_PG_STATE_RESET_POLL</a>&nbsp;&nbsp;&nbsp;-1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#aaf1dd8ba4dafb91c296554c4cbf312e3">LS_PG_STATE_IDLE</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a3c6eb19f262a990e1f9ba630d9edc309">LS_PG_STATE_SEND</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a88a7e80c12fb0449c4b0857a0c7deb21">LS_PG_STATE_SEND_FLUSH</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a373e668840b4795ff9a71bc3f744d209">LS_PG_STATE_RECV</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a08fe83fe8226002ee8b80ce0a914fd11">LS_PG_QUERY_QUEUE_LENGTH</a>&nbsp;&nbsp;&nbsp;256</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queue length should be long enough that we do not ordinarly bump into the end We should be safe as long as the thread the adds stuff to the queue is not the one that removes it.  <a href="#a08fe83fe8226002ee8b80ce0a914fd11"></a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structlspgQueryQueueStruct.html">lspgQueryQueueStruct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ae57432c0a6ac48a50457815dab2c5b4c">lspg_query_queue_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store each query along with it's callback function.  <a href="#ae57432c0a6ac48a50457815dab2c5b4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="structlspg__wait__for__detector__struct.html">lspg_wait_for_detector_struct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a6f273a499bf316de95df3816a9b1bc06">lspg_wait_for_detector_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object that implements detector / spindle timing We use database locks for exposure control and this implements the md2 portion of this handshake.  <a href="#a6f273a499bf316de95df3816a9b1bc06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="structlspg__lock__diffractometer__struct.html">lspg_lock_diffractometer_struct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a7232a0d630558f0c4c081d087150973d">lspg_lock_diffractometer_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object used to impliment locking the diffractometer Critical to exposure timing.  <a href="#a7232a0d630558f0c4c081d087150973d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="structlspg__lock__detector__struct.html">lspg_lock_detector_struct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a3442e66a1f05457eb22a0d4a5d295f3a">lspg_lock_detector_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">lock detector object Implements detector lock for exposure control  <a href="#a3442e66a1f05457eb22a0d4a5d295f3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="structlspg__seq__run__prep__struct.html">lspg_seq_run_prep_struct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ab2da550aea6388c835abe0ee0b226eb0">lspg_seq_run_prep_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data collection running object.  <a href="#ab2da550aea6388c835abe0ee0b226eb0"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ad5f3ec8f197cc330c83dba70f310533c">lspg_query_next</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next item in the postgresql queue.  <a href="#ad5f3ec8f197cc330c83dba70f310533c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a3847589e641f7e16a0cd68ef30e37cca">lspg_query_reply_next</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the oldest item in the queue.  <a href="#a3847589e641f7e16a0cd68ef30e37cca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ae6bf4f54117bedf903360883bb32699f">lspg_query_reply_peek</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next item in the reply queue but don't pop it since we may need it more than once.  <a href="#ae6bf4f54117bedf903360883bb32699f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4">lspg_query_push</a> (void(*cb)(<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *, PGresult *), char *fmt,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Place a query on the queue.  <a href="#a0bb9ef42da8fa21c4df48ec384ab69f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a46f23ae999129d6fd5712d7975b99aed">lspg_array2ptrs</a> (char *a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a null terminated list of strings parsed from postgresql array  <a href="#a46f23ae999129d6fd5712d7975b99aed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a329a7fdfa5025a403ea2779e178fd3ed">lspg_init_motors_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Motor initialization callback.  <a href="#a329a7fdfa5025a403ea2779e178fd3ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#af34559ab5624e1e68085dbcd9410c692">lspg_zoom_lut_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Zoom motor look up table callback.  <a href="#af34559ab5624e1e68085dbcd9410c692"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a71db585552ea3f58a1c9ab3fbe62bb79">lspg_scint_lut_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ac5d5d512350a9ba346635e2415d7c3d5">lspg_flight_lut_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Front Light Lookup table query callback Install the lookup table for the Front Light.  <a href="#ac5d5d512350a9ba346635e2415d7c3d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a6f5fa5727f2876f8b9370110a92afa50">lspg_blight_lut_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Back Light Lookup Table Callback Install the lookup table for the Back Light.  <a href="#a6f5fa5727f2876f8b9370110a92afa50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a9e92a204f606761d368ac7e06ef0f09c">lspg_nextshot_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Next Shot Callback.  <a href="#a9e92a204f606761d368ac7e06ef0f09c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#aff91db7d60e6c832684c023813e36dbf">lspg_nextshot_init</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the nextshot variable, mutex, and condition.  <a href="#aff91db7d60e6c832684c023813e36dbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#af17ef79544ca5d78fd477010fe90d538">lspg_nextshot_call</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queue up a nextshot query.  <a href="#af17ef79544ca5d78fd477010fe90d538"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a784a6de32a86fec9efb3ef3ae4b6e3ac">lspg_nextshot_wait</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the next shot query to get processed.  <a href="#a784a6de32a86fec9efb3ef3ae4b6e3ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a50458a014041a4118452802dfb303960">lspg_nextshot_done</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when the next shot query has been processed.  <a href="#a50458a014041a4118452802dfb303960"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a3517f8fbed91c998f6036284f9bd0c48">lspg_wait_for_detector_init</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">initialize the detector timing object  <a href="#a3517f8fbed91c998f6036284f9bd0c48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a5747c519d1aa4c310010a862cae8a823">lspg_wait_for_detector_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback for the wait for detector query.  <a href="#a5747c519d1aa4c310010a862cae8a823"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a4b5222b859a44eae616804a1e990b86d">lspg_wait_for_detector_call</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">initiate the wait for detector query  <a href="#a4b5222b859a44eae616804a1e990b86d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#af094e01be121ce8e14abb679abd17e19">lspg_wait_for_detector_wait</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pause the calling thread until the detector is ready Called by the MD2 thread.  <a href="#af094e01be121ce8e14abb679abd17e19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#abb3645dee7c4514b650ab02f27570a69">lspg_wait_for_detector_done</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Done waiting for the detector.  <a href="#abb3645dee7c4514b650ab02f27570a69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ab9780e15924a50b2a5545e10806000b3">lspg_wait_for_detector_all</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combined call to wait for the detector.  <a href="#ab9780e15924a50b2a5545e10806000b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a39bb94f8e0d47702b2b920a3dee61ebc">lspg_lock_diffractometer_init</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">initialize the diffractometer locking object  <a href="#a39bb94f8e0d47702b2b920a3dee61ebc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#aad4f378f37c0030634dafa0d9445d916">lspg_lock_diffractometer_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback routine for a lock diffractometer query.  <a href="#aad4f378f37c0030634dafa0d9445d916"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ac5ebeb38e8e9926a52f024fe76201175">lspg_lock_diffractometer_call</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request that the database grab the diffractometer lock.  <a href="#ac5ebeb38e8e9926a52f024fe76201175"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a8445e1dec753f2c517b87fcb9c5b5943">lspg_lock_diffractometer_wait</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the diffractometer lock.  <a href="#a8445e1dec753f2c517b87fcb9c5b5943"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a75aaf0b3fe33530062226c69a33ce821">lspg_lock_diffractometer_done</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finish up the lock diffractometer call.  <a href="#a75aaf0b3fe33530062226c69a33ce821"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a88b33e75c42197740b157a51ea726f21">lspg_lock_diffractometer_all</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convience function that combines lock diffractometer calls.  <a href="#a88b33e75c42197740b157a51ea726f21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a0e9bbf847dadfe0d10830d67824d9be8">lspg_lock_detector_init</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize detector lock object.  <a href="#a0e9bbf847dadfe0d10830d67824d9be8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#aa760191c2b443170cebbcbf5ea5345f3">lspg_lock_detector_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback for when the detector lock has be grabbed.  <a href="#aa760191c2b443170cebbcbf5ea5345f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a5f71a20cc297684b2afe28e7bd8e8383">lspg_lock_detector_call</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request (demand) a detector lock.  <a href="#a5f71a20cc297684b2afe28e7bd8e8383"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ad3d9c56bd3ca6bcc43db30872cc441cc">lspg_lock_detector_wait</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the detector lock.  <a href="#ad3d9c56bd3ca6bcc43db30872cc441cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a1b567040693ff6e2932a2477045d75fa">lspg_lock_detector_done</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finish waiting.  <a href="#a1b567040693ff6e2932a2477045d75fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#aff93d2f5ac31aa249a0bef40a3837c84">lspg_lock_detector_all</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detector lock convinence function.  <a href="#aff93d2f5ac31aa249a0bef40a3837c84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a31823ecb2b44d4a6674f804059a27bce">lspg_seq_run_prep_init</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the data collection object.  <a href="#a31823ecb2b44d4a6674f804059a27bce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a11cda12050dc9a86188e15e2155a6013">lspg_seq_run_prep_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback for the seq_run_prep query.  <a href="#a11cda12050dc9a86188e15e2155a6013"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#af7d6efd861b152a371442791deb42bd3">lspg_seq_run_prep_call</a> (long long skey, double <a class="el" href="pgpmac_8h.html#a0be79ccb7ebf3a665248fd856112b9fd">kappa</a>, double <a class="el" href="pgpmac_8h.html#ac8070dc568ad974a3db42b51eca828cc">phi</a>, double cx, double cy, double ax, double ay, double az)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">queue up the seq_run_prep query  <a href="#af7d6efd861b152a371442791deb42bd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ac0b01f501322432a8fa37f31898c3499">lspg_seq_run_prep_wait</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for seq run prep query to return.  <a href="#ac0b01f501322432a8fa37f31898c3499"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a472b09ddf716c80207f97e2bb5d37d66">lspg_seq_run_prep_done</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicate we are done waiting.  <a href="#a472b09ddf716c80207f97e2bb5d37d66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a4253474d4dd305aec0afdd5552b3ddd5">lspg_seq_run_prep_all</a> (long long skey, double <a class="el" href="pgpmac_8h.html#a0be79ccb7ebf3a665248fd856112b9fd">kappa</a>, double <a class="el" href="pgpmac_8h.html#ac8070dc568ad974a3db42b51eca828cc">phi</a>, double cx, double cy, double ax, double ay, double az)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convinence function to call seq run prep.  <a href="#a4253474d4dd305aec0afdd5552b3ddd5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a8184824f2b71b1d35141d7922ca69cd7">lspg_getcenter_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TODO: implement getcenter code.  <a href="#a8184824f2b71b1d35141d7922ca69cd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ad31db17587a02302ac4e40fb7d260b1b">lspg_getcenter_init</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize getcenter object.  <a href="#ad31db17587a02302ac4e40fb7d260b1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a6f7cd0a06f6a266ef65b3604cf33d6c4">lspg_getcenter_call</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request a getcenter query.  <a href="#a6f7cd0a06f6a266ef65b3604cf33d6c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a3e0e4b3cb9fa03961ee0c104e0b06754">lspg_getcenter_wait</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a getcenter query to return.  <a href="#a3e0e4b3cb9fa03961ee0c104e0b06754"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a7c678553b44c874d08ec9966ed7bb1c0">lspg_getcenter_done</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Done with getcenter query.  <a href="#a7c678553b44c874d08ec9966ed7bb1c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a523b492d9cd4970853eabee2d3c31578">lspg_getcenter_all</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function to complete synchronous getcenter query.  <a href="#a523b492d9cd4970853eabee2d3c31578"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#aeda8dad89b03d7d61cc994dd63ee5db6">lspg_nextaction_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queue the next MD2 instruction.  <a href="#aeda8dad89b03d7d61cc994dd63ee5db6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a1e11f525ca0f9ac9ab71f9fbe983c42b">lspg_cmd_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send strings directly to PMAC queue.  <a href="#a1e11f525ca0f9ac9ab71f9fbe983c42b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#af6485ac1749c5de3008dd0e0badaa09c">lspg_flush</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush psql output buffer (ie, send the query).  <a href="#af6485ac1749c5de3008dd0e0badaa09c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a714b15e117ffe7bfce4f2f2ce4725b0a">lspg_send_next_query</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">send the next queued query to the DB server  <a href="#a714b15e117ffe7bfce4f2f2ce4725b0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a038c5af23469b789fc1c55d21cb43029">lspg_receive</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a result of a query.  <a href="#a038c5af23469b789fc1c55d21cb43029"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a049f4422994aa2eb2b841ffb2937f895">lspg_sig_service</a> (struct pollfd *evt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Service a signal Signals here are treated as file descriptors and fits into our poll scheme.  <a href="#a049f4422994aa2eb2b841ffb2937f895"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#aa8d1fed4b461c2139a21826d524777d5">lspg_pg_service</a> (struct pollfd *evt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">I/O control to/from the postgresql server.  <a href="#aa8d1fed4b461c2139a21826d524777d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a581c18be0368425665a40b4b7f7d9714">lspg_pg_connect</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect to the pg server.  <a href="#a581c18be0368425665a40b4b7f7d9714"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ab52a8c8245bf6561f40c0f224fc07ff4">lspg_next_state</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implements our state machine Does not strictly only set the next state as it also calls some functions that, perhaps, alters the state mid-function.  <a href="#ab52a8c8245bf6561f40c0f224fc07ff4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#aaf4fadd2943fa3a2ecb5d840e84d68fa">lspg_worker</a> (void *dummy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The main loop for the lspg thread.  <a href="#aaf4fadd2943fa3a2ecb5d840e84d68fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a8a77972df14166e05c94ed0792baa09b">lspg_init</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initiallize the lspg module.  <a href="#a8a77972df14166e05c94ed0792baa09b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a1adfdb5ca9fdb5060849d726bf540117">lspg_run</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start 'er runnin'.  <a href="#a1adfdb5ca9fdb5060849d726bf540117"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1">ls_pg_state</a> = LS_PG_STATE_INIT</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">State of the lspg state machine.  <a href="#a4937baac0cc78ea306d58b5f027867f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct timeval <br class="typebreak"/>
lspg_time_sent&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ad40ac52086f6b774928af45b09d54c6e">now</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">used to ensure we do not inundate the db server with connection requests  <a href="#ad40ac52086f6b774928af45b09d54c6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static pthread_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a04eb0cda0d5e5afeae7c393b51689765">lspg_thread</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">our worker thread  <a href="#a04eb0cda0d5e5afeae7c393b51689765"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static pthread_mutex_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#aed46a94106c583796e3a8ca0e89aa8e4">lspg_queue_mutex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">keep the queue from getting tangled  <a href="#aed46a94106c583796e3a8ca0e89aa8e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static pthread_cond_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a61a308b6a37afd645beb422653b95baa">lspg_queue_cond</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">keeps the queue from overflowing  <a href="#a61a308b6a37afd645beb422653b95baa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct pollfd&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d">lspgfd</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">our poll info  <a href="#af3f897b8ffa020ca54289bc5b28cb64d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a357d9d98f0b8c9625ccebcebfcdce955">lspg_query_queue</a> [LS_PG_QUERY_QUEUE_LENGTH]</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Our query queue.  <a href="#a357d9d98f0b8c9625ccebcebfcdce955"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a3cbe7f3161b3c1838ebc56a3bbcfd8a6">lspg_query_queue_on</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Next position to add something to the queue.  <a href="#a3cbe7f3161b3c1838ebc56a3bbcfd8a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#aca86bb77d6cecfae9251743f4171bafb">lspg_query_queue_off</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The last item still being used (on == off means nothing in queue).  <a href="#aca86bb77d6cecfae9251743f4171bafb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a2603b071afdbff7c0924b13de2454264">lspg_query_queue_reply</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The current item being digested.  <a href="#a2603b071afdbff7c0924b13de2454264"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PGconn *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3">q</a> = NULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Database connector.  <a href="#a9012783dbbadf652a81649a289697cf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PostgresPollingStatusType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a69ae04978986e6413ca7cefcb692b645">lspg_connectPoll_response</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to determine state while connecting.  <a href="#a69ae04978986e6413ca7cefcb692b645"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PostgresPollingStatusType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a06c5a937e41a6c706a247777642ec1fb">lspg_resetPoll_response</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to determine state while reconnecting.  <a href="#a06c5a937e41a6c706a247777642ec1fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlspg__nextshot__struct.html">lspg_nextshot_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd">lspg_nextshot</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the nextshot object  <a href="#ad8d8e2f578ca79189a80c1fd5b60cefd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlspg__getcenter__struct.html">lspg_getcenter_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36">lspg_getcenter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the getcenter object  <a href="#a7ef8a09203117578c9b2ce4719519f36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlspg__wait__for__detector__struct.html">lspg_wait_for_detector_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58">lspg_wait_for_detector</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instance of the detector timing object.  <a href="#a0dfc8d0410cd2d7f7da7a70d3ef88e58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlspg__lock__diffractometer__struct.html">lspg_lock_diffractometer_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlspg__lock__detector__struct.html">lspg_lock_detector_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlspg__seq__run__prep__struct.html">lspg_seq_run_prep_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Postgresql support for the LS-CAT pgpmac project. </p>
<dl class="date"><dt><b>Date:</b></dt><dd>2012 </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Keith Brister  All Rights Reserved</dd></dl>
<pre>
  Database state machine</pre><pre>State		Description</pre><pre> -4		Initiate connection
 -3		Poll until connection initialization is complete
 -2		Initiate reset
 -1		Poll until connection reset is complete
  1		Idle (wait for a notify from the server)
  2		Send a query to the server
  3		Continue flushing a command to the server
  4		Waiting for a reply
</pre> 
<p>Definition in file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a08fe83fe8226002ee8b80ce0a914fd11"></a><!-- doxytag: member="lspg.c::LS_PG_QUERY_QUEUE_LENGTH" ref="a08fe83fe8226002ee8b80ce0a914fd11" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LS_PG_QUERY_QUEUE_LENGTH&nbsp;&nbsp;&nbsp;256</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Queue length should be long enough that we do not ordinarly bump into the end We should be safe as long as the thread the adds stuff to the queue is not the one that removes it. </p>
<p>(And we can tolerate the adding thread being paused.) </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00060">60</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="aaf1dd8ba4dafb91c296554c4cbf312e3"></a><!-- doxytag: member="lspg.c::LS_PG_STATE_IDLE" ref="aaf1dd8ba4dafb91c296554c4cbf312e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LS_PG_STATE_IDLE&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00034">34</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="af443092447378c73bf93aa143576aba4"></a><!-- doxytag: member="lspg.c::LS_PG_STATE_INIT" ref="af443092447378c73bf93aa143576aba4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LS_PG_STATE_INIT&nbsp;&nbsp;&nbsp;-4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00030">30</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="ae7ea5876846b5f04c419aee22d3c0aa1"></a><!-- doxytag: member="lspg.c::LS_PG_STATE_INIT_POLL" ref="ae7ea5876846b5f04c419aee22d3c0aa1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LS_PG_STATE_INIT_POLL&nbsp;&nbsp;&nbsp;-3</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00031">31</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a373e668840b4795ff9a71bc3f744d209"></a><!-- doxytag: member="lspg.c::LS_PG_STATE_RECV" ref="a373e668840b4795ff9a71bc3f744d209" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LS_PG_STATE_RECV&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00037">37</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="accda8c3a598dc7f5b107b04986d8ab50"></a><!-- doxytag: member="lspg.c::LS_PG_STATE_RESET" ref="accda8c3a598dc7f5b107b04986d8ab50" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LS_PG_STATE_RESET&nbsp;&nbsp;&nbsp;-2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00032">32</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="ac70a1141f3b138055ea7143bd493187c"></a><!-- doxytag: member="lspg.c::LS_PG_STATE_RESET_POLL" ref="ac70a1141f3b138055ea7143bd493187c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LS_PG_STATE_RESET_POLL&nbsp;&nbsp;&nbsp;-1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00033">33</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3c6eb19f262a990e1f9ba630d9edc309"></a><!-- doxytag: member="lspg.c::LS_PG_STATE_SEND" ref="a3c6eb19f262a990e1f9ba630d9edc309" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LS_PG_STATE_SEND&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00035">35</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a88a7e80c12fb0449c4b0857a0c7deb21"></a><!-- doxytag: member="lspg.c::LS_PG_STATE_SEND_FLUSH" ref="a88a7e80c12fb0449c4b0857a0c7deb21" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LS_PG_STATE_SEND_FLUSH&nbsp;&nbsp;&nbsp;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00036">36</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a3442e66a1f05457eb22a0d4a5d295f3a"></a><!-- doxytag: member="lspg.c::lspg_lock_detector_t" ref="a3442e66a1f05457eb22a0d4a5d295f3a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlspg__lock__detector__struct.html">lspg_lock_detector_struct</a>  <a class="el" href="structlspg__lock__detector__struct.html">lspg_lock_detector_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>lock detector object Implements detector lock for exposure control </p>

</div>
</div>
<a class="anchor" id="a7232a0d630558f0c4c081d087150973d"></a><!-- doxytag: member="lspg.c::lspg_lock_diffractometer_t" ref="a7232a0d630558f0c4c081d087150973d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlspg__lock__diffractometer__struct.html">lspg_lock_diffractometer_struct</a>  <a class="el" href="structlspg__lock__diffractometer__struct.html">lspg_lock_diffractometer_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Object used to impliment locking the diffractometer Critical to exposure timing. </p>

</div>
</div>
<a class="anchor" id="ae57432c0a6ac48a50457815dab2c5b4c"></a><!-- doxytag: member="lspg.c::lspg_query_queue_t" ref="ae57432c0a6ac48a50457815dab2c5b4c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlspgQueryQueueStruct.html">lspgQueryQueueStruct</a>  <a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Store each query along with it's callback function. </p>
<p>All calls are asynchronous </p>

</div>
</div>
<a class="anchor" id="ab2da550aea6388c835abe0ee0b226eb0"></a><!-- doxytag: member="lspg.c::lspg_seq_run_prep_t" ref="ab2da550aea6388c835abe0ee0b226eb0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlspg__seq__run__prep__struct.html">lspg_seq_run_prep_struct</a>  <a class="el" href="structlspg__seq__run__prep__struct.html">lspg_seq_run_prep_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Data collection running object. </p>

</div>
</div>
<a class="anchor" id="a6f273a499bf316de95df3816a9b1bc06"></a><!-- doxytag: member="lspg.c::lspg_wait_for_detector_t" ref="a6f273a499bf316de95df3816a9b1bc06" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlspg__wait__for__detector__struct.html">lspg_wait_for_detector_struct</a>  <a class="el" href="structlspg__wait__for__detector__struct.html">lspg_wait_for_detector_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Object that implements detector / spindle timing We use database locks for exposure control and this implements the md2 portion of this handshake. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a46f23ae999129d6fd5712d7975b99aed"></a><!-- doxytag: member="lspg.c::lspg_array2ptrs" ref="a46f23ae999129d6fd5712d7975b99aed" args="(char *a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** lspg_array2ptrs </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns a null terminated list of strings parsed from postgresql array </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00165">165</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00165"></a>00165                                  {
<a name="l00166"></a>00166   <span class="keywordtype">char</span> **rtn, *sp, *acums;
<a name="l00167"></a>00167   <span class="keywordtype">int</span> i, n, inquote, havebackslash, rtni;;
<a name="l00168"></a>00168   <span class="keywordtype">int</span> mxsz;
<a name="l00169"></a>00169   
<a name="l00170"></a>00170   inquote       = 0;
<a name="l00171"></a>00171   havebackslash = 0;
<a name="l00172"></a>00172 
<a name="l00173"></a>00173   <span class="comment">// Despense with the null input condition before we complicate the code below</span>
<a name="l00174"></a>00174   <span class="keywordflow">if</span>( a == NULL || a[0] == 0)
<a name="l00175"></a>00175     <span class="keywordflow">return</span> NULL;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177   <span class="comment">// Count the maximum number of strings</span>
<a name="l00178"></a>00178   <span class="comment">// Actual number will be less if there are quoted commas</span>
<a name="l00179"></a>00179   <span class="comment">//</span>
<a name="l00180"></a>00180   n = 1;
<a name="l00181"></a>00181   <span class="keywordflow">for</span>( i=0; a[i]; i++) {
<a name="l00182"></a>00182     <span class="keywordflow">if</span>( a[i] == <span class="charliteral">&apos;,&apos;</span>)
<a name="l00183"></a>00183       n++;
<a name="l00184"></a>00184   }
<a name="l00185"></a>00185   <span class="comment">//</span>
<a name="l00186"></a>00186   <span class="comment">// The maximum size of any string is the length of a (+1)</span>
<a name="l00187"></a>00187   <span class="comment">//</span>
<a name="l00188"></a>00188   mxsz = strlen(a) + 1;
<a name="l00189"></a>00189 
<a name="l00190"></a>00190   <span class="comment">// This is the accumulation string to make up the array elements</span>
<a name="l00191"></a>00191   acums = (<span class="keywordtype">char</span> *)calloc( mxsz, <span class="keyword">sizeof</span>( <span class="keywordtype">char</span>));
<a name="l00192"></a>00192   <span class="keywordflow">if</span>( acums == NULL) {
<a name="l00193"></a>00193     <span class="comment">// TODO: print or otherwise log this condition</span>
<a name="l00194"></a>00194     <span class="comment">// out of memory</span>
<a name="l00195"></a>00195     exit( 1);
<a name="l00196"></a>00196   }
<a name="l00197"></a>00197   
<a name="l00198"></a>00198   <span class="comment">//</span>
<a name="l00199"></a>00199   <span class="comment">// allocate storage for the pointer array and the null terminator</span>
<a name="l00200"></a>00200   <span class="comment">//</span>
<a name="l00201"></a>00201   rtn = (<span class="keywordtype">char</span> **)calloc( n+1, <span class="keyword">sizeof</span>( <span class="keywordtype">char</span> *));
<a name="l00202"></a>00202   <span class="keywordflow">if</span>( rtn == NULL) {
<a name="l00203"></a>00203     <span class="comment">// TODO: print or otherwise log this condition</span>
<a name="l00204"></a>00204     <span class="comment">// out of memory</span>
<a name="l00205"></a>00205     exit( 1);
<a name="l00206"></a>00206   }
<a name="l00207"></a>00207   rtni = 0;
<a name="l00208"></a>00208   
<a name="l00209"></a>00209   <a class="code" href="lslogging_8c.html#a0e756b36671055ef02a8f04d2ba8a93b">lslogging_log_message</a>( <span class="stringliteral">&quot;lspg_array2ptrs: enter with %s&quot;</span>, a);
<a name="l00210"></a>00210 
<a name="l00211"></a>00211 
<a name="l00212"></a>00212   <span class="comment">// Go through and create the individual strings</span>
<a name="l00213"></a>00213   sp = acums;
<a name="l00214"></a>00214   *sp = 0;
<a name="l00215"></a>00215   <span class="keywordflow">if</span>( a[0] != <span class="charliteral">&apos;{&apos;</span>) {
<a name="l00216"></a>00216     <span class="comment">// oh no!  This isn&apos;t an array after all!</span>
<a name="l00217"></a>00217     <span class="comment">// Zounds!</span>
<a name="l00218"></a>00218     <span class="keywordflow">return</span> NULL;
<a name="l00219"></a>00219   }
<a name="l00220"></a>00220   inquote = 0;
<a name="l00221"></a>00221   havebackslash = 0;
<a name="l00222"></a>00222   <span class="keywordflow">for</span>( i=1; a[i] != 0; i++) {
<a name="l00223"></a>00223     <span class="keywordflow">switch</span>( a[i]) {
<a name="l00224"></a>00224     <span class="keywordflow">case</span> <span class="charliteral">&apos;&quot;&apos;</span>:
<a name="l00225"></a>00225       <span class="keywordflow">if</span>( havebackslash) {
<a name="l00226"></a>00226         <span class="comment">// a quoted quote.  Cool</span>
<a name="l00227"></a>00227         <span class="comment">//</span>
<a name="l00228"></a>00228         *(sp++) = a[i];
<a name="l00229"></a>00229         *sp = 0;
<a name="l00230"></a>00230         havebackslash = 0;
<a name="l00231"></a>00231       } <span class="keywordflow">else</span> {
<a name="l00232"></a>00232         <span class="comment">// Toggle the flag</span>
<a name="l00233"></a>00233         inquote = 1 - inquote;
<a name="l00234"></a>00234       }
<a name="l00235"></a>00235       <span class="keywordflow">break</span>;
<a name="l00236"></a>00236 
<a name="l00237"></a>00237     <span class="keywordflow">case</span> <span class="charliteral">&apos;\\&apos;</span>:
<a name="l00238"></a>00238       <span class="keywordflow">if</span>( havebackslash) {
<a name="l00239"></a>00239         *(sp++) = a[i];
<a name="l00240"></a>00240         *sp = 0;
<a name="l00241"></a>00241         havebackslash = 0;
<a name="l00242"></a>00242       } <span class="keywordflow">else</span> {
<a name="l00243"></a>00243         havebackslash = 1;
<a name="l00244"></a>00244       }
<a name="l00245"></a>00245       <span class="keywordflow">break</span>;
<a name="l00246"></a>00246 
<a name="l00247"></a>00247     <span class="keywordflow">case</span> <span class="charliteral">&apos;,&apos;</span>:
<a name="l00248"></a>00248       <span class="keywordflow">if</span>( inquote || havebackslash) {
<a name="l00249"></a>00249         *(sp++) = a[i];
<a name="l00250"></a>00250         *sp = 0;
<a name="l00251"></a>00251         havebackslash = 0;
<a name="l00252"></a>00252       } <span class="keywordflow">else</span> {
<a name="l00253"></a>00253         rtn[rtni++] = strdup( acums);
<a name="l00254"></a>00254         sp = acums;
<a name="l00255"></a>00255       }
<a name="l00256"></a>00256       <span class="keywordflow">break</span>;
<a name="l00257"></a>00257       
<a name="l00258"></a>00258     <span class="keywordflow">case</span> <span class="charliteral">&apos;}&apos;</span>:
<a name="l00259"></a>00259       <span class="keywordflow">if</span>( inquote || havebackslash) {
<a name="l00260"></a>00260         *(sp++) = a[i];
<a name="l00261"></a>00261         *sp = 0;
<a name="l00262"></a>00262         havebackslash = 0;
<a name="l00263"></a>00263       } <span class="keywordflow">else</span> {
<a name="l00264"></a>00264         rtn[rtni++] = strdup( acums);
<a name="l00265"></a>00265         rtn[rtni]   = NULL;
<a name="l00266"></a>00266         <span class="keywordflow">return</span>( rtn);
<a name="l00267"></a>00267       }
<a name="l00268"></a>00268       <span class="keywordflow">break</span>;
<a name="l00269"></a>00269 
<a name="l00270"></a>00270     <span class="keywordflow">default</span>:
<a name="l00271"></a>00271       *(sp++) = a[i];
<a name="l00272"></a>00272       *sp = 0;
<a name="l00273"></a>00273       havebackslash = 0;
<a name="l00274"></a>00274     }
<a name="l00275"></a>00275   }
<a name="l00276"></a>00276   <span class="comment">//</span>
<a name="l00277"></a>00277   <span class="comment">// Getting here means the final &apos;}&apos; was missing</span>
<a name="l00278"></a>00278   <span class="comment">// Probably we should throw an error or log it or something.</span>
<a name="l00279"></a>00279   <span class="comment">//</span>
<a name="l00280"></a>00280   rtn[rtni++] = strdup( acums);
<a name="l00281"></a>00281   rtn[rtni]   = NULL;
<a name="l00282"></a>00282   <span class="keywordflow">return</span>( rtn);
<a name="l00283"></a>00283 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6f5fa5727f2876f8b9370110a92afa50"></a><!-- doxytag: member="lspg.c::lspg_blight_lut_cb" ref="a6f5fa5727f2876f8b9370110a92afa50" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_blight_lut_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Back Light Lookup Table Callback Install the lookup table for the Back Light. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>qqp</em>&nbsp;</td><td>Our query </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pgr</em>&nbsp;</td><td>The query's result </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00421">421</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00424"></a>00424                           {
<a name="l00425"></a>00425   <span class="keywordtype">int</span> i;
<a name="l00426"></a>00426   
<a name="l00427"></a>00427   pthread_mutex_lock( &amp;(<a class="code" href="lspmac_8c.html#a85d6eaa4b4a82bb3112574f458d1dc50" title="Back Light DAC.">blight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a188c5b1e991750ce2ffd53e0192e0907" title="coordinate waiting for motor to be done">mutex</a>));
<a name="l00428"></a>00428 
<a name="l00429"></a>00429   <a class="code" href="lspmac_8c.html#a85d6eaa4b4a82bb3112574f458d1dc50" title="Back Light DAC.">blight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a11cbc6f50c150ed446e9a901cf7cc12b" title="length of lut">nlut</a> = PQntuples( pgr)/2;
<a name="l00430"></a>00430   <a class="code" href="lspmac_8c.html#a85d6eaa4b4a82bb3112574f458d1dc50" title="Back Light DAC.">blight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a7b43671f7f3e06521f6cf91fb9ac707d" title="lookup table (instead of u2c)">lut</a>  = calloc( 2*<a class="code" href="lspmac_8c.html#a85d6eaa4b4a82bb3112574f458d1dc50" title="Back Light DAC.">blight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a11cbc6f50c150ed446e9a901cf7cc12b" title="length of lut">nlut</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00431"></a>00431   <span class="keywordflow">if</span>( <a class="code" href="lspmac_8c.html#a85d6eaa4b4a82bb3112574f458d1dc50" title="Back Light DAC.">blight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a7b43671f7f3e06521f6cf91fb9ac707d" title="lookup table (instead of u2c)">lut</a> == NULL) {
<a name="l00432"></a>00432     <a class="code" href="lslogging_8c.html#a0e756b36671055ef02a8f04d2ba8a93b">lslogging_log_message</a>( <span class="stringliteral">&quot;Out of memmory (lspg_blight_lut_cb)&quot;</span>);
<a name="l00433"></a>00433     pthread_mutex_unlock( &amp;(<a class="code" href="lspmac_8c.html#a85d6eaa4b4a82bb3112574f458d1dc50" title="Back Light DAC.">blight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a188c5b1e991750ce2ffd53e0192e0907" title="coordinate waiting for motor to be done">mutex</a>));
<a name="l00434"></a>00434     <span class="keywordflow">return</span>;
<a name="l00435"></a>00435   }
<a name="l00436"></a>00436   
<a name="l00437"></a>00437   <span class="keywordflow">for</span>( i=0; i&lt;PQntuples( pgr); i++) {
<a name="l00438"></a>00438     <a class="code" href="lspmac_8c.html#a85d6eaa4b4a82bb3112574f458d1dc50" title="Back Light DAC.">blight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a7b43671f7f3e06521f6cf91fb9ac707d" title="lookup table (instead of u2c)">lut</a>[i] = strtod( PQgetvalue( pgr, i, 0), NULL);
<a name="l00439"></a>00439   }
<a name="l00440"></a>00440 
<a name="l00441"></a>00441   pthread_mutex_unlock( &amp;(<a class="code" href="lspmac_8c.html#a85d6eaa4b4a82bb3112574f458d1dc50" title="Back Light DAC.">blight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a188c5b1e991750ce2ffd53e0192e0907" title="coordinate waiting for motor to be done">mutex</a>));
<a name="l00442"></a>00442 
<a name="l00443"></a>00443 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1e11f525ca0f9ac9ab71f9fbe983c42b"></a><!-- doxytag: member="lspg.c::lspg_cmd_cb" ref="a1e11f525ca0f9ac9ab71f9fbe983c42b" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_cmd_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send strings directly to PMAC queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>qqp</em>&nbsp;</td><td>Our query </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pgr</em>&nbsp;</td><td>Our result </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01120">1120</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01123"></a>01123                    {
<a name="l01124"></a>01124   <span class="comment">//</span>
<a name="l01125"></a>01125   <span class="comment">// Call back funciton assumes query results in zero or more commands to send to the PMAC</span>
<a name="l01126"></a>01126   <span class="comment">//</span>
<a name="l01127"></a>01127   <span class="keywordtype">int</span> i;
<a name="l01128"></a>01128   <span class="keywordtype">char</span> *sp;
<a name="l01129"></a>01129   
<a name="l01130"></a>01130   <span class="keywordflow">for</span>( i=0; i&lt;PQntuples( pgr); i++) {
<a name="l01131"></a>01131     sp = PQgetvalue( pgr, i, 0);
<a name="l01132"></a>01132     <span class="keywordflow">if</span>( sp != NULL &amp;&amp; *sp != 0) {
<a name="l01133"></a>01133       <a class="code" href="lspmac_8c.html#aaa442d9bc7a3cdee39adea0724f0e18c" title="Send a one line command.">lspmac_SockSendline</a>( sp);
<a name="l01134"></a>01134       <span class="comment">//</span>
<a name="l01135"></a>01135       <span class="comment">// Keep asking for more until</span>
<a name="l01136"></a>01136       <span class="comment">// there are no commands left</span>
<a name="l01137"></a>01137       <span class="comment">// </span>
<a name="l01138"></a>01138       <span class="comment">// This should solve a potential problem where</span>
<a name="l01139"></a>01139       <span class="comment">// more than one command is put on the queue for a given notify.</span>
<a name="l01140"></a>01140       <span class="comment">//</span>
<a name="l01141"></a>01141       <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#a1e11f525ca0f9ac9ab71f9fbe983c42b" title="Send strings directly to PMAC queue.">lspg_cmd_cb</a>, <span class="stringliteral">&quot;select pmac.md2_queue_next()&quot;</span>);
<a name="l01142"></a>01142     }
<a name="l01143"></a>01143   }
<a name="l01144"></a>01144 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac5d5d512350a9ba346635e2415d7c3d5"></a><!-- doxytag: member="lspg.c::lspg_flight_lut_cb" ref="ac5d5d512350a9ba346635e2415d7c3d5" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_flight_lut_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Front Light Lookup table query callback Install the lookup table for the Front Light. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>qqp</em>&nbsp;</td><td>Our query </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pgr</em>&nbsp;</td><td>Our result object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00393">393</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00396"></a>00396                           {
<a name="l00397"></a>00397   <span class="keywordtype">int</span> i;
<a name="l00398"></a>00398   
<a name="l00399"></a>00399   pthread_mutex_lock( &amp;(<a class="code" href="lspmac_8c.html#aeb09895663eff333b7a75acb319a9fc1" title="Front Light DAC.">flight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a188c5b1e991750ce2ffd53e0192e0907" title="coordinate waiting for motor to be done">mutex</a>));
<a name="l00400"></a>00400 
<a name="l00401"></a>00401   <a class="code" href="lspmac_8c.html#aeb09895663eff333b7a75acb319a9fc1" title="Front Light DAC.">flight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a11cbc6f50c150ed446e9a901cf7cc12b" title="length of lut">nlut</a> = PQntuples( pgr)/2;
<a name="l00402"></a>00402   <a class="code" href="lspmac_8c.html#aeb09895663eff333b7a75acb319a9fc1" title="Front Light DAC.">flight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a7b43671f7f3e06521f6cf91fb9ac707d" title="lookup table (instead of u2c)">lut</a>  = calloc( 2*<a class="code" href="lspmac_8c.html#aeb09895663eff333b7a75acb319a9fc1" title="Front Light DAC.">flight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a11cbc6f50c150ed446e9a901cf7cc12b" title="length of lut">nlut</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00403"></a>00403   <span class="keywordflow">if</span>( <a class="code" href="lspmac_8c.html#aeb09895663eff333b7a75acb319a9fc1" title="Front Light DAC.">flight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a7b43671f7f3e06521f6cf91fb9ac707d" title="lookup table (instead of u2c)">lut</a> == NULL) {
<a name="l00404"></a>00404     <a class="code" href="lslogging_8c.html#a0e756b36671055ef02a8f04d2ba8a93b">lslogging_log_message</a>( <span class="stringliteral">&quot;Out of memmory (lspg_flight_lut_cb)&quot;</span>);
<a name="l00405"></a>00405     pthread_mutex_unlock( &amp;(<a class="code" href="lspmac_8c.html#aeb09895663eff333b7a75acb319a9fc1" title="Front Light DAC.">flight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a188c5b1e991750ce2ffd53e0192e0907" title="coordinate waiting for motor to be done">mutex</a>));
<a name="l00406"></a>00406     <span class="keywordflow">return</span>;
<a name="l00407"></a>00407   }
<a name="l00408"></a>00408   
<a name="l00409"></a>00409   <span class="keywordflow">for</span>( i=0; i&lt;PQntuples( pgr); i++) {
<a name="l00410"></a>00410     <a class="code" href="lspmac_8c.html#aeb09895663eff333b7a75acb319a9fc1" title="Front Light DAC.">flight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a7b43671f7f3e06521f6cf91fb9ac707d" title="lookup table (instead of u2c)">lut</a>[i] = strtod( PQgetvalue( pgr, i, 0), NULL);
<a name="l00411"></a>00411   }
<a name="l00412"></a>00412 
<a name="l00413"></a>00413   pthread_mutex_unlock( &amp;(<a class="code" href="lspmac_8c.html#aeb09895663eff333b7a75acb319a9fc1" title="Front Light DAC.">flight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a188c5b1e991750ce2ffd53e0192e0907" title="coordinate waiting for motor to be done">mutex</a>));
<a name="l00414"></a>00414 
<a name="l00415"></a>00415 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af6485ac1749c5de3008dd0e0badaa09c"></a><!-- doxytag: member="lspg.c::lspg_flush" ref="af6485ac1749c5de3008dd0e0badaa09c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_flush </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flush psql output buffer (ie, send the query). </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01149">1149</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01149"></a>01149                   {
<a name="l01150"></a>01150   <span class="keywordtype">int</span> err;
<a name="l01151"></a>01151 
<a name="l01152"></a>01152   err = PQflush( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01153"></a>01153   <span class="keywordflow">switch</span>( err) {
<a name="l01154"></a>01154   <span class="keywordflow">case</span> -1:
<a name="l01155"></a>01155     <span class="comment">// an error occured</span>
<a name="l01156"></a>01156 
<a name="l01157"></a>01157     <a class="code" href="lslogging_8c.html#a0e756b36671055ef02a8f04d2ba8a93b">lslogging_log_message</a>( <span class="stringliteral">&quot;flush failed: %s&quot;</span>, PQerrorMessage( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>));
<a name="l01158"></a>01158 
<a name="l01159"></a>01159     <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#aaf1dd8ba4dafb91c296554c4cbf312e3">LS_PG_STATE_IDLE</a>;
<a name="l01160"></a>01160     <span class="comment">//</span>
<a name="l01161"></a>01161     <span class="comment">// We should probably reset the connection and start from scratch.  Probably the connection died.</span>
<a name="l01162"></a>01162     <span class="comment">//</span>
<a name="l01163"></a>01163     <span class="keywordflow">break</span>;
<a name="l01164"></a>01164           
<a name="l01165"></a>01165   <span class="keywordflow">case</span> 0:
<a name="l01166"></a>01166     <span class="comment">// goodness and joy.</span>
<a name="l01167"></a>01167     <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#a373e668840b4795ff9a71bc3f744d209">LS_PG_STATE_RECV</a>;
<a name="l01168"></a>01168     <span class="keywordflow">break</span>;
<a name="l01169"></a>01169 
<a name="l01170"></a>01170   <span class="keywordflow">case</span> 1:
<a name="l01171"></a>01171     <span class="comment">// more sending to do</span>
<a name="l01172"></a>01172     <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#a88a7e80c12fb0449c4b0857a0c7deb21">LS_PG_STATE_SEND_FLUSH</a>;
<a name="l01173"></a>01173     <span class="keywordflow">break</span>;
<a name="l01174"></a>01174   }
<a name="l01175"></a>01175 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a523b492d9cd4970853eabee2d3c31578"></a><!-- doxytag: member="lspg.c::lspg_getcenter_all" ref="a523b492d9cd4970853eabee2d3c31578" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_getcenter_all </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience function to complete synchronous getcenter query. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01085">1085</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01085"></a>01085                           {
<a name="l01086"></a>01086   <a class="code" href="lspg_8c.html#a6f7cd0a06f6a266ef65b3604cf33d6c4" title="Request a getcenter query.">lspg_getcenter_call</a>();
<a name="l01087"></a>01087   <a class="code" href="lspg_8c.html#a3e0e4b3cb9fa03961ee0c104e0b06754" title="Wait for a getcenter query to return.">lspg_getcenter_wait</a>();
<a name="l01088"></a>01088   <a class="code" href="lspg_8c.html#a7c678553b44c874d08ec9966ed7bb1c0" title="Done with getcenter query.">lspg_getcenter_done</a>();
<a name="l01089"></a>01089 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a6f7cd0a06f6a266ef65b3604cf33d6c4"></a><!-- doxytag: member="lspg.c::lspg_getcenter_call" ref="a6f7cd0a06f6a266ef65b3604cf33d6c4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_getcenter_call </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request a getcenter query. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01061">1061</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01061"></a>01061                            {
<a name="l01062"></a>01062   pthread_mutex_lock( &amp;<a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a214bb7e88b137162f13f41f2c43002a9" title="don&amp;#39;t let the threads collide!">mutex</a>);
<a name="l01063"></a>01063   <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a4b350f11f1e375b9e9e839caaffbcb6b" title="used with condition">new_value_ready</a> = 0;
<a name="l01064"></a>01064   pthread_mutex_unlock( &amp;<a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a214bb7e88b137162f13f41f2c43002a9" title="don&amp;#39;t let the threads collide!">mutex</a>);
<a name="l01065"></a>01065 
<a name="l01066"></a>01066   <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#a8184824f2b71b1d35141d7922ca69cd7" title="TODO: implement getcenter code.">lspg_getcenter_cb</a>, <span class="stringliteral">&quot;SELECT * FROM px.getcenter2()&quot;</span>);
<a name="l01067"></a>01067 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8184824f2b71b1d35141d7922ca69cd7"></a><!-- doxytag: member="lspg.c::lspg_getcenter_cb" ref="a8184824f2b71b1d35141d7922ca69cd7" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_getcenter_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: implement getcenter code. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00996">996</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00996"></a>00996                                                                 {
<a name="l00997"></a>00997   <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00998"></a>00998     zoom_c, dcx_c, dcy_c, dax_c, day_c, daz_c;
<a name="l00999"></a>00999 
<a name="l01000"></a>01000   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a214bb7e88b137162f13f41f2c43002a9" title="don&amp;#39;t let the threads collide!">mutex</a>));
<a name="l01001"></a>01001   
<a name="l01002"></a>01002   <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#aaeb0ccf4289b4fb306c2bc04ae85b237" title="flag in case no centering information was forthcoming">no_rows_returned</a> = PQntuples( pgr) &lt;= 0;
<a name="l01003"></a>01003   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#aaeb0ccf4289b4fb306c2bc04ae85b237" title="flag in case no centering information was forthcoming">no_rows_returned</a>) {
<a name="l01004"></a>01004     <span class="comment">//</span>
<a name="l01005"></a>01005     <span class="comment">// No particular reason this path should ever be taken</span>
<a name="l01006"></a>01006     <span class="comment">// but if we don&apos;t get rows then we had better not move anything.</span>
<a name="l01007"></a>01007     <span class="comment">//</span>
<a name="l01008"></a>01008     <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a4b350f11f1e375b9e9e839caaffbcb6b" title="used with condition">new_value_ready</a> = 1;
<a name="l01009"></a>01009     pthread_cond_signal( &amp;(<a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#ae0db0ff2608ab5ba3e7c1b4ad3fc0e91" title="provides signaling for when the query is done">cond</a>));
<a name="l01010"></a>01010     pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a214bb7e88b137162f13f41f2c43002a9" title="don&amp;#39;t let the threads collide!">mutex</a>));
<a name="l01011"></a>01011     <span class="keywordflow">return</span>;
<a name="l01012"></a>01012   }
<a name="l01013"></a>01013 
<a name="l01014"></a>01014   zoom_c = PQfnumber( pgr, <span class="stringliteral">&quot;zoom&quot;</span>);
<a name="l01015"></a>01015   dcx_c  = PQfnumber( pgr, <span class="stringliteral">&quot;dcx&quot;</span>);
<a name="l01016"></a>01016   dcy_c  = PQfnumber( pgr, <span class="stringliteral">&quot;dcy&quot;</span>);
<a name="l01017"></a>01017   dax_c  = PQfnumber( pgr, <span class="stringliteral">&quot;dax&quot;</span>);
<a name="l01018"></a>01018   day_c  = PQfnumber( pgr, <span class="stringliteral">&quot;day&quot;</span>);
<a name="l01019"></a>01019   daz_c  = PQfnumber( pgr, <span class="stringliteral">&quot;daz&quot;</span>);
<a name="l01020"></a>01020 
<a name="l01021"></a>01021   <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a6ca85a8de29039188357b2814acd7803">zoom_isnull</a> = PQgetisnull( pgr, 0, zoom_c);
<a name="l01022"></a>01022   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a6ca85a8de29039188357b2814acd7803">zoom_isnull</a> == 0)
<a name="l01023"></a>01023     <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a63e640a925611d2404a1529aea30a853" title="the next zoom level to go to before taking the next movie">zoom</a> = atoi( PQgetvalue( pgr, 0, zoom_c));
<a name="l01024"></a>01024 
<a name="l01025"></a>01025   <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#aa404da85af654998f039c81a77626748">dcx_isnull</a> = PQgetisnull( pgr, 0, dcx_c);
<a name="l01026"></a>01026   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#aa404da85af654998f039c81a77626748">dcx_isnull</a> == 0)
<a name="l01027"></a>01027     <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#ade0534056296e9ed568404c538be9227" title="center x change">dcx</a> = atof( PQgetvalue( pgr, 0, dcx_c));
<a name="l01028"></a>01028 
<a name="l01029"></a>01029   <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a352c48c8d443c52f18ebd13019d01684">dcy_isnull</a> = PQgetisnull( pgr, 0, dcy_c);
<a name="l01030"></a>01030   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a352c48c8d443c52f18ebd13019d01684">dcy_isnull</a> == 0)
<a name="l01031"></a>01031     <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a55b1a488b714e6a40d8e06a6e182bd0a" title="center y change">dcy</a> = atof( PQgetvalue( pgr, 0, dcy_c));
<a name="l01032"></a>01032 
<a name="l01033"></a>01033   <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a621b489777d61e9db8b33b784b8d70f9">dax_isnull</a> = PQgetisnull( pgr, 0, dax_c);
<a name="l01034"></a>01034   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a621b489777d61e9db8b33b784b8d70f9">dax_isnull</a> == 0)
<a name="l01035"></a>01035     <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a17db52848c28852a470222ec93ae8886" title="alignment x change">dax</a> = atof( PQgetvalue( pgr, 0, dax_c));
<a name="l01036"></a>01036 
<a name="l01037"></a>01037   <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a36f57a319288810caf365cca7827ff96">day_isnull</a> = PQgetisnull( pgr, 0, day_c);
<a name="l01038"></a>01038   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a36f57a319288810caf365cca7827ff96">day_isnull</a> == 0)
<a name="l01039"></a>01039     <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a9ce0f29540f2ff47be9788565d19f1b8" title="alignment y change">day</a> = atof( PQgetvalue( pgr, 0, day_c));
<a name="l01040"></a>01040 
<a name="l01041"></a>01041   <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a36742b6bd0f4bf9356414930ba893617">daz_isnull</a> = PQgetisnull( pgr, 0, daz_c);
<a name="l01042"></a>01042   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a36742b6bd0f4bf9356414930ba893617">daz_isnull</a> == 0)
<a name="l01043"></a>01043     <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a1170bab2161f03ab29c39f79519ed9ae" title="alignment z change">daz</a> = atof( PQgetvalue( pgr, 0, daz_c));
<a name="l01044"></a>01044 
<a name="l01045"></a>01045   <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a4b350f11f1e375b9e9e839caaffbcb6b" title="used with condition">new_value_ready</a> = 1;
<a name="l01046"></a>01046 
<a name="l01047"></a>01047   pthread_cond_signal( &amp;(<a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#ae0db0ff2608ab5ba3e7c1b4ad3fc0e91" title="provides signaling for when the query is done">cond</a>));
<a name="l01048"></a>01048   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a214bb7e88b137162f13f41f2c43002a9" title="don&amp;#39;t let the threads collide!">mutex</a>));
<a name="l01049"></a>01049 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a7c678553b44c874d08ec9966ed7bb1c0"></a><!-- doxytag: member="lspg.c::lspg_getcenter_done" ref="a7c678553b44c874d08ec9966ed7bb1c0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_getcenter_done </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Done with getcenter query. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01079">1079</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01079"></a>01079                            {
<a name="l01080"></a>01080   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a214bb7e88b137162f13f41f2c43002a9" title="don&amp;#39;t let the threads collide!">mutex</a>));
<a name="l01081"></a>01081 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad31db17587a02302ac4e40fb7d260b1b"></a><!-- doxytag: member="lspg.c::lspg_getcenter_init" ref="ad31db17587a02302ac4e40fb7d260b1b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_getcenter_init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize getcenter object. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01053">1053</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01053"></a>01053                            {
<a name="l01054"></a>01054   memset( &amp;<a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>, 0, <span class="keyword">sizeof</span>( <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>));
<a name="l01055"></a>01055   pthread_mutex_init( &amp;(<a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a214bb7e88b137162f13f41f2c43002a9" title="don&amp;#39;t let the threads collide!">mutex</a>), NULL);
<a name="l01056"></a>01056   pthread_cond_init( &amp;(<a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#ae0db0ff2608ab5ba3e7c1b4ad3fc0e91" title="provides signaling for when the query is done">cond</a>), NULL);
<a name="l01057"></a>01057 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3e0e4b3cb9fa03961ee0c104e0b06754"></a><!-- doxytag: member="lspg.c::lspg_getcenter_wait" ref="a3e0e4b3cb9fa03961ee0c104e0b06754" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_getcenter_wait </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for a getcenter query to return. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01071">1071</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01071"></a>01071                            {
<a name="l01072"></a>01072   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a214bb7e88b137162f13f41f2c43002a9" title="don&amp;#39;t let the threads collide!">mutex</a>));
<a name="l01073"></a>01073   <span class="keywordflow">while</span>( <a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a4b350f11f1e375b9e9e839caaffbcb6b" title="used with condition">new_value_ready</a> == 0)
<a name="l01074"></a>01074     pthread_cond_wait( &amp;(<a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#ae0db0ff2608ab5ba3e7c1b4ad3fc0e91" title="provides signaling for when the query is done">cond</a>), &amp;(<a class="code" href="lspg_8c.html#a7ef8a09203117578c9b2ce4719519f36" title="the getcenter object">lspg_getcenter</a>.<a class="code" href="structlspg__getcenter__struct.html#a214bb7e88b137162f13f41f2c43002a9" title="don&amp;#39;t let the threads collide!">mutex</a>));
<a name="l01075"></a>01075 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8a77972df14166e05c94ed0792baa09b"></a><!-- doxytag: member="lspg.c::lspg_init" ref="a8a77972df14166e05c94ed0792baa09b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initiallize the lspg module. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01638">1638</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01638"></a>01638                  {
<a name="l01639"></a>01639   pthread_mutex_init( &amp;<a class="code" href="lspg_8c.html#aed46a94106c583796e3a8ca0e89aa8e4" title="keep the queue from getting tangled">lspg_queue_mutex</a>, NULL);
<a name="l01640"></a>01640   pthread_cond_init( &amp;<a class="code" href="lspg_8c.html#a61a308b6a37afd645beb422653b95baa" title="keeps the queue from overflowing">lspg_queue_cond</a>, NULL);
<a name="l01641"></a>01641   <a class="code" href="lspg_8c.html#aff91db7d60e6c832684c023813e36dbf" title="Initialize the nextshot variable, mutex, and condition.">lspg_nextshot_init</a>();
<a name="l01642"></a>01642   <a class="code" href="lspg_8c.html#ad31db17587a02302ac4e40fb7d260b1b" title="Initialize getcenter object.">lspg_getcenter_init</a>();
<a name="l01643"></a>01643   <a class="code" href="lspg_8c.html#a3517f8fbed91c998f6036284f9bd0c48" title="initialize the detector timing object">lspg_wait_for_detector_init</a>();
<a name="l01644"></a>01644   <a class="code" href="lspg_8c.html#a39bb94f8e0d47702b2b920a3dee61ebc" title="initialize the diffractometer locking object">lspg_lock_diffractometer_init</a>();
<a name="l01645"></a>01645   <a class="code" href="lspg_8c.html#a0e9bbf847dadfe0d10830d67824d9be8" title="Initialize detector lock object.">lspg_lock_detector_init</a>();
<a name="l01646"></a>01646 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a329a7fdfa5025a403ea2779e178fd3ed"></a><!-- doxytag: member="lspg.c::lspg_init_motors_cb" ref="a329a7fdfa5025a403ea2779e178fd3ed" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_init_motors_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Motor initialization callback. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>qqp</em>&nbsp;</td><td>The query queue item used to call us </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pgr</em>&nbsp;</td><td>The postgresql result object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00287">287</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00290"></a>00290                            {
<a name="l00291"></a>00291   <span class="keywordtype">int</span> i, j;
<a name="l00292"></a>00292   uint32_t  motor_number, motor_number_column, max_speed_column, max_accel_column, home_column;
<a name="l00293"></a>00293   uint32_t units_column, coord_column, name_column;
<a name="l00294"></a>00294   uint32_t u2c_column;
<a name="l00295"></a>00295   uint32_t format_column;
<a name="l00296"></a>00296   uint32_t update_resolution_column;
<a name="l00297"></a>00297   uint32_t update_format_column;
<a name="l00298"></a>00298   <span class="keywordtype">char</span> *sp;
<a name="l00299"></a>00299   <a class="code" href="structlspmac__motor__struct.html" title="Motor information.">lspmac_motor_t</a> *lsdp;
<a name="l00300"></a>00300   
<a name="l00301"></a>00301   name_column              = PQfnumber( pgr, <span class="stringliteral">&quot;mm_name&quot;</span>);
<a name="l00302"></a>00302   <span class="keywordflow">if</span>( name_column == -1)
<a name="l00303"></a>00303     <span class="keywordflow">return</span>;
<a name="l00304"></a>00304 
<a name="l00305"></a>00305   motor_number_column      = PQfnumber( pgr, <span class="stringliteral">&quot;mm_motor&quot;</span>);
<a name="l00306"></a>00306   coord_column             = PQfnumber( pgr, <span class="stringliteral">&quot;mm_coord&quot;</span>);
<a name="l00307"></a>00307   units_column             = PQfnumber( pgr, <span class="stringliteral">&quot;mm_unit&quot;</span>);
<a name="l00308"></a>00308   u2c_column               = PQfnumber( pgr, <span class="stringliteral">&quot;mm_u2c&quot;</span>);
<a name="l00309"></a>00309   format_column            = PQfnumber( pgr, <span class="stringliteral">&quot;mm_printf&quot;</span>);
<a name="l00310"></a>00310   max_speed_column         = PQfnumber( pgr, <span class="stringliteral">&quot;mm_max_speed&quot;</span>);
<a name="l00311"></a>00311   max_accel_column         = PQfnumber( pgr, <span class="stringliteral">&quot;mm_max_speed&quot;</span>);
<a name="l00312"></a>00312   update_resolution_column = PQfnumber( pgr, <span class="stringliteral">&quot;mm_update_resolution&quot;</span>);
<a name="l00313"></a>00313   update_format_column     = PQfnumber( pgr, <span class="stringliteral">&quot;mm_update_format&quot;</span>);
<a name="l00314"></a>00314   home_column              = PQfnumber( pgr, <span class="stringliteral">&quot;mm_home&quot;</span>);
<a name="l00315"></a>00315 
<a name="l00316"></a>00316   <span class="keywordflow">for</span>( i=0; i&lt;PQntuples( pgr); i++) {
<a name="l00317"></a>00317 
<a name="l00318"></a>00318     lsdp = NULL;
<a name="l00319"></a>00319     <span class="keywordflow">for</span>( j=0; j&lt;<a class="code" href="lspmac_8c.html#a56260f012c50a591ee7f97e500f16994" title="The number of motors we manage.">lspmac_nmotors</a>; j++) {
<a name="l00320"></a>00320       <span class="keywordflow">if</span>( strcmp(<a class="code" href="lspmac_8c.html#a9bffbf72495499b505543cd942f665da" title="All our motors.">lspmac_motors</a>[j].name, PQgetvalue( pgr, i, name_column)) == 0) {
<a name="l00321"></a>00321         lsdp                    = &amp;(<a class="code" href="lspmac_8c.html#a9bffbf72495499b505543cd942f665da" title="All our motors.">lspmac_motors</a>[j]);
<a name="l00322"></a>00322         lsdp-&gt;<a class="code" href="structlspmac__motor__struct.html#a45fae17618f0c0827e97060dc04f79cb" title="pmac motor number">motor_num</a>         = atoi(PQgetvalue( pgr, i, motor_number_column));
<a name="l00323"></a>00323         lsdp-&gt;<a class="code" href="structlspmac__motor__struct.html#a2093b0a3cd2f9500fd92e3c89bf46577" title="coordinate system this motor belongs to (0 if none)">coord_num</a>         = atoi( PQgetvalue( pgr, i, coord_column));
<a name="l00324"></a>00324         lsdp-&gt;<a class="code" href="structlspmac__motor__struct.html#a82bceff2ae698b4b9618360b446aec08" title="string to use as the units">units</a>             = strdup( PQgetvalue( pgr, i, units_column));
<a name="l00325"></a>00325         lsdp-&gt;<a class="code" href="structlspmac__motor__struct.html#aba3d9d00271187128506bbbb1d77da19" title="printf format">format</a>            = strdup( PQgetvalue( pgr, i, format_column));
<a name="l00326"></a>00326         lsdp-&gt;<a class="code" href="structlspmac__motor__struct.html#a61415627ab2dc0f438b190d117e532db" title="conversion from counts to units: 0.0 means not loaded yet">u2c</a>               = atof(PQgetvalue( pgr, i, u2c_column));
<a name="l00327"></a>00327         lsdp-&gt;<a class="code" href="structlspmac__motor__struct.html#af27159eeef80e4438446e01f24fae9d5" title="our maximum speed (cts/msec)">max_speed</a>         = atof(PQgetvalue( pgr, i, max_speed_column));
<a name="l00328"></a>00328         lsdp-&gt;<a class="code" href="structlspmac__motor__struct.html#afec8dc1d4b97ba9c1d6e4f7a088342e4" title="our maximum acceleration (cts/msec^2)">max_accel</a>         = atof(PQgetvalue( pgr, i, max_accel_column));
<a name="l00329"></a>00329         lsdp-&gt;<a class="code" href="structlspmac__motor__struct.html#a18386126b724d9c7f72364db126f5b93" title="Change needs to be at least this big to report as a new position to the database...">update_resolution</a> = atof(PQgetvalue( pgr, i, update_resolution_column));
<a name="l00330"></a>00330         lsdp-&gt;<a class="code" href="structlspmac__motor__struct.html#a514ee9ed48c7171157d579623f7de23f" title="special format string to create text array for px.kvs update (lsupdate)">update_format</a>     = strdup( PQgetvalue( pgr, i, update_format_column));
<a name="l00331"></a>00331         lsdp-&gt;<a class="code" href="structlspmac__motor__struct.html#a073246b8878d75615b0536301b343f3d" title="pmac commands to home motor">home</a>              = <a class="code" href="lspg_8c.html#a46f23ae999129d6fd5712d7975b99aed" title="returns a null terminated list of strings parsed from postgresql array">lspg_array2ptrs</a>( PQgetvalue( pgr, i, home_column));
<a name="l00332"></a>00332         lsdp-&gt;<a class="code" href="structlspmac__motor__struct.html#af11e5f75c1cf88ed6842d04154d27a31" title="bit flags: bit 0 = motor initialized by database, bit 1 = px.kvs value initialized...">lspg_initialized</a>  = 1;
<a name="l00333"></a>00333         <span class="keywordflow">break</span>;
<a name="l00334"></a>00334       }
<a name="l00335"></a>00335     }
<a name="l00336"></a>00336     <span class="keywordflow">if</span>( lsdp == NULL)
<a name="l00337"></a>00337       <span class="keywordflow">continue</span>;
<a name="l00338"></a>00338 
<a name="l00339"></a>00339     <span class="keywordflow">if</span>( fabs(lsdp-&gt;<a class="code" href="structlspmac__motor__struct.html#a61415627ab2dc0f438b190d117e532db" title="conversion from counts to units: 0.0 means not loaded yet">u2c</a>) &lt;= 1.0e-9)
<a name="l00340"></a>00340       lsdp-&gt;<a class="code" href="structlspmac__motor__struct.html#a61415627ab2dc0f438b190d117e532db" title="conversion from counts to units: 0.0 means not loaded yet">u2c</a> = 1.0;
<a name="l00341"></a>00341   }
<a name="l00342"></a>00342 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aff93d2f5ac31aa249a0bef40a3837c84"></a><!-- doxytag: member="lspg.c::lspg_lock_detector_all" ref="aff93d2f5ac31aa249a0bef40a3837c84" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_detector_all </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detector lock convinence function. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00908">908</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00908"></a>00908                               {
<a name="l00909"></a>00909   <a class="code" href="lspg_8c.html#a5f71a20cc297684b2afe28e7bd8e8383" title="Request (demand) a detector lock.">lspg_lock_detector_call</a>();
<a name="l00910"></a>00910   <a class="code" href="lspg_8c.html#ad3d9c56bd3ca6bcc43db30872cc441cc" title="Wait for the detector lock.">lspg_lock_detector_wait</a>();
<a name="l00911"></a>00911   <a class="code" href="lspg_8c.html#a1b567040693ff6e2932a2477045d75fa" title="Finish waiting.">lspg_lock_detector_done</a>();
<a name="l00912"></a>00912 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5f71a20cc297684b2afe28e7bd8e8383"></a><!-- doxytag: member="lspg.c::lspg_lock_detector_call" ref="a5f71a20cc297684b2afe28e7bd8e8383" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_detector_call </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request (demand) a detector lock. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00884">884</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00884"></a>00884                                {
<a name="l00885"></a>00885   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#ab5ab5534b376a8fbafdd0b54cec4483c">mutex</a>));
<a name="l00886"></a>00886   <a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#a62373414b815fe178edd8522b3bd4d78">new_value_ready</a> = 0;
<a name="l00887"></a>00887   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#ab5ab5534b376a8fbafdd0b54cec4483c">mutex</a>));
<a name="l00888"></a>00888 
<a name="l00889"></a>00889   <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#aa760191c2b443170cebbcbf5ea5345f3" title="Callback for when the detector lock has be grabbed.">lspg_lock_detector_cb</a>, <span class="stringliteral">&quot;SELECT px.lock_detector()&quot;</span>);
<a name="l00890"></a>00890 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa760191c2b443170cebbcbf5ea5345f3"></a><!-- doxytag: member="lspg.c::lspg_lock_detector_cb" ref="aa760191c2b443170cebbcbf5ea5345f3" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_detector_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback for when the detector lock has be grabbed. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00875">875</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00875"></a>00875                                                                     {
<a name="l00876"></a>00876   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#ab5ab5534b376a8fbafdd0b54cec4483c">mutex</a>));
<a name="l00877"></a>00877   <a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#a62373414b815fe178edd8522b3bd4d78">new_value_ready</a> = 1;
<a name="l00878"></a>00878   pthread_cond_signal( &amp;(<a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#adc90c859665dccc8717219e824cba0b8">cond</a>));
<a name="l00879"></a>00879   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#ab5ab5534b376a8fbafdd0b54cec4483c">mutex</a>));
<a name="l00880"></a>00880 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1b567040693ff6e2932a2477045d75fa"></a><!-- doxytag: member="lspg.c::lspg_lock_detector_done" ref="a1b567040693ff6e2932a2477045d75fa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_detector_done </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finish waiting. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00902">902</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00902"></a>00902                                {
<a name="l00903"></a>00903   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#ab5ab5534b376a8fbafdd0b54cec4483c">mutex</a>));
<a name="l00904"></a>00904 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0e9bbf847dadfe0d10830d67824d9be8"></a><!-- doxytag: member="lspg.c::lspg_lock_detector_init" ref="a0e9bbf847dadfe0d10830d67824d9be8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_detector_init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize detector lock object. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00867">867</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00867"></a>00867                                {
<a name="l00868"></a>00868   <a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#a62373414b815fe178edd8522b3bd4d78">new_value_ready</a> = 0;
<a name="l00869"></a>00869   pthread_mutex_init( &amp;(<a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#ab5ab5534b376a8fbafdd0b54cec4483c">mutex</a>), NULL);
<a name="l00870"></a>00870   pthread_cond_init(  &amp;(<a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#adc90c859665dccc8717219e824cba0b8">cond</a>),  NULL);
<a name="l00871"></a>00871 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad3d9c56bd3ca6bcc43db30872cc441cc"></a><!-- doxytag: member="lspg.c::lspg_lock_detector_wait" ref="ad3d9c56bd3ca6bcc43db30872cc441cc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_detector_wait </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for the detector lock. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00894">894</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00894"></a>00894                                {
<a name="l00895"></a>00895   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#ab5ab5534b376a8fbafdd0b54cec4483c">mutex</a>));
<a name="l00896"></a>00896   <span class="keywordflow">while</span>( <a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#a62373414b815fe178edd8522b3bd4d78">new_value_ready</a> == 0)
<a name="l00897"></a>00897     pthread_cond_wait( &amp;(<a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#adc90c859665dccc8717219e824cba0b8">cond</a>), &amp;(<a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#ab5ab5534b376a8fbafdd0b54cec4483c">mutex</a>));
<a name="l00898"></a>00898 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a88b33e75c42197740b157a51ea726f21"></a><!-- doxytag: member="lspg.c::lspg_lock_diffractometer_all" ref="a88b33e75c42197740b157a51ea726f21" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_diffractometer_all </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convience function that combines lock diffractometer calls. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00849">849</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00849"></a>00849                                     {
<a name="l00850"></a>00850   <a class="code" href="lspg_8c.html#ac5ebeb38e8e9926a52f024fe76201175" title="Request that the database grab the diffractometer lock.">lspg_lock_diffractometer_call</a>();
<a name="l00851"></a>00851   <a class="code" href="lspg_8c.html#a8445e1dec753f2c517b87fcb9c5b5943" title="Wait for the diffractometer lock.">lspg_lock_diffractometer_wait</a>();
<a name="l00852"></a>00852   <a class="code" href="lspg_8c.html#a88b33e75c42197740b157a51ea726f21" title="Convience function that combines lock diffractometer calls.">lspg_lock_diffractometer_all</a>();
<a name="l00853"></a>00853 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac5ebeb38e8e9926a52f024fe76201175"></a><!-- doxytag: member="lspg.c::lspg_lock_diffractometer_call" ref="ac5ebeb38e8e9926a52f024fe76201175" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_diffractometer_call </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request that the database grab the diffractometer lock. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00825">825</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00825"></a>00825                                      {
<a name="l00826"></a>00826   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#a362e848dfd1551428b8d12d8776fd2ed">mutex</a>));
<a name="l00827"></a>00827   <a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#ae94acdf44008ce48930e3083f08f5b6c">new_value_ready</a> = 0;
<a name="l00828"></a>00828   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#a362e848dfd1551428b8d12d8776fd2ed">mutex</a>));
<a name="l00829"></a>00829 
<a name="l00830"></a>00830   <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#aad4f378f37c0030634dafa0d9445d916" title="Callback routine for a lock diffractometer query.">lspg_lock_diffractometer_cb</a>, <span class="stringliteral">&quot;SELECT px.lock_diffractomter()&quot;</span>);
<a name="l00831"></a>00831 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aad4f378f37c0030634dafa0d9445d916"></a><!-- doxytag: member="lspg.c::lspg_lock_diffractometer_cb" ref="aad4f378f37c0030634dafa0d9445d916" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_diffractometer_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback routine for a lock diffractometer query. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00816">816</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00816"></a>00816                                                                           {
<a name="l00817"></a>00817   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#a362e848dfd1551428b8d12d8776fd2ed">mutex</a>));
<a name="l00818"></a>00818   <a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#ae94acdf44008ce48930e3083f08f5b6c">new_value_ready</a> = 1;
<a name="l00819"></a>00819   pthread_cond_signal( &amp;(<a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#a7614c802af37c1d3358479a2c13ac898">cond</a>));
<a name="l00820"></a>00820   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#a362e848dfd1551428b8d12d8776fd2ed">mutex</a>));
<a name="l00821"></a>00821 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a75aaf0b3fe33530062226c69a33ce821"></a><!-- doxytag: member="lspg.c::lspg_lock_diffractometer_done" ref="a75aaf0b3fe33530062226c69a33ce821" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_diffractometer_done </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finish up the lock diffractometer call. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00843">843</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00843"></a>00843                                      {
<a name="l00844"></a>00844   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#a362e848dfd1551428b8d12d8776fd2ed">mutex</a>));
<a name="l00845"></a>00845 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a39bb94f8e0d47702b2b920a3dee61ebc"></a><!-- doxytag: member="lspg.c::lspg_lock_diffractometer_init" ref="a39bb94f8e0d47702b2b920a3dee61ebc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_diffractometer_init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>initialize the diffractometer locking object </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00808">808</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00808"></a>00808                                      {
<a name="l00809"></a>00809   <a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#ae94acdf44008ce48930e3083f08f5b6c">new_value_ready</a> = 0;
<a name="l00810"></a>00810   pthread_mutex_init( &amp;(<a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#a362e848dfd1551428b8d12d8776fd2ed">mutex</a>), NULL);
<a name="l00811"></a>00811   pthread_cond_init(  &amp;(<a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#a7614c802af37c1d3358479a2c13ac898">cond</a>), NULL);
<a name="l00812"></a>00812 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8445e1dec753f2c517b87fcb9c5b5943"></a><!-- doxytag: member="lspg.c::lspg_lock_diffractometer_wait" ref="a8445e1dec753f2c517b87fcb9c5b5943" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_diffractometer_wait </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for the diffractometer lock. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00835">835</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00835"></a>00835                                      {
<a name="l00836"></a>00836   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#a362e848dfd1551428b8d12d8776fd2ed">mutex</a>));
<a name="l00837"></a>00837   <span class="keywordflow">while</span>( <a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#ae94acdf44008ce48930e3083f08f5b6c">new_value_ready</a> == 0)
<a name="l00838"></a>00838     pthread_cond_wait( &amp;(<a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#a7614c802af37c1d3358479a2c13ac898">cond</a>), &amp;(<a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#a362e848dfd1551428b8d12d8776fd2ed">mutex</a>));
<a name="l00839"></a>00839 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab52a8c8245bf6561f40c0f224fc07ff4"></a><!-- doxytag: member="lspg.c::lspg_next_state" ref="ab52a8c8245bf6561f40c0f224fc07ff4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_next_state </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements our state machine Does not strictly only set the next state as it also calls some functions that, perhaps, alters the state mid-function. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01507">1507</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01507"></a>01507                        {
<a name="l01508"></a>01508   <span class="comment">//</span>
<a name="l01509"></a>01509   <span class="comment">// connect to the database</span>
<a name="l01510"></a>01510   <span class="comment">//</span>
<a name="l01511"></a>01511   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a> == NULL ||
<a name="l01512"></a>01512       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#af443092447378c73bf93aa143576aba4">LS_PG_STATE_INIT</a> ||
<a name="l01513"></a>01513       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#accda8c3a598dc7f5b107b04986d8ab50">LS_PG_STATE_RESET</a> ||
<a name="l01514"></a>01514       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#ae7ea5876846b5f04c419aee22d3c0aa1">LS_PG_STATE_INIT_POLL</a> ||
<a name="l01515"></a>01515       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#ac70a1141f3b138055ea7143bd493187c">LS_PG_STATE_RESET_POLL</a>)
<a name="l01516"></a>01516     <a class="code" href="lspg_8c.html#a581c18be0368425665a40b4b7f7d9714" title="Connect to the pg server.">lspg_pg_connect</a>( <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>);
<a name="l01517"></a>01517 
<a name="l01518"></a>01518 
<a name="l01519"></a>01519   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#aaf1dd8ba4dafb91c296554c4cbf312e3">LS_PG_STATE_IDLE</a> &amp;&amp; <a class="code" href="lspg_8c.html#a3cbe7f3161b3c1838ebc56a3bbcfd8a6" title="Next position to add something to the queue.">lspg_query_queue_on</a> != <a class="code" href="lspg_8c.html#aca86bb77d6cecfae9251743f4171bafb" title="The last item still being used (on == off means nothing in queue).">lspg_query_queue_off</a>)
<a name="l01520"></a>01520     <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#a3c6eb19f262a990e1f9ba630d9edc309">LS_PG_STATE_SEND</a>;
<a name="l01521"></a>01521 
<a name="l01522"></a>01522   <span class="keywordflow">switch</span>( <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a>) {
<a name="l01523"></a>01523   <span class="keywordflow">case</span> <a class="code" href="lspg_8c.html#ae7ea5876846b5f04c419aee22d3c0aa1">LS_PG_STATE_INIT_POLL</a>:
<a name="l01524"></a>01524     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a69ae04978986e6413ca7cefcb692b645" title="Used to determine state while connecting.">lspg_connectPoll_response</a> == PGRES_POLLING_WRITING)
<a name="l01525"></a>01525       <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.events = POLLOUT;
<a name="l01526"></a>01526     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a69ae04978986e6413ca7cefcb692b645" title="Used to determine state while connecting.">lspg_connectPoll_response</a> == PGRES_POLLING_READING)
<a name="l01527"></a>01527       <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.events = POLLIN;
<a name="l01528"></a>01528     <span class="keywordflow">else</span>
<a name="l01529"></a>01529       <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.events = 0;
<a name="l01530"></a>01530     <span class="keywordflow">break</span>;
<a name="l01531"></a>01531       
<a name="l01532"></a>01532   <span class="keywordflow">case</span> <a class="code" href="lspg_8c.html#ac70a1141f3b138055ea7143bd493187c">LS_PG_STATE_RESET_POLL</a>:
<a name="l01533"></a>01533     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a06c5a937e41a6c706a247777642ec1fb" title="Used to determine state while reconnecting.">lspg_resetPoll_response</a> == PGRES_POLLING_WRITING)
<a name="l01534"></a>01534       <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.events = POLLOUT;
<a name="l01535"></a>01535     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a06c5a937e41a6c706a247777642ec1fb" title="Used to determine state while reconnecting.">lspg_resetPoll_response</a> == PGRES_POLLING_READING)
<a name="l01536"></a>01536       <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.events = POLLIN;
<a name="l01537"></a>01537     <span class="keywordflow">else</span>
<a name="l01538"></a>01538       <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.events = 0;
<a name="l01539"></a>01539     <span class="keywordflow">break</span>;
<a name="l01540"></a>01540 
<a name="l01541"></a>01541   <span class="keywordflow">case</span> <a class="code" href="lspg_8c.html#aaf1dd8ba4dafb91c296554c4cbf312e3">LS_PG_STATE_IDLE</a>:
<a name="l01542"></a>01542   <span class="keywordflow">case</span> <a class="code" href="lspg_8c.html#a373e668840b4795ff9a71bc3f744d209">LS_PG_STATE_RECV</a>:
<a name="l01543"></a>01543     <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.events = POLLIN;
<a name="l01544"></a>01544     <span class="keywordflow">break</span>;
<a name="l01545"></a>01545 
<a name="l01546"></a>01546   <span class="keywordflow">case</span> <a class="code" href="lspg_8c.html#a3c6eb19f262a990e1f9ba630d9edc309">LS_PG_STATE_SEND</a>:
<a name="l01547"></a>01547   <span class="keywordflow">case</span> <a class="code" href="lspg_8c.html#a88a7e80c12fb0449c4b0857a0c7deb21">LS_PG_STATE_SEND_FLUSH</a>:
<a name="l01548"></a>01548     <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.events = POLLOUT;
<a name="l01549"></a>01549     <span class="keywordflow">break</span>;
<a name="l01550"></a>01550 
<a name="l01551"></a>01551   <span class="keywordflow">default</span>:
<a name="l01552"></a>01552     <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.events = 0;
<a name="l01553"></a>01553   }
<a name="l01554"></a>01554 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aeda8dad89b03d7d61cc994dd63ee5db6"></a><!-- doxytag: member="lspg.c::lspg_nextaction_cb" ref="aeda8dad89b03d7d61cc994dd63ee5db6" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_nextaction_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Queue the next MD2 instruction. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>qqp</em>&nbsp;</td><td>The query that generated this result </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pgr</em>&nbsp;</td><td>The result </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01094">1094</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01097"></a>01097                           {
<a name="l01098"></a>01098   <span class="keywordtype">char</span> *action;
<a name="l01099"></a>01099 
<a name="l01100"></a>01100   <span class="keywordflow">if</span>( PQntuples( pgr) &lt;= 0)
<a name="l01101"></a>01101     <span class="keywordflow">return</span>;             <span class="comment">// Note: nextaction should always return at least &quot;noAction&quot;, so this branch should never be taken</span>
<a name="l01102"></a>01102 
<a name="l01103"></a>01103   action = PQgetvalue( pgr, 0, 0);      <span class="comment">// next action only returns one row</span>
<a name="l01104"></a>01104 
<a name="l01105"></a>01105   <span class="keywordflow">if</span>( strcmp( action, <span class="stringliteral">&quot;noAction&quot;</span>) == 0)
<a name="l01106"></a>01106     <span class="keywordflow">return</span>;
<a name="l01107"></a>01107   
<a name="l01108"></a>01108   <span class="keywordflow">if</span>( pthread_mutex_trylock( &amp;<a class="code" href="md2cmds_8c.html#ad67304bb851dc6268b0cda2f40fc5aa8" title="mutex for the condition">md2cmds_mutex</a>) == 0) {
<a name="l01109"></a>01109     strncpy( <a class="code" href="md2cmds_8c.html#a5f0fe1e2dfa92cf345b8c29134ab1ede" title="our command;">md2cmds_cmd</a>, action, <a class="code" href="pgpmac_8h.html#a30f0f377b0f0695284145d420ea51846">MD2CMDS_CMD_LENGTH</a>-1);
<a name="l01110"></a>01110     <a class="code" href="md2cmds_8c.html#a5f0fe1e2dfa92cf345b8c29134ab1ede" title="our command;">md2cmds_cmd</a>[<a class="code" href="pgpmac_8h.html#a30f0f377b0f0695284145d420ea51846">MD2CMDS_CMD_LENGTH</a>-1] = 0;
<a name="l01111"></a>01111     pthread_cond_signal( &amp;<a class="code" href="md2cmds_8c.html#a08d5b18ec9478d753c46a3e28d1f2126" title="condition to signal when it&amp;#39;s time to run an md2 command">md2cmds_cond</a>);
<a name="l01112"></a>01112     pthread_mutex_unlock( &amp;<a class="code" href="md2cmds_8c.html#ad67304bb851dc6268b0cda2f40fc5aa8" title="mutex for the condition">md2cmds_mutex</a>);
<a name="l01113"></a>01113   } <span class="keywordflow">else</span> {
<a name="l01114"></a>01114     <a class="code" href="lslogging_8c.html#a0e756b36671055ef02a8f04d2ba8a93b">lslogging_log_message</a>( <span class="stringliteral">&quot;MD2 command &apos;%s&apos; ignored.  Already running &apos;%s&apos;&quot;</span>, action, <a class="code" href="md2cmds_8c.html#a5f0fe1e2dfa92cf345b8c29134ab1ede" title="our command;">md2cmds_cmd</a>);
<a name="l01115"></a>01115   }
<a name="l01116"></a>01116 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af17ef79544ca5d78fd477010fe90d538"></a><!-- doxytag: member="lspg.c::lspg_nextshot_call" ref="af17ef79544ca5d78fd477010fe90d538" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_nextshot_call </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Queue up a nextshot query. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00708">708</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00708"></a>00708                           {
<a name="l00709"></a>00709   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a38b657155fbee9b73278f76912cf2333" title="Our mutex for sanity in the multi-threaded program.">mutex</a>));
<a name="l00710"></a>00710   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#adb8da14444b98f556dba9420dd4666dc" title="Our flag for the condition to wait for.">new_value_ready</a> = 0;
<a name="l00711"></a>00711   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a38b657155fbee9b73278f76912cf2333" title="Our mutex for sanity in the multi-threaded program.">mutex</a>));
<a name="l00712"></a>00712   
<a name="l00713"></a>00713   <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#a9e92a204f606761d368ac7e06ef0f09c" title="Next Shot Callback.">lspg_nextshot_cb</a>, <span class="stringliteral">&quot;SELECT * FROM px.nextshot()&quot;</span>);
<a name="l00714"></a>00714 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a9e92a204f606761d368ac7e06ef0f09c"></a><!-- doxytag: member="lspg.c::lspg_nextshot_cb" ref="a9e92a204f606761d368ac7e06ef0f09c" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_nextshot_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Next Shot Callback. </p>
<p>This is a long and tedious routine as there are a large number of variables returned. Suck it up. Return with the global variable lspg_nextshot set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>qqp</em>&nbsp;</td><td>Our nextshot query </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pgr</em>&nbsp;</td><td>result of the query </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00453">453</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00456"></a>00456                         {
<a name="l00457"></a>00457   <span class="keyword">static</span> <span class="keywordtype">int</span> got_col_nums=0;
<a name="l00458"></a>00458   <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00459"></a>00459     dsdir_c, dspid_c, dsowidth_c, dsoscaxis_c, dsexp_c, skey_c, sstart_c, sfn_c, dsphi_c,
<a name="l00460"></a>00460     dsomega_c, dskappa_c, dsdist_c, dsnrg_c, dshpid_c, cx_c, cy_c, ax_c, ay_c, az_c,
<a name="l00461"></a>00461     active_c, sindex_c, stype_c,
<a name="l00462"></a>00462     dsowidth2_c, dsoscaxis2_c, dsexp2_c, sstart2_c, dsphi2_c, dsomega2_c, dskappa2_c, dsdist2_c, dsnrg2_c,
<a name="l00463"></a>00463     cx2_c, cy2_c, ax2_c, ay2_c, az2_c, active2_c, sindex2_c, stype2_c;
<a name="l00464"></a>00464   
<a name="l00465"></a>00465   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a38b657155fbee9b73278f76912cf2333" title="Our mutex for sanity in the multi-threaded program.">mutex</a>));
<a name="l00466"></a>00466 
<a name="l00467"></a>00467   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#abc9242805729f70b83df79706c394c71" title="flag indicating that no rows were returned.">no_rows_returned</a> = PQntuples( pgr) &lt;= 0;
<a name="l00468"></a>00468   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#abc9242805729f70b83df79706c394c71" title="flag indicating that no rows were returned.">no_rows_returned</a>) {
<a name="l00469"></a>00469     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#adb8da14444b98f556dba9420dd4666dc" title="Our flag for the condition to wait for.">new_value_ready</a> = 1;
<a name="l00470"></a>00470     pthread_cond_signal( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#afc773a9eefc173aa98d5c2889e1d7669" title="Condition to wait for a response from our postgresql server.">cond</a>));
<a name="l00471"></a>00471     pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a38b657155fbee9b73278f76912cf2333" title="Our mutex for sanity in the multi-threaded program.">mutex</a>));
<a name="l00472"></a>00472     <span class="keywordflow">return</span>;                     <span class="comment">// I guess there was no shot after all</span>
<a name="l00473"></a>00473   }
<a name="l00474"></a>00474 
<a name="l00475"></a>00475   <span class="keywordflow">if</span>( got_col_nums == 0) {
<a name="l00476"></a>00476     dsdir_c      = PQfnumber( pgr, <span class="stringliteral">&quot;dsdir&quot;</span>);
<a name="l00477"></a>00477     dspid_c      = PQfnumber( pgr, <span class="stringliteral">&quot;dspid&quot;</span>);
<a name="l00478"></a>00478     dsowidth_c   = PQfnumber( pgr, <span class="stringliteral">&quot;dsowidth&quot;</span>);
<a name="l00479"></a>00479     dsoscaxis_c  = PQfnumber( pgr, <span class="stringliteral">&quot;dsoscaxis&quot;</span>);
<a name="l00480"></a>00480     dsexp_c      = PQfnumber( pgr, <span class="stringliteral">&quot;dsexp&quot;</span>);
<a name="l00481"></a>00481     skey_c       = PQfnumber( pgr, <span class="stringliteral">&quot;skey&quot;</span>);
<a name="l00482"></a>00482     sstart_c     = PQfnumber( pgr, <span class="stringliteral">&quot;sstart&quot;</span>);
<a name="l00483"></a>00483     sfn_c        = PQfnumber( pgr, <span class="stringliteral">&quot;sfn&quot;</span>);
<a name="l00484"></a>00484     dsphi_c      = PQfnumber( pgr, <span class="stringliteral">&quot;dsphi&quot;</span>);
<a name="l00485"></a>00485     dsomega_c    = PQfnumber( pgr, <span class="stringliteral">&quot;dsomega&quot;</span>);
<a name="l00486"></a>00486     dskappa_c    = PQfnumber( pgr, <span class="stringliteral">&quot;dskappa&quot;</span>);
<a name="l00487"></a>00487     dsdist_c     = PQfnumber( pgr, <span class="stringliteral">&quot;dsdist&quot;</span>);
<a name="l00488"></a>00488     dsnrg_c      = PQfnumber( pgr, <span class="stringliteral">&quot;dsnrg&quot;</span>);
<a name="l00489"></a>00489     dshpid_c     = PQfnumber( pgr, <span class="stringliteral">&quot;dshpid&quot;</span>);
<a name="l00490"></a>00490     cx_c         = PQfnumber( pgr, <span class="stringliteral">&quot;cx&quot;</span>);
<a name="l00491"></a>00491     cy_c         = PQfnumber( pgr, <span class="stringliteral">&quot;cy&quot;</span>);
<a name="l00492"></a>00492     ax_c         = PQfnumber( pgr, <span class="stringliteral">&quot;ax&quot;</span>);
<a name="l00493"></a>00493     ay_c         = PQfnumber( pgr, <span class="stringliteral">&quot;ay&quot;</span>);
<a name="l00494"></a>00494     az_c         = PQfnumber( pgr, <span class="stringliteral">&quot;az&quot;</span>);
<a name="l00495"></a>00495     active_c     = PQfnumber( pgr, <span class="stringliteral">&quot;active&quot;</span>);
<a name="l00496"></a>00496     sindex_c     = PQfnumber( pgr, <span class="stringliteral">&quot;sindex&quot;</span>);
<a name="l00497"></a>00497     stype_c      = PQfnumber( pgr, <span class="stringliteral">&quot;stype&quot;</span>);
<a name="l00498"></a>00498     dsowidth2_c  = PQfnumber( pgr, <span class="stringliteral">&quot;dsowidth2&quot;</span>);
<a name="l00499"></a>00499     dsoscaxis2_c = PQfnumber( pgr, <span class="stringliteral">&quot;dsoscaxis2&quot;</span>);
<a name="l00500"></a>00500     dsexp2_c     = PQfnumber( pgr, <span class="stringliteral">&quot;dsexp2&quot;</span>);
<a name="l00501"></a>00501     sstart2_c    = PQfnumber( pgr, <span class="stringliteral">&quot;sstart2&quot;</span>);
<a name="l00502"></a>00502     dsphi2_c     = PQfnumber( pgr, <span class="stringliteral">&quot;dsphi2&quot;</span>);
<a name="l00503"></a>00503     dsomega2_c   = PQfnumber( pgr, <span class="stringliteral">&quot;dsomega2&quot;</span>);
<a name="l00504"></a>00504     dskappa2_c   = PQfnumber( pgr, <span class="stringliteral">&quot;dskappa2&quot;</span>);
<a name="l00505"></a>00505     dsdist2_c    = PQfnumber( pgr, <span class="stringliteral">&quot;dsdist2&quot;</span>);
<a name="l00506"></a>00506     dsnrg2_c     = PQfnumber( pgr, <span class="stringliteral">&quot;dsnrg2&quot;</span>);
<a name="l00507"></a>00507     cx2_c        = PQfnumber( pgr, <span class="stringliteral">&quot;cx2&quot;</span>);
<a name="l00508"></a>00508     cy2_c        = PQfnumber( pgr, <span class="stringliteral">&quot;cy2&quot;</span>);
<a name="l00509"></a>00509     ax2_c        = PQfnumber( pgr, <span class="stringliteral">&quot;ax2&quot;</span>);
<a name="l00510"></a>00510     ay2_c        = PQfnumber( pgr, <span class="stringliteral">&quot;ay2&quot;</span>);
<a name="l00511"></a>00511     az2_c        = PQfnumber( pgr, <span class="stringliteral">&quot;az2&quot;</span>);
<a name="l00512"></a>00512     active2_c    = PQfnumber( pgr, <span class="stringliteral">&quot;active2&quot;</span>);
<a name="l00513"></a>00513     sindex2_c    = PQfnumber( pgr, <span class="stringliteral">&quot;sindex2&quot;</span>);
<a name="l00514"></a>00514     stype2_c     = PQfnumber( pgr, <span class="stringliteral">&quot;stype2&quot;</span>);
<a name="l00515"></a>00515     
<a name="l00516"></a>00516     got_col_nums = 1;
<a name="l00517"></a>00517   }
<a name="l00518"></a>00518 
<a name="l00519"></a>00519 
<a name="l00520"></a>00520   <span class="comment">//</span>
<a name="l00521"></a>00521   <span class="comment">// NULL string values come back as empty strings</span>
<a name="l00522"></a>00522   <span class="comment">// Mark the null flag but allocate the empty string anyway</span>
<a name="l00523"></a>00523   <span class="comment">//</span>
<a name="l00524"></a>00524 
<a name="l00525"></a>00525   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a8dea57b78b92d67d83ccbb6ed6da13ca">dsdir_isnull</a> = PQgetisnull( pgr, 0, dsdir_c);
<a name="l00526"></a>00526   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ac372e1774a25b3d4bfbb9169762eb39e" title="Directory for data relative to the ESAF home directory.">dsdir</a> != NULL)
<a name="l00527"></a>00527     free( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ac372e1774a25b3d4bfbb9169762eb39e" title="Directory for data relative to the ESAF home directory.">dsdir</a>);
<a name="l00528"></a>00528   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ac372e1774a25b3d4bfbb9169762eb39e" title="Directory for data relative to the ESAF home directory.">dsdir</a> = strdup( PQgetvalue( pgr, 0, dsdir_c));
<a name="l00529"></a>00529 
<a name="l00530"></a>00530   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a7665485395487756ab448d0c81c84d10">dspid_isnull</a> = PQgetisnull( pgr, 0, dspid_c);
<a name="l00531"></a>00531   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a4487e718c2b55a8ab9ebb18329574ae1" title="ID string identifying this dataset.">dspid</a> != NULL)
<a name="l00532"></a>00532     free( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a4487e718c2b55a8ab9ebb18329574ae1" title="ID string identifying this dataset.">dspid</a>);
<a name="l00533"></a>00533   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a4487e718c2b55a8ab9ebb18329574ae1" title="ID string identifying this dataset.">dspid</a> = strdup( PQgetvalue( pgr, 0, dspid_c));
<a name="l00534"></a>00534 
<a name="l00535"></a>00535   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a51a26391afcacfb4c946fb9e8e9ab6b0">dsoscaxis_isnull</a> = PQgetisnull( pgr, 0, dsoscaxis_c);
<a name="l00536"></a>00536   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a9a62c304e66013e8e5e5618a44f0b6d4" title="dataset defined oscillation axis (always omega)">dsoscaxis</a> != NULL)
<a name="l00537"></a>00537     free( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a9a62c304e66013e8e5e5618a44f0b6d4" title="dataset defined oscillation axis (always omega)">dsoscaxis</a>);
<a name="l00538"></a>00538   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a9a62c304e66013e8e5e5618a44f0b6d4" title="dataset defined oscillation axis (always omega)">dsoscaxis</a> = strdup( PQgetvalue( pgr, 0, dsoscaxis_c));
<a name="l00539"></a>00539 
<a name="l00540"></a>00540   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a98e280e99ae847559bb82836df3c32d1">dsoscaxis2_isnull</a> = PQgetisnull( pgr, 0, dsoscaxis2_c);
<a name="l00541"></a>00541   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ac86005a6e90ff502da9e95b59d0b7a5f" title="next image ascillation axis (always &amp;quot;omega&amp;quot;)">dsoscaxis2</a> != NULL)
<a name="l00542"></a>00542     free( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ac86005a6e90ff502da9e95b59d0b7a5f" title="next image ascillation axis (always &amp;quot;omega&amp;quot;)">dsoscaxis2</a>);
<a name="l00543"></a>00543   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ac86005a6e90ff502da9e95b59d0b7a5f" title="next image ascillation axis (always &amp;quot;omega&amp;quot;)">dsoscaxis2</a> = strdup( PQgetvalue( pgr, 0, dsoscaxis2_c));
<a name="l00544"></a>00544 
<a name="l00545"></a>00545   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a56f32eb413b1fca9f085874eb86294de">sfn_isnull</a> = PQgetisnull(pgr, 0, sfn_c);
<a name="l00546"></a>00546   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a03252bba597b081edc9d08b20b558cc7" title="file name">sfn</a> != NULL)
<a name="l00547"></a>00547     free( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a03252bba597b081edc9d08b20b558cc7" title="file name">sfn</a>);
<a name="l00548"></a>00548   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a03252bba597b081edc9d08b20b558cc7" title="file name">sfn</a> = strdup( PQgetvalue( pgr, 0, sfn_c));
<a name="l00549"></a>00549 
<a name="l00550"></a>00550   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a79f48c452a4aca8506bae22f897c7441">stype_isnull</a> = PQgetisnull( pgr, 0, stype_c);
<a name="l00551"></a>00551   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ab5a70b189c2fe516ca0c84bd06f3e564" title="&amp;quot;Normal&amp;quot; or &amp;quot;Gridsearch&amp;quot;">stype</a> != NULL)
<a name="l00552"></a>00552     free( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ab5a70b189c2fe516ca0c84bd06f3e564" title="&amp;quot;Normal&amp;quot; or &amp;quot;Gridsearch&amp;quot;">stype</a>);
<a name="l00553"></a>00553   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ab5a70b189c2fe516ca0c84bd06f3e564" title="&amp;quot;Normal&amp;quot; or &amp;quot;Gridsearch&amp;quot;">stype</a> = strdup( PQgetvalue( pgr, 0, stype_c));
<a name="l00554"></a>00554 
<a name="l00555"></a>00555   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a203e29ed0bb403aaab6d7f95f690cc0d">stype2_isnull</a> = PQgetisnull( pgr, 0, stype2_c);
<a name="l00556"></a>00556   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ae08ef74ea76e6e099a3ff6c7f845d337" title="next image type (&amp;quot;Normal&amp;quot; or &amp;quot;Gridsearch&amp;quot;)">stype2</a> != NULL)
<a name="l00557"></a>00557     free( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ae08ef74ea76e6e099a3ff6c7f845d337" title="next image type (&amp;quot;Normal&amp;quot; or &amp;quot;Gridsearch&amp;quot;)">stype2</a>);
<a name="l00558"></a>00558   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ae08ef74ea76e6e099a3ff6c7f845d337" title="next image type (&amp;quot;Normal&amp;quot; or &amp;quot;Gridsearch&amp;quot;)">stype2</a> = strdup( PQgetvalue( pgr, 0, stype2_c));
<a name="l00559"></a>00559 
<a name="l00560"></a>00560   <span class="comment">//</span>
<a name="l00561"></a>00561   <span class="comment">// Probably shouldn&apos;t try to convert null number values</span>
<a name="l00562"></a>00562   <span class="comment">//</span>
<a name="l00563"></a>00563   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a5dd3db64790e09bc03499e521bbaa126">dsowidth_isnull</a> = PQgetisnull( pgr, 0, dsowidth_c);
<a name="l00564"></a>00564   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a5dd3db64790e09bc03499e521bbaa126">dsowidth_isnull</a> == 0)
<a name="l00565"></a>00565     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ad5a8f568a04aa6a13767933062b28f19" title="dataset defined oscillation width">dsowidth</a> = atof( PQgetvalue( pgr,0, dsowidth_c));
<a name="l00566"></a>00566 
<a name="l00567"></a>00567   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ae07498f62ea9c0e2f702b78c87500794">dsexp_isnull</a> = PQgetisnull( pgr, 0, dsexp_c);
<a name="l00568"></a>00568   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ae07498f62ea9c0e2f702b78c87500794">dsexp_isnull</a> == 0)
<a name="l00569"></a>00569     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a063e4c99201a763c2eb048acfc855efa" title="dataset defined exposure time">dsexp</a>    = atof( PQgetvalue( pgr,0, dsexp_c));
<a name="l00570"></a>00570 
<a name="l00571"></a>00571   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#aa53094de91e2f69d7174ab119df1cdac">sstart_isnull</a> = PQgetisnull( pgr, 0, sstart_c);
<a name="l00572"></a>00572   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#aa53094de91e2f69d7174ab119df1cdac">sstart_isnull</a> == 0)
<a name="l00573"></a>00573     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a8dc11eaa094d59f61642c4abc226918f" title="starting angle">sstart</a>   = atof( PQgetvalue( pgr,0, sstart_c));
<a name="l00574"></a>00574 
<a name="l00575"></a>00575   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a2d1f51cb1bb575a214344773136be878">dsphi_isnull</a> = PQgetisnull( pgr, 0, dsphi_c);
<a name="l00576"></a>00576   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a2d1f51cb1bb575a214344773136be878">dsphi_isnull</a> == 0)
<a name="l00577"></a>00577     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a64ebde597ca97a3b98145dc2d580c64f" title="dataset defined starting phi angle">dsphi</a>    = atof( PQgetvalue( pgr,0, dsphi_c));
<a name="l00578"></a>00578 
<a name="l00579"></a>00579   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ad1da3548dc642d415aed53dc165c44fc">dsomega_isnull</a> = PQgetisnull( pgr, 0, dsomega_c);
<a name="l00580"></a>00580   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ad1da3548dc642d415aed53dc165c44fc">dsomega_isnull</a> == 0)
<a name="l00581"></a>00581     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a4be525bb32fb0232c21a91529f1e8c73" title="dataset defined starting omega angle">dsomega</a>  = atof( PQgetvalue( pgr,0, dsomega_c));
<a name="l00582"></a>00582 
<a name="l00583"></a>00583   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a1686a72509cc1c3383ee95a790ddff14">dskappa_isnull</a> = PQgetisnull( pgr, 0, dskappa_c);
<a name="l00584"></a>00584   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a1686a72509cc1c3383ee95a790ddff14">dskappa_isnull</a> == 0)
<a name="l00585"></a>00585     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a59355281e8eb935cd7bfac597fdc5289" title="dataset defined starting kappa angle">dskappa</a>  = atof( PQgetvalue( pgr,0, dskappa_c));
<a name="l00586"></a>00586 
<a name="l00587"></a>00587   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ac6f2bdc7b023d933509bf74af7b169f9">dsdist_isnull</a> = PQgetisnull( pgr, 0, dsdist_c);
<a name="l00588"></a>00588   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ac6f2bdc7b023d933509bf74af7b169f9">dsdist_isnull</a> == 0)
<a name="l00589"></a>00589     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#acab9431a911f5bb11296cbfb271fb83a" title="dataset defined detector distance">dsdist</a>   = atof( PQgetvalue( pgr,0, dsdist_c));
<a name="l00590"></a>00590 
<a name="l00591"></a>00591   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ad14d8bb50290ec12e58f4aaec5cc5aab">dsnrg_isnull</a> = PQgetisnull( pgr, 0, dsnrg_c);
<a name="l00592"></a>00592   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ad14d8bb50290ec12e58f4aaec5cc5aab">dsnrg_isnull</a> == 0)
<a name="l00593"></a>00593     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a371e574055fec7660b8f2e637eaf9f25" title="dataset defined energy">dsnrg</a>    = atof( PQgetvalue( pgr,0, dsnrg_c));
<a name="l00594"></a>00594 
<a name="l00595"></a>00595   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a779b99533f0ed4e659177afb0b791ad2">cx_isnull</a> = PQgetisnull( pgr, 0, cx_c);
<a name="l00596"></a>00596   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a779b99533f0ed4e659177afb0b791ad2">cx_isnull</a> == 0)
<a name="l00597"></a>00597     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ad9eb2013fa6f295f72f0891fe98c863f" title="centering table x position">cx</a>       = atof( PQgetvalue( pgr,0, cx_c));
<a name="l00598"></a>00598 
<a name="l00599"></a>00599   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a3895d645420848aed05b95694ec8c6c7">cy_isnull</a> = PQgetisnull( pgr, 0, cy_c);
<a name="l00600"></a>00600   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a3895d645420848aed05b95694ec8c6c7">cy_isnull</a> == 0)
<a name="l00601"></a>00601     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ab7a7b37a17f06c4e9ebdcdf056946098" title="centering table y position">cy</a>       = atof( PQgetvalue( pgr,0, cy_c));
<a name="l00602"></a>00602 
<a name="l00603"></a>00603   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#aae46c7911b2b218497ad4a68f3dbb7d9">ax_isnull</a> = PQgetisnull( pgr, 0, ax_c);
<a name="l00604"></a>00604   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#aae46c7911b2b218497ad4a68f3dbb7d9">ax_isnull</a> == 0)
<a name="l00605"></a>00605     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a7f57874223897ab7d9c7531a9522904d" title="alignment table x position">ax</a>       = atof( PQgetvalue( pgr,0, ax_c));
<a name="l00606"></a>00606 
<a name="l00607"></a>00607   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a9da91abc8090532ed98ccd47a3bab775">ay_isnull</a> = PQgetisnull( pgr, 0, ay_c);
<a name="l00608"></a>00608   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a9da91abc8090532ed98ccd47a3bab775">ay_isnull</a> == 0)
<a name="l00609"></a>00609     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a9e20b9a0aeb41f7f7d653a1c60335bf1" title="alignment table y position">ay</a>       = atof( PQgetvalue( pgr,0, ay_c));
<a name="l00610"></a>00610 
<a name="l00611"></a>00611   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#aaebd6d432810313294b5fed5f4445cb1">az_isnull</a> = PQgetisnull( pgr, 0, az_c);
<a name="l00612"></a>00612   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#aaebd6d432810313294b5fed5f4445cb1">az_isnull</a> == 0)
<a name="l00613"></a>00613     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a66e678866ce79f6398b66d033ae45a17" title="alignment table z position">az</a>       = atof( PQgetvalue( pgr,0, az_c));
<a name="l00614"></a>00614   
<a name="l00615"></a>00615   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a9f777671ec617a0f533b3c51f28babb3">active_isnull</a> = PQgetisnull( pgr, 0, active_c);
<a name="l00616"></a>00616   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a9f777671ec617a0f533b3c51f28babb3">active_isnull</a> == 0)
<a name="l00617"></a>00617     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a1a94eefbad713976a3d9213695a6ca28" title="flag: 1=move to indicated center position, 0=don&amp;#39;t move center or alignment tables...">active</a> = atoi( PQgetvalue( pgr, 0, active_c));
<a name="l00618"></a>00618 
<a name="l00619"></a>00619   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a7ca4fbc86974d1b75a681ba5ecaaf5af">sindex_isnull</a> = PQgetisnull( pgr, 0, sindex_c);
<a name="l00620"></a>00620   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a7ca4fbc86974d1b75a681ba5ecaaf5af">sindex_isnull</a> == 0)
<a name="l00621"></a>00621     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a5d096f2c2bf9be29c44129b54eaf01da" title="index of frame (used to generate the file extension)">sindex</a> = atoi( PQgetvalue( pgr, 0, sindex_c));
<a name="l00622"></a>00622 
<a name="l00623"></a>00623   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#afe16be0382423aa3f25cb3d6cf99430b">dshpid_isnull</a> = PQgetisnull( pgr, 0, dshpid_c);
<a name="l00624"></a>00624   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#afe16be0382423aa3f25cb3d6cf99430b">dshpid_isnull</a> == 0)
<a name="l00625"></a>00625     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a5e260a420176f2973cdb100d0a5c4c09" title="sample holder ID">dshpid</a> = atoi( PQgetvalue( pgr, 0, dshpid_c));
<a name="l00626"></a>00626   
<a name="l00627"></a>00627   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#abd3c69357470052eb79ddd8eddd57b2c">skey_isnull</a> = PQgetisnull( pgr, 0, skey_c);
<a name="l00628"></a>00628   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#abd3c69357470052eb79ddd8eddd57b2c">skey_isnull</a> == 0)
<a name="l00629"></a>00629     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#af64a4e3f17752b5f1f05fb15d6f48382" title="key identifying a particulary image">skey</a>   = atoll( PQgetvalue( pgr, 0, skey_c));
<a name="l00630"></a>00630 
<a name="l00631"></a>00631   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a5ffd27b8063506fd54162658e5c2ce8a">dsowidth2_isnull</a> = PQgetisnull( pgr, 0, dsowidth2_c);
<a name="l00632"></a>00632   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a5ffd27b8063506fd54162658e5c2ce8a">dsowidth2_isnull</a> == 0)
<a name="l00633"></a>00633     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a5378e13735a5392a9fcd853ce8c9e929" title="next image oscillation width">dsowidth2</a> = atof( PQgetvalue( pgr,0, dsowidth2_c));
<a name="l00634"></a>00634 
<a name="l00635"></a>00635   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a45091283dc073e5b7da2cfbe5a75fade">dsexp2_isnull</a> = PQgetisnull( pgr, 0, dsexp2_c);
<a name="l00636"></a>00636   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a45091283dc073e5b7da2cfbe5a75fade">dsexp2_isnull</a> == 0)
<a name="l00637"></a>00637     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a4d8c34309572875352ddabe9cc9001ee" title="next image exposure time">dsexp2</a>    = atof( PQgetvalue( pgr,0, dsexp2_c));
<a name="l00638"></a>00638 
<a name="l00639"></a>00639   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a240c8532d5ce48dbc872d5123a4e721c">sstart2_isnull</a> = PQgetisnull( pgr, 0, sstart2_c);
<a name="l00640"></a>00640   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a240c8532d5ce48dbc872d5123a4e721c">sstart2_isnull</a> == 0)
<a name="l00641"></a>00641     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a8445cbd2206dc6d62b6bd433f5218c98" title="next image start angle">sstart2</a>   = atof( PQgetvalue( pgr,0, sstart2_c));
<a name="l00642"></a>00642 
<a name="l00643"></a>00643   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a57a9c43be86188f65b96d59c2adec674">dsphi2_isnull</a> = PQgetisnull( pgr, 0, dsphi2_c);
<a name="l00644"></a>00644   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a57a9c43be86188f65b96d59c2adec674">dsphi2_isnull</a> == 0)
<a name="l00645"></a>00645     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a98857616b6bbb6ba861e96b6b7551756" title="next image phi position">dsphi2</a>    = atof( PQgetvalue( pgr,0, dsphi2_c));
<a name="l00646"></a>00646 
<a name="l00647"></a>00647   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#afaf9bdf89a68e7f479969072643e55eb">dsomega2_isnull</a> = PQgetisnull( pgr, 0, dsomega2_c);
<a name="l00648"></a>00648   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#afaf9bdf89a68e7f479969072643e55eb">dsomega2_isnull</a> == 0)
<a name="l00649"></a>00649     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a84ae35abfa725d1bdbff5403f6384ee4" title="next image omega position">dsomega2</a>  = atof( PQgetvalue( pgr,0, dsomega2_c));
<a name="l00650"></a>00650 
<a name="l00651"></a>00651   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a9a7e47372f4f6e0e48a0cb3c78fa8437">dskappa2_isnull</a> = PQgetisnull( pgr, 0, dskappa2_c);
<a name="l00652"></a>00652   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a9a7e47372f4f6e0e48a0cb3c78fa8437">dskappa2_isnull</a> == 0)
<a name="l00653"></a>00653     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a8571a0b95fb6ea6356fd7204b9c9e371" title="next image kappa position">dskappa2</a>  = atof( PQgetvalue( pgr,0, dskappa2_c));
<a name="l00654"></a>00654 
<a name="l00655"></a>00655   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a7fce65f4719a4a8110006f8b72eec3f7">dsdist2_isnull</a> = PQgetisnull( pgr, 0, dsdist2_c);
<a name="l00656"></a>00656   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a7fce65f4719a4a8110006f8b72eec3f7">dsdist2_isnull</a> == 0)
<a name="l00657"></a>00657     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a516827749068577217b27860a01e6041" title="next image distance">dsdist2</a>   = atof( PQgetvalue( pgr,0, dsdist2_c));
<a name="l00658"></a>00658 
<a name="l00659"></a>00659   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#aee9f8196dd9bcea832a60f2f0ea3a999">dsnrg2_isnull</a> = PQgetisnull( pgr, 0, dsnrg2_c);
<a name="l00660"></a>00660   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#aee9f8196dd9bcea832a60f2f0ea3a999">dsnrg2_isnull</a> == 0)
<a name="l00661"></a>00661     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ae461439c2af31255227765c0fb61850f" title="next image energy">dsnrg2</a>    = atof( PQgetvalue( pgr,0, dsnrg2_c));
<a name="l00662"></a>00662 
<a name="l00663"></a>00663   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a3ad947f4efe2cb5c338244b019334749">cx2_isnull</a> = PQgetisnull( pgr, 0, cx2_c);
<a name="l00664"></a>00664   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a3ad947f4efe2cb5c338244b019334749">cx2_isnull</a> == 0)
<a name="l00665"></a>00665     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a10d45763100bc59f9a5f68f1b48db6d3" title="next image centering table x position">cx2</a>       = atof( PQgetvalue( pgr,0, cx2_c));
<a name="l00666"></a>00666 
<a name="l00667"></a>00667   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a57d78a389413827302df6ebe3dcb3c89">cy2_isnull</a> = PQgetisnull( pgr, 0, cy2_c);
<a name="l00668"></a>00668   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a57d78a389413827302df6ebe3dcb3c89">cy2_isnull</a> == 0)
<a name="l00669"></a>00669     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a3644e5c3f12af18a3b426d4d4d7e16a5" title="next image centering table y position">cy2</a>       = atof( PQgetvalue( pgr,0, cy2_c));
<a name="l00670"></a>00670 
<a name="l00671"></a>00671   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a846845b0b9ecf6517ef85554771ec71d">ax2_isnull</a> = PQgetisnull( pgr, 0, ax2_c);
<a name="l00672"></a>00672   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a846845b0b9ecf6517ef85554771ec71d">ax2_isnull</a> == 0)
<a name="l00673"></a>00673     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ab76bd38d2a098bc7eda82aff5dcb9c66" title="next image alignment x position">ax2</a>       = atof( PQgetvalue( pgr,0, ax2_c));
<a name="l00674"></a>00674 
<a name="l00675"></a>00675   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ad0f50ec6339296d3d39c8d95131ab6b5">ay2_isnull</a> = PQgetisnull( pgr, 0, ay2_c);
<a name="l00676"></a>00676   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ad0f50ec6339296d3d39c8d95131ab6b5">ay2_isnull</a> == 0)
<a name="l00677"></a>00677     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ad13759740204b42e379161f98815f3d0" title="next image alignment y position">ay2</a>       = atof( PQgetvalue( pgr,0, ay2_c));
<a name="l00678"></a>00678 
<a name="l00679"></a>00679   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a95d080f13a4e02b9aa883821ee3e721c">az2_isnull</a> = PQgetisnull( pgr, 0, az2_c);
<a name="l00680"></a>00680   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a95d080f13a4e02b9aa883821ee3e721c">az2_isnull</a> == 0)
<a name="l00681"></a>00681     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a94698a030fd5b2abf1f10a2ad33476a4" title="next image alignment z position">az2</a>       = atof( PQgetvalue( pgr,0, az2_c));
<a name="l00682"></a>00682   
<a name="l00683"></a>00683   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a1aa11ff4a4c8d69695786b4349e84e6b">active2_isnull</a> = PQgetisnull( pgr, 0, active2_c);
<a name="l00684"></a>00684   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a1aa11ff4a4c8d69695786b4349e84e6b">active2_isnull</a> == 0)
<a name="l00685"></a>00685     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a2875aa18df587806a3d8c05220fd62b5" title="flag: 1 if next image should use the above centering parameters">active2</a> = atoi( PQgetvalue( pgr, 0, active2_c));
<a name="l00686"></a>00686 
<a name="l00687"></a>00687   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a28e0b5c32a2741ef22edeb9d35b04e4d">sindex2_isnull</a> = PQgetisnull( pgr, 0, sindex2_c);
<a name="l00688"></a>00688   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a28e0b5c32a2741ef22edeb9d35b04e4d">sindex2_isnull</a> == 0)
<a name="l00689"></a>00689     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ae9d0cfdff6868e0ba9cd5acafbe133db" title="next image index number">sindex2</a> = atoi( PQgetvalue( pgr, 0, sindex2_c));
<a name="l00690"></a>00690 
<a name="l00691"></a>00691   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#adb8da14444b98f556dba9420dd4666dc" title="Our flag for the condition to wait for.">new_value_ready</a> = 1;
<a name="l00692"></a>00692 
<a name="l00693"></a>00693   pthread_cond_signal( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#afc773a9eefc173aa98d5c2889e1d7669" title="Condition to wait for a response from our postgresql server.">cond</a>));
<a name="l00694"></a>00694   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a38b657155fbee9b73278f76912cf2333" title="Our mutex for sanity in the multi-threaded program.">mutex</a>));
<a name="l00695"></a>00695 
<a name="l00696"></a>00696 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a50458a014041a4118452802dfb303960"></a><!-- doxytag: member="lspg.c::lspg_nextshot_done" ref="a50458a014041a4118452802dfb303960" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_nextshot_done </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when the next shot query has been processed. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00726">726</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00726"></a>00726                           {
<a name="l00727"></a>00727   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a38b657155fbee9b73278f76912cf2333" title="Our mutex for sanity in the multi-threaded program.">mutex</a>));
<a name="l00728"></a>00728 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aff91db7d60e6c832684c023813e36dbf"></a><!-- doxytag: member="lspg.c::lspg_nextshot_init" ref="aff91db7d60e6c832684c023813e36dbf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_nextshot_init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the nextshot variable, mutex, and condition. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00700">700</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00700"></a>00700                           {
<a name="l00701"></a>00701   memset( &amp;<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>, 0, <span class="keyword">sizeof</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>));
<a name="l00702"></a>00702   pthread_mutex_init( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a38b657155fbee9b73278f76912cf2333" title="Our mutex for sanity in the multi-threaded program.">mutex</a>), NULL);
<a name="l00703"></a>00703   pthread_cond_init( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#afc773a9eefc173aa98d5c2889e1d7669" title="Condition to wait for a response from our postgresql server.">cond</a>), NULL);
<a name="l00704"></a>00704 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a784a6de32a86fec9efb3ef3ae4b6e3ac"></a><!-- doxytag: member="lspg.c::lspg_nextshot_wait" ref="a784a6de32a86fec9efb3ef3ae4b6e3ac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_nextshot_wait </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for the next shot query to get processed. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00718">718</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00718"></a>00718                           {
<a name="l00719"></a>00719   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a38b657155fbee9b73278f76912cf2333" title="Our mutex for sanity in the multi-threaded program.">mutex</a>));
<a name="l00720"></a>00720   <span class="keywordflow">while</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#adb8da14444b98f556dba9420dd4666dc" title="Our flag for the condition to wait for.">new_value_ready</a> == 0)
<a name="l00721"></a>00721     pthread_cond_wait( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#afc773a9eefc173aa98d5c2889e1d7669" title="Condition to wait for a response from our postgresql server.">cond</a>), &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a38b657155fbee9b73278f76912cf2333" title="Our mutex for sanity in the multi-threaded program.">mutex</a>));
<a name="l00722"></a>00722 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a581c18be0368425665a40b4b7f7d9714"></a><!-- doxytag: member="lspg.c::lspg_pg_connect" ref="a581c18be0368425665a40b4b7f7d9714" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_pg_connect </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect to the pg server. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01409">1409</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01409"></a>01409                        {
<a name="l01410"></a>01410   PGresult *pgr;
<a name="l01411"></a>01411   <span class="keywordtype">int</span> wait_interval = 1;
<a name="l01412"></a>01412   <span class="keywordtype">int</span> connection_init = 0;
<a name="l01413"></a>01413   <span class="keywordtype">int</span> i, err;
<a name="l01414"></a>01414 
<a name="l01415"></a>01415   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a> == NULL)
<a name="l01416"></a>01416     <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#af443092447378c73bf93aa143576aba4">LS_PG_STATE_INIT</a>;
<a name="l01417"></a>01417 
<a name="l01418"></a>01418   <span class="keywordflow">switch</span>( <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a>) {
<a name="l01419"></a>01419   <span class="keywordflow">case</span> <a class="code" href="lspg_8c.html#af443092447378c73bf93aa143576aba4">LS_PG_STATE_INIT</a>:
<a name="l01420"></a>01420 
<a name="l01421"></a>01421     <span class="keywordflow">if</span>( lspg_time_sent.tv_sec != 0) {
<a name="l01422"></a>01422       <span class="comment">//</span>
<a name="l01423"></a>01423       <span class="comment">// Reality check: if it&apos;s less the about 10 seconds since the last failed attempt</span>
<a name="l01424"></a>01424       <span class="comment">// the just chill.</span>
<a name="l01425"></a>01425       <span class="comment">//</span>
<a name="l01426"></a>01426       gettimeofday( &amp;<a class="code" href="lspg_8c.html#ad40ac52086f6b774928af45b09d54c6e" title="used to ensure we do not inundate the db server with connection requests">now</a>, NULL);
<a name="l01427"></a>01427       <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad40ac52086f6b774928af45b09d54c6e" title="used to ensure we do not inundate the db server with connection requests">now</a>.tv_sec - lspg_time_sent.tv_sec &lt; 10) {
<a name="l01428"></a>01428         <span class="keywordflow">return</span>;
<a name="l01429"></a>01429       }
<a name="l01430"></a>01430     }
<a name="l01431"></a>01431 
<a name="l01432"></a>01432     <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a> = PQconnectStart( <span class="stringliteral">&quot;dbname=ls user=lsuser hostaddr=10.1.0.3&quot;</span>);
<a name="l01433"></a>01433     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a> == NULL) {
<a name="l01434"></a>01434       <a class="code" href="lslogging_8c.html#a0e756b36671055ef02a8f04d2ba8a93b">lslogging_log_message</a>( <span class="stringliteral">&quot;Out of memory (lspg_pg_connect)&quot;</span>);
<a name="l01435"></a>01435       exit( -1);
<a name="l01436"></a>01436     }
<a name="l01437"></a>01437 
<a name="l01438"></a>01438     err = PQstatus( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01439"></a>01439     <span class="keywordflow">if</span>( err == CONNECTION_BAD) {
<a name="l01440"></a>01440       <a class="code" href="lslogging_8c.html#a0e756b36671055ef02a8f04d2ba8a93b">lslogging_log_message</a>( <span class="stringliteral">&quot;Trouble connecting to database&quot;</span>);
<a name="l01441"></a>01441 
<a name="l01442"></a>01442       gettimeofday( &amp;lspg_time_sent, NULL);
<a name="l01443"></a>01443       <span class="keywordflow">return</span>;
<a name="l01444"></a>01444     }
<a name="l01445"></a>01445     err = PQsetnonblocking( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>, 1);
<a name="l01446"></a>01446     <span class="keywordflow">if</span>( err != 0) {
<a name="l01447"></a>01447       <a class="code" href="lslogging_8c.html#a0e756b36671055ef02a8f04d2ba8a93b">lslogging_log_message</a>( <span class="stringliteral">&quot;Odd, could not set database connection to nonblocking&quot;</span>);
<a name="l01448"></a>01448     }
<a name="l01449"></a>01449 
<a name="l01450"></a>01450     <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#ae7ea5876846b5f04c419aee22d3c0aa1">LS_PG_STATE_INIT_POLL</a>;
<a name="l01451"></a>01451     <a class="code" href="lspg_8c.html#a69ae04978986e6413ca7cefcb692b645" title="Used to determine state while connecting.">lspg_connectPoll_response</a> = PGRES_POLLING_WRITING;
<a name="l01452"></a>01452     <span class="comment">//</span>
<a name="l01453"></a>01453     <span class="comment">// set up the connection for poll</span>
<a name="l01454"></a>01454     <span class="comment">//</span>
<a name="l01455"></a>01455     <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.fd = PQsocket( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01456"></a>01456     <span class="keywordflow">break</span>;
<a name="l01457"></a>01457 
<a name="l01458"></a>01458   <span class="keywordflow">case</span> <a class="code" href="lspg_8c.html#ae7ea5876846b5f04c419aee22d3c0aa1">LS_PG_STATE_INIT_POLL</a>:
<a name="l01459"></a>01459     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a69ae04978986e6413ca7cefcb692b645" title="Used to determine state while connecting.">lspg_connectPoll_response</a> == PGRES_POLLING_FAILED) {
<a name="l01460"></a>01460       PQfinish( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01461"></a>01461       <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a> = NULL;
<a name="l01462"></a>01462       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#af443092447378c73bf93aa143576aba4">LS_PG_STATE_INIT</a>;
<a name="l01463"></a>01463     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a69ae04978986e6413ca7cefcb692b645" title="Used to determine state while connecting.">lspg_connectPoll_response</a> == PGRES_POLLING_OK) {
<a name="l01464"></a>01464       <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#a329a7fdfa5025a403ea2779e178fd3ed" title="Motor initialization callback.">lspg_init_motors_cb</a>, <span class="stringliteral">&quot;select * from pmac.md2_getmotors()&quot;</span>);
<a name="l01465"></a>01465       <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( NULL, <span class="stringliteral">&quot;select pmac.md2_init()&quot;</span>);
<a name="l01466"></a>01466       <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#af34559ab5624e1e68085dbcd9410c692" title="Zoom motor look up table callback.">lspg_zoom_lut_cb</a>, <span class="stringliteral">&quot;SELECT * FROM pmac.md2_zoom_lut()&quot;</span>);
<a name="l01467"></a>01467       <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#ac5d5d512350a9ba346635e2415d7c3d5" title="Front Light Lookup table query callback Install the lookup table for the Front Light...">lspg_flight_lut_cb</a>, <span class="stringliteral">&quot;SELECT * FROM pmac.md2_flight_lut()&quot;</span>);
<a name="l01468"></a>01468       <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#a6f5fa5727f2876f8b9370110a92afa50" title="Back Light Lookup Table Callback Install the lookup table for the Back Light.">lspg_blight_lut_cb</a>, <span class="stringliteral">&quot;SELECT * FROM pmac.md2_blight_lut()&quot;</span>);
<a name="l01469"></a>01469       <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#a71db585552ea3f58a1c9ab3fbe62bb79">lspg_scint_lut_cb</a>,      <span class="stringliteral">&quot;SELECT * FROM pmac.md2_scint_lut()&quot;</span>);
<a name="l01470"></a>01470 
<a name="l01471"></a>01471       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#aaf1dd8ba4dafb91c296554c4cbf312e3">LS_PG_STATE_IDLE</a>;
<a name="l01472"></a>01472     }
<a name="l01473"></a>01473     <span class="keywordflow">break</span>;
<a name="l01474"></a>01474 
<a name="l01475"></a>01475   <span class="keywordflow">case</span> <a class="code" href="lspg_8c.html#accda8c3a598dc7f5b107b04986d8ab50">LS_PG_STATE_RESET</a>:
<a name="l01476"></a>01476     err = PQresetStart( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01477"></a>01477     <span class="keywordflow">if</span>( err == 0) {
<a name="l01478"></a>01478       PQfinish( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01479"></a>01479       <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a> = NULL;
<a name="l01480"></a>01480       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#af443092447378c73bf93aa143576aba4">LS_PG_STATE_INIT</a>;
<a name="l01481"></a>01481     } <span class="keywordflow">else</span> {
<a name="l01482"></a>01482       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#ac70a1141f3b138055ea7143bd493187c">LS_PG_STATE_RESET_POLL</a>;
<a name="l01483"></a>01483       <a class="code" href="lspg_8c.html#a06c5a937e41a6c706a247777642ec1fb" title="Used to determine state while reconnecting.">lspg_resetPoll_response</a> = PGRES_POLLING_WRITING;
<a name="l01484"></a>01484     }
<a name="l01485"></a>01485     <span class="keywordflow">break</span>;
<a name="l01486"></a>01486 
<a name="l01487"></a>01487   <span class="keywordflow">case</span> <a class="code" href="lspg_8c.html#ac70a1141f3b138055ea7143bd493187c">LS_PG_STATE_RESET_POLL</a>:
<a name="l01488"></a>01488     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a06c5a937e41a6c706a247777642ec1fb" title="Used to determine state while reconnecting.">lspg_resetPoll_response</a> == PGRES_POLLING_FAILED) {
<a name="l01489"></a>01489       PQfinish( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01490"></a>01490       <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a> = NULL;
<a name="l01491"></a>01491       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#af443092447378c73bf93aa143576aba4">LS_PG_STATE_INIT</a>;
<a name="l01492"></a>01492     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a06c5a937e41a6c706a247777642ec1fb" title="Used to determine state while reconnecting.">lspg_resetPoll_response</a> == PGRES_POLLING_OK) {
<a name="l01493"></a>01493       <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#a329a7fdfa5025a403ea2779e178fd3ed" title="Motor initialization callback.">lspg_init_motors_cb</a>, <span class="stringliteral">&quot;select * from pmac.md2_getmotors()&quot;</span>);
<a name="l01494"></a>01494       <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( NULL, <span class="stringliteral">&quot;select pmac.md2_init()&quot;</span>);
<a name="l01495"></a>01495       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#aaf1dd8ba4dafb91c296554c4cbf312e3">LS_PG_STATE_IDLE</a>;
<a name="l01496"></a>01496     }
<a name="l01497"></a>01497     <span class="keywordflow">break</span>;
<a name="l01498"></a>01498   }
<a name="l01499"></a>01499 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa8d1fed4b461c2139a21826d524777d5"></a><!-- doxytag: member="lspg.c::lspg_pg_service" ref="aa8d1fed4b461c2139a21826d524777d5" args="(struct pollfd *evt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_pg_service </td>
          <td>(</td>
          <td class="paramtype">struct pollfd *&nbsp;</td>
          <td class="paramname"> <em>evt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>I/O control to/from the postgresql server. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>evt</em>&nbsp;</td><td>The pollfd object that we are responding to </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01309">1309</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01311"></a>01311                        {
<a name="l01312"></a>01312   <span class="comment">//</span>
<a name="l01313"></a>01313   <span class="comment">// Currently just used to check for notifies</span>
<a name="l01314"></a>01314   <span class="comment">// Other socket communication is done syncronously</span>
<a name="l01315"></a>01315   <span class="comment">// Reconsider this if we start using the pmac gather functions</span>
<a name="l01316"></a>01316   <span class="comment">// since we&apos;ll want to be servicing those sockets ASAP</span>
<a name="l01317"></a>01317   <span class="comment">//</span>
<a name="l01318"></a>01318 
<a name="l01319"></a>01319   <span class="keywordflow">if</span>( evt-&gt;revents &amp; POLLIN) {
<a name="l01320"></a>01320     <span class="keywordtype">int</span> err;
<a name="l01321"></a>01321 
<a name="l01322"></a>01322     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#ae7ea5876846b5f04c419aee22d3c0aa1">LS_PG_STATE_INIT_POLL</a>) {
<a name="l01323"></a>01323       <a class="code" href="lspg_8c.html#a69ae04978986e6413ca7cefcb692b645" title="Used to determine state while connecting.">lspg_connectPoll_response</a> = PQconnectPoll( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01324"></a>01324       <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a69ae04978986e6413ca7cefcb692b645" title="Used to determine state while connecting.">lspg_connectPoll_response</a> == PGRES_POLLING_FAILED) {
<a name="l01325"></a>01325         <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#accda8c3a598dc7f5b107b04986d8ab50">LS_PG_STATE_RESET</a>;
<a name="l01326"></a>01326       }
<a name="l01327"></a>01327       <span class="keywordflow">return</span>;
<a name="l01328"></a>01328     }
<a name="l01329"></a>01329 
<a name="l01330"></a>01330     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#ac70a1141f3b138055ea7143bd493187c">LS_PG_STATE_RESET_POLL</a>) {
<a name="l01331"></a>01331       <a class="code" href="lspg_8c.html#a06c5a937e41a6c706a247777642ec1fb" title="Used to determine state while reconnecting.">lspg_resetPoll_response</a> = PQresetPoll( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01332"></a>01332       <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a06c5a937e41a6c706a247777642ec1fb" title="Used to determine state while reconnecting.">lspg_resetPoll_response</a> == PGRES_POLLING_FAILED) {
<a name="l01333"></a>01333         <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#accda8c3a598dc7f5b107b04986d8ab50">LS_PG_STATE_RESET</a>;
<a name="l01334"></a>01334       }
<a name="l01335"></a>01335       <span class="keywordflow">return</span>;
<a name="l01336"></a>01336     }
<a name="l01337"></a>01337 
<a name="l01338"></a>01338 
<a name="l01339"></a>01339     <span class="comment">//</span>
<a name="l01340"></a>01340     <span class="comment">// if in IDLE or RECV we need to call consumeInput first</span>
<a name="l01341"></a>01341     <span class="comment">//</span>
<a name="l01342"></a>01342     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#aaf1dd8ba4dafb91c296554c4cbf312e3">LS_PG_STATE_IDLE</a>) {
<a name="l01343"></a>01343       err = PQconsumeInput( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01344"></a>01344       <span class="keywordflow">if</span>( err != 1) {
<a name="l01345"></a>01345         <a class="code" href="lslogging_8c.html#a0e756b36671055ef02a8f04d2ba8a93b">lslogging_log_message</a>( <span class="stringliteral">&quot;consume input failed: %s&quot;</span>, PQerrorMessage( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>));
<a name="l01346"></a>01346         <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#accda8c3a598dc7f5b107b04986d8ab50">LS_PG_STATE_RESET</a>;
<a name="l01347"></a>01347         <span class="keywordflow">return</span>;
<a name="l01348"></a>01348       }
<a name="l01349"></a>01349     }      
<a name="l01350"></a>01350 
<a name="l01351"></a>01351     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#a373e668840b4795ff9a71bc3f744d209">LS_PG_STATE_RECV</a>) {
<a name="l01352"></a>01352       <a class="code" href="lspg_8c.html#a038c5af23469b789fc1c55d21cb43029" title="Receive a result of a query.">lspg_receive</a>();
<a name="l01353"></a>01353     }
<a name="l01354"></a>01354 
<a name="l01355"></a>01355     <span class="comment">//</span>
<a name="l01356"></a>01356     <span class="comment">// Check for notifies regardless of our state</span>
<a name="l01357"></a>01357     <span class="comment">// Push as many requests as we have notifies.</span>
<a name="l01358"></a>01358     <span class="comment">//</span>
<a name="l01359"></a>01359     {
<a name="l01360"></a>01360       PGnotify *pgn;
<a name="l01361"></a>01361 
<a name="l01362"></a>01362       <span class="keywordflow">while</span>( 1) {
<a name="l01363"></a>01363         pgn = PQnotifies( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01364"></a>01364         <span class="keywordflow">if</span>( pgn == NULL)
<a name="l01365"></a>01365           <span class="keywordflow">break</span>;
<a name="l01366"></a>01366         
<a name="l01367"></a>01367         <span class="keywordflow">if</span>( strstr( pgn-&gt;relname, <span class="stringliteral">&quot;_pmac&quot;</span>) != NULL) {
<a name="l01368"></a>01368           <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#a1e11f525ca0f9ac9ab71f9fbe983c42b" title="Send strings directly to PMAC queue.">lspg_cmd_cb</a>, <span class="stringliteral">&quot;SELECT pmac.md2_queue_next()&quot;</span>);
<a name="l01369"></a>01369         } <span class="keywordflow">else</span> {
<a name="l01370"></a>01370           <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#aeda8dad89b03d7d61cc994dd63ee5db6" title="Queue the next MD2 instruction.">lspg_nextaction_cb</a>, <span class="stringliteral">&quot;SELECT action FROM px.nextaction()&quot;</span>);
<a name="l01371"></a>01371         }
<a name="l01372"></a>01372         PQfreemem( pgn);
<a name="l01373"></a>01373       }
<a name="l01374"></a>01374     }
<a name="l01375"></a>01375   }
<a name="l01376"></a>01376 
<a name="l01377"></a>01377   <span class="keywordflow">if</span>( evt-&gt;revents &amp; POLLOUT) {
<a name="l01378"></a>01378 
<a name="l01379"></a>01379     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#ae7ea5876846b5f04c419aee22d3c0aa1">LS_PG_STATE_INIT_POLL</a>) {
<a name="l01380"></a>01380       <a class="code" href="lspg_8c.html#a69ae04978986e6413ca7cefcb692b645" title="Used to determine state while connecting.">lspg_connectPoll_response</a> = PQconnectPoll( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01381"></a>01381       <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a69ae04978986e6413ca7cefcb692b645" title="Used to determine state while connecting.">lspg_connectPoll_response</a> == PGRES_POLLING_FAILED) {
<a name="l01382"></a>01382         <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#accda8c3a598dc7f5b107b04986d8ab50">LS_PG_STATE_RESET</a>;
<a name="l01383"></a>01383       }
<a name="l01384"></a>01384       <span class="keywordflow">return</span>;
<a name="l01385"></a>01385     }
<a name="l01386"></a>01386 
<a name="l01387"></a>01387     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#ac70a1141f3b138055ea7143bd493187c">LS_PG_STATE_RESET_POLL</a>) {
<a name="l01388"></a>01388       <a class="code" href="lspg_8c.html#a06c5a937e41a6c706a247777642ec1fb" title="Used to determine state while reconnecting.">lspg_resetPoll_response</a> = PQresetPoll( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01389"></a>01389       <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a06c5a937e41a6c706a247777642ec1fb" title="Used to determine state while reconnecting.">lspg_resetPoll_response</a> == PGRES_POLLING_FAILED) {
<a name="l01390"></a>01390         <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#accda8c3a598dc7f5b107b04986d8ab50">LS_PG_STATE_RESET</a>;
<a name="l01391"></a>01391       }
<a name="l01392"></a>01392       <span class="keywordflow">return</span>;
<a name="l01393"></a>01393     }
<a name="l01394"></a>01394 
<a name="l01395"></a>01395 
<a name="l01396"></a>01396     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#a3c6eb19f262a990e1f9ba630d9edc309">LS_PG_STATE_SEND</a>) {
<a name="l01397"></a>01397       <a class="code" href="lspg_8c.html#a714b15e117ffe7bfce4f2f2ce4725b0a" title="send the next queued query to the DB server">lspg_send_next_query</a>();
<a name="l01398"></a>01398     }
<a name="l01399"></a>01399 
<a name="l01400"></a>01400     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#a88a7e80c12fb0449c4b0857a0c7deb21">LS_PG_STATE_SEND_FLUSH</a>) {
<a name="l01401"></a>01401       <a class="code" href="lspg_8c.html#af6485ac1749c5de3008dd0e0badaa09c" title="Flush psql output buffer (ie, send the query).">lspg_flush</a>();
<a name="l01402"></a>01402     }
<a name="l01403"></a>01403   }
<a name="l01404"></a>01404 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad5f3ec8f197cc330c83dba70f310533c"></a><!-- doxytag: member="lspg.c::lspg_query_next" ref="ad5f3ec8f197cc330c83dba70f310533c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a>* lspg_query_next </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the next item in the postgresql queue. </p>
<p>If there is an item left in the queue then it is returned. Otherwise, NULL is returned. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00079">79</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00079"></a>00079                                       {
<a name="l00080"></a>00080   <a class="code" href="structlspgQueryQueueStruct.html" title="Store each query along with it&amp;#39;s callback function.">lspg_query_queue_t</a> *rtn;
<a name="l00081"></a>00081   
<a name="l00082"></a>00082   pthread_mutex_lock( &amp;<a class="code" href="lspg_8c.html#aed46a94106c583796e3a8ca0e89aa8e4" title="keep the queue from getting tangled">lspg_queue_mutex</a>);
<a name="l00083"></a>00083 
<a name="l00084"></a>00084   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#aca86bb77d6cecfae9251743f4171bafb" title="The last item still being used (on == off means nothing in queue).">lspg_query_queue_off</a> == <a class="code" href="lspg_8c.html#a3cbe7f3161b3c1838ebc56a3bbcfd8a6" title="Next position to add something to the queue.">lspg_query_queue_on</a>)
<a name="l00085"></a>00085     <span class="comment">// Queue is empty</span>
<a name="l00086"></a>00086     rtn = NULL;
<a name="l00087"></a>00087   <span class="keywordflow">else</span> {
<a name="l00088"></a>00088     rtn = &amp;(<a class="code" href="lspg_8c.html#a357d9d98f0b8c9625ccebcebfcdce955" title="Our query queue.">lspg_query_queue</a>[(<a class="code" href="lspg_8c.html#aca86bb77d6cecfae9251743f4171bafb" title="The last item still being used (on == off means nothing in queue).">lspg_query_queue_off</a>++) % <a class="code" href="lspg_8c.html#a08fe83fe8226002ee8b80ce0a914fd11" title="Queue length should be long enough that we do not ordinarly bump into the end We...">LS_PG_QUERY_QUEUE_LENGTH</a>]); 
<a name="l00089"></a>00089     pthread_cond_signal( &amp;<a class="code" href="lspg_8c.html#a61a308b6a37afd645beb422653b95baa" title="keeps the queue from overflowing">lspg_queue_cond</a>);
<a name="l00090"></a>00090   }
<a name="l00091"></a>00091   pthread_mutex_unlock( &amp;<a class="code" href="lspg_8c.html#aed46a94106c583796e3a8ca0e89aa8e4" title="keep the queue from getting tangled">lspg_queue_mutex</a>);
<a name="l00092"></a>00092 
<a name="l00093"></a>00093   <span class="keywordflow">return</span> rtn;
<a name="l00094"></a>00094 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0bb9ef42da8fa21c4df48ec384ab69f4"></a><!-- doxytag: member="lspg.c::lspg_query_push" ref="a0bb9ef42da8fa21c4df48ec384ab69f4" args="(void(*cb)(lspg_query_queue_t *, PGresult *), char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_query_push </td>
          <td>(</td>
          <td class="paramtype">void(*)(<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *, PGresult *)&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Place a query on the queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cb</em>&nbsp;</td><td>Our callback function that deals with the response </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fmt</em>&nbsp;</td><td>Printf style function to generate the query </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00132">132</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00136"></a>00136                        {
<a name="l00137"></a>00137   <span class="keywordtype">int</span> idx;
<a name="l00138"></a>00138   va_list arg_ptr;
<a name="l00139"></a>00139 
<a name="l00140"></a>00140   pthread_mutex_lock( &amp;<a class="code" href="lspg_8c.html#aed46a94106c583796e3a8ca0e89aa8e4" title="keep the queue from getting tangled">lspg_queue_mutex</a>);
<a name="l00141"></a>00141 
<a name="l00142"></a>00142   <span class="comment">//</span>
<a name="l00143"></a>00143   <span class="comment">// Pause the thread while we service the queue</span>
<a name="l00144"></a>00144   <span class="comment">//</span>
<a name="l00145"></a>00145   <span class="keywordflow">while</span>( <a class="code" href="lspg_8c.html#a3cbe7f3161b3c1838ebc56a3bbcfd8a6" title="Next position to add something to the queue.">lspg_query_queue_on</a> + 1 == <a class="code" href="lspg_8c.html#aca86bb77d6cecfae9251743f4171bafb" title="The last item still being used (on == off means nothing in queue).">lspg_query_queue_off</a>) {
<a name="l00146"></a>00146     pthread_cond_wait( &amp;<a class="code" href="lspg_8c.html#a61a308b6a37afd645beb422653b95baa" title="keeps the queue from overflowing">lspg_queue_cond</a>, &amp;<a class="code" href="lspg_8c.html#aed46a94106c583796e3a8ca0e89aa8e4" title="keep the queue from getting tangled">lspg_queue_mutex</a>);
<a name="l00147"></a>00147   }
<a name="l00148"></a>00148 
<a name="l00149"></a>00149   idx = <a class="code" href="lspg_8c.html#a3cbe7f3161b3c1838ebc56a3bbcfd8a6" title="Next position to add something to the queue.">lspg_query_queue_on</a> % <a class="code" href="lspg_8c.html#a08fe83fe8226002ee8b80ce0a914fd11" title="Queue length should be long enough that we do not ordinarly bump into the end We...">LS_PG_QUERY_QUEUE_LENGTH</a>;
<a name="l00150"></a>00150 
<a name="l00151"></a>00151   va_start( arg_ptr, fmt);
<a name="l00152"></a>00152   vsnprintf( <a class="code" href="lspg_8c.html#a357d9d98f0b8c9625ccebcebfcdce955" title="Our query queue.">lspg_query_queue</a>[idx].qs, <a class="code" href="pgpmac_8h.html#a3a8ef1b4b5994d6dd12bf74454ea891b" title="Fixed length postgresql query strings. Queries should all be function calls so this...">LS_PG_QUERY_STRING_LENGTH</a>-1, fmt, arg_ptr);
<a name="l00153"></a>00153   va_end( arg_ptr);
<a name="l00154"></a>00154 
<a name="l00155"></a>00155   <a class="code" href="lspg_8c.html#a357d9d98f0b8c9625ccebcebfcdce955" title="Our query queue.">lspg_query_queue</a>[idx].<a class="code" href="structlspgQueryQueueStruct.html#abf8c9c581b38a5e3e269eda69e47de15" title="our queries should all be pretty short as we&amp;#39;ll just be calling functions: fixed...">qs</a>[<a class="code" href="pgpmac_8h.html#a3a8ef1b4b5994d6dd12bf74454ea891b" title="Fixed length postgresql query strings. Queries should all be function calls so this...">LS_PG_QUERY_STRING_LENGTH</a> - 1] = 0;
<a name="l00156"></a>00156   <a class="code" href="lspg_8c.html#a357d9d98f0b8c9625ccebcebfcdce955" title="Our query queue.">lspg_query_queue</a>[idx].<a class="code" href="structlspgQueryQueueStruct.html#a53bac5ae4cab775423940bff5092a831" title="Callback function for when a query returns a result.">onResponse</a> = cb;
<a name="l00157"></a>00157   <a class="code" href="lspg_8c.html#a3cbe7f3161b3c1838ebc56a3bbcfd8a6" title="Next position to add something to the queue.">lspg_query_queue_on</a>++;
<a name="l00158"></a>00158 
<a name="l00159"></a>00159   pthread_kill( <a class="code" href="lspg_8c.html#a04eb0cda0d5e5afeae7c393b51689765" title="our worker thread">lspg_thread</a>, SIGUSR1);
<a name="l00160"></a>00160   pthread_mutex_unlock( &amp;<a class="code" href="lspg_8c.html#aed46a94106c583796e3a8ca0e89aa8e4" title="keep the queue from getting tangled">lspg_queue_mutex</a>);
<a name="l00161"></a>00161 };
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3847589e641f7e16a0cd68ef30e37cca"></a><!-- doxytag: member="lspg.c::lspg_query_reply_next" ref="a3847589e641f7e16a0cd68ef30e37cca" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_query_reply_next </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the oldest item in the queue. </p>
<p>this is called only when there is nothing else to service the reply: this pop does not return anything. We use the ...reply_peek function to return the next item in the reply queue </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00103">103</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00103"></a>00103                              {
<a name="l00104"></a>00104 
<a name="l00105"></a>00105   pthread_mutex_lock( &amp;<a class="code" href="lspg_8c.html#aed46a94106c583796e3a8ca0e89aa8e4" title="keep the queue from getting tangled">lspg_queue_mutex</a>);
<a name="l00106"></a>00106 
<a name="l00107"></a>00107   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a2603b071afdbff7c0924b13de2454264" title="The current item being digested.">lspg_query_queue_reply</a> != <a class="code" href="lspg_8c.html#a3cbe7f3161b3c1838ebc56a3bbcfd8a6" title="Next position to add something to the queue.">lspg_query_queue_on</a>)
<a name="l00108"></a>00108     <a class="code" href="lspg_8c.html#a2603b071afdbff7c0924b13de2454264" title="The current item being digested.">lspg_query_queue_reply</a>++;
<a name="l00109"></a>00109 
<a name="l00110"></a>00110   pthread_mutex_unlock( &amp;<a class="code" href="lspg_8c.html#aed46a94106c583796e3a8ca0e89aa8e4" title="keep the queue from getting tangled">lspg_queue_mutex</a>);
<a name="l00111"></a>00111 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae6bf4f54117bedf903360883bb32699f"></a><!-- doxytag: member="lspg.c::lspg_query_reply_peek" ref="ae6bf4f54117bedf903360883bb32699f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a>* lspg_query_reply_peek </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the next item in the reply queue but don't pop it since we may need it more than once. </p>
<p>Call <a class="el" href="lspg_8c.html#a3847589e641f7e16a0cd68ef30e37cca" title="Remove the oldest item in the queue.">lspg_query_reply_next()</a> when done. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00116">116</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00116"></a>00116                                             {
<a name="l00117"></a>00117   <a class="code" href="structlspgQueryQueueStruct.html" title="Store each query along with it&amp;#39;s callback function.">lspg_query_queue_t</a> *rtn;
<a name="l00118"></a>00118 
<a name="l00119"></a>00119   pthread_mutex_lock( &amp;<a class="code" href="lspg_8c.html#aed46a94106c583796e3a8ca0e89aa8e4" title="keep the queue from getting tangled">lspg_queue_mutex</a>);
<a name="l00120"></a>00120 
<a name="l00121"></a>00121   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a2603b071afdbff7c0924b13de2454264" title="The current item being digested.">lspg_query_queue_reply</a> == <a class="code" href="lspg_8c.html#a3cbe7f3161b3c1838ebc56a3bbcfd8a6" title="Next position to add something to the queue.">lspg_query_queue_on</a>)
<a name="l00122"></a>00122     rtn = NULL;
<a name="l00123"></a>00123   <span class="keywordflow">else</span>
<a name="l00124"></a>00124     rtn = &amp;(<a class="code" href="lspg_8c.html#a357d9d98f0b8c9625ccebcebfcdce955" title="Our query queue.">lspg_query_queue</a>[(<a class="code" href="lspg_8c.html#a2603b071afdbff7c0924b13de2454264" title="The current item being digested.">lspg_query_queue_reply</a>) % <a class="code" href="lspg_8c.html#a08fe83fe8226002ee8b80ce0a914fd11" title="Queue length should be long enough that we do not ordinarly bump into the end We...">LS_PG_QUERY_QUEUE_LENGTH</a>]);
<a name="l00125"></a>00125 
<a name="l00126"></a>00126   pthread_mutex_unlock( &amp;<a class="code" href="lspg_8c.html#aed46a94106c583796e3a8ca0e89aa8e4" title="keep the queue from getting tangled">lspg_queue_mutex</a>);
<a name="l00127"></a>00127   <span class="keywordflow">return</span> rtn;
<a name="l00128"></a>00128 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a038c5af23469b789fc1c55d21cb43029"></a><!-- doxytag: member="lspg.c::lspg_receive" ref="a038c5af23469b789fc1c55d21cb43029" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_receive </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive a result of a query. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01226">1226</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01226"></a>01226                     {
<a name="l01227"></a>01227   PGresult *pgr;
<a name="l01228"></a>01228   <a class="code" href="structlspgQueryQueueStruct.html" title="Store each query along with it&amp;#39;s callback function.">lspg_query_queue_t</a> *qqp;
<a name="l01229"></a>01229   <span class="keywordtype">int</span> err;
<a name="l01230"></a>01230 
<a name="l01231"></a>01231   err = PQconsumeInput( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01232"></a>01232   <span class="keywordflow">if</span>( err != 1) {
<a name="l01233"></a>01233     <a class="code" href="lslogging_8c.html#a0e756b36671055ef02a8f04d2ba8a93b">lslogging_log_message</a>( <span class="stringliteral">&quot;consume input failed: %s&quot;</span>, PQerrorMessage( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>));
<a name="l01234"></a>01234     <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#accda8c3a598dc7f5b107b04986d8ab50">LS_PG_STATE_RESET</a>;
<a name="l01235"></a>01235     <span class="keywordflow">return</span>;
<a name="l01236"></a>01236   }
<a name="l01237"></a>01237 
<a name="l01238"></a>01238   <span class="comment">//</span>
<a name="l01239"></a>01239   <span class="comment">// We must call PQgetResult until it returns NULL before sending the next query</span>
<a name="l01240"></a>01240   <span class="comment">// This implies that only one query can ever be active at a time and our queue</span>
<a name="l01241"></a>01241   <span class="comment">// management should be simple</span>
<a name="l01242"></a>01242   <span class="comment">//</span>
<a name="l01243"></a>01243   <span class="comment">// We should be in the LS_PG_STATE_RECV here</span>
<a name="l01244"></a>01244   <span class="comment">//</span>
<a name="l01245"></a>01245 
<a name="l01246"></a>01246   <span class="keywordflow">while</span>( !PQisBusy( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>)) {
<a name="l01247"></a>01247     pgr = PQgetResult( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01248"></a>01248     <span class="keywordflow">if</span>( pgr == NULL) {
<a name="l01249"></a>01249       <a class="code" href="lspg_8c.html#a3847589e641f7e16a0cd68ef30e37cca" title="Remove the oldest item in the queue.">lspg_query_reply_next</a>();
<a name="l01250"></a>01250       <span class="comment">//</span>
<a name="l01251"></a>01251       <span class="comment">// we are now done reading the response from the database</span>
<a name="l01252"></a>01252       <span class="comment">//</span>
<a name="l01253"></a>01253       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#aaf1dd8ba4dafb91c296554c4cbf312e3">LS_PG_STATE_IDLE</a>;
<a name="l01254"></a>01254       <span class="keywordflow">break</span>;
<a name="l01255"></a>01255     } <span class="keywordflow">else</span> {
<a name="l01256"></a>01256       ExecStatusType es;
<a name="l01257"></a>01257 
<a name="l01258"></a>01258       qqp = <a class="code" href="lspg_8c.html#ae6bf4f54117bedf903360883bb32699f" title="Return the next item in the reply queue but don&amp;#39;t pop it since we may need it...">lspg_query_reply_peek</a>();
<a name="l01259"></a>01259       es = PQresultStatus( pgr);
<a name="l01260"></a>01260 
<a name="l01261"></a>01261       <span class="keywordflow">if</span>( es != PGRES_COMMAND_OK &amp;&amp; es != PGRES_TUPLES_OK) {
<a name="l01262"></a>01262         <span class="keywordtype">char</span> *emess;
<a name="l01263"></a>01263         emess = PQresultErrorMessage( pgr);
<a name="l01264"></a>01264         <span class="keywordflow">if</span>( emess != NULL &amp;&amp; emess[0] != 0) {
<a name="l01265"></a>01265           <a class="code" href="lslogging_8c.html#a0e756b36671055ef02a8f04d2ba8a93b">lslogging_log_message</a>( <span class="stringliteral">&quot;Error from query &apos;%s&apos;:\n%s&quot;</span>, qqp-&gt;<a class="code" href="structlspgQueryQueueStruct.html#abf8c9c581b38a5e3e269eda69e47de15" title="our queries should all be pretty short as we&amp;#39;ll just be calling functions: fixed...">qs</a>, emess);
<a name="l01266"></a>01266         }
<a name="l01267"></a>01267       } <span class="keywordflow">else</span> {
<a name="l01268"></a>01268         <span class="comment">//</span>
<a name="l01269"></a>01269         <span class="comment">// Deal with the response</span>
<a name="l01270"></a>01270         <span class="comment">//</span>
<a name="l01271"></a>01271         <span class="comment">// If the response is likely to take awhile we should probably</span>
<a name="l01272"></a>01272         <span class="comment">// add a new state and put something in the main look to run the onResponse</span>
<a name="l01273"></a>01273         <span class="comment">// routine in the main loop.  For now, though, we only expect very brief onResponse routines</span>
<a name="l01274"></a>01274         <span class="comment">//</span>
<a name="l01275"></a>01275         <span class="keywordflow">if</span>( qqp != NULL &amp;&amp; qqp-&gt;<a class="code" href="structlspgQueryQueueStruct.html#a53bac5ae4cab775423940bff5092a831" title="Callback function for when a query returns a result.">onResponse</a> != NULL)
<a name="l01276"></a>01276           qqp-&gt;<a class="code" href="structlspgQueryQueueStruct.html#a53bac5ae4cab775423940bff5092a831" title="Callback function for when a query returns a result.">onResponse</a>( qqp, pgr);
<a name="l01277"></a>01277       }
<a name="l01278"></a>01278       PQclear( pgr);
<a name="l01279"></a>01279     }
<a name="l01280"></a>01280   }
<a name="l01281"></a>01281 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1adfdb5ca9fdb5060849d726bf540117"></a><!-- doxytag: member="lspg.c::lspg_run" ref="a1adfdb5ca9fdb5060849d726bf540117" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_run </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start 'er runnin'. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01650">1650</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01650"></a>01650                 {
<a name="l01651"></a>01651   pthread_create( &amp;<a class="code" href="lspg_8c.html#a04eb0cda0d5e5afeae7c393b51689765" title="our worker thread">lspg_thread</a>, NULL, <a class="code" href="lspg_8c.html#aaf4fadd2943fa3a2ecb5d840e84d68fa" title="The main loop for the lspg thread.">lspg_worker</a>, NULL);
<a name="l01652"></a>01652 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a71db585552ea3f58a1c9ab3fbe62bb79"></a><!-- doxytag: member="lspg.c::lspg_scint_lut_cb" ref="a71db585552ea3f58a1c9ab3fbe62bb79" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_scint_lut_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>qqp</em>&nbsp;</td><td>Our query </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pgr</em>&nbsp;</td><td>Our result object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00369">369</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00372"></a>00372                           {
<a name="l00373"></a>00373   <span class="keywordtype">int</span> i;
<a name="l00374"></a>00374   pthread_mutex_lock( &amp;(<a class="code" href="lspmac_8c.html#a8a3ca6fcf5e24dcc26170736843e53b2" title="Scintillator Piezo DAC.">fscint</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a188c5b1e991750ce2ffd53e0192e0907" title="coordinate waiting for motor to be done">mutex</a>));
<a name="l00375"></a>00375   
<a name="l00376"></a>00376   <a class="code" href="lspmac_8c.html#a8a3ca6fcf5e24dcc26170736843e53b2" title="Scintillator Piezo DAC.">fscint</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a11cbc6f50c150ed446e9a901cf7cc12b" title="length of lut">nlut</a> = PQntuples( pgr)/2;
<a name="l00377"></a>00377   <a class="code" href="lspmac_8c.html#a8a3ca6fcf5e24dcc26170736843e53b2" title="Scintillator Piezo DAC.">fscint</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a7b43671f7f3e06521f6cf91fb9ac707d" title="lookup table (instead of u2c)">lut</a>  = calloc( 2*<a class="code" href="lspmac_8c.html#a8a3ca6fcf5e24dcc26170736843e53b2" title="Scintillator Piezo DAC.">fscint</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a11cbc6f50c150ed446e9a901cf7cc12b" title="length of lut">nlut</a>, <span class="keyword">sizeof</span>( <span class="keywordtype">double</span>));
<a name="l00378"></a>00378   <span class="keywordflow">if</span>( <a class="code" href="lspmac_8c.html#a8a3ca6fcf5e24dcc26170736843e53b2" title="Scintillator Piezo DAC.">fscint</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a7b43671f7f3e06521f6cf91fb9ac707d" title="lookup table (instead of u2c)">lut</a> == NULL) {
<a name="l00379"></a>00379     <a class="code" href="lslogging_8c.html#a0e756b36671055ef02a8f04d2ba8a93b">lslogging_log_message</a>( <span class="stringliteral">&quot;lspg_scint_lut_cb: Out of memory&quot;</span>);
<a name="l00380"></a>00380     pthread_mutex_unlock( &amp;(<a class="code" href="lspmac_8c.html#a8a3ca6fcf5e24dcc26170736843e53b2" title="Scintillator Piezo DAC.">fscint</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a188c5b1e991750ce2ffd53e0192e0907" title="coordinate waiting for motor to be done">mutex</a>));
<a name="l00381"></a>00381   }
<a name="l00382"></a>00382   
<a name="l00383"></a>00383   <span class="keywordflow">for</span>( i=0; i&lt;PQntuples( pgr); i++) {
<a name="l00384"></a>00384     <a class="code" href="lspmac_8c.html#a8a3ca6fcf5e24dcc26170736843e53b2" title="Scintillator Piezo DAC.">fscint</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a7b43671f7f3e06521f6cf91fb9ac707d" title="lookup table (instead of u2c)">lut</a>[i] = strtod( PQgetvalue( pgr, i, 0), NULL);
<a name="l00385"></a>00385   }
<a name="l00386"></a>00386 
<a name="l00387"></a>00387   pthread_mutex_unlock( &amp;(<a class="code" href="lspmac_8c.html#a8a3ca6fcf5e24dcc26170736843e53b2" title="Scintillator Piezo DAC.">fscint</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a188c5b1e991750ce2ffd53e0192e0907" title="coordinate waiting for motor to be done">mutex</a>));
<a name="l00388"></a>00388 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a714b15e117ffe7bfce4f2f2ce4725b0a"></a><!-- doxytag: member="lspg.c::lspg_send_next_query" ref="a714b15e117ffe7bfce4f2f2ce4725b0a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_send_next_query </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>send the next queued query to the DB server </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01179">1179</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01179"></a>01179                             {
<a name="l01180"></a>01180   <span class="comment">//</span>
<a name="l01181"></a>01181   <span class="comment">// Normally we should be in the &quot;send&quot; state</span>
<a name="l01182"></a>01182   <span class="comment">// but we can also send if we are servicing</span>
<a name="l01183"></a>01183   <span class="comment">// a reply</span>
<a name="l01184"></a>01184   <span class="comment">//</span>
<a name="l01185"></a>01185 
<a name="l01186"></a>01186   <a class="code" href="structlspgQueryQueueStruct.html" title="Store each query along with it&amp;#39;s callback function.">lspg_query_queue_t</a> *qqp;
<a name="l01187"></a>01187   <span class="keywordtype">int</span> err;
<a name="l01188"></a>01188 
<a name="l01189"></a>01189   qqp = <a class="code" href="lspg_8c.html#ad5f3ec8f197cc330c83dba70f310533c" title="Return the next item in the postgresql queue.">lspg_query_next</a>();
<a name="l01190"></a>01190   <span class="keywordflow">if</span>( qqp == NULL) {
<a name="l01191"></a>01191     <span class="comment">//</span>
<a name="l01192"></a>01192     <span class="comment">// A send without a query?  Should never happen.</span>
<a name="l01193"></a>01193     <span class="comment">// But at least we shouldn&apos;t segfault if it does.</span>
<a name="l01194"></a>01194     <span class="comment">//</span>
<a name="l01195"></a>01195     <span class="keywordflow">return</span>;
<a name="l01196"></a>01196   }
<a name="l01197"></a>01197 
<a name="l01198"></a>01198   <span class="keywordflow">if</span>( qqp-&gt;<a class="code" href="structlspgQueryQueueStruct.html#abf8c9c581b38a5e3e269eda69e47de15" title="our queries should all be pretty short as we&amp;#39;ll just be calling functions: fixed...">qs</a>[0] == 0) {
<a name="l01199"></a>01199     <span class="comment">//</span>
<a name="l01200"></a>01200     <span class="comment">// Do we really have to check this case?</span>
<a name="l01201"></a>01201     <span class="comment">// It would only come up if we stupidly pushed an empty query string</span>
<a name="l01202"></a>01202     <span class="comment">// or ran off the end of the queue</span>
<a name="l01203"></a>01203     <span class="comment">//</span>
<a name="l01204"></a>01204     <a class="code" href="lslogging_8c.html#a0e756b36671055ef02a8f04d2ba8a93b">lslogging_log_message</a>( <span class="stringliteral">&quot;Popped empty query string.  Probably bad things are going on.&quot;</span>);
<a name="l01205"></a>01205 
<a name="l01206"></a>01206     <a class="code" href="lspg_8c.html#a3847589e641f7e16a0cd68ef30e37cca" title="Remove the oldest item in the queue.">lspg_query_reply_next</a>();
<a name="l01207"></a>01207     <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#aaf1dd8ba4dafb91c296554c4cbf312e3">LS_PG_STATE_IDLE</a>;
<a name="l01208"></a>01208   } <span class="keywordflow">else</span> {
<a name="l01209"></a>01209     err = PQsendQuery( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>, qqp-&gt;<a class="code" href="structlspgQueryQueueStruct.html#abf8c9c581b38a5e3e269eda69e47de15" title="our queries should all be pretty short as we&amp;#39;ll just be calling functions: fixed...">qs</a>);
<a name="l01210"></a>01210     <span class="keywordflow">if</span>( err == 0) {
<a name="l01211"></a>01211       <a class="code" href="lslogging_8c.html#a0e756b36671055ef02a8f04d2ba8a93b">lslogging_log_message</a>( <span class="stringliteral">&quot;query failed: %s\n&quot;</span>, PQerrorMessage( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>));
<a name="l01212"></a>01212 
<a name="l01213"></a>01213       <span class="comment">//</span>
<a name="l01214"></a>01214       <span class="comment">// Don&apos;t wait for a reply, just reset the connection</span>
<a name="l01215"></a>01215       <span class="comment">//</span>
<a name="l01216"></a>01216       <a class="code" href="lspg_8c.html#a3847589e641f7e16a0cd68ef30e37cca" title="Remove the oldest item in the queue.">lspg_query_reply_next</a>();
<a name="l01217"></a>01217       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#accda8c3a598dc7f5b107b04986d8ab50">LS_PG_STATE_RESET</a>;
<a name="l01218"></a>01218     } <span class="keywordflow">else</span> {
<a name="l01219"></a>01219       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#a88a7e80c12fb0449c4b0857a0c7deb21">LS_PG_STATE_SEND_FLUSH</a>;
<a name="l01220"></a>01220     }
<a name="l01221"></a>01221   }
<a name="l01222"></a>01222 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4253474d4dd305aec0afdd5552b3ddd5"></a><!-- doxytag: member="lspg.c::lspg_seq_run_prep_all" ref="a4253474d4dd305aec0afdd5552b3ddd5" args="(long long skey, double kappa, double phi, double cx, double cy, double ax, double ay, double az)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_seq_run_prep_all </td>
          <td>(</td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>skey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>kappa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>az</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convinence function to call seq run prep. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>skey</em>&nbsp;</td><td>px.shots key for this image </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>kappa</em>&nbsp;</td><td>current kappa postion </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>phi</em>&nbsp;</td><td>current phi postition </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cx</em>&nbsp;</td><td>current center table x </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cy</em>&nbsp;</td><td>current center table y </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ax</em>&nbsp;</td><td>current alignment table x </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ay</em>&nbsp;</td><td>current alignment table y </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>az</em>&nbsp;</td><td>current alignment table z </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00979">979</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00988"></a>00988                              {
<a name="l00989"></a>00989   <a class="code" href="lspg_8c.html#af7d6efd861b152a371442791deb42bd3" title="queue up the seq_run_prep query">lspg_seq_run_prep_call</a>( skey, <a class="code" href="lspmac_8c.html#a0be79ccb7ebf3a665248fd856112b9fd" title="Kappa.">kappa</a>, <a class="code" href="lspmac_8c.html#ac8070dc568ad974a3db42b51eca828cc" title="Phi (not data collection axis).">phi</a>, cx, cy, ax, ay, az);
<a name="l00990"></a>00990   <a class="code" href="lspg_8c.html#ac0b01f501322432a8fa37f31898c3499" title="Wait for seq run prep query to return.">lspg_seq_run_prep_wait</a>();
<a name="l00991"></a>00991   <a class="code" href="lspg_8c.html#a472b09ddf716c80207f97e2bb5d37d66" title="Indicate we are done waiting.">lspg_seq_run_prep_done</a>();
<a name="l00992"></a>00992 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af7d6efd861b152a371442791deb42bd3"></a><!-- doxytag: member="lspg.c::lspg_seq_run_prep_call" ref="af7d6efd861b152a371442791deb42bd3" args="(long long skey, double kappa, double phi, double cx, double cy, double ax, double ay, double az)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_seq_run_prep_call </td>
          <td>(</td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>skey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>kappa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>az</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>queue up the seq_run_prep query </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>skey</em>&nbsp;</td><td>px.shots key for this image </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>kappa</em>&nbsp;</td><td>current kappa postion </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>phi</em>&nbsp;</td><td>current phi postition </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cx</em>&nbsp;</td><td>current center table x </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cy</em>&nbsp;</td><td>current center table y </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ax</em>&nbsp;</td><td>current alignment table x </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ay</em>&nbsp;</td><td>current alignment table y </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>az</em>&nbsp;</td><td>current alignment table z </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00945">945</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00954"></a>00954                               {
<a name="l00955"></a>00955   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#ad146cb91b5f7dd8bb283092c28781fe7">mutex</a>));
<a name="l00956"></a>00956   <a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#a42d08888327e9059ddd69ddfec31b8a9">new_value_ready</a> = 0;
<a name="l00957"></a>00957   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#ad146cb91b5f7dd8bb283092c28781fe7">mutex</a>));
<a name="l00958"></a>00958 
<a name="l00959"></a>00959   <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#a11cda12050dc9a86188e15e2155a6013" title="Callback for the seq_run_prep query.">lspg_seq_run_prep_cb</a>, <span class="stringliteral">&quot;SELECT px.seq_run_prep( %lld, %.3f, %.3f, %.3f, %.3f, %.3f, %.3f, %.3f)&quot;</span>,
<a name="l00960"></a>00960                    skey, <a class="code" href="lspmac_8c.html#a0be79ccb7ebf3a665248fd856112b9fd" title="Kappa.">kappa</a>, <a class="code" href="lspmac_8c.html#ac8070dc568ad974a3db42b51eca828cc" title="Phi (not data collection axis).">phi</a>, cx, cy, ax, ay, az);
<a name="l00961"></a>00961 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a11cda12050dc9a86188e15e2155a6013"></a><!-- doxytag: member="lspg.c::lspg_seq_run_prep_cb" ref="a11cda12050dc9a86188e15e2155a6013" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_seq_run_prep_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback for the seq_run_prep query. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>qqp</em>&nbsp;</td><td>The query item that generated this callback </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pgr</em>&nbsp;</td><td>The result of the query </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00933">933</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00936"></a>00936                             {
<a name="l00937"></a>00937   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#ad146cb91b5f7dd8bb283092c28781fe7">mutex</a>));
<a name="l00938"></a>00938   <a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#a42d08888327e9059ddd69ddfec31b8a9">new_value_ready</a> = 1;
<a name="l00939"></a>00939   pthread_cond_signal( &amp;(<a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#acd83ea6994f57377716ff01c8ee7ce43">cond</a>));
<a name="l00940"></a>00940   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#ad146cb91b5f7dd8bb283092c28781fe7">mutex</a>));
<a name="l00941"></a>00941 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a472b09ddf716c80207f97e2bb5d37d66"></a><!-- doxytag: member="lspg.c::lspg_seq_run_prep_done" ref="a472b09ddf716c80207f97e2bb5d37d66" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_seq_run_prep_done </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicate we are done waiting. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00973">973</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00973"></a>00973                               {
<a name="l00974"></a>00974   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#ad146cb91b5f7dd8bb283092c28781fe7">mutex</a>));
<a name="l00975"></a>00975 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a31823ecb2b44d4a6674f804059a27bce"></a><!-- doxytag: member="lspg.c::lspg_seq_run_prep_init" ref="a31823ecb2b44d4a6674f804059a27bce" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_seq_run_prep_init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the data collection object. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00925">925</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00925"></a>00925                               {
<a name="l00926"></a>00926   <a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#a42d08888327e9059ddd69ddfec31b8a9">new_value_ready</a> = 0;
<a name="l00927"></a>00927   pthread_mutex_init( &amp;(<a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#ad146cb91b5f7dd8bb283092c28781fe7">mutex</a>), NULL);
<a name="l00928"></a>00928   pthread_cond_init(  &amp;(<a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#acd83ea6994f57377716ff01c8ee7ce43">cond</a>),  NULL);
<a name="l00929"></a>00929 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac0b01f501322432a8fa37f31898c3499"></a><!-- doxytag: member="lspg.c::lspg_seq_run_prep_wait" ref="ac0b01f501322432a8fa37f31898c3499" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_seq_run_prep_wait </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for seq run prep query to return. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00965">965</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00965"></a>00965                               {
<a name="l00966"></a>00966   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#ad146cb91b5f7dd8bb283092c28781fe7">mutex</a>));
<a name="l00967"></a>00967   <span class="keywordflow">while</span>( <a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#a42d08888327e9059ddd69ddfec31b8a9">new_value_ready</a> == 0)
<a name="l00968"></a>00968     pthread_cond_wait( &amp;(<a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#acd83ea6994f57377716ff01c8ee7ce43">cond</a>), &amp;(<a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#ad146cb91b5f7dd8bb283092c28781fe7">mutex</a>));
<a name="l00969"></a>00969 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a049f4422994aa2eb2b841ffb2937f895"></a><!-- doxytag: member="lspg.c::lspg_sig_service" ref="a049f4422994aa2eb2b841ffb2937f895" args="(struct pollfd *evt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_sig_service </td>
          <td>(</td>
          <td class="paramtype">struct pollfd *&nbsp;</td>
          <td class="paramname"> <em>evt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Service a signal Signals here are treated as file descriptors and fits into our poll scheme. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>evt</em>&nbsp;</td><td>The pollfd object that triggered this call </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01287">1287</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01289"></a>01289                         {
<a name="l01290"></a>01290   <span class="keyword">struct </span>signalfd_siginfo fdsi;
<a name="l01291"></a>01291 
<a name="l01292"></a>01292   <span class="comment">//</span>
<a name="l01293"></a>01293   <span class="comment">// Really, we don&apos;t care about the signal,</span>
<a name="l01294"></a>01294   <span class="comment">// it&apos;s just used to drop out of the poll</span>
<a name="l01295"></a>01295   <span class="comment">// function when there is something for us</span>
<a name="l01296"></a>01296   <span class="comment">// to do that didn&apos;t invovle something coming</span>
<a name="l01297"></a>01297   <span class="comment">// from our postgresql server.</span>
<a name="l01298"></a>01298   <span class="comment">//</span>
<a name="l01299"></a>01299   <span class="comment">// This is accompished by the query_push function</span>
<a name="l01300"></a>01300   <span class="comment">// to notify us that a new query is ready.</span>
<a name="l01301"></a>01301   <span class="comment">//</span>
<a name="l01302"></a>01302 
<a name="l01303"></a>01303   read( evt-&gt;fd, &amp;fdsi, <span class="keyword">sizeof</span>( <span class="keyword">struct</span> signalfd_siginfo));
<a name="l01304"></a>01304 
<a name="l01305"></a>01305 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab9780e15924a50b2a5545e10806000b3"></a><!-- doxytag: member="lspg.c::lspg_wait_for_detector_all" ref="ab9780e15924a50b2a5545e10806000b3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_wait_for_detector_all </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Combined call to wait for the detector. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00789">789</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00789"></a>00789                                   {
<a name="l00790"></a>00790   <a class="code" href="lspg_8c.html#a4b5222b859a44eae616804a1e990b86d" title="initiate the wait for detector query">lspg_wait_for_detector_call</a>();
<a name="l00791"></a>00791   <a class="code" href="lspg_8c.html#af094e01be121ce8e14abb679abd17e19" title="Pause the calling thread until the detector is ready Called by the MD2 thread.">lspg_wait_for_detector_wait</a>();
<a name="l00792"></a>00792   <a class="code" href="lspg_8c.html#abb3645dee7c4514b650ab02f27570a69" title="Done waiting for the detector.">lspg_wait_for_detector_done</a>();
<a name="l00793"></a>00793 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4b5222b859a44eae616804a1e990b86d"></a><!-- doxytag: member="lspg.c::lspg_wait_for_detector_call" ref="a4b5222b859a44eae616804a1e990b86d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_wait_for_detector_call </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>initiate the wait for detector query </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00763">763</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00763"></a>00763                                    {
<a name="l00764"></a>00764   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#a958e9fe59e671e61f95c2ce796ba24ce">mutex</a>));
<a name="l00765"></a>00765   <a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#ad950e85c70c4473c5c7c40f8ceeae61d">new_value_ready</a> = 0;
<a name="l00766"></a>00766   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#a958e9fe59e671e61f95c2ce796ba24ce">mutex</a>));
<a name="l00767"></a>00767   
<a name="l00768"></a>00768   <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#a5747c519d1aa4c310010a862cae8a823" title="Callback for the wait for detector query.">lspg_wait_for_detector_cb</a>, <span class="stringliteral">&quot;SELECT px.lock_detector_test_block()&quot;</span>);
<a name="l00769"></a>00769 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5747c519d1aa4c310010a862cae8a823"></a><!-- doxytag: member="lspg.c::lspg_wait_for_detector_cb" ref="a5747c519d1aa4c310010a862cae8a823" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_wait_for_detector_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback for the wait for detector query. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00754">754</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00754"></a>00754                                                                         {
<a name="l00755"></a>00755   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#a958e9fe59e671e61f95c2ce796ba24ce">mutex</a>));
<a name="l00756"></a>00756   <a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#ad950e85c70c4473c5c7c40f8ceeae61d">new_value_ready</a> = 1;
<a name="l00757"></a>00757   pthread_cond_signal(  &amp;(<a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#aa97388f93ca5099196ba0da1e4a5b7bb">cond</a>));
<a name="l00758"></a>00758   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#a958e9fe59e671e61f95c2ce796ba24ce">mutex</a>));
<a name="l00759"></a>00759 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="abb3645dee7c4514b650ab02f27570a69"></a><!-- doxytag: member="lspg.c::lspg_wait_for_detector_done" ref="abb3645dee7c4514b650ab02f27570a69" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_wait_for_detector_done </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Done waiting for the detector. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00782">782</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00782"></a>00782                                    {
<a name="l00783"></a>00783   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#a958e9fe59e671e61f95c2ce796ba24ce">mutex</a>));
<a name="l00784"></a>00784 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3517f8fbed91c998f6036284f9bd0c48"></a><!-- doxytag: member="lspg.c::lspg_wait_for_detector_init" ref="a3517f8fbed91c998f6036284f9bd0c48" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_wait_for_detector_init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>initialize the detector timing object </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00746">746</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00746"></a>00746                                    {
<a name="l00747"></a>00747   <a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#ad950e85c70c4473c5c7c40f8ceeae61d">new_value_ready</a> = 0;
<a name="l00748"></a>00748   pthread_mutex_init( &amp;(<a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#a958e9fe59e671e61f95c2ce796ba24ce">mutex</a>), NULL);
<a name="l00749"></a>00749   pthread_cond_init(  &amp;(<a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#aa97388f93ca5099196ba0da1e4a5b7bb">cond</a>), NULL);
<a name="l00750"></a>00750 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af094e01be121ce8e14abb679abd17e19"></a><!-- doxytag: member="lspg.c::lspg_wait_for_detector_wait" ref="af094e01be121ce8e14abb679abd17e19" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_wait_for_detector_wait </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pause the calling thread until the detector is ready Called by the MD2 thread. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00774">774</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00774"></a>00774                                    {
<a name="l00775"></a>00775   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#a958e9fe59e671e61f95c2ce796ba24ce">mutex</a>));
<a name="l00776"></a>00776   <span class="keywordflow">while</span>( <a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#ad950e85c70c4473c5c7c40f8ceeae61d">new_value_ready</a> == 0)
<a name="l00777"></a>00777     pthread_cond_wait( &amp;(<a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#aa97388f93ca5099196ba0da1e4a5b7bb">cond</a>), &amp;(<a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#a958e9fe59e671e61f95c2ce796ba24ce">mutex</a>));
<a name="l00778"></a>00778 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aaf4fadd2943fa3a2ecb5d840e84d68fa"></a><!-- doxytag: member="lspg.c::lspg_worker" ref="aaf4fadd2943fa3a2ecb5d840e84d68fa" args="(void *dummy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* lspg_worker </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dummy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The main loop for the lspg thread. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dummy</em>&nbsp;</td><td>Required by pthreads but unused </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01558">1558</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01560"></a>01560                     {
<a name="l01561"></a>01561   <span class="keyword">static</span> <span class="keyword">struct </span>pollfd fda[2];  <span class="comment">// 0=signal handler, 1=pg socket</span>
<a name="l01562"></a>01562   <span class="keyword">static</span> <span class="keywordtype">int</span> nfda = 0;
<a name="l01563"></a>01563   <span class="keyword">static</span> sigset_t our_sigset;
<a name="l01564"></a>01564   <span class="keywordtype">int</span> sigfd;
<a name="l01565"></a>01565 
<a name="l01566"></a>01566   sigemptyset( &amp;our_sigset);
<a name="l01567"></a>01567   sigaddset( &amp;our_sigset, SIGUSR1);
<a name="l01568"></a>01568 
<a name="l01569"></a>01569 
<a name="l01570"></a>01570   <span class="comment">//</span>
<a name="l01571"></a>01571   <span class="comment">// block ordinary signal mechanism</span>
<a name="l01572"></a>01572   <span class="comment">//</span>
<a name="l01573"></a>01573   sigprocmask(SIG_BLOCK, &amp;our_sigset, NULL);
<a name="l01574"></a>01574 
<a name="l01575"></a>01575     
<a name="l01576"></a>01576   fda[0].fd = signalfd( -1, &amp;our_sigset, SFD_NONBLOCK);
<a name="l01577"></a>01577   <span class="keywordflow">if</span>( fda[0].fd == -1) {
<a name="l01578"></a>01578     <span class="keywordtype">char</span> *es;
<a name="l01579"></a>01579 
<a name="l01580"></a>01580     es = strerror( errno);
<a name="l01581"></a>01581     <a class="code" href="lslogging_8c.html#a0e756b36671055ef02a8f04d2ba8a93b">lslogging_log_message</a>( <span class="stringliteral">&quot;Signalfd trouble: %s&quot;</span>, es);
<a name="l01582"></a>01582   }
<a name="l01583"></a>01583   fda[0].events = POLLIN;
<a name="l01584"></a>01584 
<a name="l01585"></a>01585   <span class="comment">//</span>
<a name="l01586"></a>01586   <span class="comment">//  make sure file descriptor is not legal until it&apos;s been conneceted</span>
<a name="l01587"></a>01587   <span class="comment">//</span>
<a name="l01588"></a>01588   <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.fd   = -1;
<a name="l01589"></a>01589 
<a name="l01590"></a>01590 
<a name="l01591"></a>01591   <span class="keywordflow">while</span>( 1) {
<a name="l01592"></a>01592     <span class="keywordtype">int</span> pollrtn;
<a name="l01593"></a>01593     <span class="keywordtype">int</span> poll_timeout_ms;
<a name="l01594"></a>01594 
<a name="l01595"></a>01595     <a class="code" href="lspg_8c.html#ab52a8c8245bf6561f40c0f224fc07ff4" title="Implements our state machine Does not strictly only set the next state as it also...">lspg_next_state</a>();
<a name="l01596"></a>01596 
<a name="l01597"></a>01597     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.fd == -1) {
<a name="l01598"></a>01598       <span class="comment">//</span>
<a name="l01599"></a>01599       <span class="comment">// Here a connection to the database is not established.</span>
<a name="l01600"></a>01600       <span class="comment">// Periodicaly try again.  Should possibly arrange to reconnect</span>
<a name="l01601"></a>01601       <span class="comment">// to signalfd but that&apos;s unlikely to be nessesary.</span>
<a name="l01602"></a>01602       <span class="comment">//</span>
<a name="l01603"></a>01603       nfda = 1;
<a name="l01604"></a>01604       poll_timeout_ms = 10000;
<a name="l01605"></a>01605       fda[1].revents = 0;
<a name="l01606"></a>01606     } <span class="keywordflow">else</span> {
<a name="l01607"></a>01607       <span class="comment">//</span>
<a name="l01608"></a>01608       <span class="comment">// Arrange to peacfully do nothing until either the pg server sends us something</span>
<a name="l01609"></a>01609       <span class="comment">// or someone pushs something onto our queue</span>
<a name="l01610"></a>01610       <span class="comment">//</span>
<a name="l01611"></a>01611       nfda = 2;
<a name="l01612"></a>01612       fda[1].fd      = <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.fd;
<a name="l01613"></a>01613       fda[1].events  = <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.events;
<a name="l01614"></a>01614       fda[1].revents = 0;
<a name="l01615"></a>01615       poll_timeout_ms = -1;
<a name="l01616"></a>01616     }
<a name="l01617"></a>01617 
<a name="l01618"></a>01618     pollrtn = poll( fda, nfda, poll_timeout_ms);
<a name="l01619"></a>01619 
<a name="l01620"></a>01620     <span class="keywordflow">if</span>( pollrtn &amp;&amp; fda[0].revents) {
<a name="l01621"></a>01621       <a class="code" href="lspg_8c.html#a049f4422994aa2eb2b841ffb2937f895" title="Service a signal Signals here are treated as file descriptors and fits into our poll...">lspg_sig_service</a>( &amp;(fda[0]));
<a name="l01622"></a>01622       pollrtn--;
<a name="l01623"></a>01623     } 
<a name="l01624"></a>01624     <span class="keywordflow">if</span>( pollrtn &amp;&amp; fda[1].revents) {
<a name="l01625"></a>01625       <a class="code" href="lspg_8c.html#aa8d1fed4b461c2139a21826d524777d5" title="I/O control to/from the postgresql server.">lspg_pg_service</a>( &amp;(fda[1]));
<a name="l01626"></a>01626       pollrtn--;
<a name="l01627"></a>01627     } 
<a name="l01628"></a>01628 
<a name="l01629"></a>01629 
<a name="l01630"></a>01630 
<a name="l01631"></a>01631 
<a name="l01632"></a>01632   }
<a name="l01633"></a>01633 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af34559ab5624e1e68085dbcd9410c692"></a><!-- doxytag: member="lspg.c::lspg_zoom_lut_cb" ref="af34559ab5624e1e68085dbcd9410c692" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_zoom_lut_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Zoom motor look up table callback. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>qqp</em>&nbsp;</td><td>the queue item responsible for calling us </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pgr</em>&nbsp;</td><td>The Postgresql result object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00346">346</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00349"></a>00349                         {
<a name="l00350"></a>00350   <span class="keywordtype">int</span> i;
<a name="l00351"></a>00351   
<a name="l00352"></a>00352   pthread_mutex_lock( &amp;(<a class="code" href="lspmac_8c.html#ad53a42cfaa04eff0336a44c8c9986333" title="Optical zoom.">zoom</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a188c5b1e991750ce2ffd53e0192e0907" title="coordinate waiting for motor to be done">mutex</a>));
<a name="l00353"></a>00353 
<a name="l00354"></a>00354   <a class="code" href="lspmac_8c.html#ad53a42cfaa04eff0336a44c8c9986333" title="Optical zoom.">zoom</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a11cbc6f50c150ed446e9a901cf7cc12b" title="length of lut">nlut</a> = PQntuples( pgr)/2;
<a name="l00355"></a>00355   <a class="code" href="lspmac_8c.html#ad53a42cfaa04eff0336a44c8c9986333" title="Optical zoom.">zoom</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a7b43671f7f3e06521f6cf91fb9ac707d" title="lookup table (instead of u2c)">lut</a>  = calloc( 2*<a class="code" href="lspmac_8c.html#ad53a42cfaa04eff0336a44c8c9986333" title="Optical zoom.">zoom</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a11cbc6f50c150ed446e9a901cf7cc12b" title="length of lut">nlut</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00356"></a>00356   <span class="keywordflow">if</span>( <a class="code" href="lspmac_8c.html#ad53a42cfaa04eff0336a44c8c9986333" title="Optical zoom.">zoom</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a7b43671f7f3e06521f6cf91fb9ac707d" title="lookup table (instead of u2c)">lut</a> == NULL) {
<a name="l00357"></a>00357     <a class="code" href="lslogging_8c.html#a0e756b36671055ef02a8f04d2ba8a93b">lslogging_log_message</a>( <span class="stringliteral">&quot;Out of memmory (lspg_zoom_lut_cb)&quot;</span>);
<a name="l00358"></a>00358     pthread_mutex_unlock( &amp;(<a class="code" href="lspmac_8c.html#ad53a42cfaa04eff0336a44c8c9986333" title="Optical zoom.">zoom</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a188c5b1e991750ce2ffd53e0192e0907" title="coordinate waiting for motor to be done">mutex</a>));
<a name="l00359"></a>00359     <span class="keywordflow">return</span>;
<a name="l00360"></a>00360   }
<a name="l00361"></a>00361   
<a name="l00362"></a>00362   <span class="keywordflow">for</span>( i=0; i&lt;PQntuples( pgr); i++) {
<a name="l00363"></a>00363     <a class="code" href="lspmac_8c.html#ad53a42cfaa04eff0336a44c8c9986333" title="Optical zoom.">zoom</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a7b43671f7f3e06521f6cf91fb9ac707d" title="lookup table (instead of u2c)">lut</a>[i] = strtod( PQgetvalue( pgr, i, 0), NULL);
<a name="l00364"></a>00364   }
<a name="l00365"></a>00365 
<a name="l00366"></a>00366   pthread_mutex_unlock( &amp;(<a class="code" href="lspmac_8c.html#ad53a42cfaa04eff0336a44c8c9986333" title="Optical zoom.">zoom</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a188c5b1e991750ce2ffd53e0192e0907" title="coordinate waiting for motor to be done">mutex</a>));
<a name="l00367"></a>00367 }
</pre></div></p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a4937baac0cc78ea306d58b5f027867f1"></a><!-- doxytag: member="lspg.c::ls_pg_state" ref="a4937baac0cc78ea306d58b5f027867f1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1">ls_pg_state</a> = LS_PG_STATE_INIT<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>State of the lspg state machine. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00039">39</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a69ae04978986e6413ca7cefcb692b645"></a><!-- doxytag: member="lspg.c::lspg_connectPoll_response" ref="a69ae04978986e6413ca7cefcb692b645" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostgresPollingStatusType <a class="el" href="lspg_8c.html#a69ae04978986e6413ca7cefcb692b645">lspg_connectPoll_response</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used to determine state while connecting. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00069">69</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a7ef8a09203117578c9b2ce4719519f36"></a><!-- doxytag: member="lspg.c::lspg_getcenter" ref="a7ef8a09203117578c9b2ce4719519f36" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlspg__getcenter__struct.html">lspg_getcenter_t</a> <a class="el" href="pgpmac_8h.html#a7ef8a09203117578c9b2ce4719519f36">lspg_getcenter</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the getcenter object </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00073">73</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="adbf3b3652c6531c3d194320d1abc1c80"></a><!-- doxytag: member="lspg.c::lspg_lock_detector" ref="adbf3b3652c6531c3d194320d1abc1c80" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlspg__lock__detector__struct.html">lspg_lock_detector_t</a> <a class="el" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00863">863</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="aaae7ce3ecd7d54a9e46c41d7a742a454"></a><!-- doxytag: member="lspg.c::lspg_lock_diffractometer" ref="aaae7ce3ecd7d54a9e46c41d7a742a454" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlspg__lock__diffractometer__struct.html">lspg_lock_diffractometer_t</a> <a class="el" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00804">804</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="ad8d8e2f578ca79189a80c1fd5b60cefd"></a><!-- doxytag: member="lspg.c::lspg_nextshot" ref="ad8d8e2f578ca79189a80c1fd5b60cefd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlspg__nextshot__struct.html">lspg_nextshot_t</a> <a class="el" href="pgpmac_8h.html#ad8d8e2f578ca79189a80c1fd5b60cefd">lspg_nextshot</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the nextshot object </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00072">72</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a357d9d98f0b8c9625ccebcebfcdce955"></a><!-- doxytag: member="lspg.c::lspg_query_queue" ref="a357d9d98f0b8c9625ccebcebfcdce955" args="[LS_PG_QUERY_QUEUE_LENGTH]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> <a class="el" href="lspg_8c.html#a357d9d98f0b8c9625ccebcebfcdce955">lspg_query_queue</a>[LS_PG_QUERY_QUEUE_LENGTH]<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Our query queue. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00061">61</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="aca86bb77d6cecfae9251743f4171bafb"></a><!-- doxytag: member="lspg.c::lspg_query_queue_off" ref="aca86bb77d6cecfae9251743f4171bafb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="lspg_8c.html#aca86bb77d6cecfae9251743f4171bafb">lspg_query_queue_off</a> = 0<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The last item still being used (on == off means nothing in queue). </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00063">63</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3cbe7f3161b3c1838ebc56a3bbcfd8a6"></a><!-- doxytag: member="lspg.c::lspg_query_queue_on" ref="a3cbe7f3161b3c1838ebc56a3bbcfd8a6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="lspg_8c.html#a3cbe7f3161b3c1838ebc56a3bbcfd8a6">lspg_query_queue_on</a> = 0<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Next position to add something to the queue. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00062">62</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a2603b071afdbff7c0924b13de2454264"></a><!-- doxytag: member="lspg.c::lspg_query_queue_reply" ref="a2603b071afdbff7c0924b13de2454264" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="lspg_8c.html#a2603b071afdbff7c0924b13de2454264">lspg_query_queue_reply</a> = 0<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The current item being digested. </p>
<p>Normally off &lt;= reply &lt;= on. Corner case of queue wrap arround works because we only increment and compare for equality. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00064">64</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a61a308b6a37afd645beb422653b95baa"></a><!-- doxytag: member="lspg.c::lspg_queue_cond" ref="a61a308b6a37afd645beb422653b95baa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_cond_t <a class="el" href="lspg_8c.html#a61a308b6a37afd645beb422653b95baa">lspg_queue_cond</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>keeps the queue from overflowing </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00044">44</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="aed46a94106c583796e3a8ca0e89aa8e4"></a><!-- doxytag: member="lspg.c::lspg_queue_mutex" ref="aed46a94106c583796e3a8ca0e89aa8e4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_mutex_t <a class="el" href="lspg_8c.html#aed46a94106c583796e3a8ca0e89aa8e4">lspg_queue_mutex</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>keep the queue from getting tangled </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00043">43</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a06c5a937e41a6c706a247777642ec1fb"></a><!-- doxytag: member="lspg.c::lspg_resetPoll_response" ref="a06c5a937e41a6c706a247777642ec1fb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostgresPollingStatusType <a class="el" href="lspg_8c.html#a06c5a937e41a6c706a247777642ec1fb">lspg_resetPoll_response</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used to determine state while reconnecting. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00070">70</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a1b0d9fc30bcea6905b075d2362149172"></a><!-- doxytag: member="lspg.c::lspg_seq_run_prep" ref="a1b0d9fc30bcea6905b075d2362149172" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlspg__seq__run__prep__struct.html">lspg_seq_run_prep_t</a> <a class="el" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00921">921</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a04eb0cda0d5e5afeae7c393b51689765"></a><!-- doxytag: member="lspg.c::lspg_thread" ref="a04eb0cda0d5e5afeae7c393b51689765" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_t <a class="el" href="lspg_8c.html#a04eb0cda0d5e5afeae7c393b51689765">lspg_thread</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>our worker thread </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00042">42</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a0dfc8d0410cd2d7f7da7a70d3ef88e58"></a><!-- doxytag: member="lspg.c::lspg_wait_for_detector" ref="a0dfc8d0410cd2d7f7da7a70d3ef88e58" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlspg__wait__for__detector__struct.html">lspg_wait_for_detector_t</a> <a class="el" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58">lspg_wait_for_detector</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Instance of the detector timing object. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00742">742</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="af3f897b8ffa020ca54289bc5b28cb64d"></a><!-- doxytag: member="lspg.c::lspgfd" ref="af3f897b8ffa020ca54289bc5b28cb64d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct pollfd <a class="el" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d">lspgfd</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>our poll info </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00045">45</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="ad40ac52086f6b774928af45b09d54c6e"></a><!-- doxytag: member="lspg.c::now" ref="ad40ac52086f6b774928af45b09d54c6e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct timeval lspg_time_sent <a class="el" href="lspmac_8c.html#a4bed9053319d1d2cad5cc03d0549e17f">now</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>used to ensure we do not inundate the db server with connection requests </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00040">40</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a9012783dbbadf652a81649a289697cf3"></a><!-- doxytag: member="lspg.c::q" ref="a9012783dbbadf652a81649a289697cf3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PGconn* <a class="el" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3">q</a> = NULL<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Database connector. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00068">68</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 13 Nov 2012 for LS-CAT PGPMAC by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
