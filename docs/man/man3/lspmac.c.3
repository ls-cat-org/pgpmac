.TH "lspmac.c" 3 "Fri Nov 16 2012" "LS-CAT PGPMAC" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lspmac.c \- 
.PP
Routines concerned with communication with PMAC\&.  

.SH SYNOPSIS
.br
.PP
\fC#include 'pgpmac\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBmd2StatusStruct\fP"
.br
.RI "\fIThe block of memory retrieved in a status request\&. \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBLS_PMAC_STATE_RESET\fP   -1"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_DETACHED\fP   0"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_IDLE\fP   1"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_SC\fP   2"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_WACK_NFR\fP   3"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_WACK_CC\fP   4"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_WACK\fP   5"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_GMR\fP   6"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_CR\fP   7"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_RR\fP   8"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_WACK_RR\fP   9"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_GB\fP   10"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_WCR\fP   11"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_WGB\fP   12"
.br
.ti -1c
.RI "#define \fBLSPMAC_PRESET_REGEX\fP   '(\&.*\\\\\&.%s\\\\\&.presets)\\\\\&.([0-9]+)\\\\\&.(name|position)'"
.br
.RI "\fIRegex to pick out preset name and corresponding position\&. \fP"
.ti -1c
.RI "#define \fBPMACPORT\fP   1025"
.br
.RI "\fIThe PMAC (only) listens on this port\&. \fP"
.ti -1c
.RI "#define \fBpmac_cmd_size\fP   8"
.br
.RI "\fIPMAC command size in bytes\&. \fP"
.ti -1c
.RI "#define \fBVR_UPLOAD\fP   0xc0"
.br
.ti -1c
.RI "#define \fBVR_DOWNLOAD\fP   0x40"
.br
.ti -1c
.RI "#define \fBVR_PMAC_SENDLINE\fP   0xb0"
.br
.ti -1c
.RI "#define \fBVR_PMAC_GETLINE\fP   0xb1"
.br
.ti -1c
.RI "#define \fBVR_PMAC_FLUSH\fP   0xb3"
.br
.ti -1c
.RI "#define \fBVR_PMAC_GETMEM\fP   0xb4"
.br
.ti -1c
.RI "#define \fBVR_PMAC_SETMEM\fP   0xb5"
.br
.ti -1c
.RI "#define \fBVR_PMAC_SENDCTRLCHAR\fP   0xb6"
.br
.ti -1c
.RI "#define \fBVR_PMAC_SETBIT\fP   0xba"
.br
.ti -1c
.RI "#define \fBVR_PMAC_SETBITS\fP   0xbb"
.br
.ti -1c
.RI "#define \fBVR_PMAC_PORT\fP   0xbe"
.br
.ti -1c
.RI "#define \fBVR_PMAC_GETRESPONSE\fP   0xbf"
.br
.ti -1c
.RI "#define \fBVR_PMAC_READREADY\fP   0xc2"
.br
.ti -1c
.RI "#define \fBVR_CTRL_RESPONSE\fP   0xc4"
.br
.ti -1c
.RI "#define \fBVR_PMAC_GETBUFFER\fP   0xc5"
.br
.ti -1c
.RI "#define \fBVR_PMAC_WRITEBUFFER\fP   0xc6"
.br
.ti -1c
.RI "#define \fBVR_PMAC_WRITEERROR\fP   0xc7"
.br
.ti -1c
.RI "#define \fBVR_FWDOWNLOAD\fP   0xcb"
.br
.ti -1c
.RI "#define \fBVR_IPADDRESS\fP   0xe0"
.br
.ti -1c
.RI "#define \fBPMAC_MIN_CMD_TIME\fP   20000\&.0"
.br
.RI "\fIMinimum time between commands to the pmac\&. \fP"
.ti -1c
.RI "#define \fBPMAC_CMD_QUEUE_LENGTH\fP   2048"
.br
.RI "\fISize of the PMAC command queue\&. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBmd2StatusStruct\fP \fBmd2_status_t\fP"
.br
.RI "\fIThe block of memory retrieved in a status request\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "double \fBlspmac_lut\fP (int nlut, double *lut, double x)"
.br
.RI "\fILook up table support for motor positions (think x=zoom, y=light intensity) use a lookup table to find the 'counts' to move the motor to the requested position The look up table is a simple one dimensional array with the x values as even indicies and the y values as odd indices\&. \fP"
.ti -1c
.RI "double \fBlspmac_rlut\fP (int nlut, double *lut, double y)"
.br
.ti -1c
.RI "void \fBhex_dump\fP (int n, unsigned char *s)"
.br
.RI "\fIPrints a hex dump of the given data\&. \fP"
.ti -1c
.RI "void \fBcleanstr\fP (char *s)"
.br
.RI "\fIReplace \\r with \\n in null terminated string and print result to terminal\&. \fP"
.ti -1c
.RI "void \fBlsConnect\fP (char *ipaddr)"
.br
.RI "\fIConnect to the PMAC socket\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_push_queue\fP (\fBpmac_cmd_queue_t\fP *cmd)"
.br
.RI "\fIPut a new command on the queue\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_pop_queue\fP ()"
.br
.RI "\fIRemove the oldest queue item\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_pop_reply\fP ()"
.br
.RI "\fIRemove the next command queue item that is waiting for a reply\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_send_command\fP (int rqType, int rq, int wValue, int wIndex, int wLength, unsigned char *data, void(*responseCB)(\fBpmac_cmd_queue_t\fP *, int, unsigned char *), int no_reply)"
.br
.RI "\fICompose a packet and send it to the PMAC\&. \fP"
.ti -1c
.RI "void \fBlspmac_SockFlush\fP ()"
.br
.RI "\fIReset the PMAC socket from the PMAC side\&. \fP"
.ti -1c
.RI "void \fBlspmac_Reset\fP ()"
.br
.RI "\fIClear the queue and put the PMAC into a known state\&. \fP"
.ti -1c
.RI "void \fBlspmac_Error\fP (unsigned char *buff)"
.br
.RI "\fIThe service routing detected an error condition\&. \fP"
.ti -1c
.RI "void \fBlspmac_Service\fP (struct pollfd *evt)"
.br
.RI "\fIService routine for packet coming from the PMAC\&. \fP"
.ti -1c
.RI "void \fBlspmac_GetShortReplyCB\fP (\fBpmac_cmd_queue_t\fP *cmd, int nreceived, unsigned char *buff)"
.br
.RI "\fIReceive a reply that does not require multiple buffers\&. \fP"
.ti -1c
.RI "void \fBlspmac_SendControlReplyPrintCB\fP (\fBpmac_cmd_queue_t\fP *cmd, int nreceived, unsigned char *buff)"
.br
.RI "\fIReceive a reply to a control character Print a 'printable' version of the character to the terminal Followed by a hex dump of the response\&. \fP"
.ti -1c
.RI "void \fBlspmac_GetmemReplyCB\fP (\fBpmac_cmd_queue_t\fP *cmd, int nreceived, unsigned char *buff)"
.br
.RI "\fIService a reply to the getmem command\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_SockGetmem\fP (int offset, int nbytes)"
.br
.RI "\fIRequest a chunk of memory to be returned\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_SockSendline\fP (char *fmt,\&.\&.\&.)"
.br
.RI "\fISend a one line command\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_SockSendline_nr\fP (char *fmt,\&.\&.\&.)"
.br
.RI "\fISend a command and ignore the response\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_SockSendControlCharPrint\fP (char c)"
.br
.RI "\fISend a control character\&. \fP"
.ti -1c
.RI "void \fBlspmac_Getmem\fP ()"
.br
.RI "\fIRequest a block of double buffer memory\&. \fP"
.ti -1c
.RI "void \fBlspmac_bo_read\fP (\fBlspmac_motor_t\fP *mp)"
.br
.RI "\fIRead the state of a binary i/o motor This is the read method for the binary i/o motor class\&. \fP"
.ti -1c
.RI "void \fBlspmac_dac_read\fP (\fBlspmac_motor_t\fP *mp)"
.br
.RI "\fIRead a DAC motor position\&. \fP"
.ti -1c
.RI "void \fBlspmac_shutter_read\fP (\fBlspmac_motor_t\fP *mp)"
.br
.RI "\fIFast shutter read routine The shutter is mildly complicated in that we need to take into account the fact that the shutter can open and close again between status updates\&. \fP"
.ti -1c
.RI "void \fBlspmac_home1_queue\fP (\fBlspmac_motor_t\fP *mp)"
.br
.RI "\fIHoming method for steppers and servos\&. \fP"
.ti -1c
.RI "void \fBlspmac_home2_queue\fP (\fBlspmac_motor_t\fP *mp)"
.br
.RI "\fISecond stage of homing\&. \fP"
.ti -1c
.RI "void \fBlspmac_pmacmotor_read\fP (\fBlspmac_motor_t\fP *mp)"
.br
.RI "\fIRead the position and status of a normal PMAC motor\&. \fP"
.ti -1c
.RI "void \fBlspmac_get_status_cb\fP (\fBpmac_cmd_queue_t\fP *cmd, int nreceived, unsigned char *buff)"
.br
.RI "\fIService routing for status upate This updates positions and status information\&. \fP"
.ti -1c
.RI "void \fBlspmac_get_status\fP ()"
.br
.RI "\fIRequest a status update from the PMAC\&. \fP"
.ti -1c
.RI "void \fBlspmac_GetAllIVarsCB\fP (\fBpmac_cmd_queue_t\fP *cmd, int nreceived, unsigned char *buff)"
.br
.RI "\fIReceive the values of all the I variables Update our Postgresql database with the results\&. \fP"
.ti -1c
.RI "void \fBlspmac_GetAllIVars\fP ()"
.br
.RI "\fIRequest the values of all the I variables\&. \fP"
.ti -1c
.RI "void \fBlspmac_GetAllMVarsCB\fP (\fBpmac_cmd_queue_t\fP *cmd, int nreceived, unsigned char *buff)"
.br
.RI "\fIReceive the values of all the M variables Update our database with the results\&. \fP"
.ti -1c
.RI "void \fBlspmac_GetAllMVars\fP ()"
.br
.RI "\fIRequest the values of all the M variables\&. \fP"
.ti -1c
.RI "void \fBlspmac_sendcmd_nocb\fP (char *fmt,\&.\&.\&.)"
.br
.RI "\fISend a command that does not need to deal with the reply\&. \fP"
.ti -1c
.RI "void \fBlspmac_sendcmd\fP (void(*responseCB)(\fBpmac_cmd_queue_t\fP *, int, unsigned char *), char *fmt,\&.\&.\&.)"
.br
.RI "\fIPMAC command with call back\&. \fP"
.ti -1c
.RI "void \fBlspmac_next_state\fP ()"
.br
.RI "\fIState machine logic\&. \fP"
.ti -1c
.RI "void * \fBlspmac_worker\fP (void *dummy)"
.br
.RI "\fIOur lspmac worker thread\&. \fP"
.ti -1c
.RI "void \fBlspmac_movedac_queue\fP (\fBlspmac_motor_t\fP *mp, double requested_position)"
.br
.RI "\fIMove method for dac motor objects (ie, lights) \fP"
.ti -1c
.RI "void \fBlspmac_movezoom_queue\fP (\fBlspmac_motor_t\fP *mp, double requested_position)"
.br
.RI "\fIMove method for the zoom motor\&. \fP"
.ti -1c
.RI "void \fBlspmac_move_preset_queue\fP (\fBlspmac_motor_t\fP *mp, char *name)"
.br
.RI "\fIMove a given motor to one of its preset positions\&. \fP"
.ti -1c
.RI "void \fBlspmac_moveabs_fshut_queue\fP (\fBlspmac_motor_t\fP *mp, double requested_position)"
.br
.RI "\fIMove method for the fast shutter\&. \fP"
.ti -1c
.RI "void \fBlspmac_moveabs_bo_queue\fP (\fBlspmac_motor_t\fP *mp, double requested_position)"
.br
.RI "\fIMove method for binary i/o motor objects\&. \fP"
.ti -1c
.RI "void \fBlspmac_moveabs_queue\fP (\fBlspmac_motor_t\fP *mp, double requested_position)"
.br
.RI "\fIMove method for normal stepper and servo motor objects\&. \fP"
.ti -1c
.RI "void \fBlspmac_moveabs_wait\fP (\fBlspmac_motor_t\fP *mp)"
.br
.RI "\fIWait for motor to finish moving\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBlspmac_motor_init\fP (\fBlspmac_motor_t\fP *d, int motor_number, int wy, int wx, int *posp, int *stat1p, int *stat2p, char *wtitle, char *name, void(*moveAbs)(\fBlspmac_motor_t\fP *, double))"
.br
.RI "\fIInitialize a pmac stepper or servo motor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBlspmac_fshut_init\fP (\fBlspmac_motor_t\fP *d)"
.br
.RI "\fIInitalize the fast shutter motor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBlspmac_bo_init\fP (\fBlspmac_motor_t\fP *d, char *name, char *write_fmt, int *read_ptr, int read_mask)"
.br
.RI "\fIInitialize binary i/o motor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBlspmac_dac_init\fP (\fBlspmac_motor_t\fP *d, int *posp, double scale, char *mvar, char *name)"
.br
.RI "\fIInitialize DAC motor Note that some motors require further initialization from a database query\&. \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBlspmac_bi_init\fP (\fBlspmac_bi_t\fP *d, int *ptr, int mask, char *onEvent, char *offEvent)"
.br
.RI "\fIInitialize binary input\&. \fP"
.ti -1c
.RI "void \fBlspmac_init\fP (int ivarsflag, int mvarsflag)"
.br
.RI "\fIInitialize this module\&. \fP"
.ti -1c
.RI "void \fBlspmac_cryoSwitchChanged_cb\fP (char *event)"
.br
.ti -1c
.RI "void \fBlspmac_scint_inPosition_cb\fP (char *event)"
.br
.RI "\fIMaybe start drying off the scintilator\&. \fP"
.ti -1c
.RI "void \fBlspmac_scint_dried_cb\fP (char *event)"
.br
.RI "\fITurn off the dryer\&. \fP"
.ti -1c
.RI "void \fBlspmac_newKV_cb\fP (char *event)"
.br
.ti -1c
.RI "void \fBlspmac_run\fP ()"
.br
.RI "\fIStart up the lspmac thread\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static int \fBls_pmac_state\fP = \fBLS_PMAC_STATE_DETACHED\fP"
.br
.RI "\fICurrent state of the PMAC communications state machine\&. \fP"
.ti -1c
.RI "int \fBlspmac_shutter_state\fP"
.br
.RI "\fIState of the shutter, used to detect changes\&. \fP"
.ti -1c
.RI "int \fBlspmac_shutter_has_opened\fP"
.br
.RI "\fIIndicates that the shutter had opened, perhaps briefly even if the state did not change\&. \fP"
.ti -1c
.RI "pthread_mutex_t \fBlspmac_shutter_mutex\fP"
.br
.RI "\fICoordinates threads reading shutter status\&. \fP"
.ti -1c
.RI "pthread_cond_t \fBlspmac_shutter_cond\fP"
.br
.RI "\fIAllows waiting for the shutter status to change\&. \fP"
.ti -1c
.RI "pthread_mutex_t \fBlspmac_moving_mutex\fP"
.br
.RI "\fICoordinate moving motors between threads\&. \fP"
.ti -1c
.RI "pthread_cond_t \fBlspmac_moving_cond\fP"
.br
.RI "\fIWait for motor(s) to finish moving condition\&. \fP"
.ti -1c
.RI "int \fBlspmac_moving_flags\fP"
.br
.RI "\fIFlag used to implement motor moving condition\&. \fP"
.ti -1c
.RI "static pthread_t \fBpmac_thread\fP"
.br
.RI "\fIour thread to manage access and communication to the pmac \fP"
.ti -1c
.RI "static pthread_mutex_t \fBpmac_queue_mutex\fP"
.br
.RI "\fImanage access to the pmac command queue \fP"
.ti -1c
.RI "static pthread_cond_t \fBpmac_queue_cond\fP"
.br
.RI "\fIwait for a command to be sent to PMAC before continuing \fP"
.ti -1c
.RI "static struct pollfd \fBpmacfd\fP"
.br
.RI "\fIour poll structure \fP"
.ti -1c
.RI "static int \fBgetivars\fP = 0"
.br
.RI "\fIflag set at initialization to send i vars to db \fP"
.ti -1c
.RI "static int \fBgetmvars\fP = 0"
.br
.RI "\fIflag set at initialization to send m vars to db \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP \fBlspmac_bis\fP [16]"
.br
.RI "\fIarray of binary inputs \fP"
.ti -1c
.RI "int \fBlspmac_nbis\fP = 0"
.br
.RI "\fInumber of active binary inputs \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP \fBlspmac_motors\fP [32]"
.br
.RI "\fIAll our motors\&. \fP"
.ti -1c
.RI "int \fBlspmac_nmotors\fP = 0"
.br
.RI "\fIThe number of motors we manage\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBomega\fP"
.br
.RI "\fIMD2 omega axis (the air bearing) \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBalignx\fP"
.br
.RI "\fIAlignment stage X\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBaligny\fP"
.br
.RI "\fIAlignment stage Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBalignz\fP"
.br
.RI "\fIAlignment stage X\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBanal\fP"
.br
.RI "\fIPolaroid analyzer motor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBzoom\fP"
.br
.RI "\fIOptical zoom\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBapery\fP"
.br
.RI "\fIAperture Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBaperz\fP"
.br
.RI "\fIAperture Z\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcapy\fP"
.br
.RI "\fICapillary Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcapz\fP"
.br
.RI "\fICapillary Z\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBscint\fP"
.br
.RI "\fIScintillator Z\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcenx\fP"
.br
.RI "\fICentering Table X\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBceny\fP"
.br
.RI "\fICentering Table Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBkappa\fP"
.br
.RI "\fIKappa\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBphi\fP"
.br
.RI "\fIPhi (not data collection axis) \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBfshut\fP"
.br
.RI "\fIFast shutter\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBflight\fP"
.br
.RI "\fIFront Light DAC\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBblight\fP"
.br
.RI "\fIBack Light DAC\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBfscint\fP"
.br
.RI "\fIScintillator Piezo DAC\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBblight_ud\fP"
.br
.RI "\fIBack Light Up/Down actuator\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcryo\fP"
.br
.RI "\fIMove the cryostream towards or away from the crystal\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBdryer\fP"
.br
.RI "\fIblow air on the scintilator to dry it off \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBfluo\fP"
.br
.RI "\fIMove the fluorescence detector in/out\&. \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBcryo_switch\fP"
.br
.RI "\fIthat little toggle switch for the cryo \fP"
.ti -1c
.RI "static int \fBlinesReceived\fP =0"
.br
.RI "\fIcurrent number of lines received \fP"
.ti -1c
.RI "static unsigned char \fBdbmem\fP [64 *1024]"
.br
.RI "\fIdouble buffered memory \fP"
.ti -1c
.RI "static int \fBdbmemIn\fP = 0"
.br
.RI "\fInext location \fP"
.ti -1c
.RI "static struct timeval 
.br
pmac_time_sent \fBnow\fP"
.br
.RI "\fIused to ensure we do not send commands to the pmac too often\&. Only needed for non-DB commands\&. \fP"
.ti -1c
.RI "static \fBpmac_cmd_t\fP \fBrr_cmd\fP"
.br
.ti -1c
.RI "static \fBpmac_cmd_t\fP \fBgb_cmd\fP"
.br
.ti -1c
.RI "static \fBpmac_cmd_t\fP \fBcr_cmd\fP"
.br
.RI "\fIcommands to send out 'readready', 'getbuffer', controlresponse (initialized in main) \fP"
.ti -1c
.RI "static \fBpmac_cmd_queue_t\fP \fBethCmdQueue\fP [\fBPMAC_CMD_QUEUE_LENGTH\fP]"
.br
.RI "\fIPMAC command queue\&. \fP"
.ti -1c
.RI "static unsigned int \fBethCmdOn\fP = 0"
.br
.RI "\fIpoints to next empty PMAC command queue position \fP"
.ti -1c
.RI "static unsigned int \fBethCmdOff\fP = 0"
.br
.RI "\fIpoints to current command (or none if == ethCmdOn) \fP"
.ti -1c
.RI "static unsigned int \fBethCmdReply\fP = 0"
.br
.RI "\fIUsed like ethCmdOff only to deal with the pmac reply to a command\&. \fP"
.ti -1c
.RI "static char * \fBpmac_error_strs\fP []"
.br
.RI "\fIDecode the errors perhaps returned by the PMAC\&. \fP"
.ti -1c
.RI "static \fBmd2_status_t\fP \fBmd2_status\fP"
.br
.RI "\fIBuffer for MD2 Status\&. \fP"
.ti -1c
.RI "pthread_mutex_t \fBmd2_status_mutex\fP"
.br
.RI "\fISynchronize reading/writting status buffer\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Routines concerned with communication with PMAC\&. 

.PP
.nf
\date 2012
\author Keith Brister
\copyright All Rights Reserved
.fi
.PP
.PP
This is a state machine (surprise!) Lacking is support for writingbuffer, control writing and reading, as well as double buffered memory It looks like several different methods of managing PMAC communications are possible\&. Here is set up a queue of outgoing commands and deal completely with the result before sending the next\&. A full handshake of acknowledgements and 'readready' is expected\&.
.PP
State Description  -1 Reset the connection  0 Detached: need to connect to tcp port  1 Idle (waiting for a command to send to the pmac)  2 Send command  3 Waiting for command acknowledgement (no further response expected)  4 Waiting for control character acknowledgement (further response expected)  5 Waiting for command acknowledgement (further response expected)  6 Waiting for get memory response  7 Send controlresponse  8 Send readready  9 Waiting for acknowledgement of 'readready'  10 Send readbuffer  11 Waiting for control response  12 Waiting for readbuffer response 
.PP

.PP
Definition in file \fBlspmac\&.c\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define LS_PMAC_STATE_CR   7"

.PP
Definition at line 45 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_DETACHED   0"

.PP
Definition at line 38 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_GB   10"

.PP
Definition at line 48 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_GMR   6"

.PP
Definition at line 44 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_IDLE   1"

.PP
Definition at line 39 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_RESET   -1"

.PP
Definition at line 37 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_RR   8"

.PP
Definition at line 46 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_SC   2"

.PP
Definition at line 40 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_WACK   5"

.PP
Definition at line 43 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_WACK_CC   4"

.PP
Definition at line 42 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_WACK_NFR   3"

.PP
Definition at line 41 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_WACK_RR   9"

.PP
Definition at line 47 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_WCR   11"

.PP
Definition at line 49 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_WGB   12"

.PP
Definition at line 50 of file lspmac\&.c\&.
.SS "#define LSPMAC_PRESET_REGEX   '(\&.*\\\\\&.%s\\\\\&.presets)\\\\\&.([0-9]+)\\\\\&.(name|position)'"

.PP
Regex to pick out preset name and corresponding position\&. 
.PP
Definition at line 104 of file lspmac\&.c\&.
.SS "#define PMAC_CMD_QUEUE_LENGTH   2048"

.PP
Size of the PMAC command queue\&. 
.PP
Definition at line 148 of file lspmac\&.c\&.
.SS "#define pmac_cmd_size   8"

.PP
PMAC command size in bytes\&. 
.PP
Definition at line 114 of file lspmac\&.c\&.
.SS "#define PMAC_MIN_CMD_TIME   20000\&.0"

.PP
Minimum time between commands to the pmac\&. 
.PP
Definition at line 144 of file lspmac\&.c\&.
.SS "#define PMACPORT   1025"

.PP
The PMAC (only) listens on this port\&. 
.PP
Definition at line 108 of file lspmac\&.c\&.
.SS "#define VR_CTRL_RESPONSE   0xc4"

.PP
Definition at line 130 of file lspmac\&.c\&.
.SS "#define VR_DOWNLOAD   0x40"

.PP
Definition at line 117 of file lspmac\&.c\&.
.SS "#define VR_FWDOWNLOAD   0xcb"

.PP
Definition at line 134 of file lspmac\&.c\&.
.SS "#define VR_IPADDRESS   0xe0"

.PP
Definition at line 135 of file lspmac\&.c\&.
.SS "#define VR_PMAC_FLUSH   0xb3"

.PP
Definition at line 121 of file lspmac\&.c\&.
.SS "#define VR_PMAC_GETBUFFER   0xc5"

.PP
Definition at line 131 of file lspmac\&.c\&.
.SS "#define VR_PMAC_GETLINE   0xb1"

.PP
Definition at line 120 of file lspmac\&.c\&.
.SS "#define VR_PMAC_GETMEM   0xb4"

.PP
Definition at line 122 of file lspmac\&.c\&.
.SS "#define VR_PMAC_GETRESPONSE   0xbf"

.PP
Definition at line 128 of file lspmac\&.c\&.
.SS "#define VR_PMAC_PORT   0xbe"

.PP
Definition at line 127 of file lspmac\&.c\&.
.SS "#define VR_PMAC_READREADY   0xc2"

.PP
Definition at line 129 of file lspmac\&.c\&.
.SS "#define VR_PMAC_SENDCTRLCHAR   0xb6"

.PP
Definition at line 124 of file lspmac\&.c\&.
.SS "#define VR_PMAC_SENDLINE   0xb0"

.PP
Definition at line 119 of file lspmac\&.c\&.
.SS "#define VR_PMAC_SETBIT   0xba"

.PP
Definition at line 125 of file lspmac\&.c\&.
.SS "#define VR_PMAC_SETBITS   0xbb"

.PP
Definition at line 126 of file lspmac\&.c\&.
.SS "#define VR_PMAC_SETMEM   0xb5"

.PP
Definition at line 123 of file lspmac\&.c\&.
.SS "#define VR_PMAC_WRITEBUFFER   0xc6"

.PP
Definition at line 132 of file lspmac\&.c\&.
.SS "#define VR_PMAC_WRITEERROR   0xc7"

.PP
Definition at line 133 of file lspmac\&.c\&.
.SS "#define VR_UPLOAD   0xc0"

.PP
Definition at line 116 of file lspmac\&.c\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBmd2StatusStruct\fP  \fBmd2_status_t\fP"

.PP
The block of memory retrieved in a status request\&. 
.SH "Function Documentation"
.PP 
.SS "void cleanstr (char *s)"

.PP
Replace \\r with \\n in null terminated string and print result to terminal\&. Needed to turn PMAC messages into something printable\&. \fBParameters:\fP
.RS 4
\fIs\fP String to print to terminal\&. 
.RE
.PP

.PP
Definition at line 441 of file lspmac\&.c\&.
.PP
.nf
                {
  int i;

  pthread_mutex_lock( &ncurses_mutex);

  for( i=0; i<strlen( s); i++) {
    if( s[i] == '\r')
      wprintw( term_output, '\n');
    else
      wprintw( term_output, '%c', s[i]);
  }

  pthread_mutex_unlock( &ncurses_mutex);
}
.fi
.SS "void hex_dump (intn, unsigned char *s)"

.PP
Prints a hex dump of the given data\&. Used to debug packet data\&. \fBParameters:\fP
.RS 4
\fIn\fP Number of bytes passed in s 
.br
\fIs\fP Data to dump 
.RE
.PP

.PP
Definition at line 413 of file lspmac\&.c\&.
.PP
.nf
                {

  int i;        // row counter
  int j;        // column counter

  pthread_mutex_lock( &ncurses_mutex);

  for( i=0; n > 0; i++) {
    for( j=0; j<16 && n > 0; j++) {
      if( j==8)
        wprintw( term_output, '  ');
      wprintw( term_output, ' %02x', *(s + 16*i + j));
      n--;
    }
    wprintw( term_output, '\n');
  }
  wprintw( term_output, '\n');

  pthread_mutex_unlock( &ncurses_mutex);
}
.fi
.SS "void lsConnect (char *ipaddr)"

.PP
Connect to the PMAC socket\&. Establish or reestablish communications\&. \fBParameters:\fP
.RS 4
\fIipaddr\fP String representation of the IP address (dot quad or FQN) 
.RE
.PP

.PP
Definition at line 462 of file lspmac\&.c\&.
.PP
.nf
                 {
  int psock;                    // our socket: value stored in pmacfda\&.fd
  int err;                      // error code from some system calls
  struct sockaddr_in *addrP;    // our address structure to connect to
  struct addrinfo ai_hints;     // required for getaddrinfo
  struct addrinfo *ai_resultP;  // linked list of address structures (we'll always pick the first)

  pmacfd\&.fd     = -1;
  pmacfd\&.events = 0;

  // Initial buffer(s)
  memset( &ai_hints,  0, sizeof( ai_hints));

  ai_hints\&.ai_family   = AF_INET;
  ai_hints\&.ai_socktype = SOCK_STREAM;


  //
  // get address
  //
  err = getaddrinfo( ipaddr, NULL, &ai_hints, &ai_resultP);
  if( err != 0) {

    lslogging_log_message( 'Could not find address: %s', gai_strerror( err));

    return;
  }


  addrP = (struct sockaddr_in *)ai_resultP->ai_addr;
  addrP->sin_port = htons( PMACPORT);


  psock = socket( PF_INET, SOCK_STREAM, 0);
  if( psock == -1) {
    lslogging_log_message( 'Could not create socket');
    return;
  }

  err = connect( psock, (const struct sockaddr *)addrP, sizeof( *addrP));
  if( err != 0) {
    lslogging_log_message( 'Could not connect socket: %s', strerror( errno));
    return;
  }

  ls_pmac_state = LS_PMAC_STATE_IDLE;
  pmacfd\&.fd     = psock;
  pmacfd\&.events = POLLIN;

}
.fi
.SS "\fBlspmac_bi_t\fP* lspmac_bi_init (\fBlspmac_bi_t\fP *d, int *ptr, intmask, char *onEvent, char *offEvent)"

.PP
Initialize binary input\&. 
.PP
Definition at line 2214 of file lspmac\&.c\&.
.PP
.nf
                                                                                                {
  lspmac_nbis++;
  pthread_mutex_init( &(d->mutex), NULL);
  d->ptr            = ptr;
  d->mask           = mask;
  d->changeEventOn  = strdup( onEvent);
  d->changeEventOff = strdup( offEvent);
  d->first_time     = 1;
}
.fi
.SS "\fBlspmac_motor_t\fP* lspmac_bo_init (\fBlspmac_motor_t\fP *d, char *name, char *write_fmt, int *read_ptr, intread_mask)"

.PP
Initialize binary i/o motor\&. \fBParameters:\fP
.RS 4
\fId\fP Our uninitialized motor object 
.br
\fIname\fP Name of motor to coordinate with DB 
.br
\fIwrite_fmt\fP Format string used to generate PMAC command to move motor 
.br
\fIread_ptr\fP Pointer to byte in md2_status to find position 
.br
\fIread_mask\fP Bitmask to find position in *read_ptr 
.RE
.PP

.PP
Definition at line 2141 of file lspmac\&.c\&.
.PP
.nf
                                  {
  lspmac_nmotors++;

  lskvs_regcomp( &(d->preset_regex), REG_EXTENDED, LSPMAC_PRESET_REGEX, name);
  d->presets           = NULL;
  d->name              = strdup( name);
  d->moveAbs           = lspmac_moveabs_bo_queue;
  d->read              = lspmac_bo_read;
  d->lut               = NULL;
  d->nlut              = 0;
  d->actual_pos_cnts_p = NULL;
  d->status1_p         = NULL;
  d->status2_p         = NULL;
  d->motor_num         = -1;
  d->dac_mvar          = NULL;
  d->win               = NULL;
  d->write_fmt         = strdup( write_fmt);
  d->read_ptr          = read_ptr;
  d->read_mask         = read_mask;
  d->homing            = 0;
  d->win               = NULL;
  d->u2c               = 1\&.0;

  d->lspg_initialized = 0;
  return d;
}
.fi
.SS "void lspmac_bo_read (\fBlspmac_motor_t\fP *mp)"

.PP
Read the state of a binary i/o motor This is the read method for the binary i/o motor class\&. \fBParameters:\fP
.RS 4
\fImp\fP The motor 
.RE
.PP

.PP
Definition at line 1004 of file lspmac\&.c\&.
.PP
.nf
                       {
  char s[512];
  int pos;

  pthread_mutex_lock( &(mp->mutex));

  pos = (*(mp->read_ptr) & mp->read_mask) == 0 ? 0 : 1;
  mp->position = pos;

  // Not sure what kind of status makes sense to report
  mp->statuss[0] = 0;


  pthread_mutex_unlock( &(mp->mutex));
}
.fi
.SS "void lspmac_cryoSwitchChanged_cb (char *event)"

.PP
Definition at line 2316 of file lspmac\&.c\&.
.PP
.nf
                                               {
  int pos;

  pthread_mutex_lock( &(cryo->mutex));
  pos = cryo->position;
  pthread_mutex_unlock( &(cryo->mutex));

  cryo->moveAbs( cryo, pos ? 0\&.0 : 1\&.0);
}
.fi
.SS "\fBlspmac_motor_t\fP* lspmac_dac_init (\fBlspmac_motor_t\fP *d, int *posp, doublescale, char *mvar, char *name)"

.PP
Initialize DAC motor Note that some motors require further initialization from a database query\&. For this reason this initialzation code must be run before the database queue is allowed to be processed\&. \fBParameters:\fP
.RS 4
\fId\fP Returns the (almost) initialized motor object [in,out] unitintialized motor 
.br
\fIposp\fP Location of current position 
.br
\fIscale\fP Scale factor (units) 
.br
\fImvar\fP M variable, ie, 'M1200' 
.br
\fIname\fP name to coordinate with DB 
.RE
.PP

.PP
Definition at line 2181 of file lspmac\&.c\&.
.PP
.nf
                                  {
  lspmac_nmotors++;
  lskvs_regcomp( &(d->preset_regex), REG_EXTENDED, LSPMAC_PRESET_REGEX, name);
  d->presets           = NULL;

  d->name              = strdup( name);
  d->moveAbs           = lspmac_movedac_queue;
  d->read              = lspmac_dac_read;
  d->lut               = NULL;
  d->nlut              = 0;
  d->actual_pos_cnts_p = posp;
  d->status1_p         = NULL;
  d->status2_p         = NULL;
  d->motor_num         = -1;
  d->dac_mvar          = strdup(mvar);
  d->u2c               = scale;
  d->homing            = 0;
  d->win               = NULL;

  d->lspg_initialized = 0;
  return d;
}
.fi
.SS "void lspmac_dac_read (\fBlspmac_motor_t\fP *mp)"

.PP
Read a DAC motor position\&. \fBParameters:\fP
.RS 4
\fImp\fP The motor 
.RE
.PP

.PP
Definition at line 1024 of file lspmac\&.c\&.
.PP
.nf
                       {
  int pos;
  pthread_mutex_lock( &(mp->mutex));
  mp->actual_pos_cnts = *mp->actual_pos_cnts_p;

  if( mp->nlut >0 && mp->lut != NULL) {
    mp->position = lspmac_rlut( mp->nlut, mp->lut, mp->actual_pos_cnts);
  } else {
    if( mp->u2c != 0\&.0) {
      mp->position = mp->actual_pos_cnts / mp->u2c;
    } else {
      mp->position = mp->actual_pos_cnts;
    }
  }

  // Not sure what kind of status makes sense to report
  mp->statuss[0] = 0;

  pthread_mutex_unlock( &(mp->mutex));
}
.fi
.SS "void lspmac_Error (unsigned char *buff)"

.PP
The service routing detected an error condition\&. Scan the response buffer for an error code and print it out\&. \fBParameters:\fP
.RS 4
\fIbuff\fP Buffer returned by PMAC perhaps containing a NULL terminated message\&. 
.RE
.PP

.PP
Definition at line 659 of file lspmac\&.c\&.
.PP
.nf
                    {
  int err;
  //
  // assume buff points to a 1400 byte array of stuff read from the pmac
  //

  if( buff[0] == 7 && buff[1] == 'E' && buff[2] == 'R' && buff[3] == 'R') {
    buff[7] = 0;  // For null termination
    err = atoi( &(buff[4]));
    if( err > 0 && err < 20) {
      lslogging_log_message( pmac_error_strs[err]);

      pthread_mutex_lock( &ncurses_mutex);
      wprintw( term_output, '\n%s\n', pmac_error_strs[err]);
      wnoutrefresh( term_output);
      wnoutrefresh( term_input);
      doupdate();
      pthread_mutex_unlock( &ncurses_mutex);
    }
  }
  lspmac_Reset();
}
.fi
.SS "\fBlspmac_motor_t\fP* lspmac_fshut_init (\fBlspmac_motor_t\fP *d)"

.PP
Initalize the fast shutter motor\&. \fBParameters:\fP
.RS 4
\fId\fP Our uninitialized motor object 
.RE
.PP

.PP
Definition at line 2110 of file lspmac\&.c\&.
.PP
.nf
                                    {
  lspmac_nmotors++;

  d->presets           = NULL;
  d->name              = strdup('fastShutter');
  lskvs_regcomp( &(d->preset_regex), REG_EXTENDED, LSPMAC_PRESET_REGEX, d->name);
  d->moveAbs           = lspmac_moveabs_fshut_queue;
  d->read              = lspmac_shutter_read;
  d->lut               = NULL;
  d->nlut              = 0;
  d->actual_pos_cnts_p = NULL;
  d->status1_p         = NULL;
  d->status2_p         = NULL;
  d->motor_num         = -1;
  d->dac_mvar          = NULL;
  d->homing            = 0;
  d->win               = NULL;

  d->lspg_initialized = 0;
  return d;
}
.fi
.SS "void lspmac_get_status ()"

.PP
Request a status update from the PMAC\&. 
.PP
Definition at line 1543 of file lspmac\&.c\&.
.PP
.nf
                         {
  lspmac_send_command( VR_UPLOAD, VR_PMAC_GETMEM, 0x400, 0, sizeof(md2_status_t), NULL, lspmac_get_status_cb, 0);
}
.fi
.SS "void lspmac_get_status_cb (\fBpmac_cmd_queue_t\fP *cmd, intnreceived, unsigned char *buff)"

.PP
Service routing for status upate This updates positions and status information\&. \fBParameters:\fP
.RS 4
\fIcmd\fP The command that generated this reply 
.br
\fInreceived\fP Number of bytes received 
.br
\fIbuff\fP The Big Byte Buffer 
.RE
.PP

.PP
Definition at line 1374 of file lspmac\&.c\&.
.PP
.nf
                            {
  static int cnt = 0;
  static char s[256];
  static struct timeval ts1, ts2;

  char *sp;
  int i, pos;
  lspmac_motor_t *mp;
  lspmac_bi_t    *bp;

  if( cnt == 0) {
    gettimeofday( &ts1, NULL);
  }

  pthread_mutex_lock( &md2_status_mutex);
  memcpy( &md2_status, buff, sizeof(md2_status));
  pthread_mutex_unlock( &md2_status_mutex);


  //
  // track the coordinate system moving flags
  //
  pthread_mutex_lock( &lspmac_moving_mutex);
  if( md2_status\&.moving_flags != lspmac_moving_flags) {
    lspmac_moving_flags = md2_status\&.moving_flags;
    pthread_cond_signal( &lspmac_moving_cond);
  }
  pthread_mutex_unlock( &lspmac_moving_mutex);


  //
  // Read the motor positions
  //
  for( i=0; i<lspmac_nmotors; i++) {
    lspmac_motors[i]\&.read(&(lspmac_motors[i]));
  }

  //
  // Read the binary inputs and perhaps send an event
  //
  for( i=0; i<lspmac_nbis; i++) {
    bp = &(lspmac_bis[i]);
    
    pthread_mutex_lock( &(bp->mutex));

    pos = (*(bp->ptr) & bp->mask) == 0 ? 0 : 1;

    if( bp->first_time) {
      bp->first_time = 0;
      if( pos==1 && bp->changeEventOn != NULL && bp->changeEventOn[0] != 0)
        lsevents_send_event( lspmac_bis[i]\&.changeEventOn);
      if( pos==0 && bp->changeEventOff != NULL && bp->changeEventOff[0] != 0)
        lsevents_send_event( lspmac_bis[i]\&.changeEventOff);
    } else {
      if( pos != bp->previous) {
        if( pos==1 && bp->changeEventOn != NULL && bp->changeEventOn[0] != 0)
          lsevents_send_event( lspmac_bis[i]\&.changeEventOn);
        if( pos==0 && bp->changeEventOff != NULL && bp->changeEventOff[0] != 0)
          lsevents_send_event( lspmac_bis[i]\&.changeEventOff);
      }
    }
    bp->previous = pos;
    pthread_mutex_unlock( &(bp->mutex));
  }

  pthread_mutex_lock( &ncurses_mutex);

  // acc11c_1
  // mask  bit
  // 0x01  0    Air pressure OK
  // 0x02  1    Air bearing OK
  // 0x04  2    Cryo switch
  // 0x08  3
  // 0x10  4
  // 0x20  5
  // 0x40  6    Cryo is back

  //
  // acc11c_2
  // mask  bit
  // 0x01  0    Fluor Dector back
  // 0x02  1    Sample Detected
  // 0x04  2
  // 0x08  3
  // 0x10  4
  // 0x20  5    Etel Ready
  // 0x40  6    Etel On
  // 0x80  7    Etel Init OK

  if( md2_status\&.acc11c_2 & 0x01)
    mvwprintw( term_status2, 3, 10, '%*s', -8, 'Fluor Out');
  else
    mvwprintw( term_status2, 3, 10, '%*s', -8, 'Fluor In');

  if( md2_status\&.acc11c_5 & 0x08)
    mvwprintw( term_status2, 4, 1, '%*s', -(LS_DISPLAY_WINDOW_WIDTH-2), 'Dryer On');
  else
    mvwprintw( term_status2, 4, 1, '%*s', -(LS_DISPLAY_WINDOW_WIDTH-2), 'Dryer Off');

  if( md2_status\&.acc11c_2 & 0x02)
    mvwprintw( term_status2, 2, 1, '%*s', -(LS_DISPLAY_WINDOW_WIDTH-2), 'Cap Dectected');
  else
    mvwprintw( term_status2, 2, 1, '%*s', -(LS_DISPLAY_WINDOW_WIDTH-2), 'Cap Not Dectected');
  wnoutrefresh( term_status2);


  // acc11c_3
  // mask  bit
  // 0x01  0    Minikappa OK
  // 0x02  1
  // 0x04  2
  // 0x08  3    Arm Parked

  // acc11c_5
  // mask  bit
  // 0x01  0    Mag Off
  // 0x02  1    Condenser Out
  // 0x04  2    Cryo Back
  // 0x08  3    Dryer On
  // 0x10  4    FluoDet Out
  // 0x20  5
  // 0x40  6    1=SmartMag, 0=Permanent Mag
  //

  if( md2_status\&.acc11c_5 & 0x04)
    mvwprintw( term_status2, 3, 1, '%*s', -8, 'Cryo Out');
  else
    mvwprintw( term_status2, 3, 1, '%*s', -8, 'Cryo In ');

  // acc11c_6
  // mask   bit
  // 0x0080   7   Etel Enable
  // 0x0100   8   Fast Shutter Enable
  // 0x0200   9   Fast Shutter Manual Enable
  // 0x0400  10   Fast Shutter On



  if( md2_status\&.acc11c_5 & 0x02)
    mvwprintw( term_status,  3, 1, '%*s', -(LS_DISPLAY_WINDOW_WIDTH-2), 'Backlight Up');
  else
    mvwprintw( term_status,  3, 1, '%*s', -(LS_DISPLAY_WINDOW_WIDTH-2), 'Backlight Down');

  mvwprintw( term_status, 4, 1, 'Front: %*u', LS_DISPLAY_WINDOW_WIDTH-2-8, (int)flight->position);
  mvwprintw( term_status, 5, 1, 'Back: %*u', LS_DISPLAY_WINDOW_WIDTH-2-7,  (int)blight->position);
  mvwprintw( term_status, 6, 1, 'Piezo: %*u', LS_DISPLAY_WINDOW_WIDTH-2-8, (int)fscint->position);
  wnoutrefresh( term_status);

  wnoutrefresh( term_input);
  doupdate();
  pthread_mutex_unlock( &ncurses_mutex);

  /*
  if( ++cnt % 1000 == 0) {
    gettimeofday( &ts2, NULL);

    lslogging_log_message( 'Refresh Rate: %0\&.1f Hz', 1000000\&.*(cnt)/(ts2\&.tv_sec*1000000 + ts2\&.tv_usec - ts1\&.tv_sec*1000000 - ts1\&.tv_usec));

    cnt = 0;
  }
  */
}
.fi
.SS "void lspmac_GetAllIVars ()"

.PP
Request the values of all the I variables\&. 
.PP
Definition at line 1568 of file lspmac\&.c\&.
.PP
.nf
                          {
  static char *cmds = 'I0\&.\&.8191';
  lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDLINE, 0, 0, strlen( cmds), cmds, lspmac_GetAllIVarsCB, 0);
}
.fi
.SS "void lspmac_GetAllIVarsCB (\fBpmac_cmd_queue_t\fP *cmd, intnreceived, unsigned char *buff)"

.PP
Receive the values of all the I variables Update our Postgresql database with the results\&. \fBParameters:\fP
.RS 4
\fIcmd\fP The command that gave this response 
.br
\fInreceived\fP Number of bytes received 
.br
\fIbuff\fP The byte buffer 
.RE
.PP

.PP
Definition at line 1551 of file lspmac\&.c\&.
.PP
.nf
                            {
  static char qs[LS_PG_QUERY_STRING_LENGTH];
  char *sp;
  int i;
  for( i=0, sp=strtok(buff, '\r'); sp != NULL; sp=strtok( NULL, '\r'), i++) {
    snprintf( qs, sizeof( qs)-1, 'SELECT pmac\&.md2_ivar_set( %d, '%s')', i, sp);
    qs[sizeof( qs)-1]=0;
    lspg_query_push( NULL, qs);
  }
}
.fi
.SS "void lspmac_GetAllMVars ()"

.PP
Request the values of all the M variables\&. 
.PP
Definition at line 1593 of file lspmac\&.c\&.
.PP
.nf
                          {
  static char *cmds = 'M0\&.\&.8191->';
  lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDLINE, 0, 0, strlen( cmds), cmds, lspmac_GetAllMVarsCB, 0);
}
.fi
.SS "void lspmac_GetAllMVarsCB (\fBpmac_cmd_queue_t\fP *cmd, intnreceived, unsigned char *buff)"

.PP
Receive the values of all the M variables Update our database with the results\&. \fBParameters:\fP
.RS 4
\fIcmd\fP The command that started this 
.br
\fInreceived\fP Number of bytes received 
.br
\fIbuff\fP Our byte buffer 
.RE
.PP

.PP
Definition at line 1576 of file lspmac\&.c\&.
.PP
.nf
                            {
  static char qs[LS_PG_QUERY_STRING_LENGTH];
  char *sp;
  int i;
  for( i=0, sp=strtok(buff, '\r'); sp != NULL; sp=strtok( NULL, '\r'), i++) {
    snprintf( qs, sizeof( qs)-1, 'SELECT pmac\&.md2_mvar_set( %d, '%s')', i, sp);
    qs[sizeof( qs)-1]=0;
    lspg_query_push( NULL, qs);
  }
}
.fi
.SS "void lspmac_Getmem ()"

.PP
Request a block of double buffer memory\&. 
.PP
Definition at line 995 of file lspmac\&.c\&.
.PP
.nf
                     {
  int nbytes;
  nbytes = (dbmemIn + 1400 > sizeof( dbmem)) ? sizeof( dbmem) - dbmemIn : 1400;
  lspmac_SockGetmem( dbmemIn, nbytes);
}
.fi
.SS "void lspmac_GetmemReplyCB (\fBpmac_cmd_queue_t\fP *cmd, intnreceived, unsigned char *buff)"

.PP
Service a reply to the getmem command\&. Not currently used\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcmd\fP Queue item this is a reply to 
.br
\fInreceived\fP Number of bytes received 
.br
\fIbuff\fP Buffer of bytes recieved 
.RE
.PP

.PP
Definition at line 926 of file lspmac\&.c\&.
.PP
.nf
                                                                                      {

  memcpy( &(dbmem[ntohs(cmd->pcmd\&.wValue)]), buff, nreceived);

  dbmemIn += nreceived;
  if( dbmemIn >= sizeof( dbmem)) {
    dbmemIn = 0;
  }
}
.fi
.SS "void lspmac_GetShortReplyCB (\fBpmac_cmd_queue_t\fP *cmd, intnreceived, unsigned char *buff)"

.PP
Receive a reply that does not require multiple buffers\&. \fBParameters:\fP
.RS 4
\fIcmd\fP Queue item this is a reply to 
.br
\fInreceived\fP Number of bytes received 
.br
\fIbuff\fP The buffer of bytes 
.RE
.PP

.PP
Definition at line 868 of file lspmac\&.c\&.
.PP
.nf
                              {

  char *sp;     // pointer to the command this is a reply to

  if( nreceived < 1400)
    buff[nreceived]=0;

  sp = (char *)(cmd->pcmd\&.bData);

  if( *buff == 0) {
    pthread_mutex_lock( &ncurses_mutex);
    wprintw( term_output, '%s\n', sp);
    pthread_mutex_unlock( &ncurses_mutex);
  } else {
    pthread_mutex_lock( &ncurses_mutex);
    wprintw( term_output, '%s: ', sp);
    pthread_mutex_unlock( &ncurses_mutex);
    cleanstr( buff);
  }
  wnoutrefresh( term_output);
  wnoutrefresh( term_input);
  doupdate();

  memset( cmd->pcmd\&.bData, 0, sizeof( cmd->pcmd\&.bData));
}
.fi
.SS "void lspmac_home1_queue (\fBlspmac_motor_t\fP *mp)"

.PP
Homing method for steppers and servos\&. \fBParameters:\fP
.RS 4
\fImp\fP motor we are concerned about 
.RE
.PP

.PP
Definition at line 1090 of file lspmac\&.c\&.
.PP
.nf
                         {
  char openloops[32];
  char *sp;
  int i;

  pthread_mutex_lock( &(mp->mutex));

  
  // We got here before the initialization routine finished
  // TODO: arrange to retry or at least indicated we haven't run
  //
  if( (mp->lspg_initialized & 1) == 0) {
    pthread_mutex_unlock( &(mp->mutex));
    return;
  }    


  // Each of the motors should have this defined
  // but let's not seg fault if home is missing
  //
  if( mp->home == NULL || *(mp->home) == NULL) {
    //
    // Note we are already initialized
    // so if we are here there is something wrong\&.
    // TODO: log this event
    pthread_mutex_unlock( &(mp->mutex));
    return;
  }

  // We've already been called\&.  Don't home again until
  // we're finish with the last time\&.
  //
  if( mp->homing) {
    pthread_mutex_unlock( &(mp->mutex));
    return;
  }    


  //
  // Don't go on if any other motors in this coordinate system are homing\&.
  // It's possible to write the homing program to home all the motors in the coordinate
  // system\&.
  //
  if( mp->coord_num > 0) {
    for( i=0; i<lspmac_nmotors; i++) {
      if( &(lspmac_motors[i]) == mp)
        continue;
      if( lspmac_motors[i]\&.coord_num == mp->coord_num) {
        if( lspmac_motors[i]\&.homing) {
          pthread_mutex_unlock( &(mp->mutex));
          return;
        }
      }
    }
  }
  mp->homing = 1;
       
  // This opens the control loop\&.
  // The status routine should notice this and the fact that
  // the homing flag is set and call on the home2 routine
  //
  // Only send the open loop command if we are not in
  // open loop mode already\&.  This test might prevent a race condition
  // where we've already moved the home2 routine (and queue the homing program motion)
  // before the open loop command is dequeued and acted on\&.
  //
  if( ~(mp->status1) & 0x040000) {
    snprintf( openloops, sizeof(openloops)-1, '#%d$*', mp->motor_num);
    openloops[sizeof(openloops)-1] = 0;
    lspmac_SockSendline( openloops);
  }

  pthread_mutex_unlock( &(mp->mutex));
}
.fi
.SS "void lspmac_home2_queue (\fBlspmac_motor_t\fP *mp)"

.PP
Second stage of homing\&. \fBParameters:\fP
.RS 4
\fImp\fP motor we are concerned about 
.RE
.PP

.PP
Definition at line 1170 of file lspmac\&.c\&.
.PP
.nf
                         {

  char **spp;

  //
  // At this point we are in open loop\&.
  // Run the motor specific commands
  //

  pthread_mutex_lock( &(mp->mutex));
  //
  // We don't have any motors that have a null home text array so 
  // there is currently no need to worry about this case other than
  // not to seg fault
  //
  // Also, Only go on if the first homing phase has been started
  //
  if( mp->home == NULL || mp->homing != 1) {
    pthread_mutex_unlock( &(mp->mutex));
    return;
  }

  for( spp = mp->home; *spp != NULL; spp++) {

    pthread_mutex_lock( &ncurses_mutex);
    wprintw( term_output, 'home2 is queuing '%s'\n', *spp);
    wnoutrefresh( term_output);
    doupdate();
    pthread_mutex_unlock( &ncurses_mutex);

    lspmac_SockSendline( *spp);
  }

  mp->homing = 2;
  pthread_mutex_unlock( &(mp->mutex));
  
}
.fi
.SS "void lspmac_init (intivarsflag, intmvarsflag)"

.PP
Initialize this module\&. \fBParameters:\fP
.RS 4
\fIivarsflag\fP Set global flag to harvest i variables 
.br
\fImvarsflag\fP Set global flag to harvest m variables 
.RE
.PP

.PP
Definition at line 2226 of file lspmac\&.c\&.
.PP
.nf
                   {
  md2_status_t *p;

  // Set our global harvest flags
  getivars = ivarsflag;
  getmvars = mvarsflag;

  // All important status mutex
  pthread_mutex_init( &md2_status_mutex, NULL);

  //
  // Initialize the motor objects
  //

  p = &md2_status;

  omega  = lspmac_motor_init( &(lspmac_motors[ 0]),  1, 0, 0, &p->omega_act_pos,     &p->omega_status_1,     &p->omega_status_2,     'Omega   #1 &1 X', 'omega',       lspmac_moveabs_queue);
  alignx = lspmac_motor_init( &(lspmac_motors[ 1]),  2, 0, 1, &p->alignx_act_pos,    &p->alignx_status_1,    &p->alignx_status_2,    'Align X #2 &3 X', 'align\&.x',     lspmac_moveabs_queue);
  aligny = lspmac_motor_init( &(lspmac_motors[ 2]),  3, 0, 2, &p->aligny_act_pos,    &p->aligny_status_1,    &p->aligny_status_2,    'Align Y #3 &3 Y', 'align\&.y',     lspmac_moveabs_queue);
  alignz = lspmac_motor_init( &(lspmac_motors[ 3]),  4, 0, 3, &p->alignz_act_pos,    &p->alignz_status_1,    &p->alignz_status_2,    'Align Z #4 &3 Z', 'align\&.z',     lspmac_moveabs_queue);
  anal   = lspmac_motor_init( &(lspmac_motors[ 4]),  5, 0, 4, &p->analyzer_act_pos,  &p->analyzer_status_1,  &p->analyzer_status_2,  'Anal    #5',      'lightPolar',  lspmac_moveabs_queue);
  zoom   = lspmac_motor_init( &(lspmac_motors[ 5]),  6, 1, 0, &p->zoom_act_pos,      &p->zoom_status_1,      &p->zoom_status_2,      'Zoom    #6 &4 Z', 'zoom',        lspmac_movezoom_queue);
  apery  = lspmac_motor_init( &(lspmac_motors[ 6]),  7, 1, 1, &p->aperturey_act_pos, &p->aperturey_status_1, &p->aperturey_status_2, 'Aper Y  #7 &5 Y', 'appy',        lspmac_moveabs_queue);
  aperz  = lspmac_motor_init( &(lspmac_motors[ 7]),  8, 1, 2, &p->aperturez_act_pos, &p->aperturez_status_1, &p->aperturez_status_2, 'Aper Z  #8 &5 Z', 'appz',        lspmac_moveabs_queue);
  capy   = lspmac_motor_init( &(lspmac_motors[ 8]),  9, 1, 3, &p->capy_act_pos,      &p->capy_status_1,      &p->capy_status_2,      'Cap Y   #9 &5 U', 'capy',        lspmac_moveabs_queue);
  capz   = lspmac_motor_init( &(lspmac_motors[ 9]), 10, 1, 4, &p->capz_act_pos,      &p->capz_status_1,      &p->capz_status_2,      'Cap Z  #10 &5 V', 'capz',        lspmac_moveabs_queue);
  scint  = lspmac_motor_init( &(lspmac_motors[10]), 11, 2, 0, &p->scint_act_pos,     &p->scint_status_1,     &p->scint_status_2,     'Scin Z #11 &5 W', 'scint',       lspmac_moveabs_queue);
  cenx   = lspmac_motor_init( &(lspmac_motors[11]), 17, 2, 1, &p->centerx_act_pos,   &p->centerx_status_1,   &p->centerx_status_2,   'Cen X  #17 &2 X', 'centering\&.x', lspmac_moveabs_queue);
  ceny   = lspmac_motor_init( &(lspmac_motors[12]), 18, 2, 2, &p->centery_act_pos,   &p->centery_status_1,   &p->centery_status_2,   'Cen Y  #18 &2 Y', 'centering\&.y', lspmac_moveabs_queue);
  kappa  = lspmac_motor_init( &(lspmac_motors[13]), 19, 2, 3, &p->kappa_act_pos,     &p->kappa_status_1,     &p->kappa_status_2,     'Kappa  #19 &7 X', 'kappa',       lspmac_moveabs_queue);
  phi    = lspmac_motor_init( &(lspmac_motors[14]), 20, 2, 4, &p->phi_act_pos,       &p->phi_status_1,       &p->phi_status_2,       'Phi    #20 &7 Y', 'phi',         lspmac_moveabs_queue);

  fshut  = lspmac_fshut_init( &(lspmac_motors[15]));
  flight = lspmac_dac_init( &(lspmac_motors[16]), &p->front_dac,   160\&.0, 'M1200', 'frontLight\&.intensity');
  blight = lspmac_dac_init( &(lspmac_motors[17]), &p->back_dac,    160\&.0, 'M1201', 'backLight\&.intensity');
  fscint = lspmac_dac_init( &(lspmac_motors[18]), &p->scint_piezo, 320\&.0, 'M1203', 'scint\&.focus');

  blight_ud = lspmac_bo_init( &(lspmac_motors[19]), 'backLight', 'M1101=%d', &(md2_status\&.acc11c_5), 0x02);
  cryo      = lspmac_bo_init( &(lspmac_motors[20]), 'cryo',      'M1102=%d', &(md2_status\&.acc11c_5), 0x04);
  dryer     = lspmac_bo_init( &(lspmac_motors[21]), 'dryer',     'M1103=%d', &(md2_status\&.acc11c_5), 0x08);
  fluo      = lspmac_bo_init( &(lspmac_motors[22]), 'fluo',      'M1008=%d', &(md2_status\&.acc11c_2), 0x01);

  cryo_switch = lspmac_bi_init( &(lspmac_bis[0]), &(md2_status\&.acc11c_1), 0x04, 'CryoSwitchChanged', 'CryoSwitchChanged');


  //
  // Initialize several commands that get called, perhaps, alot
  //
  rr_cmd\&.RequestType = VR_UPLOAD;
  rr_cmd\&.Request     = VR_PMAC_READREADY;
  rr_cmd\&.wValue      = 0;
  rr_cmd\&.wIndex      = 0;
  rr_cmd\&.wLength     = htons(2);
  memset( rr_cmd\&.bData, 0, sizeof(rr_cmd\&.bData));

  gb_cmd\&.RequestType = VR_UPLOAD;
  gb_cmd\&.Request     = VR_PMAC_GETBUFFER;
  gb_cmd\&.wValue      = 0;
  gb_cmd\&.wIndex      = 0;
  gb_cmd\&.wLength     = htons(1400);
  memset( gb_cmd\&.bData, 0, sizeof(gb_cmd\&.bData));

  cr_cmd\&.RequestType = VR_UPLOAD;
  cr_cmd\&.Request     = VR_CTRL_RESPONSE;
  cr_cmd\&.wValue      = 0;
  cr_cmd\&.wIndex      = 0;
  cr_cmd\&.wLength     = htons(1400);
  memset( cr_cmd\&.bData, 0, sizeof(cr_cmd\&.bData));

  //
  // Initialize some mutexs and conditions
  //

  pthread_mutex_init( &pmac_queue_mutex, NULL);
  pthread_cond_init(  &pmac_queue_cond, NULL);

  lspmac_shutter_state = 0;                             // assume the shutter is now closed: not a big deal if we are wrong
  pthread_mutex_init( &lspmac_shutter_mutex, NULL);
  pthread_cond_init(  &lspmac_shutter_cond, NULL);
  pmacfd\&.fd = -1;

  pthread_mutex_init( &lspmac_moving_mutex, NULL);
  pthread_cond_init(  &lspmac_moving_cond, NULL);

}
.fi
.SS "double lspmac_lut (intnlut, double *lut, doublex)"

.PP
Look up table support for motor positions (think x=zoom, y=light intensity) use a lookup table to find the 'counts' to move the motor to the requested position The look up table is a simple one dimensional array with the x values as even indicies and the y values as odd indices\&. Returns: y value \fBParameters:\fP
.RS 4
\fInlut\fP number of entries in lookup table 
.br
\fIlut\fP The lookup table: even indicies are the x values, odd are the y's 
.br
\fIx\fP The x value we are looking up\&. 
.RE
.PP

.PP
Definition at line 300 of file lspmac\&.c\&.
.PP
.nf
                    {
  int i, foundone;
  double m;
  double y1, y2, x1, x2, y;

  foundone = 0;
  if( lut != NULL && nlut > 1) {
    for( i=0; i < 2*nlut; i += 2) {
      x1 = lut[i];
      y1 = lut[i+1];
      if( i < 2*nlut - 2) {
        x2 = lut[i+2];
        y2 = lut[i+3];
      }

      //
      // First one too big?  Use the y value of the first element
      //
      if( i == 0 && x1 > x) {
        y = y1;
        foundone = 1;
        break;
      }

      //
      // Look for equality
      //
      if( x1 == x) {
        y = y1;
        foundone = 1;
        break;
      }

      //
      // Maybe interpolate
      //
      if( (i < 2*nlut-2) && x < x2) {
        m = (y2 - y1) / (x2 - x1);
        y = m*(x - x1) + y1;
        foundone = 1;
        break;
      }
    }
    if( foundone == 0) {
      // must be bigger than the last entry
      //
      //
      y = lut[2*(nlut-1) + 1];
    }
    return y;
  }
  return 0\&.0;
}
.fi
.SS "\fBlspmac_motor_t\fP* lspmac_motor_init (\fBlspmac_motor_t\fP *d, intmotor_number, intwy, intwx, int *posp, int *stat1p, int *stat2p, char *wtitle, char *name, void(*)(\fBlspmac_motor_t\fP *, double)moveAbs)"

.PP
Initialize a pmac stepper or servo motor\&. \fBParameters:\fP
.RS 4
\fId\fP An uninitialize motor object 
.br
\fImotor_number\fP The PMAC motor number 
.br
\fIwy\fP Curses status window row index 
.br
\fIwx\fP Curses status window column index 
.br
\fIposp\fP Pointer to position status 
.br
\fIstat1p\fP Pointer to 1st status word 
.br
\fIstat2p\fP Pointer to 2nd status word 
.br
\fIwtitle\fP Title for this motor (to display) 
.br
\fIname\fP Name of this motor (to match database) 
.br
\fImoveAbs\fP Method to use to move this motor 
.RE
.PP

.PP
Definition at line 2068 of file lspmac\&.c\&.
.PP
.nf
                                    {
  lspmac_nmotors++;

  pthread_mutex_init( &(d->mutex), NULL);
  pthread_cond_init(  &(d->cond), NULL);

  lskvs_regcomp( &(d->preset_regex), REG_EXTENDED, LSPMAC_PRESET_REGEX, name);

  d->presets             = NULL;
  d->name                = strdup(name);
  d->moveAbs             = moveAbs;
  d->read                = lspmac_pmacmotor_read;
  d->lut                 = NULL;
  d->nlut                = 0;
  d->actual_pos_cnts_p   = posp;
  d->status1_p           = stat1p;
  d->status2_p           = stat2p;
  d->motor_num           = motor_number;
  d->dac_mvar            = NULL;
  d->win = newwin( LS_DISPLAY_WINDOW_HEIGHT, LS_DISPLAY_WINDOW_WIDTH, wy*LS_DISPLAY_WINDOW_HEIGHT, wx*LS_DISPLAY_WINDOW_WIDTH);
  box( d->win, 0, 0);
  mvwprintw( d->win, 1, 1, '%s', wtitle);
  wnoutrefresh( d->win);
  d->homing              = 0;
  d->lspg_initialized    = 0;

  return d;
}
.fi
.SS "void lspmac_move_preset_queue (\fBlspmac_motor_t\fP *mp, char *name)"

.PP
Move a given motor to one of its preset positions\&. No movement if the preset is not found\&. 
.PP
\fBParameters:\fP
.RS 4
\fImp\fP lspmac motor pointer 
.br
\fIname\fP Name of the preset to use 
.RE
.PP
< 0 = stns\&.2\&.appy\&.preset, for example, 1 = index, 2 = 'position' or 'name'
.PP
< 0 = stns\&.2\&.appy\&.preset, for example, 1 = index, 2 = 'position' or 'name' 
.PP
Definition at line 1859 of file lspmac\&.c\&.
.PP
.nf
                                                               {
  lskvs_kvs_list_t *q, *r;
  regmatch_t q_pmatch[4];       
  regmatch_t r_pmatch[4];       
  double pos;

  lslogging_log_message( 'lspmac_move_preset_queue: Called with motor %s and preset named '%s'', mp->name, name);

  //
  // This checks both the '\&.name' and the '\&.position' entries
  // but as long as no one gives names like '1\&.23' to their presets
  // we should be OK\&.
  //
  for( q=mp->presets; q != NULL; q = q->next) {
    if( strcmp( name, q->kvs->v) == 0)
      break;
  }
  if( q == NULL) {
    lslogging_log_message( 'lspmac_move_preset_queue: no preset named %s found for motor %s', name, mp->name);
    return;
  }
  if( regexec( &(mp->preset_regex), q->kvs->k, 4, q_pmatch, 0) != 0 || q_pmatch[2]\&.rm_so == -1 || q_pmatch[2]\&.rm_eo == -1) {
    lslogging_log_message( 'lspmac_move_preset_queue: Could not parse %s (q)', q->kvs->k);
    return;
  }
  
  //
  // find the position entry\&.  Note we are assuming that we've already found the name and only the position is left with the sample index
  //
  for( r=mp->presets; r != NULL; r = r->next) {
    if( r == q)
      continue;
    if( regexec( &(mp->preset_regex), r->kvs->k, 4, r_pmatch, 0) != 0 || r_pmatch[2]\&.rm_so == -1 || r_pmatch[2]\&.rm_eo == -1) {
      lslogging_log_message( 'lspmac_move_preset_queue: Could not parse %s (r)', r->kvs->k);
      return;
    }

    //
    // Make sure everything matches up to (and through) the array index
    //
    if( strncmp( q->kvs->k, r->kvs->k, q_pmatch[2]\&.rm_eo + 1) == 0) {
      break;
    }
  }

  if( r == NULL) {
    lslogging_log_message( 'lspmac_move_preset_queue: Could not find position for preset '%s' for motor '%s'', name, mp->name);
    return;
  }

  errno = 0;
  pos = strtod( r->kvs->v, NULL);
  if( errno != 0) {
    lslogging_log_message( 'lspmac_move_preset_queue: Could not parse preset position '%s' for motor '%s'', r->kvs->v, mp->name);
    return;
  }
  mp->moveAbs( mp, pos);
  lslogging_log_message( 'lspmac_move_preset_queue: moving %s to preset '%s' (%f)', mp->name, name, pos);
}
.fi
.SS "void lspmac_moveabs_bo_queue (\fBlspmac_motor_t\fP *mp, doublerequested_position)"

.PP
Move method for binary i/o motor objects\&. \fBParameters:\fP
.RS 4
\fImp\fP A binary i/o motor object 
.br
\fIrequested_position\fP a 1 or a 0 request to move 
.RE
.PP

.PP
Definition at line 1953 of file lspmac\&.c\&.
.PP
.nf
                                {


  pthread_mutex_lock( &(mp->mutex));
  mp->requested_position = requested_position == 0\&.0 ? 0\&.0 : 1\&.0;
  mp->requested_pos_cnts = requested_position == 0\&.0 ? 0 : 1;

  mp->not_done    = 1;
  mp->motion_seen = 0;
  mp->pq = lspmac_SockSendline_nr( mp->write_fmt, mp->requested_pos_cnts);


  pthread_mutex_unlock( &(mp->mutex));

  if( mp == blight_ud) {
    if( requested_position == 0) {
      lspmac_movedac_queue( blight, 0);
    } else {
      pthread_mutex_lock( &(zoom->mutex));
      lspmac_movedac_queue( blight, zoom->position);
      pthread_mutex_unlock( &(zoom->mutex));
    }
  }
}
.fi
.SS "void lspmac_moveabs_fshut_queue (\fBlspmac_motor_t\fP *mp, doublerequested_position)"

.PP
Move method for the fast shutter\&. Slightly more complicated than a binary io as some flags need to be set up\&. \fBParameters:\fP
.RS 4
\fImp\fP The fast shutter motor instance 
.br
\fIrequested_position\fP 1 (open) or 0 (close), really 
.RE
.PP

.PP
Definition at line 1926 of file lspmac\&.c\&.
.PP
.nf
                                  {
  pthread_mutex_lock( &(mp->mutex));

  mp->requested_position = requested_position;
  mp->not_done    = 1;
  mp->motion_seen = 0;
  mp->requested_pos_cnts = requested_position;
  if( requested_position != 0) {
    //
    // ScanEnable=0, ManualEnable=1, ManualOn=1
    //
    mp->pq = lspmac_SockSendline_nr( 'M1124=0 M1125=1 M1126=1');
  } else {
    //
    // ManualOn=0, ManualEnable=0, ScanEnable=1
    //
    mp->pq = lspmac_SockSendline_nr( 'M1126=0 M1125=0 M1124=1');
  }

  pthread_mutex_unlock( &(mp->mutex));
}
.fi
.SS "void lspmac_moveabs_queue (\fBlspmac_motor_t\fP *mp, doublerequested_position)"

.PP
Move method for normal stepper and servo motor objects\&. \fBParameters:\fP
.RS 4
\fImp\fP The motor to move 
.br
\fIrequested_position\fP Where to move it 
.RE
.PP

.PP
Definition at line 1984 of file lspmac\&.c\&.
.PP
.nf
                            {
  char s[512];

  pthread_mutex_lock( &(mp->mutex));
  mp->requested_position = requested_position;
  if( mp->u2c != 0\&.0) {
    mp->not_done    = 1;
    mp->motion_seen = 0;
    mp->requested_pos_cnts = mp->u2c * requested_position;  
    snprintf( s, sizeof(s)-1, '#%d j=%d', mp->motor_num, mp->requested_pos_cnts);
    mp->pq = lspmac_SockSendline_nr( s);
  }
  pthread_mutex_unlock( &(mp->mutex));
}
.fi
.SS "void lspmac_moveabs_wait (\fBlspmac_motor_t\fP *mp)"

.PP
Wait for motor to finish moving\&. Assume motion already queued, now just wait \fBParameters:\fP
.RS 4
\fImp\fP The motor object to wait for 
.RE
.PP

.PP
Definition at line 2007 of file lspmac\&.c\&.
.PP
.nf
                           {
  struct timespec wt;
  int return_code;

  pthread_mutex_lock( &pmac_queue_mutex);

  //
  // wait for the command to be sent
  //
  while( mp->pq->time_sent\&.tv_sec==0)
    pthread_cond_wait( &pmac_queue_cond, &pmac_queue_mutex);

  //
  // set the timeout to be long enough after we sent the motion request to ensure that
  // we will have read back the motor moving status but not so long that the timeout causes
  // problems;
  //
  wt\&.tv_sec  = mp->pq->time_sent\&.tv_sec;
  wt\&.tv_nsec = mp->pq->time_sent\&.tv_nsec + 500000000;

  pthread_mutex_unlock( &pmac_queue_mutex);

  if( wt\&.tv_nsec >= 1000000000) {
    wt\&.tv_nsec -= 1000000000;
    wt\&.tv_sec += 1;
  }

  //
  // wait for the motion to have started
  // This will time out if the motion ends before we can read the status back
  // hence the added complication of time stamp of the sent packet\&.
  //

  return_code=0;

  pthread_mutex_lock( &(mp->mutex));
  while( mp->motion_seen == 0 && return_code == 0)
    return_code = pthread_cond_timedwait( &(mp->cond), &(mp->mutex), &wt);

  if( return_code == 0) {
    //
    // wait for the motion that we know has started to finish
    //
    while( mp->not_done)
      pthread_cond_wait( &(mp->cond), &(mp->mutex));

  }

  //
  // if return code was not 0 then we know we shouldn't wait for not_done flag\&.
  // In this case the motion ended before we read the status that should the motor moving\&.
  //
  pthread_mutex_unlock( &(mp->mutex));

}
.fi
.SS "void lspmac_movedac_queue (\fBlspmac_motor_t\fP *mp, doublerequested_position)"

.PP
Move method for dac motor objects (ie, lights) \fBParameters:\fP
.RS 4
\fImp\fP Our motor 
.br
\fIrequested_position\fP Desired x postion (look up and send y position) 
.RE
.PP

.PP
Definition at line 1782 of file lspmac\&.c\&.
.PP
.nf
                            {
  char s[512];
  double y;

  pthread_mutex_lock( &(mp->mutex));

  mp->requested_position = requested_position;

  if( mp->nlut > 0 && mp->lut != NULL) {
    mp->requested_pos_cnts = lspmac_lut( mp->nlut, mp->lut, requested_position);
    mp->not_done    = 1;
    mp->motion_seen = 0;


    //
    //  By convention requested_pos_cnts scales from 0 to 100
    //  for the lights u2c converts this to 0 to 16,000
    //  for the scintilator focus this is   0 to 32,000
    //
    snprintf( s, sizeof(s)-1, '%s=%d', mp->dac_mvar, mp->requested_pos_cnts);
    mp->pq = lspmac_SockSendline_nr( s);

  }

  pthread_mutex_unlock( &(mp->mutex));
}
.fi
.SS "void lspmac_movezoom_queue (\fBlspmac_motor_t\fP *mp, doublerequested_position)"

.PP
Move method for the zoom motor\&. \fBParameters:\fP
.RS 4
\fImp\fP the zoom motor 
.br
\fIrequested_position\fP our desired zoom 
.RE
.PP

.PP
Definition at line 1815 of file lspmac\&.c\&.
.PP
.nf
                             {
  char s[512];
  double y;
  int blud;
  pthread_mutex_lock( &(mp->mutex));

  mp->requested_position = requested_position;

  if( mp->nlut > 0 && mp->lut != NULL) {
    y = lspmac_lut( mp->nlut, mp->lut, requested_position);

    mp->requested_pos_cnts = (int)y;
    mp->not_done    = 1;
    mp->motion_seen = 0;


    snprintf( s, sizeof(s)-1, '#%d j=%d', mp->motor_num, mp->requested_pos_cnts);
    mp->pq = lspmac_SockSendline_nr( s);

  }
  pthread_mutex_unlock( &(mp->mutex));

  //
  // the lights should 'move' with the zoom motor
  //
  lspmac_movedac_queue( flight, requested_position);

  pthread_mutex_lock( &(blight_ud->mutex));
  blud = blight_ud->position;
  pthread_mutex_unlock( &(blight_ud->mutex));

  if( blud > 0) {
    lspmac_movedac_queue( blight, requested_position);
  }
}
.fi
.SS "void lspmac_newKV_cb (char *event)"

.PP
Definition at line 2360 of file lspmac\&.c\&.
.PP
.nf
                                   {
  lspmac_motor_t   *d;
  lskvs_kvs_t      *p;
  lskvs_kvs_list_t *q;
  lskvs_kvs_list_t *r;
  int i;

  pthread_rwlock_rdlock( &lskvs_rwlock);
  p = lskvs_kvs;
  pthread_rwlock_unlock( &lskvs_rwlock);  

  while( p != NULL) {
    for( i=0; i<lspmac_nmotors; i++) {
      d = &(lspmac_motors[i]);

      if( regexec( &(d->preset_regex), p->k, 0, NULL, 0) == 0) {
        for( q = d->presets; q != NULL; q = q->next)
          if( strcmp( q->kvs->k, p->k) == 0)
            break;
        if( q == NULL) {
          //
          // We don't know about this preset yet\&.  Add it to our list\&.
          //
          r = calloc( 1, sizeof( *r));
          if( r == NULL) {
            lslogging_log_message( 'lspmac_newKV_cb: Out of memory for kv %s', p->k);
            exit( -1);
          }
          r->kvs = p;
          pthread_mutex_lock( &(d->mutex));
          r->next    = d->presets;
          d->presets = r;
          pthread_mutex_unlock( &(d->mutex));
          lslogging_log_message( 'lspmac_newKV_cb: added '%s' with value '%s' to motor '%s'', p->k, p->v, d->name);
        }
      }
    }
    p = p->next;
  }
}
.fi
.SS "void lspmac_next_state ()"

.PP
State machine logic\&. Given the current state, generate the next one 
.PP
Definition at line 1641 of file lspmac\&.c\&.
.PP
.nf
                         {


  //
  // Connect to the pmac and perhaps initialize it\&.
  // OK, this is slightly more than just the state
  // machine logic\&.\&.\&.
  //
  if( ls_pmac_state == LS_PMAC_STATE_DETACHED) {
    //
    // TODO (eventually)
    // This ip address wont change in a single PMAC installation
    // We'll need to audit the code if we decide to implement
    // multiple PMACs so might as well wait til then\&.
    //
    lsConnect( '192\&.6\&.94\&.5');

    //
    // If the connect was successful we can proceed with the initialization
    //
    if( ls_pmac_state != LS_PMAC_STATE_DETACHED) {
      lspmac_SockFlush();
      
      //
      // Harvest the I and M variables in case we need them
      // one day\&.
      //
      if( getmvars) {
        lspmac_GetAllMVars();
        getmvars = 0;
      }
      
      if( getivars) {
        lspmac_GetAllIVars();
        getivars = 0;
      }
    }
  }

  //
  // Check the command queue and perhaps go to the 'Send Command' state\&.
  //
  if( ls_pmac_state == LS_PMAC_STATE_IDLE && ethCmdOn != ethCmdOff)
    ls_pmac_state = LS_PMAC_STATE_SC;


  //
  // Set the events flag
  // to tell poll what we are waiting for\&.
  //
  switch( ls_pmac_state) {
  case LS_PMAC_STATE_DETACHED:
    //
    // there shouldn't be a valid fd, so ignore the events
    //
    pmacfd\&.events = 0;
    break;

  case LS_PMAC_STATE_IDLE:
    if( ethCmdOn == ethCmdOff) {
      //
      // Anytime we are idle we want to
      // get the status of the PMAC
      //

      lspmac_get_status();
    }



  //
  // These state require that we listen for packets
  //
  case LS_PMAC_STATE_WACK_NFR:
  case LS_PMAC_STATE_WACK:
  case LS_PMAC_STATE_WACK_CC:
  case LS_PMAC_STATE_WACK_RR:
  case LS_PMAC_STATE_WCR:
  case LS_PMAC_STATE_WGB:
  case LS_PMAC_STATE_GMR:
    pmacfd\&.events = POLLIN;
    break;
    
  //
  // These state require that we send packets out\&.
  //
  case LS_PMAC_STATE_SC:
  case LS_PMAC_STATE_CR:
  case LS_PMAC_STATE_RR:
  case LS_PMAC_STATE_GB:
    //
    // Sad fact: PMAC will fail to process commands if we send them too quickly\&.
    // We deal with that by waiting a tad before we let poll tell us the PMAC socket is ready to write\&.
    //
    gettimeofday( &now, NULL);
    if(  ((now\&.tv_sec * 1000000\&. + now\&.tv_usec) - (pmac_time_sent\&.tv_sec * 1000000\&. + pmac_time_sent\&.tv_usec)) < PMAC_MIN_CMD_TIME) {
      pmacfd\&.events = 0;
    } else {
      pmacfd\&.events = POLLOUT;
    }
    break;
  }
}
.fi
.SS "void lspmac_pmacmotor_read (\fBlspmac_motor_t\fP *mp)"

.PP
Read the position and status of a normal PMAC motor\&. \fBParameters:\fP
.RS 4
\fImp\fP Our motor 
.RE
.PP

.PP
Definition at line 1212 of file lspmac\&.c\&.
.PP
.nf
                             {
  char s[512], *sp;
  int homing1, homing2;

  pthread_mutex_lock( &(mp->mutex));

  //
  // if this time and last time were both 'in position'
  // and the position changed significantly then log the event
  //
  // On E omega has been observed to change by 0x10000 on its own
  // with no real motion\&.
  //
  if( mp->status2 & 1 && mp->status2 == *mp->status2_p && abs( mp->actual_pos_cnts - *mp->actual_pos_cnts_p) > 256) {
    //    lslogging_log_message( 'Instantaneous change: %s old status1: %0x, new status1: %0x, old status2: %0x, new status2: %0x, old cnts: %0x, new cnts: %0x',
    //                     mp->name, mp->status1, *mp->status1_p, mp->status2, *mp->status2_p, mp->actual_pos_cnts, *mp->actual_pos_cnts_p);

    //
    // At this point we'll just log the event and return
    // There is no reason to believe the change is real\&.
    //
    // There is a non-zero probability that the first value is the bad one and any value afterwards will be taken as
    // wrong\&.  Homing (or moving) the motor should fix this\&.  There is a non-zero probably that it can happen
    // two or more times in a row after moving\&.
    //
    // TODO: account for the case where mp->actual_pos_cnts is the bad value\&.
    //
    // TODO: Is this a problem when the motor is moving?  Can we detect it?
    //
    // TODO: Think of the correct change value here (currently 256) that works for all motors
    // or have this value configurable
    //
    pthread_mutex_unlock( &(mp->mutex));
    return;
  }


  // Send an event if inPosition has changed
  //
  if( (mp->status2 & 0x000001) != (*mp->status2_p & 0x000001)) {
    lsevents_send_event( '%s %s', mp->name, (*mp->status2_p & 0x000001) ? 'In Position' : 'Moving');
  }

  // Make local copies so we can inspect them in other threads
  // without having to grab the status mutex
  //

  mp->status1 = *mp->status1_p;
  mp->status2 = *mp->status2_p;
  mp->actual_pos_cnts = *mp->actual_pos_cnts_p;

  //
  // See if we are done moving, ie, in position
  //
  if( mp->status2 & 0x000001) {
    if( mp->not_done) {
      mp->not_done = 0;
      pthread_cond_signal( &(mp->cond));
    }
  } else if( mp->not_done == 0) {
    mp->not_done = 1;
  }

  //
  // See if homed or desired velocity zero
  // TODO: What's going on here?  Does this logic do anything interesting?
  //
  if( mp->status1 & 0x020000 || mp->status1 & 0x000400) {
    if( mp->motion_seen == 0) {
      mp->motion_seen = 1;
      pthread_cond_signal( &(mp->cond));
    }
  }

  mvwprintw( mp->win, 2, 1, '%*s', LS_DISPLAY_WINDOW_WIDTH-2, ' ');
  mvwprintw( mp->win, 2, 1, '%*d cts', LS_DISPLAY_WINDOW_WIDTH-6, mp->actual_pos_cnts);
  mvwprintw( mp->win, 3, 1, '%*s', LS_DISPLAY_WINDOW_WIDTH-2, ' ');

  if( mp->nlut >0 && mp->lut != NULL) {
    mp->position = lspmac_rlut( mp->nlut, mp->lut, mp->actual_pos_cnts);
  } else {
    if( mp->u2c != 0\&.0) {
      mp->position = mp->actual_pos_cnts / mp->u2c;
    } else {
      mp->position = mp->actual_pos_cnts;
    }
  }
  snprintf( s, sizeof(s)-1, mp->format, 8, mp->position);

  // set flag if we are not homed
  homing1 = 0;
  //                        ~(homed flag)
  if( mp->homing == 0  && (~mp->status2 & 0x000400) != 0) {
    homing1 = 1;
  }

  // set flag if we are homing and in open loop
  homing2 = 0;
  //                         open loop
  if( mp->homing == 1 && (mp->status1 & 0x040000) != 0) {
    homing2 = 1;
  }
  // maybe reset homing flag
  //                        homed flag                       in position flag
  if( mp->homing == 2 && (mp->status2 & 0x000400 != 0) && (mp->status2 & 0x000001 != 0))
    mp->homing = 0;


  s[sizeof(s)-1] = 0;
  mvwprintw( mp->win, 3, 1, '%*s', LS_DISPLAY_WINDOW_WIDTH-6, s);

  mvwprintw( mp->win, 4, 1, '%*x', LS_DISPLAY_WINDOW_WIDTH-2, mp->status1);
  mvwprintw( mp->win, 5, 1, '%*x', LS_DISPLAY_WINDOW_WIDTH-2, mp->status2);
  sp = '';
  if( mp->status2 & 0x000002)
    sp = 'Following Warning';
  else if( mp->status2 & 0x000004)
    sp = 'Following Error';
  else if( mp->status2 & 0x000020)
    sp = 'I2T Amp Fault';
  else if( mp->status2 & 0x000008)
    sp = 'Amp\&. Fault';
  else if( mp->status2 & 0x000800)
    sp = 'Stopped on Limit';
  else if( mp->status1 & 0x040000)
    sp = 'Open Loop';
  else if( ~(mp->status1) & 0x080000)
    sp = 'Motor Disabled';
  else if( mp->status1 & 0x000400)
    sp = 'Homing';
  else if( (mp->status1 & 0x600000) == 0x600000)
    sp = 'Both Limits Tripped';
  else if( mp->status1 & 0x200000)
    sp = 'Positive Limit';
  else if( mp->status1 & 0x400000)
    sp = 'Negative Limit';
  else if( ~(mp->status2) & 0x000400)
    sp = 'Not Homed';
  else if( mp->status2 & 0x000001)
    sp = 'In Position';

  mvwprintw( mp->win, 6, 1, '%*s', LS_DISPLAY_WINDOW_WIDTH-2, sp);
  wnoutrefresh( mp->win);
  
  strncpy( mp->statuss, sp, sizeof( mp->statuss)-1);
  mp->statuss[sizeof(mp->statuss)-1] = 0;

  pthread_mutex_unlock( &(mp->mutex));

  if( homing1)
    lspmac_home1_queue( mp);

  if( homing2)
    lspmac_home2_queue( mp);

}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_pop_queue ()"

.PP
Remove the oldest queue item\&. Used to send command to PMAC\&. Note that there is a separate reply index to ensure we've know to what command a reply is refering\&. Returns the item\&. 
.PP
Definition at line 546 of file lspmac\&.c\&.
.PP
.nf
                                     {
  pmac_cmd_queue_t *rtn;

  pthread_mutex_lock( &pmac_queue_mutex);

  if( ethCmdOn == ethCmdOff)
    rtn = NULL;
  else {
    rtn = &(ethCmdQueue[(ethCmdOff++) % PMAC_CMD_QUEUE_LENGTH]);
    clock_gettime( CLOCK_REALTIME, &(rtn->time_sent));
  }
  pthread_mutex_unlock( &pmac_queue_mutex);
  return rtn;
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_pop_reply ()"

.PP
Remove the next command queue item that is waiting for a reply\&. We always need a reply to know we are done with a given command\&. Returns the item\&. 
.PP
Definition at line 566 of file lspmac\&.c\&.
.PP
.nf
                                     {
  pmac_cmd_queue_t *rtn;

  pthread_mutex_lock( &pmac_queue_mutex);

  if( ethCmdOn == ethCmdReply)
    rtn = NULL;
  else
    rtn = &(ethCmdQueue[(ethCmdReply++) % PMAC_CMD_QUEUE_LENGTH]);

  pthread_mutex_unlock( &pmac_queue_mutex);
  return rtn;
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_push_queue (\fBpmac_cmd_queue_t\fP *cmd)"

.PP
Put a new command on the queue\&. Pointer is returned so caller can evaluate the time command was actually sent\&. \fBParameters:\fP
.RS 4
\fIcmd\fP Command to send to the PMAC 
.RE
.PP

.PP
Definition at line 522 of file lspmac\&.c\&.
.PP
.nf
                                      {
  pmac_cmd_queue_t *rtn;

  pthread_mutex_lock( &pmac_queue_mutex);
  rtn = &(ethCmdQueue[(ethCmdOn++) % PMAC_CMD_QUEUE_LENGTH]);
  memcpy( rtn, cmd, sizeof( pmac_cmd_queue_t));
  rtn->time_sent\&.tv_sec  = 0;
  rtn->time_sent\&.tv_nsec = 0;
  pthread_cond_signal( &pmac_queue_cond);
  pthread_mutex_unlock( &pmac_queue_mutex);

  return rtn;
}
.fi
.SS "void lspmac_Reset ()"

.PP
Clear the queue and put the PMAC into a known state\&. 
.PP
Definition at line 643 of file lspmac\&.c\&.
.PP
.nf
                    {
  ls_pmac_state = LS_PMAC_STATE_IDLE;

  // clear queue
  ethCmdReply = ethCmdOn;
  ethCmdOff   = ethCmdOn;

  lspmac_SockFlush();
}
.fi
.SS "double lspmac_rlut (intnlut, double *lut, doubley)"
\fBParameters:\fP
.RS 4
\fInlut\fP number of entries in lookup table 
.br
\fIlut\fP our lookup table 
.br
\fIy\fP the y value for which we need an x 
.RE
.PP

.PP
Definition at line 358 of file lspmac\&.c\&.
.PP
.nf
                     {
  int i, foundone, up;
  double m;
  double y1, y2, x1, x2, x;

  foundone = 0;
  if( lut != NULL && nlut > 1) {

    if( lut[1] < lut[2*nlut-1])
      up = 1;
    else
      up = 0;

    for( i=0; i < 2*nlut; i += 2) {
      x1 = lut[i];
      y1 = lut[i+1];
      if( i < 2*nlut - 2) {
        x2 = lut[i+2];
        y2 = lut[i+3];
      }
      if( i==0 && ( up ? y1 > y : y1 < y)) {
        x = x1;
        foundone = 1;
        break;
      }
      if( y1 == y) {
        x = x1;
        foundone = 1;
        break;
      }
      if( (i < 2*nlut-2) && (up ? y < y2 : y > y2)) {
        m = (x2 - x1) / (y2 - y1);
        x = m * (y - y1) + x1;
        foundone = 1;
        break;
      }
    }
    if( foundone == 0 ) {
      x = lut[2*(nlut-1)];
    }
    return x;
  }
  return 0\&.0;
}
.fi
.SS "void lspmac_run ()"

.PP
Start up the lspmac thread\&. 
.PP
Definition at line 2403 of file lspmac\&.c\&.
.PP
.nf
                  {
  pthread_create( &pmac_thread, NULL, lspmac_worker, NULL);
  lsevents_add_listener( 'NewKV', lspmac_newKV_cb);
  lsevents_add_listener( 'CryoSwitchChanged', lspmac_cryoSwitchChanged_cb);
  lsevents_add_listener( 'scint In Position', lspmac_scint_inPosition_cb);
  lsevents_add_listener( 'scintDried',        lspmac_scint_dried_cb);
}
.fi
.SS "void lspmac_scint_dried_cb (char *event)"

.PP
Turn off the dryer\&. \fBParameters:\fP
.RS 4
\fIevent\fP required by protocol 
.RE
.PP

.PP
Definition at line 2354 of file lspmac\&.c\&.
.PP
.nf
                                         {
  lslogging_log_message( 'lspmac_scint_dried_cb: Stopping dryer');
  dryer->moveAbs( dryer, 0\&.0);
}
.fi
.SS "void lspmac_scint_inPosition_cb (char *event)"

.PP
Maybe start drying off the scintilator\&. \fBParameters:\fP
.RS 4
\fIevent\fP required by protocol 
.RE
.PP

.PP
Definition at line 2329 of file lspmac\&.c\&.
.PP
.nf
                                              {
  double pos;
  double cover;
  int err;

  pthread_mutex_lock( &(scint->mutex));
  pos = scint->position;
  cover = lskvs_find_preset_position( scint, 'Cover', &err);
  pthread_mutex_unlock( &(scint->mutex));

  lslogging_log_message( 'lspmac_scint_inPosition_cb: pos %f, cover %f, diff %f, err %d', pos, cover, fabs( pos-cover), err);

  if( err != 0)
    return;

  if( fabs( pos - cover) <= 0\&.1) {
    dryer->moveAbs( dryer, 1\&.0);
    lslogging_log_message( 'lspmac_scint_inPosition_cb: Starting dryer');
    lstimer_add_timer( 'scintDried', 1, 120, 0);
  }
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_send_command (intrqType, intrq, intwValue, intwIndex, intwLength, unsigned char *data, void(*)(\fBpmac_cmd_queue_t\fP *, int, unsigned char *)responseCB, intno_reply)"

.PP
Compose a packet and send it to the PMAC\&. This is the meat of the PMAC communications routines\&. The queued command is returned\&. \fBParameters:\fP
.RS 4
\fIrqType\fP VR_UPLOAD or VR_DOWNLOAD 
.br
\fIrq\fP PMAC command (see PMAC User Manual 
.br
\fIwValue\fP Command argument 1 
.br
\fIwIndex\fP Command argument 2 
.br
\fIwLength\fP Length of data array 
.br
\fIdata\fP Data array (or NULL) 
.br
\fIresponseCB\fP Function to call when a response is read from the PMAC 
.br
\fIno_reply\fP Flag, non-zero means no reply is expected 
.RE
.PP

.PP
Definition at line 584 of file lspmac\&.c\&.
.PP
.nf
                                        {
  static pmac_cmd_queue_t cmd;

  cmd\&.pcmd\&.RequestType = rqType;
  cmd\&.pcmd\&.Request     = rq;
  cmd\&.pcmd\&.wValue      = htons(wValue);
  cmd\&.pcmd\&.wIndex      = htons(wIndex);
  cmd\&.pcmd\&.wLength     = htons(wLength);
  cmd\&.onResponse       = responseCB;
  cmd\&.no_reply          = no_reply;

  //
  // Setting the message buff bData requires a bit more care to avoid over filling it
  // or sending garbage in the unused bytes\&.
  //

  if( wLength > sizeof( cmd\&.pcmd\&.bData)) {
    //
    // Bad things happen if we do not catch this case\&.
    //
    lslogging_log_message( 'Message Length %d longer than maximum of %ld, aborting', wLength, sizeof( cmd\&.pcmd\&.bData));
    exit( -1);
  }
  if( data == NULL) {
    memset( cmd\&.pcmd\&.bData, 0, sizeof( cmd\&.pcmd\&.bData));
  } else {
    //
    // This could leave bData non-null terminated\&.  I do not know if this is a problem\&.
    //
    if( wLength > 0)
      memcpy( cmd\&.pcmd\&.bData, data, wLength);
    if( wLength < sizeof( cmd\&.pcmd\&.bData))
      memset( cmd\&.pcmd\&.bData + wLength, 0, sizeof( cmd\&.pcmd\&.bData) - wLength);
  }

  return lspmac_push_queue( &cmd);
}
.fi
.SS "void lspmac_sendcmd (void(*)(\fBpmac_cmd_queue_t\fP *, int, unsigned char *)responseCB, char *fmt, \&.\&.\&.)"

.PP
PMAC command with call back\&. \fBParameters:\fP
.RS 4
\fIresponseCB\fP our callback routine 
.br
\fIfmt\fP printf style format string 
.RE
.PP

.PP
Definition at line 1621 of file lspmac\&.c\&.
.PP
.nf
                          {
  static char tmps[1024];
  va_list arg_ptr;

  va_start( arg_ptr, fmt);
  vsnprintf( tmps, sizeof(tmps)-1, fmt, arg_ptr);
  tmps[sizeof(tmps)-1]=0;
  va_end( arg_ptr);

  lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDLINE, 0, 0, strlen(tmps), tmps, responseCB, 0);
}
.fi
.SS "void lspmac_sendcmd_nocb (char *fmt, \&.\&.\&.)"

.PP
Send a command that does not need to deal with the reply\&. \fBParameters:\fP
.RS 4
\fIfmt\fP A printf style format string 
.RE
.PP

.PP
Definition at line 1602 of file lspmac\&.c\&.
.PP
.nf
                           {
  static char tmps[1024];
  va_list arg_ptr;

  va_start( arg_ptr, fmt);
  vsnprintf( tmps, sizeof(tmps)-1, fmt, arg_ptr);
  tmps[sizeof(tmps)-1]=0;
  va_end( arg_ptr);

  lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDLINE, 0, 0, strlen(tmps), tmps, NULL, 0);
}
.fi
.SS "void lspmac_SendControlReplyPrintCB (\fBpmac_cmd_queue_t\fP *cmd, intnreceived, unsigned char *buff)"

.PP
Receive a reply to a control character Print a 'printable' version of the character to the terminal Followed by a hex dump of the response\&. \fBParameters:\fP
.RS 4
\fIcmd\fP Queue item this is a reply to 
.br
\fInreceived\fP Number of bytes received 
.br
\fIbuff\fP Buffer of bytes received 
.RE
.PP

.PP
Definition at line 902 of file lspmac\&.c\&.
.PP
.nf
                                      {
    pthread_mutex_lock( &ncurses_mutex);
    wprintw( term_output, 'control-%c: ', '@'+ ntohs(cmd->pcmd\&.wValue));
    pthread_mutex_unlock( &ncurses_mutex);
    hex_dump( nreceived, buff);
    pthread_mutex_lock( &ncurses_mutex);
    wnoutrefresh( term_output);
    wnoutrefresh( term_input);
    doupdate();
    pthread_mutex_unlock( &ncurses_mutex);
}
.fi
.SS "void lspmac_Service (struct pollfd *evt)"

.PP
Service routine for packet coming from the PMAC\&. All communications is asynchronous so this is the only place incomming packets are handled \fBParameters:\fP
.RS 4
\fIevt\fP pollfd object returned by poll 
.RE
.PP

.PP
Definition at line 690 of file lspmac\&.c\&.
.PP
.nf
                      {
  static unsigned char *receiveBuffer = NULL;   // the buffer inwhich to stick our incomming characters
  static int receiveBufferSize = 0;             // size of receiveBuffer
  static int receiveBufferIn = 0;               // next location to write to in receiveBuffer
  pmac_cmd_queue_t *cmd;                        // maybe the command we are servicing
  ssize_t nsent, nread;                         // nbytes dealt with
  int i;                                        // loop counter
  int foundEOCR;                                // end of command response flag

  if( evt->revents & (POLLERR | POLLHUP | POLLNVAL)) {
    if( evt->fd != -1) {
      close( evt->fd);
      evt->fd = -1;
    }
    ls_pmac_state = LS_PMAC_STATE_DETACHED;
    return;
  }


  if( evt->revents & POLLOUT) {

    switch( ls_pmac_state) {
    case LS_PMAC_STATE_DETACHED:
      break;
    case LS_PMAC_STATE_IDLE:
      break;

    case LS_PMAC_STATE_SC:
      cmd = lspmac_pop_queue();
      if( cmd != NULL) {
        if( cmd->pcmd\&.Request == VR_PMAC_GETMEM) {
          nsent = send( evt->fd, cmd, pmac_cmd_size, 0);
          if( nsent != pmac_cmd_size) {
            lslogging_log_message( 'Could only send %d of %d bytes\&.\&.\&.\&.Not good\&.', (int)nsent, (int)(pmac_cmd_size));
          }
        } else {
          nsent = send( evt->fd, cmd, pmac_cmd_size + ntohs(cmd->pcmd\&.wLength), 0);
          gettimeofday( &pmac_time_sent, NULL);
          if( nsent != pmac_cmd_size + ntohs(cmd->pcmd\&.wLength)) {
            lslogging_log_message( 'Could only send %d of %d bytes\&.\&.\&.\&.Not good\&.', (int)nsent, (int)(pmac_cmd_size + ntohs(cmd->pcmd\&.wLength)));
          }
        }
      }
      if( cmd->pcmd\&.Request == VR_PMAC_SENDCTRLCHAR)
        ls_pmac_state = LS_PMAC_STATE_WACK_CC;
      else if( cmd->pcmd\&.Request == VR_PMAC_GETMEM)
        ls_pmac_state = LS_PMAC_STATE_GMR;
      else if( cmd->no_reply == 0)
        ls_pmac_state = LS_PMAC_STATE_WACK;
      else
        ls_pmac_state = LS_PMAC_STATE_WACK_NFR;
      break;

    case LS_PMAC_STATE_CR:
      nsent = send( evt->fd, &cr_cmd, pmac_cmd_size, 0);
      gettimeofday( &pmac_time_sent, NULL);
      ls_pmac_state = LS_PMAC_STATE_WCR;
      break;

    case LS_PMAC_STATE_RR:
      nsent = send( evt->fd, &rr_cmd, pmac_cmd_size, 0);
      gettimeofday( &pmac_time_sent, NULL);
      ls_pmac_state = LS_PMAC_STATE_WACK_RR;
      break;

    case LS_PMAC_STATE_GB:
      nsent = send( evt->fd, &gb_cmd, pmac_cmd_size, 0);
      gettimeofday( &pmac_time_sent, NULL);
      ls_pmac_state = LS_PMAC_STATE_WGB;
      break;
    }
  }

  if( evt->revents & POLLIN) {

    if( receiveBufferSize - receiveBufferIn < 1400) {
      unsigned char *newbuff;

      receiveBufferSize += 1400;
      newbuff = calloc( receiveBufferSize, sizeof( unsigned char));
      if( newbuff == NULL) {
        lslogging_log_message( 'Out of memory');
        exit( -1);
      }
      memcpy( newbuff, receiveBuffer, receiveBufferIn);
      receiveBuffer = newbuff;
    }

    nread = read( evt->fd, receiveBuffer + receiveBufferIn, 1400);

    foundEOCR = 0;
    if( ls_pmac_state == LS_PMAC_STATE_GMR) {
      //
      // get memory returns binary stuff, don't try to parse it
      //
      receiveBufferIn += nread;
    } else {
      //
      // other commands end in 6 if OK, 7 if not
      //
      for( i=receiveBufferIn; i<receiveBufferIn+nread; i++) {
        if( receiveBuffer[i] == 7) {
          //
          // Error condition
          //
          lspmac_Error( &(receiveBuffer[i]));
          receiveBufferIn = 0;
          return;
        }
        if( receiveBuffer[i] == 6) {
          //
          // End of command response
          //
          foundEOCR = 1;
          receiveBuffer[i] = 0;
          break;
        }
      }
      receiveBufferIn = i;
    }

    cmd = NULL;

    switch( ls_pmac_state) {
    case LS_PMAC_STATE_WACK_NFR:
      receiveBuffer[--receiveBufferIn] = 0;
      cmd = lspmac_pop_reply();
      ls_pmac_state = LS_PMAC_STATE_IDLE;
      break;
    case LS_PMAC_STATE_WACK:
      receiveBuffer[--receiveBufferIn] = 0;
      ls_pmac_state = LS_PMAC_STATE_RR;
      break;
    case LS_PMAC_STATE_WACK_CC:
      receiveBuffer[--receiveBufferIn] = 0;
      ls_pmac_state = LS_PMAC_STATE_CR;
      break;
    case LS_PMAC_STATE_WACK_RR:
      receiveBufferIn -= 2;
      if( receiveBuffer[receiveBufferIn])
        ls_pmac_state = LS_PMAC_STATE_GB;
      else
        ls_pmac_state = LS_PMAC_STATE_RR;
      receiveBuffer[receiveBufferIn] = 0;
      break;
    case LS_PMAC_STATE_GMR:
      cmd = lspmac_pop_reply();
      ls_pmac_state = LS_PMAC_STATE_IDLE;
      break;

    case LS_PMAC_STATE_WCR:
      cmd = lspmac_pop_reply();
      ls_pmac_state = LS_PMAC_STATE_IDLE;
      break;
    case LS_PMAC_STATE_WGB:
      if( foundEOCR) {
        cmd = lspmac_pop_reply();
        ls_pmac_state = LS_PMAC_STATE_IDLE;
      } else {
        ls_pmac_state = LS_PMAC_STATE_RR;
      }
      break;
    }


    if( cmd != NULL && cmd->onResponse != NULL) {
      cmd->onResponse( cmd, receiveBufferIn, receiveBuffer);
      receiveBufferIn = 0;
    }
  }
}
.fi
.SS "void lspmac_shutter_read (\fBlspmac_motor_t\fP *mp)"

.PP
Fast shutter read routine The shutter is mildly complicated in that we need to take into account the fact that the shutter can open and close again between status updates\&. This means that we need to rely on a PCL program running in the PMAC to monitor the shutter state and let us know that this has happened\&. \fBParameters:\fP
.RS 4
\fImp\fP The motor object associated with the fast shutter 
.RE
.PP

.PP
Definition at line 1053 of file lspmac\&.c\&.
.PP
.nf
                           {
  //
  // track the shutter state and signal if it has changed
  //
  pthread_mutex_lock( &lspmac_shutter_mutex);
  if( md2_status\&.fs_has_opened && !lspmac_shutter_has_opened && !md2_status\&.fs_is_open) {
    //
    // Here the shutter opened and closed again before we got the memo
    // Treat it as a shutter closed event
    //
    pthread_cond_signal( &lspmac_shutter_cond);
  }
  lspmac_shutter_has_opened = md2_status\&.fs_has_opened;

  if( lspmac_shutter_state !=  md2_status\&.fs_is_open) {
    lspmac_shutter_state = md2_status\&.fs_is_open;
    pthread_cond_signal( &lspmac_shutter_cond);
  }

  if( md2_status\&.fs_is_open) {
    mvwprintw( term_status2, 1, 1, 'Shutter Open  ');
    mp->position = 1;
  } else {
    mvwprintw( term_status2, 1, 1, 'Shutter Closed');
    mp->position = 0;
  }

  // Not sure what kind of status makes sense to report
  mp->statuss[0] = 0;

  pthread_mutex_unlock( &lspmac_shutter_mutex);
}
.fi
.SS "void lspmac_SockFlush ()"

.PP
Reset the PMAC socket from the PMAC side\&. Puts the PMAC into a known communications state 
.PP
Definition at line 636 of file lspmac\&.c\&.
.PP
.nf
                        {
  lspmac_send_command( VR_DOWNLOAD, VR_PMAC_FLUSH, 0, 0, 0, NULL, NULL, 1);
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_SockGetmem (intoffset, intnbytes)"

.PP
Request a chunk of memory to be returned\&. Not currently used \fBParameters:\fP
.RS 4
\fIoffset\fP Offset in PMAC Double Buffer 
.br
\fInbytes\fP Number of bytes to request 
.RE
.PP

.PP
Definition at line 939 of file lspmac\&.c\&.
.PP
.nf
                                       {
  return lspmac_send_command( VR_UPLOAD,   VR_PMAC_GETMEM, offset, 0, nbytes, NULL, lspmac_GetmemReplyCB, 0);
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_SockSendControlCharPrint (charc)"

.PP
Send a control character\&. \fBParameters:\fP
.RS 4
\fIc\fP The control character to send 
.RE
.PP

.PP
Definition at line 987 of file lspmac\&.c\&.
.PP
.nf
                                                    {
  return lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDCTRLCHAR, c, 0, 0, NULL, lspmac_SendControlReplyPrintCB, 0);
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_SockSendline (char *fmt, \&.\&.\&.)"

.PP
Send a one line command\&. Uses printf style arguments\&. \fBParameters:\fP
.RS 4
\fIfmt\fP Printf style format string 
.RE
.PP

.PP
Definition at line 949 of file lspmac\&.c\&.
.PP
.nf
                                         {
  va_list arg_ptr;
  char payload[1400];

  va_start( arg_ptr, fmt);
  vsnprintf( payload, sizeof(payload)-1, fmt, arg_ptr);
  payload[ sizeof(payload)-1] = 0;
  va_end( arg_ptr);

  lslogging_log_message( payload);

  return lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDLINE, 0, 0, strlen( payload), payload, lspmac_GetShortReplyCB, 0);
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_SockSendline_nr (char *fmt, \&.\&.\&.)"

.PP
Send a command and ignore the response\&. \fBParameters:\fP
.RS 4
\fIfmt\fP Printf style format string 
.RE
.PP

.PP
Definition at line 968 of file lspmac\&.c\&.
.PP
.nf
                                           {
  va_list arg_ptr;
  char s[512];

  va_start( arg_ptr, fmt);
  vsnprintf( s, sizeof(s)-1, fmt, arg_ptr);
  s[sizeof(s)-1] = 0;
  va_end( arg_ptr);

  lslogging_log_message( s);

  return lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDLINE, 0, 0, strlen( s), s, NULL, 1);
}
.fi
.SS "void* lspmac_worker (void *dummy)"

.PP
Our lspmac worker thread\&. \fBParameters:\fP
.RS 4
\fIdummy\fP Unused but required by pthread library 
.RE
.PP

.PP
Definition at line 1748 of file lspmac\&.c\&.
.PP
.nf
                      {

  while( 1) {
    int pollrtn;

    lspmac_next_state();

    if( pmacfd\&.fd == -1) {
      sleep( 10);       // The pmac is not connected\&.  Should we warn someone?
      //
      // This just puts us into a holding pattern until the pmac becomes connected again
      //
      // TODO:
      // Check PMAC initialization logic and our queues to ensure that it is sane to
      // re-initialize things\&.  Probably bad things will happen\&.
      //
      continue;
    }

    pollrtn = poll( &pmacfd, 1, 10);
    if( pollrtn) {
      lspmac_Service( &pmacfd);
    }
  }
}
.fi
.SH "Variable Documentation"
.PP 
.SS "\fBlspmac_motor_t\fP* alignx"

.PP
Alignment stage X\&. 
.PP
Definition at line 76 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* aligny"

.PP
Alignment stage Y\&. 
.PP
Definition at line 77 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* alignz"

.PP
Alignment stage X\&. 
.PP
Definition at line 78 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* anal"

.PP
Polaroid analyzer motor\&. 
.PP
Definition at line 79 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* apery"

.PP
Aperture Y\&. 
.PP
Definition at line 81 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* aperz"

.PP
Aperture Z\&. 
.PP
Definition at line 82 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* blight"

.PP
Back Light DAC\&. 
.PP
Definition at line 93 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* blight_ud"

.PP
Back Light Up/Down actuator\&. 
.PP
Definition at line 96 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* capy"

.PP
Capillary Y\&. 
.PP
Definition at line 83 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* capz"

.PP
Capillary Z\&. 
.PP
Definition at line 84 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* cenx"

.PP
Centering Table X\&. 
.PP
Definition at line 86 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* ceny"

.PP
Centering Table Y\&. 
.PP
Definition at line 87 of file lspmac\&.c\&.
.SS "\fBpmac_cmd_t\fP cr_cmd\fC [static]\fP"

.PP
commands to send out 'readready', 'getbuffer', controlresponse (initialized in main) 
.PP
Definition at line 149 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* cryo"

.PP
Move the cryostream towards or away from the crystal\&. 
.PP
Definition at line 97 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* cryo_switch"

.PP
that little toggle switch for the cryo 
.PP
Definition at line 101 of file lspmac\&.c\&.
.SS "unsigned char dbmem[64 *1024]\fC [static]\fP"

.PP
double buffered memory 
.PP
Definition at line 139 of file lspmac\&.c\&.
.SS "int dbmemIn = 0\fC [static]\fP"

.PP
next location 
.PP
Definition at line 140 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* dryer"

.PP
blow air on the scintilator to dry it off 
.PP
Definition at line 98 of file lspmac\&.c\&.
.SS "unsigned int ethCmdOff = 0\fC [static]\fP"

.PP
points to current command (or none if == ethCmdOn) 
.PP
Definition at line 152 of file lspmac\&.c\&.
.SS "unsigned int ethCmdOn = 0\fC [static]\fP"

.PP
points to next empty PMAC command queue position 
.PP
Definition at line 151 of file lspmac\&.c\&.
.SS "\fBpmac_cmd_queue_t\fP ethCmdQueue[\fBPMAC_CMD_QUEUE_LENGTH\fP]\fC [static]\fP"

.PP
PMAC command queue\&. 
.PP
Definition at line 150 of file lspmac\&.c\&.
.SS "unsigned int ethCmdReply = 0\fC [static]\fP"

.PP
Used like ethCmdOff only to deal with the pmac reply to a command\&. 
.PP
Definition at line 153 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* flight"

.PP
Front Light DAC\&. 
.PP
Definition at line 92 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* fluo"

.PP
Move the fluorescence detector in/out\&. 
.PP
Definition at line 99 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* fscint"

.PP
Scintillator Piezo DAC\&. 
.PP
Definition at line 94 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* fshut"

.PP
Fast shutter\&. 
.PP
Definition at line 91 of file lspmac\&.c\&.
.SS "\fBpmac_cmd_t\fP gb_cmd\fC [static]\fP"

.PP
Definition at line 149 of file lspmac\&.c\&.
.SS "int getivars = 0\fC [static]\fP"

.PP
flag set at initialization to send i vars to db 
.PP
Definition at line 67 of file lspmac\&.c\&.
.SS "int getmvars = 0\fC [static]\fP"

.PP
flag set at initialization to send m vars to db 
.PP
Definition at line 68 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* kappa"

.PP
Kappa\&. 
.PP
Definition at line 88 of file lspmac\&.c\&.
.SS "int linesReceived =0\fC [static]\fP"

.PP
current number of lines received 
.PP
Definition at line 138 of file lspmac\&.c\&.
.SS "int ls_pmac_state = \fBLS_PMAC_STATE_DETACHED\fP\fC [static]\fP"

.PP
Current state of the PMAC communications state machine\&. 
.PP
Definition at line 51 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP lspmac_bis[16]"

.PP
array of binary inputs 
.PP
Definition at line 70 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP lspmac_motors[32]"

.PP
All our motors\&. 
.PP
Definition at line 73 of file lspmac\&.c\&.
.SS "pthread_cond_t lspmac_moving_cond"

.PP
Wait for motor(s) to finish moving condition\&. 
.PP
Definition at line 58 of file lspmac\&.c\&.
.SS "int lspmac_moving_flags"

.PP
Flag used to implement motor moving condition\&. 
.PP
Definition at line 59 of file lspmac\&.c\&.
.SS "pthread_mutex_t lspmac_moving_mutex"

.PP
Coordinate moving motors between threads\&. 
.PP
Definition at line 57 of file lspmac\&.c\&.
.SS "int lspmac_nbis = 0"

.PP
number of active binary inputs 
.PP
Definition at line 71 of file lspmac\&.c\&.
.SS "int lspmac_nmotors = 0"

.PP
The number of motors we manage\&. 
.PP
Definition at line 74 of file lspmac\&.c\&.
.SS "pthread_cond_t lspmac_shutter_cond"

.PP
Allows waiting for the shutter status to change\&. 
.PP
Definition at line 56 of file lspmac\&.c\&.
.SS "int lspmac_shutter_has_opened"

.PP
Indicates that the shutter had opened, perhaps briefly even if the state did not change\&. 
.PP
Definition at line 54 of file lspmac\&.c\&.
.SS "pthread_mutex_t lspmac_shutter_mutex"

.PP
Coordinates threads reading shutter status\&. 
.PP
Definition at line 55 of file lspmac\&.c\&.
.SS "int lspmac_shutter_state"

.PP
State of the shutter, used to detect changes\&. 
.PP
Definition at line 53 of file lspmac\&.c\&.
.SS "\fBmd2_status_t\fP md2_status\fC [static]\fP"

.PP
Buffer for MD2 Status\&. 
.PP
Definition at line 287 of file lspmac\&.c\&.
.SS "pthread_mutex_t md2_status_mutex"

.PP
Synchronize reading/writting status buffer\&. 
.PP
Definition at line 288 of file lspmac\&.c\&.
.SS "struct timeval pmac_time_sent now\fC [static]\fP"

.PP
used to ensure we do not send commands to the pmac too often\&. Only needed for non-DB commands\&. 
.PP
Definition at line 145 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* omega"

.PP
MD2 omega axis (the air bearing) 
.PP
Definition at line 75 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* phi"

.PP
Phi (not data collection axis) 
.PP
Definition at line 89 of file lspmac\&.c\&.
.SS "char* pmac_error_strs[]\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
  'ERR000: Unknown error',
  'ERR001: Command not allowed during program execution',
  'ERR002: Password error',
  'ERR003: Data error or unrecognized command',
  'ERR004: Illegal character',
  'ERR005: Command not allowed unless buffer is open',
  'ERR006: No room in buffer for command',
  'ERR007: Buffer already in use',
  'ERR008: MACRO auziliary communication error',
  'ERR009: Program structure error (e\&.g\&. ENDIF without IF)',
  'ERR010: Both overtravel limits set for a motor in the C\&.S\&.',
  'ERR011: Previous move not completed',
  'ERR012: A motor in the coordinate system is open-loop',
  'ERR013: A motor in the coordinate system is not activated',
  'ERR014: No motors in the coordinate system',
  'ERR015: Not pointer to valid program buffer',
  'ERR016: Running improperly structure program (e\&.g\&. missing ENDWHILE)',
  'ERR017: Trying to resume after H or Q with motors out of stopped position',
  'ERR018: Attempt to perform phase reference during move, move during phase reference, or enabling with phase clock error',
  'ERR019: Illegal position-chage command while moves stored in CCBUFFER'
}
.fi
.PP
Decode the errors perhaps returned by the PMAC\&. 
.PP
Definition at line 156 of file lspmac\&.c\&.
.SS "pthread_cond_t pmac_queue_cond\fC [static]\fP"

.PP
wait for a command to be sent to PMAC before continuing 
.PP
Definition at line 64 of file lspmac\&.c\&.
.SS "pthread_mutex_t pmac_queue_mutex\fC [static]\fP"

.PP
manage access to the pmac command queue 
.PP
Definition at line 63 of file lspmac\&.c\&.
.SS "pthread_t pmac_thread\fC [static]\fP"

.PP
our thread to manage access and communication to the pmac 
.PP
Definition at line 62 of file lspmac\&.c\&.
.SS "struct pollfd pmacfd\fC [static]\fP"

.PP
our poll structure 
.PP
Definition at line 65 of file lspmac\&.c\&.
.SS "\fBpmac_cmd_t\fP rr_cmd\fC [static]\fP"

.PP
Definition at line 149 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* scint"

.PP
Scintillator Z\&. 
.PP
Definition at line 85 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* zoom"

.PP
Optical zoom\&. 
.PP
Definition at line 80 of file lspmac\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for LS-CAT PGPMAC from the source code\&.
