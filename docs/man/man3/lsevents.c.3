.TH "lsevents.c" 3 "Tue Feb 12 2013" "LS-CAT PGPMAC" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lsevents.c \- 
.PP
event subsystem for inter-pgpmac communication  

.SH SYNOPSIS
.br
.PP
\fC#include 'pgpmac\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBlsevents_queue_struct\fP"
.br
.RI "\fIStorage definition for the events\&. \fP"
.ti -1c
.RI "struct \fBlsevents_listener_struct\fP"
.br
.RI "\fILinked list of event listeners\&. \fP"
.ti -1c
.RI "struct \fBlsevents_callbacks_struct\fP"
.br
.RI "\fIlsevents linked list of callbacks for each event \fP"
.ti -1c
.RI "struct \fBlsevents_event_names_struct\fP"
.br
.RI "\fIlinked list of all the event names used to regenerate the hash table \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBLSEVENTS_QUEUE_LENGTH\fP   512"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct 
.br
\fBlsevents_queue_struct\fP \fBlsevents_queue_t\fP"
.br
.RI "\fIStorage definition for the events\&. \fP"
.ti -1c
.RI "typedef struct 
.br
\fBlsevents_listener_struct\fP \fBlsevents_listener_t\fP"
.br
.RI "\fILinked list of event listeners\&. \fP"
.ti -1c
.RI "typedef struct 
.br
\fBlsevents_callbacks_struct\fP \fBlsevents_callbacks_t\fP"
.br
.RI "\fIlsevents linked list of callbacks for each event \fP"
.ti -1c
.RI "typedef struct 
.br
\fBlsevents_event_names_struct\fP \fBlsevents_event_names_t\fP"
.br
.RI "\fIlinked list of all the event names used to regenerate the hash table \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBlsevents_send_event\fP (char *fmt,\&.\&.\&.)"
.br
.RI "\fICall the callback routines for the given event\&. \fP"
.ti -1c
.RI "void \fBlsevents_add_listener\fP (char *raw_regexp, void(*cb)(char *))"
.br
.RI "\fIAdd a callback routine to listen for a specific event\&. \fP"
.ti -1c
.RI "void \fBlsevents_remove_listener\fP (char *event, void(*cb)(char *))"
.br
.RI "\fIRemove a listener previously added with lsevents_add_listener\&. \fP"
.ti -1c
.RI "\fBlsevents_callbacks_t\fP * \fBlsevents_register_event\fP (char *event)"
.br
.RI "\fIAdd a new event name and find matching callbacks as a returned linked list\&. \fP"
.ti -1c
.RI "void \fBlsevents_preregister_event\fP (char *fmt,\&.\&.\&.)"
.br
.ti -1c
.RI "void * \fBlsevents_worker\fP (void *dummy)"
.br
.RI "\fIOur worker\&. \fP"
.ti -1c
.RI "void \fBlsevents_init\fP ()"
.br
.RI "\fIInitialize this module\&. \fP"
.ti -1c
.RI "void \fBlsevents_run\fP ()"
.br
.RI "\fIStart up the thread and get out of the way\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static \fBlsevents_queue_t\fP \fBlsevents_queue\fP [\fBLSEVENTS_QUEUE_LENGTH\fP]"
.br
.RI "\fIsimple list of events \fP"
.ti -1c
.RI "static unsigned int \fBlsevents_queue_on\fP = 0"
.br
.RI "\fInext queue location to write \fP"
.ti -1c
.RI "static unsigned int \fBlsevents_queue_off\fP = 0"
.br
.RI "\fInext queue location to read \fP"
.ti -1c
.RI "static int \fBlsevents_max_events\fP = 1024"
.br
.ti -1c
.RI "static int \fBlsevents_n_events\fP = 0"
.br
.ti -1c
.RI "static struct hsearch_data \fBlsevents_event_name_ht\fP"
.br
.ti -1c
.RI "static \fBlsevents_listener_t\fP * \fBlsevents_listeners_p\fP = NULL"
.br
.RI "\fIPointer to the first item in the link list of listeners\&. \fP"
.ti -1c
.RI "static \fBlsevents_event_names_t\fP * \fBlsevents_event_names\fP = NULL"
.br
.ti -1c
.RI "static pthread_t \fBlsevents_thread\fP"
.br
.RI "\fIthread to run the event queue \fP"
.ti -1c
.RI "static pthread_mutex_t \fBlsevents_listener_mutex\fP"
.br
.RI "\fImutex to protect the listener linked list \fP"
.ti -1c
.RI "static pthread_mutex_t \fBlsevents_queue_mutex\fP"
.br
.RI "\fImutex to protect the event queue \fP"
.ti -1c
.RI "static pthread_cond_t \fBlsevents_queue_cond\fP"
.br
.RI "\fIcondition to pause the queue if needed \fP"
.in -1c
.SH "Detailed Description"
.PP 
event subsystem for inter-pgpmac communication 

\fBDate:\fP
.RS 4
2012 
.RE
.PP
\fBAuthor:\fP
.RS 4
Keith Brister 
.RE
.PP
\fBCopyright:\fP
.RS 4
All Rights Reserved 
.RE
.PP

.PP
Definition in file \fBlsevents\&.c\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define LSEVENTS_QUEUE_LENGTH   512"

.PP
Definition at line 10 of file lsevents\&.c\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBlsevents_callbacks_struct\fP  \fBlsevents_callbacks_t\fP"

.PP
lsevents linked list of callbacks for each event 
.SS "typedef struct \fBlsevents_event_names_struct\fP  \fBlsevents_event_names_t\fP"

.PP
linked list of all the event names used to regenerate the hash table 
.SS "typedef struct \fBlsevents_listener_struct\fP  \fBlsevents_listener_t\fP"

.PP
Linked list of event listeners\&. 
.SS "typedef struct \fBlsevents_queue_struct\fP  \fBlsevents_queue_t\fP"

.PP
Storage definition for the events\&. Just a string for now\&. Perhaps one day we'll succumb to the temptation to add an argument or two\&. 
.SH "Function Documentation"
.PP 
.SS "void lsevents_add_listener (char *raw_regexp, void(*)(char *)cb)"

.PP
Add a callback routine to listen for a specific event\&. \fBParameters:\fP
.RS 4
\fIraw_regexp\fP String value of regular expression to listen to 
.br
\fIcb\fP the routine to call 
.RE
.PP

.PP
Definition at line 99 of file lsevents\&.c\&.
.PP
.nf
                                                                  {
  lsevents_listener_t    *new;
  lsevents_event_names_t *enp;
  lsevents_callbacks_t   *cbp;
  int err;
  char *errbuf;
  int nerrbuf;



  new = calloc( 1, sizeof( lsevents_listener_t));
  if( new == NULL) {
    lslogging_log_message( 'lsevents_add_listener: out of memory');
    exit( -1);
  }

  err = regcomp( &new->re, raw_regexp, REG_EXTENDED | REG_NOSUB);
  if( err != 0) {
    nerrbuf = regerror( err, &new->re, NULL, 0);
    errbuf = calloc( nerrbuf, sizeof( char));
    if( errbuf == NULL) {
      lslogging_log_message( 'lsevents_add_listener: out of memory (re)');
      exit( -1);
    }
    regerror( err, &new->re, errbuf, nerrbuf);
    lslogging_log_message( 'lsevents_add_listener: %s', errbuf);
    free( errbuf);
    free( new);
    return;
  }

  new->raw_regexp = strdup( raw_regexp);
  new->cb   = cb;

  pthread_mutex_lock( &lsevents_listener_mutex);
  new->next = lsevents_listeners_p;
  lsevents_listeners_p = new;

  for( enp = lsevents_event_names; enp != NULL; enp = enp->next) {
    if( regexec( &new->re, enp->event, 0, NULL, 0) == 0) {
      cbp       = calloc( 1, sizeof( lsevents_callbacks_t));
      cbp->cb   = cb;
      cbp->next = enp->cbl;
      enp->cbl  = cbp;
    }
  }
  

  pthread_mutex_unlock( &lsevents_listener_mutex);

  lslogging_log_message( 'lsevents_add_listener: added listener for event '%s'', raw_regexp);

}
.fi
.SS "void lsevents_init ()"

.PP
Initialize this module\&. 
.PP
Definition at line 373 of file lsevents\&.c\&.
.PP
.nf
                     {
  pthread_mutexattr_t mutex_initializer;

  // Use recursive mutexs
  //
  pthread_mutexattr_init( &mutex_initializer);
  pthread_mutexattr_settype( &mutex_initializer, PTHREAD_MUTEX_RECURSIVE);

  pthread_mutex_init( &lsevents_queue_mutex,    &mutex_initializer);
  pthread_cond_init(  &lsevents_queue_cond,     NULL);
  pthread_mutex_init( &lsevents_listener_mutex, &mutex_initializer);

  hcreate_r( 2*lsevents_max_events, &lsevents_event_name_ht);
}
.fi
.SS "void lsevents_preregister_event (char *fmt, \&.\&.\&.)"

.PP
Definition at line 314 of file lsevents\&.c\&.
.PP
.nf
                                                 {
  char  s[128];
  va_list arg_ptr;

  va_start( arg_ptr, fmt);
  vsnprintf( s, sizeof( s) - 1, fmt, arg_ptr);
  s[sizeof(s)-1] = 0;
  va_end( arg_ptr);

  lsevents_register_event( s);
}
.fi
.SS "\fBlsevents_callbacks_t\fP* lsevents_register_event (char *event)"

.PP
Add a new event name and find matching callbacks as a returned linked list\&. 
.PP
Definition at line 221 of file lsevents\&.c\&.
.PP
.nf
                                                            {
  ENTRY entry_in, *entry_outp;
  int err;
  lsevents_callbacks_t *new_cb;
  lsevents_event_names_t *new_event_name, *enp;
  lsevents_listener_t *p;


  //
  // Search for event
  //
  entry_in\&.key  = event;
  entry_in\&.data = NULL;

  pthread_mutex_lock( &lsevents_listener_mutex);
  err = hsearch_r( entry_in, FIND, &entry_outp, &lsevents_event_name_ht);
  if( err != 0) {
    //
    // Success, we found the entry
    //
    enp = entry_outp->data;
    pthread_mutex_unlock( &lsevents_listener_mutex);
    return enp->cbl;
  }

  if( errno != ESRCH) {
    //
    // Something awful happened\&.  At least log it
    //
    lslogging_log_message( 'lsevents_register_event: hsearch_r returnd %d: %s', errno, strerror( errno));
    pthread_mutex_unlock( &lsevents_listener_mutex);
    return NULL;
  }

  lslogging_log_message( 'lsevents_register_event: adding event '%s'', event);
  //
  // Not Found
  //
  // Create new event name item
  new_event_name = calloc( 1, sizeof( lsevents_event_names_t));
  new_event_name->event = strdup( event);
  new_event_name->cbl   = NULL;

  //
  // Find matching callbacks
  //
  for( p = lsevents_listeners_p; p != NULL; p = p->next) {
    if( regexec( &p->re, event, 0, NULL, 0) == 0) {
      new_cb = calloc( 1, sizeof( lsevents_callbacks_t));
      new_cb->cb = p->cb;
      new_cb->next = new_event_name->cbl;
      new_event_name->cbl = new_cb;
    }
  }

  //
  // Add the new event to our linked list
  //
  new_event_name->next  = lsevents_event_names;
  lsevents_event_names  = new_event_name;

  //
  // Also add the new event to our hash table
  //
  entry_in\&.key  = new_event_name->event;
  entry_in\&.data = new_event_name;
  err = hsearch_r( entry_in, ENTER, &entry_outp, &lsevents_event_name_ht);
  if( err == 0) {
    //
    // Something bad happend but we can still return a valid callback list\&.  We just can't use the hash table to find it again later
    //
    lslogging_log_message( 'lsevents_register_event: Could not add event name: hsearch_r returned %d: %s', errno, strerror( errno));
    pthread_mutex_unlock( &lsevents_listener_mutex);
    return new_event_name->cbl;
  }

  if( ++lsevents_n_events  >= lsevents_max_events) {
    hdestroy_r( &lsevents_event_name_ht);
    lslogging_log_message( 'lsevents_register_event: Increasing event name hash table to %d\&. lsevents_n_events=%d', 2 * lsevents_max_events, lsevents_n_events);
    lsevents_max_events *= 2;
    hcreate_r( lsevents_max_events * 2, &lsevents_event_name_ht);
    for( enp = lsevents_event_names; enp != NULL; enp = enp->next) {
      entry_in\&.key  = enp->event;
      entry_in\&.data = enp;
      hsearch_r( entry_in, ENTER, &entry_outp, &lsevents_event_name_ht);
    }
  }
  lslogging_log_message( 'lsevents_register_event: added event '%s'', event);
  pthread_mutex_unlock( &lsevents_listener_mutex);
  return new_event_name->cbl;
}  
.fi
.SS "void lsevents_remove_listener (char *event, void(*)(char *)cb)"

.PP
Remove a listener previously added with lsevents_add_listener\&. \fBParameters:\fP
.RS 4
\fIevent\fP The name of the event (possibly a regular expression string) 
.br
\fIcb\fP The callback routine to remove 
.RE
.PP

.PP
Definition at line 157 of file lsevents\&.c\&.
.PP
.nf
                                                                {
  
  lsevents_listener_t *last, *current;
  lsevents_event_names_t *enp;
  lsevents_callbacks_t   *cbp, *last_cbp;

  //
  // Find the listener to remove
  // and unlink it from the list
  //
  pthread_mutex_lock( &lsevents_listener_mutex);
  last = NULL;
  for( current = lsevents_listeners_p; current != NULL; current = current->next) {
    if( strcmp( last->raw_regexp, event) == 0 && last->cb == cb) {
      if( last == NULL) {
        lsevents_listeners_p = current->next;
      } else {
        last->next = current->next;
      }
      break;
    }
    last = current;
  }

  if( current == NULL) {
    lslogging_log_message( 'lsevents_remove_listener: Could not find this listener for event '%s'', event);
    pthread_mutex_unlock( &lsevents_listener_mutex);
    return;
  }

  //
  // Remove callback from lists of event names
  //
  for( enp = lsevents_event_names; enp != NULL; enp = enp->next) {
    if( regexec( &current->re, enp->event, 0, NULL, 0) == 0) {
      last_cbp = NULL;
      for( cbp = enp->cbl; cbp != NULL; cbp = cbp->next) {
        if( cbp->cb == cb) {
          if( last_cbp == NULL)
            enp->cbl = NULL;
          else
            last_cbp->next = cbp->next;
          free( cbp);
          break;
        }
      }
    }
  }


  pthread_mutex_unlock( &lsevents_listener_mutex);

  //
  // Now remove it
  //
  if( current->raw_regexp != NULL)
    free( current->raw_regexp);
  free(current);

}
.fi
.SS "void lsevents_run ()"

.PP
Start up the thread and get out of the way\&. 
.PP
Definition at line 390 of file lsevents\&.c\&.
.PP
.nf
                    {
  pthread_create( &lsevents_thread, NULL, lsevents_worker, NULL);
}
.fi
.SS "void lsevents_send_event (char *fmt, \&.\&.\&.)"

.PP
Call the callback routines for the given event\&. \fBParameters:\fP
.RS 4
\fIfmt\fP a printf style formating string 
.br
\fI\&.\&.\&.\fP list of arguments specified by the format string 
.RE
.PP

.PP
Definition at line 73 of file lsevents\&.c\&.
.PP
.nf
                                          {
  char event[LSEVENTS_EVENT_LENGTH];
  va_list arg_ptr;

  va_start( arg_ptr, fmt);
  vsnprintf( event, sizeof(event)-1, fmt, arg_ptr);
  event[sizeof(event)-1]=0;
  va_end( arg_ptr);

  pthread_mutex_lock( &lsevents_queue_mutex);

  // maybe wait for room on the queue
  while( (lsevents_queue_on + 1) % LSEVENTS_QUEUE_LENGTH == lsevents_queue_off % LSEVENTS_QUEUE_LENGTH)
    pthread_cond_wait( &lsevents_queue_cond, &lsevents_queue_mutex);
  
  lsevents_queue[(lsevents_queue_on++) % LSEVENTS_QUEUE_LENGTH]\&.evp = strdup(event);

  pthread_cond_signal(  &lsevents_queue_cond);
  pthread_mutex_unlock( &lsevents_queue_mutex);
}
.fi
.SS "void* lsevents_worker (void *dummy)"

.PP
Our worker\&. \fBParameters:\fP
.RS 4
\fIdummy\fP Unused but needed by pthreads to be happy 
.RE
.PP

.PP
Definition at line 331 of file lsevents\&.c\&.
.PP
.nf
                       {
  
  char *event;
  lsevents_callbacks_t *cbi;

  while( 1) {
    pthread_mutex_lock( &lsevents_queue_mutex);

    //
    // wait for someone to send an event
    //
    while( lsevents_queue_off == lsevents_queue_on)
      pthread_cond_wait( &lsevents_queue_cond, &lsevents_queue_mutex);

    //
    // Get our event name
    //
    event = lsevents_queue[(lsevents_queue_off++) % LSEVENTS_QUEUE_LENGTH]\&.evp;

    //
    // let the send event process know there is room on the queue again
    //
    pthread_cond_signal(  &lsevents_queue_cond);
    pthread_mutex_unlock( &lsevents_queue_mutex);

    // call our callbacks
    //
    pthread_mutex_lock( &lsevents_listener_mutex);
    for( cbi = lsevents_register_event( event); cbi != NULL; cbi = cbi->next) {
      cbi->cb( event);
    }
    pthread_mutex_unlock( &lsevents_listener_mutex);

    free( event);
  }
  return NULL;
}
.fi
.SH "Variable Documentation"
.PP 
.SS "struct hsearch_data lsevents_event_name_ht\fC [static]\fP"

.PP
Definition at line 31 of file lsevents\&.c\&.
.SS "\fBlsevents_event_names_t\fP* lsevents_event_names = NULL\fC [static]\fP"

.PP
Definition at line 60 of file lsevents\&.c\&.
.SS "pthread_mutex_t lsevents_listener_mutex\fC [static]\fP"

.PP
mutex to protect the listener linked list 
.PP
Definition at line 65 of file lsevents\&.c\&.
.SS "\fBlsevents_listener_t\fP* lsevents_listeners_p = NULL\fC [static]\fP"

.PP
Pointer to the first item in the link list of listeners\&. 
.PP
Definition at line 42 of file lsevents\&.c\&.
.SS "int lsevents_max_events = 1024\fC [static]\fP"

.PP
Definition at line 29 of file lsevents\&.c\&.
.SS "int lsevents_n_events = 0\fC [static]\fP"

.PP
Definition at line 30 of file lsevents\&.c\&.
.SS "\fBlsevents_queue_t\fP lsevents_queue[\fBLSEVENTS_QUEUE_LENGTH\fP]\fC [static]\fP"

.PP
simple list of events 
.PP
Definition at line 21 of file lsevents\&.c\&.
.SS "pthread_cond_t lsevents_queue_cond\fC [static]\fP"

.PP
condition to pause the queue if needed 
.PP
Definition at line 67 of file lsevents\&.c\&.
.SS "pthread_mutex_t lsevents_queue_mutex\fC [static]\fP"

.PP
mutex to protect the event queue 
.PP
Definition at line 66 of file lsevents\&.c\&.
.SS "unsigned int lsevents_queue_off = 0\fC [static]\fP"

.PP
next queue location to read 
.PP
Definition at line 23 of file lsevents\&.c\&.
.SS "unsigned int lsevents_queue_on = 0\fC [static]\fP"

.PP
next queue location to write 
.PP
Definition at line 22 of file lsevents\&.c\&.
.SS "pthread_t lsevents_thread\fC [static]\fP"

.PP
thread to run the event queue 
.PP
Definition at line 64 of file lsevents\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for LS-CAT PGPMAC from the source code\&.
