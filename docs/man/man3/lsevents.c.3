.TH "lsevents.c" 3 "Fri Dec 14 2012" "LS-CAT PGPMAC" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lsevents.c \- 
.PP
event subsystem for inter-pgpmac communication  

.SH SYNOPSIS
.br
.PP
\fC#include 'pgpmac\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBlsevents_queue_struct\fP"
.br
.RI "\fIStorage definition for the events\&. \fP"
.ti -1c
.RI "struct \fBlsevents_listener_struct\fP"
.br
.RI "\fILinked list of event listeners\&. \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBLSEVENTS_QUEUE_LENGTH\fP   2096"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct 
.br
\fBlsevents_queue_struct\fP \fBlsevents_queue_t\fP"
.br
.RI "\fIStorage definition for the events\&. \fP"
.ti -1c
.RI "typedef struct 
.br
\fBlsevents_listener_struct\fP \fBlsevents_listener_t\fP"
.br
.RI "\fILinked list of event listeners\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBlsevents_send_event\fP (char *fmt,\&.\&.\&.)"
.br
.RI "\fICall the callback routines for the given event\&. \fP"
.ti -1c
.RI "void \fBlsevents_add_listener\fP (char *event, void(*cb)(char *))"
.br
.RI "\fIAdd a callback routine to listen for a specific event\&. \fP"
.ti -1c
.RI "void \fBlsevents_remove_listener\fP (char *event, void(*cb)(char *))"
.br
.RI "\fIRemove a listener previously added with lsevents_add_listener\&. \fP"
.ti -1c
.RI "void * \fBlsevents_worker\fP (void *dummy)"
.br
.RI "\fIOur worker\&. \fP"
.ti -1c
.RI "void \fBlsevents_init\fP ()"
.br
.RI "\fIInitialize this module\&. \fP"
.ti -1c
.RI "void \fBlsevents_run\fP ()"
.br
.RI "\fIStart up the thread and get out of the way\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static \fBlsevents_queue_t\fP \fBlsevents_queue\fP [\fBLSEVENTS_QUEUE_LENGTH\fP]"
.br
.RI "\fIsimple list of events \fP"
.ti -1c
.RI "static unsigned int \fBlsevents_queue_on\fP = 0"
.br
.RI "\fInext queue location to write \fP"
.ti -1c
.RI "static unsigned int \fBlsevents_queue_off\fP = 0"
.br
.RI "\fInext queue location to read \fP"
.ti -1c
.RI "static \fBlsevents_listener_t\fP * \fBlsevents_listeners_p\fP = NULL"
.br
.RI "\fIPointer to the first item in the link list of listeners\&. \fP"
.ti -1c
.RI "static pthread_t \fBlsevents_thread\fP"
.br
.RI "\fIthread to run the event queue \fP"
.ti -1c
.RI "static pthread_mutex_t \fBlsevents_listener_mutex\fP"
.br
.RI "\fImutex to protect the listener linked list \fP"
.ti -1c
.RI "static pthread_mutex_t \fBlsevents_queue_mutex\fP"
.br
.RI "\fImutex to protect the event queue \fP"
.ti -1c
.RI "static pthread_cond_t \fBlsevents_queue_cond\fP"
.br
.RI "\fIcondition to pause the queue if needed \fP"
.in -1c
.SH "Detailed Description"
.PP 
event subsystem for inter-pgpmac communication 

\fBDate:\fP
.RS 4
2012 
.RE
.PP
\fBAuthor:\fP
.RS 4
Keith Brister 
.RE
.PP
\fBCopyright:\fP
.RS 4
All Rights Reserved 
.RE
.PP

.PP
Definition in file \fBlsevents\&.c\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define LSEVENTS_QUEUE_LENGTH   2096"

.PP
Definition at line 10 of file lsevents\&.c\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBlsevents_listener_struct\fP  \fBlsevents_listener_t\fP"

.PP
Linked list of event listeners\&. 
.SS "typedef struct \fBlsevents_queue_struct\fP  \fBlsevents_queue_t\fP"

.PP
Storage definition for the events\&. Just a string for now\&. Perhaps one day we'll succumb to the temptation to add an argument or two\&. 
.SH "Function Documentation"
.PP 
.SS "void lsevents_add_listener (char *event, void(*)(char *)cb)"

.PP
Add a callback routine to listen for a specific event\&. \fBParameters:\fP
.RS 4
\fIevent\fP the name of the event to listen for 
.br
\fIcb\fP the routine to call 
.RE
.PP

.PP
Definition at line 77 of file lsevents\&.c\&.
.PP
.nf
                                                             {
  lsevents_listener_t *new;
  int err;
  char *errbuf;
  int nerrbuf;



  new = calloc( 1, sizeof( lsevents_listener_t));
  if( new == NULL) {
    lslogging_log_message( 'lsevents_add_listener: out of memory');
    exit( -1);
  }

  err = regcomp( &new->re, event, REG_EXTENDED | REG_NOSUB);
  if( err != 0) {
    nerrbuf = regerror( err, &new->re, NULL, 0);
    errbuf = calloc( nerrbuf, sizeof( char));
    if( errbuf == NULL) {
      lslogging_log_message( 'lsevents_add_listener: out of memory (re)');
      exit( -1);
    }
    regerror( err, &new->re, errbuf, nerrbuf);
    lslogging_log_message( 'lsevents_add_listener: %s', errbuf);
    free( errbuf);
    free( new);
    return;
  }

  new->raw_regexp = strdup( event);
  new->cb   = cb;

  pthread_mutex_lock( &lsevents_listener_mutex);
  new->next = lsevents_listeners_p;
  lsevents_listeners_p = new;
  pthread_mutex_unlock( &lsevents_listener_mutex);

  lslogging_log_message( 'lsevents_add_listener: added listener for event %s', event);

}
.fi
.SS "void lsevents_init ()"

.PP
Initialize this module\&. 
.PP
Definition at line 206 of file lsevents\&.c\&.
.PP
.nf
                     {
  pthread_mutex_init( &lsevents_queue_mutex, NULL);
  pthread_cond_init(  &lsevents_queue_cond, NULL);
  pthread_mutex_init( &lsevents_listener_mutex, NULL);
}
.fi
.SS "void lsevents_remove_listener (char *event, void(*)(char *)cb)"

.PP
Remove a listener previously added with lsevents_add_listener\&. \fBParameters:\fP
.RS 4
\fIevent\fP The name of the event 
.br
\fIcb\fP The callback routine to remove 
.RE
.PP

.PP
Definition at line 122 of file lsevents\&.c\&.
.PP
.nf
                                                                {
  
  lsevents_listener_t *last, *current;

  //
  // Find the listener to remove
  // and unlink it from the list
  //
  pthread_mutex_lock( &lsevents_listener_mutex);
  last = NULL;
  for( current = lsevents_listeners_p; current != NULL; current = current->next) {
    if( strcmp( last->raw_regexp, event) == 0 && last->cb == cb) {
      if( last == NULL) {
        lsevents_listeners_p = current->next;
      } else {
        last->next = current->next;
      }
      break;
    }
  }
  pthread_mutex_unlock( &lsevents_listener_mutex);

  //
  // Now remove it
  //
  if( current != NULL) {
    if( current->raw_regexp != NULL)
      free( current->raw_regexp);
    free(current);
  }
}
.fi
.SS "void lsevents_run ()"

.PP
Start up the thread and get out of the way\&. 
.PP
Definition at line 214 of file lsevents\&.c\&.
.PP
.nf
                    {
  pthread_create( &lsevents_thread, NULL, lsevents_worker, NULL);
}
.fi
.SS "void lsevents_send_event (char *fmt, \&.\&.\&.)"

.PP
Call the callback routines for the given event\&. \fBParameters:\fP
.RS 4
\fIfmt\fP a printf style formating string 
.br
\fI\&.\&.\&.\fP list of arguments specified by the format string 
.RE
.PP

.PP
Definition at line 45 of file lsevents\&.c\&.
.PP
.nf
                                          {
  char event[LSEVENTS_EVENT_LENGTH];
  char *sp;
  va_list arg_ptr;

  va_start( arg_ptr, fmt);
  vsnprintf( event, sizeof(event)-1, fmt, arg_ptr);
  event[sizeof(event)-1]=0;
  va_end( arg_ptr);

  lslogging_log_message( 'lsevents_send_event: %s', event);

  pthread_mutex_lock( &lsevents_queue_mutex);

  // maybe wait for room on the queue
  while( lsevents_queue_on + 1 == lsevents_queue_off)
    pthread_cond_wait( &lsevents_queue_cond, &lsevents_queue_mutex);
  
  sp = lsevents_queue[(lsevents_queue_on++) % LSEVENTS_QUEUE_LENGTH]\&.event;
  strncpy( sp, event, LSEVENTS_EVENT_LENGTH);
  sp[LSEVENTS_EVENT_LENGTH - 1] = 0;

  pthread_cond_signal(  &lsevents_queue_cond);
  pthread_mutex_unlock( &lsevents_queue_mutex);

}
.fi
.SS "void* lsevents_worker (void *dummy)"

.PP
Our worker\&. \fBParameters:\fP
.RS 4
\fIdummy\fP Unused but needed by pthreads to be happy 
.RE
.PP

.PP
Definition at line 157 of file lsevents\&.c\&.
.PP
.nf
                       {
  
  char *event;
  lsevents_queue_t *ep;
  lsevents_listener_t *p;

  while( 1) {
    pthread_mutex_lock( &lsevents_queue_mutex);

    //
    // wait for someone to send an event
    //
    while( lsevents_queue_off == lsevents_queue_on)
      pthread_cond_wait( &lsevents_queue_cond, &lsevents_queue_mutex);

    //
    // copy event string since the value in the queue may change when
    // we unlock the mutex
    //
    ep = &(lsevents_queue[(lsevents_queue_off++) % LSEVENTS_QUEUE_LENGTH]);
    event = strndup( ep->event, LSEVENTS_EVENT_LENGTH-1);
    event[LSEVENTS_EVENT_LENGTH-1] = 0;

    //
    // let the send event process know there is room on the queue again
    //
    pthread_cond_signal(  &lsevents_queue_cond);
    pthread_mutex_unlock( &lsevents_queue_mutex);

    //
    // Find the callbacks and, well, call them back
    //
    pthread_mutex_lock( &lsevents_listener_mutex);
    for( p = lsevents_listeners_p; p != NULL; p = p->next) {
      if( regexec( &p->re, event, 0, NULL, 0) == 0) {
        p->cb( event);
      }
    }
    free( event);

    pthread_mutex_unlock( &lsevents_listener_mutex);
  }
  return NULL;
}
.fi
.SH "Variable Documentation"
.PP 
.SS "pthread_mutex_t lsevents_listener_mutex\fC [static]\fP"

.PP
mutex to protect the listener linked list 
.PP
Definition at line 37 of file lsevents\&.c\&.
.SS "\fBlsevents_listener_t\fP* lsevents_listeners_p = NULL\fC [static]\fP"

.PP
Pointer to the first item in the link list of listeners\&. 
.PP
Definition at line 34 of file lsevents\&.c\&.
.SS "\fBlsevents_queue_t\fP lsevents_queue[\fBLSEVENTS_QUEUE_LENGTH\fP]\fC [static]\fP"

.PP
simple list of events 
.PP
Definition at line 21 of file lsevents\&.c\&.
.SS "pthread_cond_t lsevents_queue_cond\fC [static]\fP"

.PP
condition to pause the queue if needed 
.PP
Definition at line 39 of file lsevents\&.c\&.
.SS "pthread_mutex_t lsevents_queue_mutex\fC [static]\fP"

.PP
mutex to protect the event queue 
.PP
Definition at line 38 of file lsevents\&.c\&.
.SS "unsigned int lsevents_queue_off = 0\fC [static]\fP"

.PP
next queue location to read 
.PP
Definition at line 23 of file lsevents\&.c\&.
.SS "unsigned int lsevents_queue_on = 0\fC [static]\fP"

.PP
next queue location to write 
.PP
Definition at line 22 of file lsevents\&.c\&.
.SS "pthread_t lsevents_thread\fC [static]\fP"

.PP
thread to run the event queue 
.PP
Definition at line 36 of file lsevents\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for LS-CAT PGPMAC from the source code\&.
