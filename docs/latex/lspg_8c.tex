\hypertarget{lspg_8c}{
\section{lspg.c File Reference}
\label{lspg_8c}\index{lspg.c@{lspg.c}}
}


Postgresql support for the LS-\/CAT pgpmac project.  
{\ttfamily \#include \char`\"{}pgpmac.h\char`\"{}}\par
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structlspgQueryQueueStruct}{lspgQueryQueueStruct}
\begin{DoxyCompactList}\small\item\em Store each query along with it's callback function. \item\end{DoxyCompactList}\item 
struct \hyperlink{structlspg__wait__for__detector__struct}{lspg\_\-wait\_\-for\_\-detector\_\-struct}
\begin{DoxyCompactList}\small\item\em Object that implements detector / spindle timing We use database locks for exposure control and this implements the md2 portion of this handshake. \item\end{DoxyCompactList}\item 
struct \hyperlink{structlspg__lock__diffractometer__struct}{lspg\_\-lock\_\-diffractometer\_\-struct}
\begin{DoxyCompactList}\small\item\em Object used to impliment locking the diffractometer Critical to exposure timing. \item\end{DoxyCompactList}\item 
struct \hyperlink{structlspg__lock__detector__struct}{lspg\_\-lock\_\-detector\_\-struct}
\begin{DoxyCompactList}\small\item\em lock detector object Implements detector lock for exposure control \item\end{DoxyCompactList}\item 
struct \hyperlink{structlspg__seq__run__prep__struct}{lspg\_\-seq\_\-run\_\-prep\_\-struct}
\begin{DoxyCompactList}\small\item\em Data collection running object. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{lspg_8c_af443092447378c73bf93aa143576aba4}{LS\_\-PG\_\-STATE\_\-INIT}~-\/4
\item 
\#define \hyperlink{lspg_8c_ae7ea5876846b5f04c419aee22d3c0aa1}{LS\_\-PG\_\-STATE\_\-INIT\_\-POLL}~-\/3
\item 
\#define \hyperlink{lspg_8c_accda8c3a598dc7f5b107b04986d8ab50}{LS\_\-PG\_\-STATE\_\-RESET}~-\/2
\item 
\#define \hyperlink{lspg_8c_ac70a1141f3b138055ea7143bd493187c}{LS\_\-PG\_\-STATE\_\-RESET\_\-POLL}~-\/1
\item 
\#define \hyperlink{lspg_8c_aaf1dd8ba4dafb91c296554c4cbf312e3}{LS\_\-PG\_\-STATE\_\-IDLE}~1
\item 
\#define \hyperlink{lspg_8c_a3c6eb19f262a990e1f9ba630d9edc309}{LS\_\-PG\_\-STATE\_\-SEND}~2
\item 
\#define \hyperlink{lspg_8c_a88a7e80c12fb0449c4b0857a0c7deb21}{LS\_\-PG\_\-STATE\_\-SEND\_\-FLUSH}~3
\item 
\#define \hyperlink{lspg_8c_a373e668840b4795ff9a71bc3f744d209}{LS\_\-PG\_\-STATE\_\-RECV}~4
\item 
\#define \hyperlink{lspg_8c_a08fe83fe8226002ee8b80ce0a914fd11}{LS\_\-PG\_\-QUERY\_\-QUEUE\_\-LENGTH}~256
\begin{DoxyCompactList}\small\item\em Queue length should be long enough that we do not ordinarly bump into the end We should be safe as long as the thread the adds stuff to the queue is not the one that removes it. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \hyperlink{structlspgQueryQueueStruct}{lspgQueryQueueStruct} \hyperlink{lspg_8c_ae57432c0a6ac48a50457815dab2c5b4c}{lspg\_\-query\_\-queue\_\-t}
\begin{DoxyCompactList}\small\item\em Store each query along with it's callback function. \item\end{DoxyCompactList}\item 
typedef struct \hyperlink{structlspg__wait__for__detector__struct}{lspg\_\-wait\_\-for\_\-detector\_\-struct} \hyperlink{lspg_8c_a6f273a499bf316de95df3816a9b1bc06}{lspg\_\-wait\_\-for\_\-detector\_\-t}
\begin{DoxyCompactList}\small\item\em Object that implements detector / spindle timing We use database locks for exposure control and this implements the md2 portion of this handshake. \item\end{DoxyCompactList}\item 
typedef struct \hyperlink{structlspg__lock__diffractometer__struct}{lspg\_\-lock\_\-diffractometer\_\-struct} \hyperlink{lspg_8c_a7232a0d630558f0c4c081d087150973d}{lspg\_\-lock\_\-diffractometer\_\-t}
\begin{DoxyCompactList}\small\item\em Object used to impliment locking the diffractometer Critical to exposure timing. \item\end{DoxyCompactList}\item 
typedef struct \hyperlink{structlspg__lock__detector__struct}{lspg\_\-lock\_\-detector\_\-struct} \hyperlink{lspg_8c_a3442e66a1f05457eb22a0d4a5d295f3a}{lspg\_\-lock\_\-detector\_\-t}
\begin{DoxyCompactList}\small\item\em lock detector object Implements detector lock for exposure control \item\end{DoxyCompactList}\item 
typedef struct \hyperlink{structlspg__seq__run__prep__struct}{lspg\_\-seq\_\-run\_\-prep\_\-struct} \hyperlink{lspg_8c_ab2da550aea6388c835abe0ee0b226eb0}{lspg\_\-seq\_\-run\_\-prep\_\-t}
\begin{DoxyCompactList}\small\item\em Data collection running object. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{structlspgQueryQueueStruct}{lspg\_\-query\_\-queue\_\-t} $\ast$ \hyperlink{lspg_8c_ad5f3ec8f197cc330c83dba70f310533c}{lspg\_\-query\_\-next} ()
\begin{DoxyCompactList}\small\item\em Return the next item in the postgresql queue. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a3847589e641f7e16a0cd68ef30e37cca}{lspg\_\-query\_\-reply\_\-next} ()
\begin{DoxyCompactList}\small\item\em Remove the oldest item in the queue. \item\end{DoxyCompactList}\item 
\hyperlink{structlspgQueryQueueStruct}{lspg\_\-query\_\-queue\_\-t} $\ast$ \hyperlink{lspg_8c_ae6bf4f54117bedf903360883bb32699f}{lspg\_\-query\_\-reply\_\-peek} ()
\begin{DoxyCompactList}\small\item\em Return the next item in the reply queue but don't pop it since we may need it more than once. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a0bb9ef42da8fa21c4df48ec384ab69f4}{lspg\_\-query\_\-push} (void($\ast$cb)(\hyperlink{structlspgQueryQueueStruct}{lspg\_\-query\_\-queue\_\-t} $\ast$, PGresult $\ast$), char $\ast$fmt,...)
\begin{DoxyCompactList}\small\item\em Place a query on the queue. \item\end{DoxyCompactList}\item 
char $\ast$$\ast$ \hyperlink{lspg_8c_a46f23ae999129d6fd5712d7975b99aed}{lspg\_\-array2ptrs} (char $\ast$a)
\begin{DoxyCompactList}\small\item\em returns a null terminated list of strings parsed from postgresql array \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a329a7fdfa5025a403ea2779e178fd3ed}{lspg\_\-init\_\-motors\_\-cb} (\hyperlink{structlspgQueryQueueStruct}{lspg\_\-query\_\-queue\_\-t} $\ast$qqp, PGresult $\ast$pgr)
\begin{DoxyCompactList}\small\item\em Motor initialization callback. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_af34559ab5624e1e68085dbcd9410c692}{lspg\_\-zoom\_\-lut\_\-cb} (\hyperlink{structlspgQueryQueueStruct}{lspg\_\-query\_\-queue\_\-t} $\ast$qqp, PGresult $\ast$pgr)
\begin{DoxyCompactList}\small\item\em Zoom motor look up table callback. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a71db585552ea3f58a1c9ab3fbe62bb79}{lspg\_\-scint\_\-lut\_\-cb} (\hyperlink{structlspgQueryQueueStruct}{lspg\_\-query\_\-queue\_\-t} $\ast$qqp, PGresult $\ast$pgr)
\item 
void \hyperlink{lspg_8c_ac5d5d512350a9ba346635e2415d7c3d5}{lspg\_\-flight\_\-lut\_\-cb} (\hyperlink{structlspgQueryQueueStruct}{lspg\_\-query\_\-queue\_\-t} $\ast$qqp, PGresult $\ast$pgr)
\begin{DoxyCompactList}\small\item\em Front Light Lookup table query callback Install the lookup table for the Front Light. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a6f5fa5727f2876f8b9370110a92afa50}{lspg\_\-blight\_\-lut\_\-cb} (\hyperlink{structlspgQueryQueueStruct}{lspg\_\-query\_\-queue\_\-t} $\ast$qqp, PGresult $\ast$pgr)
\begin{DoxyCompactList}\small\item\em Back Light Lookup Table Callback Install the lookup table for the Back Light. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a9e92a204f606761d368ac7e06ef0f09c}{lspg\_\-nextshot\_\-cb} (\hyperlink{structlspgQueryQueueStruct}{lspg\_\-query\_\-queue\_\-t} $\ast$qqp, PGresult $\ast$pgr)
\begin{DoxyCompactList}\small\item\em Next Shot Callback. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_aff91db7d60e6c832684c023813e36dbf}{lspg\_\-nextshot\_\-init} ()
\begin{DoxyCompactList}\small\item\em Initialize the nextshot variable, mutex, and condition. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_af17ef79544ca5d78fd477010fe90d538}{lspg\_\-nextshot\_\-call} ()
\begin{DoxyCompactList}\small\item\em Queue up a nextshot query. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a784a6de32a86fec9efb3ef3ae4b6e3ac}{lspg\_\-nextshot\_\-wait} ()
\begin{DoxyCompactList}\small\item\em Wait for the next shot query to get processed. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a50458a014041a4118452802dfb303960}{lspg\_\-nextshot\_\-done} ()
\begin{DoxyCompactList}\small\item\em Called when the next shot query has been processed. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a3517f8fbed91c998f6036284f9bd0c48}{lspg\_\-wait\_\-for\_\-detector\_\-init} ()
\begin{DoxyCompactList}\small\item\em initialize the detector timing object \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a5747c519d1aa4c310010a862cae8a823}{lspg\_\-wait\_\-for\_\-detector\_\-cb} (\hyperlink{structlspgQueryQueueStruct}{lspg\_\-query\_\-queue\_\-t} $\ast$qqp, PGresult $\ast$pgr)
\begin{DoxyCompactList}\small\item\em Callback for the wait for detector query. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a4b5222b859a44eae616804a1e990b86d}{lspg\_\-wait\_\-for\_\-detector\_\-call} ()
\begin{DoxyCompactList}\small\item\em initiate the wait for detector query \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_af094e01be121ce8e14abb679abd17e19}{lspg\_\-wait\_\-for\_\-detector\_\-wait} ()
\begin{DoxyCompactList}\small\item\em Pause the calling thread until the detector is ready Called by the MD2 thread. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_abb3645dee7c4514b650ab02f27570a69}{lspg\_\-wait\_\-for\_\-detector\_\-done} ()
\begin{DoxyCompactList}\small\item\em Done waiting for the detector. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_ab9780e15924a50b2a5545e10806000b3}{lspg\_\-wait\_\-for\_\-detector\_\-all} ()
\begin{DoxyCompactList}\small\item\em Combined call to wait for the detector. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a39bb94f8e0d47702b2b920a3dee61ebc}{lspg\_\-lock\_\-diffractometer\_\-init} ()
\begin{DoxyCompactList}\small\item\em initialize the diffractometer locking object \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_aad4f378f37c0030634dafa0d9445d916}{lspg\_\-lock\_\-diffractometer\_\-cb} (\hyperlink{structlspgQueryQueueStruct}{lspg\_\-query\_\-queue\_\-t} $\ast$qqp, PGresult $\ast$pgr)
\begin{DoxyCompactList}\small\item\em Callback routine for a lock diffractometer query. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_ac5ebeb38e8e9926a52f024fe76201175}{lspg\_\-lock\_\-diffractometer\_\-call} ()
\begin{DoxyCompactList}\small\item\em Request that the database grab the diffractometer lock. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a8445e1dec753f2c517b87fcb9c5b5943}{lspg\_\-lock\_\-diffractometer\_\-wait} ()
\begin{DoxyCompactList}\small\item\em Wait for the diffractometer lock. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a75aaf0b3fe33530062226c69a33ce821}{lspg\_\-lock\_\-diffractometer\_\-done} ()
\begin{DoxyCompactList}\small\item\em Finish up the lock diffractometer call. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a88b33e75c42197740b157a51ea726f21}{lspg\_\-lock\_\-diffractometer\_\-all} ()
\begin{DoxyCompactList}\small\item\em Convience function that combines lock diffractometer calls. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a0e9bbf847dadfe0d10830d67824d9be8}{lspg\_\-lock\_\-detector\_\-init} ()
\begin{DoxyCompactList}\small\item\em Initialize detector lock object. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_aa760191c2b443170cebbcbf5ea5345f3}{lspg\_\-lock\_\-detector\_\-cb} (\hyperlink{structlspgQueryQueueStruct}{lspg\_\-query\_\-queue\_\-t} $\ast$qqp, PGresult $\ast$pgr)
\begin{DoxyCompactList}\small\item\em Callback for when the detector lock has be grabbed. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a5f71a20cc297684b2afe28e7bd8e8383}{lspg\_\-lock\_\-detector\_\-call} ()
\begin{DoxyCompactList}\small\item\em Request (demand) a detector lock. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_ad3d9c56bd3ca6bcc43db30872cc441cc}{lspg\_\-lock\_\-detector\_\-wait} ()
\begin{DoxyCompactList}\small\item\em Wait for the detector lock. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a1b567040693ff6e2932a2477045d75fa}{lspg\_\-lock\_\-detector\_\-done} ()
\begin{DoxyCompactList}\small\item\em Finish waiting. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_aff93d2f5ac31aa249a0bef40a3837c84}{lspg\_\-lock\_\-detector\_\-all} ()
\begin{DoxyCompactList}\small\item\em Detector lock convinence function. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a31823ecb2b44d4a6674f804059a27bce}{lspg\_\-seq\_\-run\_\-prep\_\-init} ()
\begin{DoxyCompactList}\small\item\em Initialize the data collection object. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a11cda12050dc9a86188e15e2155a6013}{lspg\_\-seq\_\-run\_\-prep\_\-cb} (\hyperlink{structlspgQueryQueueStruct}{lspg\_\-query\_\-queue\_\-t} $\ast$qqp, PGresult $\ast$pgr)
\begin{DoxyCompactList}\small\item\em Callback for the seq\_\-run\_\-prep query. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_af7d6efd861b152a371442791deb42bd3}{lspg\_\-seq\_\-run\_\-prep\_\-call} (long long skey, double \hyperlink{pgpmac_8h_a0be79ccb7ebf3a665248fd856112b9fd}{kappa}, double \hyperlink{pgpmac_8h_ac8070dc568ad974a3db42b51eca828cc}{phi}, double cx, double cy, double ax, double ay, double az)
\begin{DoxyCompactList}\small\item\em queue up the seq\_\-run\_\-prep query \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_ac0b01f501322432a8fa37f31898c3499}{lspg\_\-seq\_\-run\_\-prep\_\-wait} ()
\begin{DoxyCompactList}\small\item\em Wait for seq run prep query to return. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a472b09ddf716c80207f97e2bb5d37d66}{lspg\_\-seq\_\-run\_\-prep\_\-done} ()
\begin{DoxyCompactList}\small\item\em Indicate we are done waiting. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a4253474d4dd305aec0afdd5552b3ddd5}{lspg\_\-seq\_\-run\_\-prep\_\-all} (long long skey, double \hyperlink{pgpmac_8h_a0be79ccb7ebf3a665248fd856112b9fd}{kappa}, double \hyperlink{pgpmac_8h_ac8070dc568ad974a3db42b51eca828cc}{phi}, double cx, double cy, double ax, double ay, double az)
\begin{DoxyCompactList}\small\item\em Convinence function to call seq run prep. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a8184824f2b71b1d35141d7922ca69cd7}{lspg\_\-getcenter\_\-cb} (\hyperlink{structlspgQueryQueueStruct}{lspg\_\-query\_\-queue\_\-t} $\ast$qqp, PGresult $\ast$pgr)
\begin{DoxyCompactList}\small\item\em TODO: implement getcenter code. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_ad31db17587a02302ac4e40fb7d260b1b}{lspg\_\-getcenter\_\-init} ()
\begin{DoxyCompactList}\small\item\em Initialize getcenter object. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a6f7cd0a06f6a266ef65b3604cf33d6c4}{lspg\_\-getcenter\_\-call} ()
\begin{DoxyCompactList}\small\item\em Request a getcenter query. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a3e0e4b3cb9fa03961ee0c104e0b06754}{lspg\_\-getcenter\_\-wait} ()
\begin{DoxyCompactList}\small\item\em Wait for a getcenter query to return. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a7c678553b44c874d08ec9966ed7bb1c0}{lspg\_\-getcenter\_\-done} ()
\begin{DoxyCompactList}\small\item\em Done with getcenter query. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a523b492d9cd4970853eabee2d3c31578}{lspg\_\-getcenter\_\-all} ()
\begin{DoxyCompactList}\small\item\em Convenience function to complete synchronous getcenter query. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_aeda8dad89b03d7d61cc994dd63ee5db6}{lspg\_\-nextaction\_\-cb} (\hyperlink{structlspgQueryQueueStruct}{lspg\_\-query\_\-queue\_\-t} $\ast$qqp, PGresult $\ast$pgr)
\begin{DoxyCompactList}\small\item\em Queue the next MD2 instruction. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a6de3621552c9265950a0df573429c519}{lspg\_\-kvs\_\-cb} (\hyperlink{structlspgQueryQueueStruct}{lspg\_\-query\_\-queue\_\-t} $\ast$qqp, PGresult $\ast$pgr)
\begin{DoxyCompactList}\small\item\em retrieve kv pairs with new values \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a1e11f525ca0f9ac9ab71f9fbe983c42b}{lspg\_\-cmd\_\-cb} (\hyperlink{structlspgQueryQueueStruct}{lspg\_\-query\_\-queue\_\-t} $\ast$qqp, PGresult $\ast$pgr)
\begin{DoxyCompactList}\small\item\em Send strings directly to PMAC queue. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_af6485ac1749c5de3008dd0e0badaa09c}{lspg\_\-flush} ()
\begin{DoxyCompactList}\small\item\em Flush psql output buffer (ie, send the query). \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a714b15e117ffe7bfce4f2f2ce4725b0a}{lspg\_\-send\_\-next\_\-query} ()
\begin{DoxyCompactList}\small\item\em send the next queued query to the DB server \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a038c5af23469b789fc1c55d21cb43029}{lspg\_\-receive} ()
\begin{DoxyCompactList}\small\item\em Receive a result of a query. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a049f4422994aa2eb2b841ffb2937f895}{lspg\_\-sig\_\-service} (struct pollfd $\ast$evt)
\begin{DoxyCompactList}\small\item\em Service a signal Signals here are treated as file descriptors and fits into our poll scheme. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_aa8d1fed4b461c2139a21826d524777d5}{lspg\_\-pg\_\-service} (struct pollfd $\ast$evt)
\begin{DoxyCompactList}\small\item\em I/O control to/from the postgresql server. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a581c18be0368425665a40b4b7f7d9714}{lspg\_\-pg\_\-connect} ()
\begin{DoxyCompactList}\small\item\em Connect to the pg server. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_ab52a8c8245bf6561f40c0f224fc07ff4}{lspg\_\-next\_\-state} ()
\begin{DoxyCompactList}\small\item\em Implements our state machine Does not strictly only set the next state as it also calls some functions that, perhaps, alters the state mid-\/function. \item\end{DoxyCompactList}\item 
void $\ast$ \hyperlink{lspg_8c_aaf4fadd2943fa3a2ecb5d840e84d68fa}{lspg\_\-worker} (void $\ast$dummy)
\begin{DoxyCompactList}\small\item\em The main loop for the lspg thread. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a8a77972df14166e05c94ed0792baa09b}{lspg\_\-init} ()
\begin{DoxyCompactList}\small\item\em Initiallize the lspg module. \item\end{DoxyCompactList}\item 
void \hyperlink{lspg_8c_a1adfdb5ca9fdb5060849d726bf540117}{lspg\_\-run} ()
\begin{DoxyCompactList}\small\item\em Start 'er runnin'. \item\end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{lspg_8c_a4937baac0cc78ea306d58b5f027867f1}{ls\_\-pg\_\-state} = LS\_\-PG\_\-STATE\_\-INIT
\begin{DoxyCompactList}\small\item\em State of the lspg state machine. \item\end{DoxyCompactList}\item 
static struct timeval lspg\_\-time\_\-sent \hyperlink{lspg_8c_ad40ac52086f6b774928af45b09d54c6e}{now}
\begin{DoxyCompactList}\small\item\em used to ensure we do not inundate the db server with connection requests \item\end{DoxyCompactList}\item 
static pthread\_\-t \hyperlink{lspg_8c_a04eb0cda0d5e5afeae7c393b51689765}{lspg\_\-thread}
\begin{DoxyCompactList}\small\item\em our worker thread \item\end{DoxyCompactList}\item 
static pthread\_\-mutex\_\-t \hyperlink{lspg_8c_aed46a94106c583796e3a8ca0e89aa8e4}{lspg\_\-queue\_\-mutex}
\begin{DoxyCompactList}\small\item\em keep the queue from getting tangled \item\end{DoxyCompactList}\item 
static pthread\_\-cond\_\-t \hyperlink{lspg_8c_a61a308b6a37afd645beb422653b95baa}{lspg\_\-queue\_\-cond}
\begin{DoxyCompactList}\small\item\em keeps the queue from overflowing \item\end{DoxyCompactList}\item 
static struct pollfd \hyperlink{lspg_8c_af3f897b8ffa020ca54289bc5b28cb64d}{lspgfd}
\begin{DoxyCompactList}\small\item\em our poll info \item\end{DoxyCompactList}\item 
static \hyperlink{structlspgQueryQueueStruct}{lspg\_\-query\_\-queue\_\-t} \hyperlink{lspg_8c_a357d9d98f0b8c9625ccebcebfcdce955}{lspg\_\-query\_\-queue} \mbox{[}LS\_\-PG\_\-QUERY\_\-QUEUE\_\-LENGTH\mbox{]}
\begin{DoxyCompactList}\small\item\em Our query queue. \item\end{DoxyCompactList}\item 
static unsigned int \hyperlink{lspg_8c_a3cbe7f3161b3c1838ebc56a3bbcfd8a6}{lspg\_\-query\_\-queue\_\-on} = 0
\begin{DoxyCompactList}\small\item\em Next position to add something to the queue. \item\end{DoxyCompactList}\item 
static unsigned int \hyperlink{lspg_8c_aca86bb77d6cecfae9251743f4171bafb}{lspg\_\-query\_\-queue\_\-off} = 0
\begin{DoxyCompactList}\small\item\em The last item still being used (on == off means nothing in queue). \item\end{DoxyCompactList}\item 
static unsigned int \hyperlink{lspg_8c_a2603b071afdbff7c0924b13de2454264}{lspg\_\-query\_\-queue\_\-reply} = 0
\begin{DoxyCompactList}\small\item\em The current item being digested. \item\end{DoxyCompactList}\item 
static PGconn $\ast$ \hyperlink{lspg_8c_a9012783dbbadf652a81649a289697cf3}{q} = NULL
\begin{DoxyCompactList}\small\item\em Database connector. \item\end{DoxyCompactList}\item 
static PostgresPollingStatusType \hyperlink{lspg_8c_a69ae04978986e6413ca7cefcb692b645}{lspg\_\-connectPoll\_\-response}
\begin{DoxyCompactList}\small\item\em Used to determine state while connecting. \item\end{DoxyCompactList}\item 
static PostgresPollingStatusType \hyperlink{lspg_8c_a06c5a937e41a6c706a247777642ec1fb}{lspg\_\-resetPoll\_\-response}
\begin{DoxyCompactList}\small\item\em Used to determine state while reconnecting. \item\end{DoxyCompactList}\item 
\hyperlink{structlspg__nextshot__struct}{lspg\_\-nextshot\_\-t} \hyperlink{lspg_8c_ad8d8e2f578ca79189a80c1fd5b60cefd}{lspg\_\-nextshot}
\begin{DoxyCompactList}\small\item\em the nextshot object \item\end{DoxyCompactList}\item 
\hyperlink{structlspg__getcenter__struct}{lspg\_\-getcenter\_\-t} \hyperlink{lspg_8c_a7ef8a09203117578c9b2ce4719519f36}{lspg\_\-getcenter}
\begin{DoxyCompactList}\small\item\em the getcenter object \item\end{DoxyCompactList}\item 
static \hyperlink{structlspg__wait__for__detector__struct}{lspg\_\-wait\_\-for\_\-detector\_\-t} \hyperlink{lspg_8c_a0dfc8d0410cd2d7f7da7a70d3ef88e58}{lspg\_\-wait\_\-for\_\-detector}
\begin{DoxyCompactList}\small\item\em Instance of the detector timing object. \item\end{DoxyCompactList}\item 
static \hyperlink{structlspg__lock__diffractometer__struct}{lspg\_\-lock\_\-diffractometer\_\-t} \hyperlink{lspg_8c_aaae7ce3ecd7d54a9e46c41d7a742a454}{lspg\_\-lock\_\-diffractometer}
\item 
static \hyperlink{structlspg__lock__detector__struct}{lspg\_\-lock\_\-detector\_\-t} \hyperlink{lspg_8c_adbf3b3652c6531c3d194320d1abc1c80}{lspg\_\-lock\_\-detector}
\item 
static \hyperlink{structlspg__seq__run__prep__struct}{lspg\_\-seq\_\-run\_\-prep\_\-t} \hyperlink{lspg_8c_a1b0d9fc30bcea6905b075d2362149172}{lspg\_\-seq\_\-run\_\-prep}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Postgresql support for the LS-\/CAT pgpmac project. \begin{DoxyDate}{Date}
2012 
\end{DoxyDate}
\begin{DoxyAuthor}{Author}
Keith Brister  All Rights Reserved
\end{DoxyAuthor}

\begin{DoxyPre}
  Database state machine\end{DoxyPre}



\begin{DoxyPre}State		Description\end{DoxyPre}



\begin{DoxyPre} -4		Initiate connection
 -3		Poll until connection initialization is complete
 -2		Initiate reset
 -1		Poll until connection reset is complete
  1		Idle (wait for a notify from the server)
  2		Send a query to the server
  3		Continue flushing a command to the server
  4		Waiting for a reply
\end{DoxyPre}
 

Definition in file \hyperlink{lspg_8c_source}{lspg.c}.

\subsection{Define Documentation}
\hypertarget{lspg_8c_a08fe83fe8226002ee8b80ce0a914fd11}{
\index{lspg.c@{lspg.c}!LS\_\-PG\_\-QUERY\_\-QUEUE\_\-LENGTH@{LS\_\-PG\_\-QUERY\_\-QUEUE\_\-LENGTH}}
\index{LS\_\-PG\_\-QUERY\_\-QUEUE\_\-LENGTH@{LS\_\-PG\_\-QUERY\_\-QUEUE\_\-LENGTH}!lspg.c@{lspg.c}}
\subsubsection[{LS\_\-PG\_\-QUERY\_\-QUEUE\_\-LENGTH}]{\setlength{\rightskip}{0pt plus 5cm}\#define LS\_\-PG\_\-QUERY\_\-QUEUE\_\-LENGTH~256}}
\label{lspg_8c_a08fe83fe8226002ee8b80ce0a914fd11}


Queue length should be long enough that we do not ordinarly bump into the end We should be safe as long as the thread the adds stuff to the queue is not the one that removes it. (And we can tolerate the adding thread being paused.) 

Definition at line 60 of file lspg.c.\hypertarget{lspg_8c_aaf1dd8ba4dafb91c296554c4cbf312e3}{
\index{lspg.c@{lspg.c}!LS\_\-PG\_\-STATE\_\-IDLE@{LS\_\-PG\_\-STATE\_\-IDLE}}
\index{LS\_\-PG\_\-STATE\_\-IDLE@{LS\_\-PG\_\-STATE\_\-IDLE}!lspg.c@{lspg.c}}
\subsubsection[{LS\_\-PG\_\-STATE\_\-IDLE}]{\setlength{\rightskip}{0pt plus 5cm}\#define LS\_\-PG\_\-STATE\_\-IDLE~1}}
\label{lspg_8c_aaf1dd8ba4dafb91c296554c4cbf312e3}


Definition at line 34 of file lspg.c.\hypertarget{lspg_8c_af443092447378c73bf93aa143576aba4}{
\index{lspg.c@{lspg.c}!LS\_\-PG\_\-STATE\_\-INIT@{LS\_\-PG\_\-STATE\_\-INIT}}
\index{LS\_\-PG\_\-STATE\_\-INIT@{LS\_\-PG\_\-STATE\_\-INIT}!lspg.c@{lspg.c}}
\subsubsection[{LS\_\-PG\_\-STATE\_\-INIT}]{\setlength{\rightskip}{0pt plus 5cm}\#define LS\_\-PG\_\-STATE\_\-INIT~-\/4}}
\label{lspg_8c_af443092447378c73bf93aa143576aba4}


Definition at line 30 of file lspg.c.\hypertarget{lspg_8c_ae7ea5876846b5f04c419aee22d3c0aa1}{
\index{lspg.c@{lspg.c}!LS\_\-PG\_\-STATE\_\-INIT\_\-POLL@{LS\_\-PG\_\-STATE\_\-INIT\_\-POLL}}
\index{LS\_\-PG\_\-STATE\_\-INIT\_\-POLL@{LS\_\-PG\_\-STATE\_\-INIT\_\-POLL}!lspg.c@{lspg.c}}
\subsubsection[{LS\_\-PG\_\-STATE\_\-INIT\_\-POLL}]{\setlength{\rightskip}{0pt plus 5cm}\#define LS\_\-PG\_\-STATE\_\-INIT\_\-POLL~-\/3}}
\label{lspg_8c_ae7ea5876846b5f04c419aee22d3c0aa1}


Definition at line 31 of file lspg.c.\hypertarget{lspg_8c_a373e668840b4795ff9a71bc3f744d209}{
\index{lspg.c@{lspg.c}!LS\_\-PG\_\-STATE\_\-RECV@{LS\_\-PG\_\-STATE\_\-RECV}}
\index{LS\_\-PG\_\-STATE\_\-RECV@{LS\_\-PG\_\-STATE\_\-RECV}!lspg.c@{lspg.c}}
\subsubsection[{LS\_\-PG\_\-STATE\_\-RECV}]{\setlength{\rightskip}{0pt plus 5cm}\#define LS\_\-PG\_\-STATE\_\-RECV~4}}
\label{lspg_8c_a373e668840b4795ff9a71bc3f744d209}


Definition at line 37 of file lspg.c.\hypertarget{lspg_8c_accda8c3a598dc7f5b107b04986d8ab50}{
\index{lspg.c@{lspg.c}!LS\_\-PG\_\-STATE\_\-RESET@{LS\_\-PG\_\-STATE\_\-RESET}}
\index{LS\_\-PG\_\-STATE\_\-RESET@{LS\_\-PG\_\-STATE\_\-RESET}!lspg.c@{lspg.c}}
\subsubsection[{LS\_\-PG\_\-STATE\_\-RESET}]{\setlength{\rightskip}{0pt plus 5cm}\#define LS\_\-PG\_\-STATE\_\-RESET~-\/2}}
\label{lspg_8c_accda8c3a598dc7f5b107b04986d8ab50}


Definition at line 32 of file lspg.c.\hypertarget{lspg_8c_ac70a1141f3b138055ea7143bd493187c}{
\index{lspg.c@{lspg.c}!LS\_\-PG\_\-STATE\_\-RESET\_\-POLL@{LS\_\-PG\_\-STATE\_\-RESET\_\-POLL}}
\index{LS\_\-PG\_\-STATE\_\-RESET\_\-POLL@{LS\_\-PG\_\-STATE\_\-RESET\_\-POLL}!lspg.c@{lspg.c}}
\subsubsection[{LS\_\-PG\_\-STATE\_\-RESET\_\-POLL}]{\setlength{\rightskip}{0pt plus 5cm}\#define LS\_\-PG\_\-STATE\_\-RESET\_\-POLL~-\/1}}
\label{lspg_8c_ac70a1141f3b138055ea7143bd493187c}


Definition at line 33 of file lspg.c.\hypertarget{lspg_8c_a3c6eb19f262a990e1f9ba630d9edc309}{
\index{lspg.c@{lspg.c}!LS\_\-PG\_\-STATE\_\-SEND@{LS\_\-PG\_\-STATE\_\-SEND}}
\index{LS\_\-PG\_\-STATE\_\-SEND@{LS\_\-PG\_\-STATE\_\-SEND}!lspg.c@{lspg.c}}
\subsubsection[{LS\_\-PG\_\-STATE\_\-SEND}]{\setlength{\rightskip}{0pt plus 5cm}\#define LS\_\-PG\_\-STATE\_\-SEND~2}}
\label{lspg_8c_a3c6eb19f262a990e1f9ba630d9edc309}


Definition at line 35 of file lspg.c.\hypertarget{lspg_8c_a88a7e80c12fb0449c4b0857a0c7deb21}{
\index{lspg.c@{lspg.c}!LS\_\-PG\_\-STATE\_\-SEND\_\-FLUSH@{LS\_\-PG\_\-STATE\_\-SEND\_\-FLUSH}}
\index{LS\_\-PG\_\-STATE\_\-SEND\_\-FLUSH@{LS\_\-PG\_\-STATE\_\-SEND\_\-FLUSH}!lspg.c@{lspg.c}}
\subsubsection[{LS\_\-PG\_\-STATE\_\-SEND\_\-FLUSH}]{\setlength{\rightskip}{0pt plus 5cm}\#define LS\_\-PG\_\-STATE\_\-SEND\_\-FLUSH~3}}
\label{lspg_8c_a88a7e80c12fb0449c4b0857a0c7deb21}


Definition at line 36 of file lspg.c.

\subsection{Typedef Documentation}
\hypertarget{lspg_8c_a3442e66a1f05457eb22a0d4a5d295f3a}{
\index{lspg.c@{lspg.c}!lspg\_\-lock\_\-detector\_\-t@{lspg\_\-lock\_\-detector\_\-t}}
\index{lspg\_\-lock\_\-detector\_\-t@{lspg\_\-lock\_\-detector\_\-t}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-lock\_\-detector\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf lspg\_\-lock\_\-detector\_\-struct}  {\bf lspg\_\-lock\_\-detector\_\-t}}}
\label{lspg_8c_a3442e66a1f05457eb22a0d4a5d295f3a}


lock detector object Implements detector lock for exposure control \hypertarget{lspg_8c_a7232a0d630558f0c4c081d087150973d}{
\index{lspg.c@{lspg.c}!lspg\_\-lock\_\-diffractometer\_\-t@{lspg\_\-lock\_\-diffractometer\_\-t}}
\index{lspg\_\-lock\_\-diffractometer\_\-t@{lspg\_\-lock\_\-diffractometer\_\-t}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-lock\_\-diffractometer\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf lspg\_\-lock\_\-diffractometer\_\-struct}  {\bf lspg\_\-lock\_\-diffractometer\_\-t}}}
\label{lspg_8c_a7232a0d630558f0c4c081d087150973d}


Object used to impliment locking the diffractometer Critical to exposure timing. \hypertarget{lspg_8c_ae57432c0a6ac48a50457815dab2c5b4c}{
\index{lspg.c@{lspg.c}!lspg\_\-query\_\-queue\_\-t@{lspg\_\-query\_\-queue\_\-t}}
\index{lspg\_\-query\_\-queue\_\-t@{lspg\_\-query\_\-queue\_\-t}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-query\_\-queue\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf lspgQueryQueueStruct}  {\bf lspg\_\-query\_\-queue\_\-t}}}
\label{lspg_8c_ae57432c0a6ac48a50457815dab2c5b4c}


Store each query along with it's callback function. All calls are asynchronous \hypertarget{lspg_8c_ab2da550aea6388c835abe0ee0b226eb0}{
\index{lspg.c@{lspg.c}!lspg\_\-seq\_\-run\_\-prep\_\-t@{lspg\_\-seq\_\-run\_\-prep\_\-t}}
\index{lspg\_\-seq\_\-run\_\-prep\_\-t@{lspg\_\-seq\_\-run\_\-prep\_\-t}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-seq\_\-run\_\-prep\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf lspg\_\-seq\_\-run\_\-prep\_\-struct}  {\bf lspg\_\-seq\_\-run\_\-prep\_\-t}}}
\label{lspg_8c_ab2da550aea6388c835abe0ee0b226eb0}


Data collection running object. \hypertarget{lspg_8c_a6f273a499bf316de95df3816a9b1bc06}{
\index{lspg.c@{lspg.c}!lspg\_\-wait\_\-for\_\-detector\_\-t@{lspg\_\-wait\_\-for\_\-detector\_\-t}}
\index{lspg\_\-wait\_\-for\_\-detector\_\-t@{lspg\_\-wait\_\-for\_\-detector\_\-t}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-wait\_\-for\_\-detector\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf lspg\_\-wait\_\-for\_\-detector\_\-struct}  {\bf lspg\_\-wait\_\-for\_\-detector\_\-t}}}
\label{lspg_8c_a6f273a499bf316de95df3816a9b1bc06}


Object that implements detector / spindle timing We use database locks for exposure control and this implements the md2 portion of this handshake. 

\subsection{Function Documentation}
\hypertarget{lspg_8c_a46f23ae999129d6fd5712d7975b99aed}{
\index{lspg.c@{lspg.c}!lspg\_\-array2ptrs@{lspg\_\-array2ptrs}}
\index{lspg\_\-array2ptrs@{lspg\_\-array2ptrs}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-array2ptrs}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$$\ast$ lspg\_\-array2ptrs (char $\ast$ {\em a})}}
\label{lspg_8c_a46f23ae999129d6fd5712d7975b99aed}


returns a null terminated list of strings parsed from postgresql array 

Definition at line 165 of file lspg.c.


\begin{DoxyCode}
165                                  {
166   char **rtn, *sp, *acums;
167   int i, n, inquote, havebackslash, rtni;;
168   int mxsz;
169   
170   inquote       = 0;
171   havebackslash = 0;
172 
173   // Despense with the null input condition before we complicate the code below
174   if( a == NULL || a[0] == 0)
175     return NULL;
176 
177   // Count the maximum number of strings
178   // Actual number will be less if there are quoted commas
179   //
180   n = 1;
181   for( i=0; a[i]; i++) {
182     if( a[i] == ',')
183       n++;
184   }
185   //
186   // The maximum size of any string is the length of a (+1)
187   //
188   mxsz = strlen(a) + 1;
189 
190   // This is the accumulation string to make up the array elements
191   acums = (char *)calloc( mxsz, sizeof( char));
192   if( acums == NULL) {
193     // TODO: print or otherwise log this condition
194     // out of memory
195     exit( 1);
196   }
197   
198   //
199   // allocate storage for the pointer array and the null terminator
200   //
201   rtn = (char **)calloc( n+1, sizeof( char *));
202   if( rtn == NULL) {
203     // TODO: print or otherwise log this condition
204     // out of memory
205     exit( 1);
206   }
207   rtni = 0;
208   
209   lslogging_log_message( "lspg_array2ptrs: enter with %s", a);
210 
211 
212   // Go through and create the individual strings
213   sp = acums;
214   *sp = 0;
215   if( a[0] != '{') {
216     // oh no!  This isn't an array after all!
217     // Zounds!
218     return NULL;
219   }
220   inquote = 0;
221   havebackslash = 0;
222   for( i=1; a[i] != 0; i++) {
223     switch( a[i]) {
224     case '"':
225       if( havebackslash) {
226         // a quoted quote.  Cool
227         //
228         *(sp++) = a[i];
229         *sp = 0;
230         havebackslash = 0;
231       } else {
232         // Toggle the flag
233         inquote = 1 - inquote;
234       }
235       break;
236 
237     case '\\':
238       if( havebackslash) {
239         *(sp++) = a[i];
240         *sp = 0;
241         havebackslash = 0;
242       } else {
243         havebackslash = 1;
244       }
245       break;
246 
247     case ',':
248       if( inquote || havebackslash) {
249         *(sp++) = a[i];
250         *sp = 0;
251         havebackslash = 0;
252       } else {
253         rtn[rtni++] = strdup( acums);
254         sp = acums;
255       }
256       break;
257       
258     case '}':
259       if( inquote || havebackslash) {
260         *(sp++) = a[i];
261         *sp = 0;
262         havebackslash = 0;
263       } else {
264         rtn[rtni++] = strdup( acums);
265         rtn[rtni]   = NULL;
266         return( rtn);
267       }
268       break;
269 
270     default:
271       *(sp++) = a[i];
272       *sp = 0;
273       havebackslash = 0;
274     }
275   }
276   //
277   // Getting here means the final '}' was missing
278   // Probably we should throw an error or log it or something.
279   //
280   rtn[rtni++] = strdup( acums);
281   rtn[rtni]   = NULL;
282   return( rtn);
283 }
\end{DoxyCode}
\hypertarget{lspg_8c_a6f5fa5727f2876f8b9370110a92afa50}{
\index{lspg.c@{lspg.c}!lspg\_\-blight\_\-lut\_\-cb@{lspg\_\-blight\_\-lut\_\-cb}}
\index{lspg\_\-blight\_\-lut\_\-cb@{lspg\_\-blight\_\-lut\_\-cb}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-blight\_\-lut\_\-cb}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-blight\_\-lut\_\-cb ({\bf lspg\_\-query\_\-queue\_\-t} $\ast$ {\em qqp}, \/  PGresult $\ast$ {\em pgr})}}
\label{lspg_8c_a6f5fa5727f2876f8b9370110a92afa50}


Back Light Lookup Table Callback Install the lookup table for the Back Light. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em qqp}]Our query \item[\mbox{$\leftarrow$} {\em pgr}]The query's result \end{DoxyParams}


Definition at line 421 of file lspg.c.


\begin{DoxyCode}
424                           {
425   int i;
426   
427   pthread_mutex_lock( &(blight->mutex));
428 
429   blight->nlut = PQntuples( pgr)/2;
430   blight->lut  = calloc( 2*blight->nlut, sizeof(double));
431   if( blight->lut == NULL) {
432     lslogging_log_message( "Out of memmory (lspg_blight_lut_cb)");
433     pthread_mutex_unlock( &(blight->mutex));
434     return;
435   }
436   
437   for( i=0; i<PQntuples( pgr); i++) {
438     blight->lut[i] = strtod( PQgetvalue( pgr, i, 0), NULL);
439   }
440 
441   pthread_mutex_unlock( &(blight->mutex));
442 
443 }
\end{DoxyCode}
\hypertarget{lspg_8c_a1e11f525ca0f9ac9ab71f9fbe983c42b}{
\index{lspg.c@{lspg.c}!lspg\_\-cmd\_\-cb@{lspg\_\-cmd\_\-cb}}
\index{lspg\_\-cmd\_\-cb@{lspg\_\-cmd\_\-cb}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-cmd\_\-cb}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-cmd\_\-cb ({\bf lspg\_\-query\_\-queue\_\-t} $\ast$ {\em qqp}, \/  PGresult $\ast$ {\em pgr})}}
\label{lspg_8c_a1e11f525ca0f9ac9ab71f9fbe983c42b}


Send strings directly to PMAC queue. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em qqp}]Our query \item[\mbox{$\leftarrow$} {\em pgr}]Our result \end{DoxyParams}


Definition at line 1137 of file lspg.c.


\begin{DoxyCode}
1140                    {
1141   //
1142   // Call back funciton assumes query results in zero or more commands to send to
       the PMAC
1143   //
1144   int i;
1145   char *sp;
1146   
1147   for( i=0; i<PQntuples( pgr); i++) {
1148     sp = PQgetvalue( pgr, i, 0);
1149     if( sp != NULL && *sp != 0) {
1150       lspmac_SockSendline( sp);
1151       //
1152       // Keep asking for more until
1153       // there are no commands left
1154       // 
1155       // This should solve a potential problem where
1156       // more than one command is put on the queue for a given notify.
1157       //
1158       lspg_query_push( lspg_cmd_cb, "select pmac.md2_queue_next()");
1159     }
1160   }
1161 }
\end{DoxyCode}
\hypertarget{lspg_8c_ac5d5d512350a9ba346635e2415d7c3d5}{
\index{lspg.c@{lspg.c}!lspg\_\-flight\_\-lut\_\-cb@{lspg\_\-flight\_\-lut\_\-cb}}
\index{lspg\_\-flight\_\-lut\_\-cb@{lspg\_\-flight\_\-lut\_\-cb}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-flight\_\-lut\_\-cb}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-flight\_\-lut\_\-cb ({\bf lspg\_\-query\_\-queue\_\-t} $\ast$ {\em qqp}, \/  PGresult $\ast$ {\em pgr})}}
\label{lspg_8c_ac5d5d512350a9ba346635e2415d7c3d5}


Front Light Lookup table query callback Install the lookup table for the Front Light. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em qqp}]Our query \item[\mbox{$\leftarrow$} {\em pgr}]Our result object \end{DoxyParams}


Definition at line 393 of file lspg.c.


\begin{DoxyCode}
396                           {
397   int i;
398   
399   pthread_mutex_lock( &(flight->mutex));
400 
401   flight->nlut = PQntuples( pgr)/2;
402   flight->lut  = calloc( 2*flight->nlut, sizeof(double));
403   if( flight->lut == NULL) {
404     lslogging_log_message( "Out of memmory (lspg_flight_lut_cb)");
405     pthread_mutex_unlock( &(flight->mutex));
406     return;
407   }
408   
409   for( i=0; i<PQntuples( pgr); i++) {
410     flight->lut[i] = strtod( PQgetvalue( pgr, i, 0), NULL);
411   }
412 
413   pthread_mutex_unlock( &(flight->mutex));
414 
415 }
\end{DoxyCode}
\hypertarget{lspg_8c_af6485ac1749c5de3008dd0e0badaa09c}{
\index{lspg.c@{lspg.c}!lspg\_\-flush@{lspg\_\-flush}}
\index{lspg\_\-flush@{lspg\_\-flush}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-flush}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-flush ()}}
\label{lspg_8c_af6485ac1749c5de3008dd0e0badaa09c}


Flush psql output buffer (ie, send the query). 

Definition at line 1166 of file lspg.c.


\begin{DoxyCode}
1166                   {
1167   int err;
1168 
1169   err = PQflush( q);
1170   switch( err) {
1171   case -1:
1172     // an error occured
1173 
1174     lslogging_log_message( "flush failed: %s", PQerrorMessage( q));
1175 
1176     ls_pg_state = LS_PG_STATE_IDLE;
1177     //
1178     // We should probably reset the connection and start from scratch.  Probably 
      the connection died.
1179     //
1180     break;
1181           
1182   case 0:
1183     // goodness and joy.
1184     ls_pg_state = LS_PG_STATE_RECV;
1185     break;
1186 
1187   case 1:
1188     // more sending to do
1189     ls_pg_state = LS_PG_STATE_SEND_FLUSH;
1190     break;
1191   }
1192 }
\end{DoxyCode}
\hypertarget{lspg_8c_a523b492d9cd4970853eabee2d3c31578}{
\index{lspg.c@{lspg.c}!lspg\_\-getcenter\_\-all@{lspg\_\-getcenter\_\-all}}
\index{lspg\_\-getcenter\_\-all@{lspg\_\-getcenter\_\-all}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-getcenter\_\-all}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-getcenter\_\-all ()}}
\label{lspg_8c_a523b492d9cd4970853eabee2d3c31578}


Convenience function to complete synchronous getcenter query. 

Definition at line 1085 of file lspg.c.


\begin{DoxyCode}
1085                           {
1086   lspg_getcenter_call();
1087   lspg_getcenter_wait();
1088   lspg_getcenter_done();
1089 }
\end{DoxyCode}
\hypertarget{lspg_8c_a6f7cd0a06f6a266ef65b3604cf33d6c4}{
\index{lspg.c@{lspg.c}!lspg\_\-getcenter\_\-call@{lspg\_\-getcenter\_\-call}}
\index{lspg\_\-getcenter\_\-call@{lspg\_\-getcenter\_\-call}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-getcenter\_\-call}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-getcenter\_\-call ()}}
\label{lspg_8c_a6f7cd0a06f6a266ef65b3604cf33d6c4}


Request a getcenter query. 

Definition at line 1061 of file lspg.c.


\begin{DoxyCode}
1061                            {
1062   pthread_mutex_lock( &lspg_getcenter.mutex);
1063   lspg_getcenter.new_value_ready = 0;
1064   pthread_mutex_unlock( &lspg_getcenter.mutex);
1065 
1066   lspg_query_push( lspg_getcenter_cb, "SELECT * FROM px.getcenter2()");
1067 }
\end{DoxyCode}
\hypertarget{lspg_8c_a8184824f2b71b1d35141d7922ca69cd7}{
\index{lspg.c@{lspg.c}!lspg\_\-getcenter\_\-cb@{lspg\_\-getcenter\_\-cb}}
\index{lspg\_\-getcenter\_\-cb@{lspg\_\-getcenter\_\-cb}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-getcenter\_\-cb}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-getcenter\_\-cb ({\bf lspg\_\-query\_\-queue\_\-t} $\ast$ {\em qqp}, \/  PGresult $\ast$ {\em pgr})}}
\label{lspg_8c_a8184824f2b71b1d35141d7922ca69cd7}


TODO: implement getcenter code. 

Definition at line 996 of file lspg.c.


\begin{DoxyCode}
996                                                                 {
997   static int
998     zoom_c, dcx_c, dcy_c, dax_c, day_c, daz_c;
999 
1000   pthread_mutex_lock( &(lspg_getcenter.mutex));
1001   
1002   lspg_getcenter.no_rows_returned = PQntuples( pgr) <= 0;
1003   if( lspg_getcenter.no_rows_returned) {
1004     //
1005     // No particular reason this path should ever be taken
1006     // but if we don't get rows then we had better not move anything.
1007     //
1008     lspg_getcenter.new_value_ready = 1;
1009     pthread_cond_signal( &(lspg_getcenter.cond));
1010     pthread_mutex_unlock( &(lspg_getcenter.mutex));
1011     return;
1012   }
1013 
1014   zoom_c = PQfnumber( pgr, "zoom");
1015   dcx_c  = PQfnumber( pgr, "dcx");
1016   dcy_c  = PQfnumber( pgr, "dcy");
1017   dax_c  = PQfnumber( pgr, "dax");
1018   day_c  = PQfnumber( pgr, "day");
1019   daz_c  = PQfnumber( pgr, "daz");
1020 
1021   lspg_getcenter.zoom_isnull = PQgetisnull( pgr, 0, zoom_c);
1022   if( lspg_getcenter.zoom_isnull == 0)
1023     lspg_getcenter.zoom = atoi( PQgetvalue( pgr, 0, zoom_c));
1024 
1025   lspg_getcenter.dcx_isnull = PQgetisnull( pgr, 0, dcx_c);
1026   if( lspg_getcenter.dcx_isnull == 0)
1027     lspg_getcenter.dcx = atof( PQgetvalue( pgr, 0, dcx_c));
1028 
1029   lspg_getcenter.dcy_isnull = PQgetisnull( pgr, 0, dcy_c);
1030   if( lspg_getcenter.dcy_isnull == 0)
1031     lspg_getcenter.dcy = atof( PQgetvalue( pgr, 0, dcy_c));
1032 
1033   lspg_getcenter.dax_isnull = PQgetisnull( pgr, 0, dax_c);
1034   if( lspg_getcenter.dax_isnull == 0)
1035     lspg_getcenter.dax = atof( PQgetvalue( pgr, 0, dax_c));
1036 
1037   lspg_getcenter.day_isnull = PQgetisnull( pgr, 0, day_c);
1038   if( lspg_getcenter.day_isnull == 0)
1039     lspg_getcenter.day = atof( PQgetvalue( pgr, 0, day_c));
1040 
1041   lspg_getcenter.daz_isnull = PQgetisnull( pgr, 0, daz_c);
1042   if( lspg_getcenter.daz_isnull == 0)
1043     lspg_getcenter.daz = atof( PQgetvalue( pgr, 0, daz_c));
1044 
1045   lspg_getcenter.new_value_ready = 1;
1046 
1047   pthread_cond_signal( &(lspg_getcenter.cond));
1048   pthread_mutex_unlock( &(lspg_getcenter.mutex));
1049 }
\end{DoxyCode}
\hypertarget{lspg_8c_a7c678553b44c874d08ec9966ed7bb1c0}{
\index{lspg.c@{lspg.c}!lspg\_\-getcenter\_\-done@{lspg\_\-getcenter\_\-done}}
\index{lspg\_\-getcenter\_\-done@{lspg\_\-getcenter\_\-done}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-getcenter\_\-done}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-getcenter\_\-done ()}}
\label{lspg_8c_a7c678553b44c874d08ec9966ed7bb1c0}


Done with getcenter query. 

Definition at line 1079 of file lspg.c.


\begin{DoxyCode}
1079                            {
1080   pthread_mutex_unlock( &(lspg_getcenter.mutex));
1081 }
\end{DoxyCode}
\hypertarget{lspg_8c_ad31db17587a02302ac4e40fb7d260b1b}{
\index{lspg.c@{lspg.c}!lspg\_\-getcenter\_\-init@{lspg\_\-getcenter\_\-init}}
\index{lspg\_\-getcenter\_\-init@{lspg\_\-getcenter\_\-init}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-getcenter\_\-init}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-getcenter\_\-init ()}}
\label{lspg_8c_ad31db17587a02302ac4e40fb7d260b1b}


Initialize getcenter object. 

Definition at line 1053 of file lspg.c.


\begin{DoxyCode}
1053                            {
1054   memset( &lspg_getcenter, 0, sizeof( lspg_getcenter));
1055   pthread_mutex_init( &(lspg_getcenter.mutex), NULL);
1056   pthread_cond_init( &(lspg_getcenter.cond), NULL);
1057 }
\end{DoxyCode}
\hypertarget{lspg_8c_a3e0e4b3cb9fa03961ee0c104e0b06754}{
\index{lspg.c@{lspg.c}!lspg\_\-getcenter\_\-wait@{lspg\_\-getcenter\_\-wait}}
\index{lspg\_\-getcenter\_\-wait@{lspg\_\-getcenter\_\-wait}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-getcenter\_\-wait}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-getcenter\_\-wait ()}}
\label{lspg_8c_a3e0e4b3cb9fa03961ee0c104e0b06754}


Wait for a getcenter query to return. 

Definition at line 1071 of file lspg.c.


\begin{DoxyCode}
1071                            {
1072   pthread_mutex_lock( &(lspg_getcenter.mutex));
1073   while( lspg_getcenter.new_value_ready == 0)
1074     pthread_cond_wait( &(lspg_getcenter.cond), &(lspg_getcenter.mutex));
1075 }
\end{DoxyCode}
\hypertarget{lspg_8c_a8a77972df14166e05c94ed0792baa09b}{
\index{lspg.c@{lspg.c}!lspg\_\-init@{lspg\_\-init}}
\index{lspg\_\-init@{lspg\_\-init}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-init}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-init ()}}
\label{lspg_8c_a8a77972df14166e05c94ed0792baa09b}


Initiallize the lspg module. 

Definition at line 1655 of file lspg.c.


\begin{DoxyCode}
1655                  {
1656   pthread_mutex_init( &lspg_queue_mutex, NULL);
1657   pthread_cond_init( &lspg_queue_cond, NULL);
1658   lspg_nextshot_init();
1659   lspg_getcenter_init();
1660   lspg_wait_for_detector_init();
1661   lspg_lock_diffractometer_init();
1662   lspg_lock_detector_init();
1663 }
\end{DoxyCode}
\hypertarget{lspg_8c_a329a7fdfa5025a403ea2779e178fd3ed}{
\index{lspg.c@{lspg.c}!lspg\_\-init\_\-motors\_\-cb@{lspg\_\-init\_\-motors\_\-cb}}
\index{lspg\_\-init\_\-motors\_\-cb@{lspg\_\-init\_\-motors\_\-cb}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-init\_\-motors\_\-cb}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-init\_\-motors\_\-cb ({\bf lspg\_\-query\_\-queue\_\-t} $\ast$ {\em qqp}, \/  PGresult $\ast$ {\em pgr})}}
\label{lspg_8c_a329a7fdfa5025a403ea2779e178fd3ed}


Motor initialization callback. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em qqp}]The query queue item used to call us \item[\mbox{$\leftarrow$} {\em pgr}]The postgresql result object \end{DoxyParams}


Definition at line 287 of file lspg.c.


\begin{DoxyCode}
290                            {
291   int i, j;
292   uint32_t  motor_number, motor_number_column, max_speed_column, max_accel_column
      , home_column;
293   uint32_t units_column, coord_column, name_column;
294   uint32_t u2c_column;
295   uint32_t format_column;
296   uint32_t update_resolution_column;
297   uint32_t update_format_column;
298   char *sp;
299   lspmac_motor_t *lsdp;
300   
301   name_column              = PQfnumber( pgr, "mm_name");
302   if( name_column == -1)
303     return;
304 
305   motor_number_column      = PQfnumber( pgr, "mm_motor");
306   coord_column             = PQfnumber( pgr, "mm_coord");
307   units_column             = PQfnumber( pgr, "mm_unit");
308   u2c_column               = PQfnumber( pgr, "mm_u2c");
309   format_column            = PQfnumber( pgr, "mm_printf");
310   max_speed_column         = PQfnumber( pgr, "mm_max_speed");
311   max_accel_column         = PQfnumber( pgr, "mm_max_speed");
312   update_resolution_column = PQfnumber( pgr, "mm_update_resolution");
313   update_format_column     = PQfnumber( pgr, "mm_update_format");
314   home_column              = PQfnumber( pgr, "mm_home");
315 
316   for( i=0; i<PQntuples( pgr); i++) {
317 
318     lsdp = NULL;
319     for( j=0; j<lspmac_nmotors; j++) {
320       if( strcmp(lspmac_motors[j].name, PQgetvalue( pgr, i, name_column)) == 0) {
      
321         lsdp                    = &(lspmac_motors[j]);
322         lsdp->motor_num         = atoi(PQgetvalue( pgr, i, motor_number_column));
      
323         lsdp->coord_num         = atoi( PQgetvalue( pgr, i, coord_column));
324         lsdp->units             = strdup( PQgetvalue( pgr, i, units_column));
325         lsdp->format            = strdup( PQgetvalue( pgr, i, format_column));
326         lsdp->u2c               = atof(PQgetvalue( pgr, i, u2c_column));
327         lsdp->max_speed         = atof(PQgetvalue( pgr, i, max_speed_column));
328         lsdp->max_accel         = atof(PQgetvalue( pgr, i, max_accel_column));
329         lsdp->update_resolution = atof(PQgetvalue( pgr, i, update_resolution_colu
      mn));
330         lsdp->update_format     = strdup( PQgetvalue( pgr, i, update_format_colum
      n));
331         lsdp->home              = lspg_array2ptrs( PQgetvalue( pgr, i, home_colum
      n));
332         lsdp->lspg_initialized  = 1;
333         break;
334       }
335     }
336     if( lsdp == NULL)
337       continue;
338 
339     if( fabs(lsdp->u2c) <= 1.0e-9)
340       lsdp->u2c = 1.0;
341   }
342 }
\end{DoxyCode}
\hypertarget{lspg_8c_a6de3621552c9265950a0df573429c519}{
\index{lspg.c@{lspg.c}!lspg\_\-kvs\_\-cb@{lspg\_\-kvs\_\-cb}}
\index{lspg\_\-kvs\_\-cb@{lspg\_\-kvs\_\-cb}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-kvs\_\-cb}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-kvs\_\-cb ({\bf lspg\_\-query\_\-queue\_\-t} $\ast$ {\em qqp}, \/  PGresult $\ast$ {\em pgr})}}
\label{lspg_8c_a6de3621552c9265950a0df573429c519}


retrieve kv pairs with new values 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em qqp}]Our query \item[\mbox{$\leftarrow$} {\em pgr}]Our result \end{DoxyParams}


Definition at line 1120 of file lspg.c.


\begin{DoxyCode}
1123                    {
1124   int i;
1125 
1126   lslogging_log_message( "lspg_kvs_cb: %d tuples", PQntuples(pgr));
1127 
1128   // Even i is key  (the name)
1129   // Odd  i is value
1130   //
1131   for( i=0; i<PQntuples(pgr)/2; i++) {
1132     lskvs_set( PQgetvalue( pgr, 2*i, 0), PQgetvalue( pgr, 2*i+1, 0));
1133   }
1134 }
\end{DoxyCode}
\hypertarget{lspg_8c_aff93d2f5ac31aa249a0bef40a3837c84}{
\index{lspg.c@{lspg.c}!lspg\_\-lock\_\-detector\_\-all@{lspg\_\-lock\_\-detector\_\-all}}
\index{lspg\_\-lock\_\-detector\_\-all@{lspg\_\-lock\_\-detector\_\-all}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-lock\_\-detector\_\-all}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-lock\_\-detector\_\-all ()}}
\label{lspg_8c_aff93d2f5ac31aa249a0bef40a3837c84}


Detector lock convinence function. 

Definition at line 908 of file lspg.c.


\begin{DoxyCode}
908                               {
909   lspg_lock_detector_call();
910   lspg_lock_detector_wait();
911   lspg_lock_detector_done();
912 }
\end{DoxyCode}
\hypertarget{lspg_8c_a5f71a20cc297684b2afe28e7bd8e8383}{
\index{lspg.c@{lspg.c}!lspg\_\-lock\_\-detector\_\-call@{lspg\_\-lock\_\-detector\_\-call}}
\index{lspg\_\-lock\_\-detector\_\-call@{lspg\_\-lock\_\-detector\_\-call}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-lock\_\-detector\_\-call}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-lock\_\-detector\_\-call ()}}
\label{lspg_8c_a5f71a20cc297684b2afe28e7bd8e8383}


Request (demand) a detector lock. 

Definition at line 884 of file lspg.c.


\begin{DoxyCode}
884                                {
885   pthread_mutex_lock( &(lspg_lock_detector.mutex));
886   lspg_lock_detector.new_value_ready = 0;
887   pthread_mutex_unlock( &(lspg_lock_detector.mutex));
888 
889   lspg_query_push( lspg_lock_detector_cb, "SELECT px.lock_detector()");
890 }
\end{DoxyCode}
\hypertarget{lspg_8c_aa760191c2b443170cebbcbf5ea5345f3}{
\index{lspg.c@{lspg.c}!lspg\_\-lock\_\-detector\_\-cb@{lspg\_\-lock\_\-detector\_\-cb}}
\index{lspg\_\-lock\_\-detector\_\-cb@{lspg\_\-lock\_\-detector\_\-cb}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-lock\_\-detector\_\-cb}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-lock\_\-detector\_\-cb ({\bf lspg\_\-query\_\-queue\_\-t} $\ast$ {\em qqp}, \/  PGresult $\ast$ {\em pgr})}}
\label{lspg_8c_aa760191c2b443170cebbcbf5ea5345f3}


Callback for when the detector lock has be grabbed. 

Definition at line 875 of file lspg.c.


\begin{DoxyCode}
875                                                                     {
876   pthread_mutex_lock( &(lspg_lock_detector.mutex));
877   lspg_lock_detector.new_value_ready = 1;
878   pthread_cond_signal( &(lspg_lock_detector.cond));
879   pthread_mutex_unlock( &(lspg_lock_detector.mutex));
880 }
\end{DoxyCode}
\hypertarget{lspg_8c_a1b567040693ff6e2932a2477045d75fa}{
\index{lspg.c@{lspg.c}!lspg\_\-lock\_\-detector\_\-done@{lspg\_\-lock\_\-detector\_\-done}}
\index{lspg\_\-lock\_\-detector\_\-done@{lspg\_\-lock\_\-detector\_\-done}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-lock\_\-detector\_\-done}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-lock\_\-detector\_\-done ()}}
\label{lspg_8c_a1b567040693ff6e2932a2477045d75fa}


Finish waiting. 

Definition at line 902 of file lspg.c.


\begin{DoxyCode}
902                                {
903   pthread_mutex_unlock( &(lspg_lock_detector.mutex));
904 }
\end{DoxyCode}
\hypertarget{lspg_8c_a0e9bbf847dadfe0d10830d67824d9be8}{
\index{lspg.c@{lspg.c}!lspg\_\-lock\_\-detector\_\-init@{lspg\_\-lock\_\-detector\_\-init}}
\index{lspg\_\-lock\_\-detector\_\-init@{lspg\_\-lock\_\-detector\_\-init}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-lock\_\-detector\_\-init}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-lock\_\-detector\_\-init ()}}
\label{lspg_8c_a0e9bbf847dadfe0d10830d67824d9be8}


Initialize detector lock object. 

Definition at line 867 of file lspg.c.


\begin{DoxyCode}
867                                {
868   lspg_lock_detector.new_value_ready = 0;
869   pthread_mutex_init( &(lspg_lock_detector.mutex), NULL);
870   pthread_cond_init(  &(lspg_lock_detector.cond),  NULL);
871 }
\end{DoxyCode}
\hypertarget{lspg_8c_ad3d9c56bd3ca6bcc43db30872cc441cc}{
\index{lspg.c@{lspg.c}!lspg\_\-lock\_\-detector\_\-wait@{lspg\_\-lock\_\-detector\_\-wait}}
\index{lspg\_\-lock\_\-detector\_\-wait@{lspg\_\-lock\_\-detector\_\-wait}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-lock\_\-detector\_\-wait}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-lock\_\-detector\_\-wait ()}}
\label{lspg_8c_ad3d9c56bd3ca6bcc43db30872cc441cc}


Wait for the detector lock. 

Definition at line 894 of file lspg.c.


\begin{DoxyCode}
894                                {
895   pthread_mutex_lock( &(lspg_lock_detector.mutex));
896   while( lspg_lock_detector.new_value_ready == 0)
897     pthread_cond_wait( &(lspg_lock_detector.cond), &(lspg_lock_detector.mutex));
898 }
\end{DoxyCode}
\hypertarget{lspg_8c_a88b33e75c42197740b157a51ea726f21}{
\index{lspg.c@{lspg.c}!lspg\_\-lock\_\-diffractometer\_\-all@{lspg\_\-lock\_\-diffractometer\_\-all}}
\index{lspg\_\-lock\_\-diffractometer\_\-all@{lspg\_\-lock\_\-diffractometer\_\-all}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-lock\_\-diffractometer\_\-all}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-lock\_\-diffractometer\_\-all ()}}
\label{lspg_8c_a88b33e75c42197740b157a51ea726f21}


Convience function that combines lock diffractometer calls. 

Definition at line 849 of file lspg.c.


\begin{DoxyCode}
849                                     {
850   lspg_lock_diffractometer_call();
851   lspg_lock_diffractometer_wait();
852   lspg_lock_diffractometer_all();
853 }
\end{DoxyCode}
\hypertarget{lspg_8c_ac5ebeb38e8e9926a52f024fe76201175}{
\index{lspg.c@{lspg.c}!lspg\_\-lock\_\-diffractometer\_\-call@{lspg\_\-lock\_\-diffractometer\_\-call}}
\index{lspg\_\-lock\_\-diffractometer\_\-call@{lspg\_\-lock\_\-diffractometer\_\-call}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-lock\_\-diffractometer\_\-call}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-lock\_\-diffractometer\_\-call ()}}
\label{lspg_8c_ac5ebeb38e8e9926a52f024fe76201175}


Request that the database grab the diffractometer lock. 

Definition at line 825 of file lspg.c.


\begin{DoxyCode}
825                                      {
826   pthread_mutex_lock( &(lspg_lock_diffractometer.mutex));
827   lspg_lock_diffractometer.new_value_ready = 0;
828   pthread_mutex_unlock( &(lspg_lock_diffractometer.mutex));
829 
830   lspg_query_push( lspg_lock_diffractometer_cb, "SELECT px.lock_diffractomter()")
      ;
831 }
\end{DoxyCode}
\hypertarget{lspg_8c_aad4f378f37c0030634dafa0d9445d916}{
\index{lspg.c@{lspg.c}!lspg\_\-lock\_\-diffractometer\_\-cb@{lspg\_\-lock\_\-diffractometer\_\-cb}}
\index{lspg\_\-lock\_\-diffractometer\_\-cb@{lspg\_\-lock\_\-diffractometer\_\-cb}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-lock\_\-diffractometer\_\-cb}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-lock\_\-diffractometer\_\-cb ({\bf lspg\_\-query\_\-queue\_\-t} $\ast$ {\em qqp}, \/  PGresult $\ast$ {\em pgr})}}
\label{lspg_8c_aad4f378f37c0030634dafa0d9445d916}


Callback routine for a lock diffractometer query. 

Definition at line 816 of file lspg.c.


\begin{DoxyCode}
816                                                                           {
817   pthread_mutex_lock( &(lspg_lock_diffractometer.mutex));
818   lspg_lock_diffractometer.new_value_ready = 1;
819   pthread_cond_signal( &(lspg_lock_diffractometer.cond));
820   pthread_mutex_unlock( &(lspg_lock_diffractometer.mutex));
821 }
\end{DoxyCode}
\hypertarget{lspg_8c_a75aaf0b3fe33530062226c69a33ce821}{
\index{lspg.c@{lspg.c}!lspg\_\-lock\_\-diffractometer\_\-done@{lspg\_\-lock\_\-diffractometer\_\-done}}
\index{lspg\_\-lock\_\-diffractometer\_\-done@{lspg\_\-lock\_\-diffractometer\_\-done}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-lock\_\-diffractometer\_\-done}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-lock\_\-diffractometer\_\-done ()}}
\label{lspg_8c_a75aaf0b3fe33530062226c69a33ce821}


Finish up the lock diffractometer call. 

Definition at line 843 of file lspg.c.


\begin{DoxyCode}
843                                      {
844   pthread_mutex_unlock( &(lspg_lock_diffractometer.mutex));
845 }
\end{DoxyCode}
\hypertarget{lspg_8c_a39bb94f8e0d47702b2b920a3dee61ebc}{
\index{lspg.c@{lspg.c}!lspg\_\-lock\_\-diffractometer\_\-init@{lspg\_\-lock\_\-diffractometer\_\-init}}
\index{lspg\_\-lock\_\-diffractometer\_\-init@{lspg\_\-lock\_\-diffractometer\_\-init}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-lock\_\-diffractometer\_\-init}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-lock\_\-diffractometer\_\-init ()}}
\label{lspg_8c_a39bb94f8e0d47702b2b920a3dee61ebc}


initialize the diffractometer locking object 

Definition at line 808 of file lspg.c.


\begin{DoxyCode}
808                                      {
809   lspg_lock_diffractometer.new_value_ready = 0;
810   pthread_mutex_init( &(lspg_lock_diffractometer.mutex), NULL);
811   pthread_cond_init(  &(lspg_lock_diffractometer.cond), NULL);
812 }
\end{DoxyCode}
\hypertarget{lspg_8c_a8445e1dec753f2c517b87fcb9c5b5943}{
\index{lspg.c@{lspg.c}!lspg\_\-lock\_\-diffractometer\_\-wait@{lspg\_\-lock\_\-diffractometer\_\-wait}}
\index{lspg\_\-lock\_\-diffractometer\_\-wait@{lspg\_\-lock\_\-diffractometer\_\-wait}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-lock\_\-diffractometer\_\-wait}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-lock\_\-diffractometer\_\-wait ()}}
\label{lspg_8c_a8445e1dec753f2c517b87fcb9c5b5943}


Wait for the diffractometer lock. 

Definition at line 835 of file lspg.c.


\begin{DoxyCode}
835                                      {
836   pthread_mutex_lock( &(lspg_lock_diffractometer.mutex));
837   while( lspg_lock_diffractometer.new_value_ready == 0)
838     pthread_cond_wait( &(lspg_lock_diffractometer.cond), &(
      lspg_lock_diffractometer.mutex));
839 }
\end{DoxyCode}
\hypertarget{lspg_8c_ab52a8c8245bf6561f40c0f224fc07ff4}{
\index{lspg.c@{lspg.c}!lspg\_\-next\_\-state@{lspg\_\-next\_\-state}}
\index{lspg\_\-next\_\-state@{lspg\_\-next\_\-state}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-next\_\-state}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-next\_\-state ()}}
\label{lspg_8c_ab52a8c8245bf6561f40c0f224fc07ff4}


Implements our state machine Does not strictly only set the next state as it also calls some functions that, perhaps, alters the state mid-\/function. 

Definition at line 1524 of file lspg.c.


\begin{DoxyCode}
1524                        {
1525   //
1526   // connect to the database
1527   //
1528   if( q == NULL ||
1529       ls_pg_state == LS_PG_STATE_INIT ||
1530       ls_pg_state == LS_PG_STATE_RESET ||
1531       ls_pg_state == LS_PG_STATE_INIT_POLL ||
1532       ls_pg_state == LS_PG_STATE_RESET_POLL)
1533     lspg_pg_connect( lspgfd);
1534 
1535 
1536   if( ls_pg_state == LS_PG_STATE_IDLE && lspg_query_queue_on != 
      lspg_query_queue_off)
1537     ls_pg_state = LS_PG_STATE_SEND;
1538 
1539   switch( ls_pg_state) {
1540   case LS_PG_STATE_INIT_POLL:
1541     if( lspg_connectPoll_response == PGRES_POLLING_WRITING)
1542       lspgfd.events = POLLOUT;
1543     else if( lspg_connectPoll_response == PGRES_POLLING_READING)
1544       lspgfd.events = POLLIN;
1545     else
1546       lspgfd.events = 0;
1547     break;
1548       
1549   case LS_PG_STATE_RESET_POLL:
1550     if( lspg_resetPoll_response == PGRES_POLLING_WRITING)
1551       lspgfd.events = POLLOUT;
1552     else if( lspg_resetPoll_response == PGRES_POLLING_READING)
1553       lspgfd.events = POLLIN;
1554     else
1555       lspgfd.events = 0;
1556     break;
1557 
1558   case LS_PG_STATE_IDLE:
1559   case LS_PG_STATE_RECV:
1560     lspgfd.events = POLLIN;
1561     break;
1562 
1563   case LS_PG_STATE_SEND:
1564   case LS_PG_STATE_SEND_FLUSH:
1565     lspgfd.events = POLLOUT;
1566     break;
1567 
1568   default:
1569     lspgfd.events = 0;
1570   }
1571 }
\end{DoxyCode}
\hypertarget{lspg_8c_aeda8dad89b03d7d61cc994dd63ee5db6}{
\index{lspg.c@{lspg.c}!lspg\_\-nextaction\_\-cb@{lspg\_\-nextaction\_\-cb}}
\index{lspg\_\-nextaction\_\-cb@{lspg\_\-nextaction\_\-cb}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-nextaction\_\-cb}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-nextaction\_\-cb ({\bf lspg\_\-query\_\-queue\_\-t} $\ast$ {\em qqp}, \/  PGresult $\ast$ {\em pgr})}}
\label{lspg_8c_aeda8dad89b03d7d61cc994dd63ee5db6}


Queue the next MD2 instruction. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em qqp}]The query that generated this result \item[\mbox{$\leftarrow$} {\em pgr}]The result \end{DoxyParams}


Definition at line 1094 of file lspg.c.


\begin{DoxyCode}
1097                           {
1098   char *action;
1099 
1100   if( PQntuples( pgr) <= 0)
1101     return;             // Note: nextaction should always return at least "noActi
      on", so this branch should never be taken
1102 
1103   action = PQgetvalue( pgr, 0, 0);      // next action only returns one row
1104 
1105   if( strcmp( action, "noAction") == 0)
1106     return;
1107   
1108   if( pthread_mutex_trylock( &md2cmds_mutex) == 0) {
1109     strncpy( md2cmds_cmd, action, MD2CMDS_CMD_LENGTH-1);
1110     md2cmds_cmd[MD2CMDS_CMD_LENGTH-1] = 0;
1111     pthread_cond_signal( &md2cmds_cond);
1112     pthread_mutex_unlock( &md2cmds_mutex);
1113   } else {
1114     lslogging_log_message( "MD2 command '%s' ignored.  Already running '%s'", act
      ion, md2cmds_cmd);
1115   }
1116 }
\end{DoxyCode}
\hypertarget{lspg_8c_af17ef79544ca5d78fd477010fe90d538}{
\index{lspg.c@{lspg.c}!lspg\_\-nextshot\_\-call@{lspg\_\-nextshot\_\-call}}
\index{lspg\_\-nextshot\_\-call@{lspg\_\-nextshot\_\-call}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-nextshot\_\-call}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-nextshot\_\-call ()}}
\label{lspg_8c_af17ef79544ca5d78fd477010fe90d538}


Queue up a nextshot query. 

Definition at line 708 of file lspg.c.


\begin{DoxyCode}
708                           {
709   pthread_mutex_lock( &(lspg_nextshot.mutex));
710   lspg_nextshot.new_value_ready = 0;
711   pthread_mutex_unlock( &(lspg_nextshot.mutex));
712   
713   lspg_query_push( lspg_nextshot_cb, "SELECT * FROM px.nextshot()");
714 }
\end{DoxyCode}
\hypertarget{lspg_8c_a9e92a204f606761d368ac7e06ef0f09c}{
\index{lspg.c@{lspg.c}!lspg\_\-nextshot\_\-cb@{lspg\_\-nextshot\_\-cb}}
\index{lspg\_\-nextshot\_\-cb@{lspg\_\-nextshot\_\-cb}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-nextshot\_\-cb}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-nextshot\_\-cb ({\bf lspg\_\-query\_\-queue\_\-t} $\ast$ {\em qqp}, \/  PGresult $\ast$ {\em pgr})}}
\label{lspg_8c_a9e92a204f606761d368ac7e06ef0f09c}


Next Shot Callback. This is a long and tedious routine as there are a large number of variables returned. Suck it up. Return with the global variable lspg\_\-nextshot set. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em qqp}]Our nextshot query \item[\mbox{$\leftarrow$} {\em pgr}]result of the query \end{DoxyParams}


Definition at line 453 of file lspg.c.


\begin{DoxyCode}
456                         {
457   static int got_col_nums=0;
458   static int
459     dsdir_c, dspid_c, dsowidth_c, dsoscaxis_c, dsexp_c, skey_c, sstart_c, sfn_c, 
      dsphi_c,
460     dsomega_c, dskappa_c, dsdist_c, dsnrg_c, dshpid_c, cx_c, cy_c, ax_c, ay_c, az
      _c,
461     active_c, sindex_c, stype_c,
462     dsowidth2_c, dsoscaxis2_c, dsexp2_c, sstart2_c, dsphi2_c, dsomega2_c, dskappa
      2_c, dsdist2_c, dsnrg2_c,
463     cx2_c, cy2_c, ax2_c, ay2_c, az2_c, active2_c, sindex2_c, stype2_c;
464   
465   pthread_mutex_lock( &(lspg_nextshot.mutex));
466 
467   lspg_nextshot.no_rows_returned = PQntuples( pgr) <= 0;
468   if( lspg_nextshot.no_rows_returned) {
469     lspg_nextshot.new_value_ready = 1;
470     pthread_cond_signal( &(lspg_nextshot.cond));
471     pthread_mutex_unlock( &(lspg_nextshot.mutex));
472     return;                     // I guess there was no shot after all
473   }
474 
475   if( got_col_nums == 0) {
476     dsdir_c      = PQfnumber( pgr, "dsdir");
477     dspid_c      = PQfnumber( pgr, "dspid");
478     dsowidth_c   = PQfnumber( pgr, "dsowidth");
479     dsoscaxis_c  = PQfnumber( pgr, "dsoscaxis");
480     dsexp_c      = PQfnumber( pgr, "dsexp");
481     skey_c       = PQfnumber( pgr, "skey");
482     sstart_c     = PQfnumber( pgr, "sstart");
483     sfn_c        = PQfnumber( pgr, "sfn");
484     dsphi_c      = PQfnumber( pgr, "dsphi");
485     dsomega_c    = PQfnumber( pgr, "dsomega");
486     dskappa_c    = PQfnumber( pgr, "dskappa");
487     dsdist_c     = PQfnumber( pgr, "dsdist");
488     dsnrg_c      = PQfnumber( pgr, "dsnrg");
489     dshpid_c     = PQfnumber( pgr, "dshpid");
490     cx_c         = PQfnumber( pgr, "cx");
491     cy_c         = PQfnumber( pgr, "cy");
492     ax_c         = PQfnumber( pgr, "ax");
493     ay_c         = PQfnumber( pgr, "ay");
494     az_c         = PQfnumber( pgr, "az");
495     active_c     = PQfnumber( pgr, "active");
496     sindex_c     = PQfnumber( pgr, "sindex");
497     stype_c      = PQfnumber( pgr, "stype");
498     dsowidth2_c  = PQfnumber( pgr, "dsowidth2");
499     dsoscaxis2_c = PQfnumber( pgr, "dsoscaxis2");
500     dsexp2_c     = PQfnumber( pgr, "dsexp2");
501     sstart2_c    = PQfnumber( pgr, "sstart2");
502     dsphi2_c     = PQfnumber( pgr, "dsphi2");
503     dsomega2_c   = PQfnumber( pgr, "dsomega2");
504     dskappa2_c   = PQfnumber( pgr, "dskappa2");
505     dsdist2_c    = PQfnumber( pgr, "dsdist2");
506     dsnrg2_c     = PQfnumber( pgr, "dsnrg2");
507     cx2_c        = PQfnumber( pgr, "cx2");
508     cy2_c        = PQfnumber( pgr, "cy2");
509     ax2_c        = PQfnumber( pgr, "ax2");
510     ay2_c        = PQfnumber( pgr, "ay2");
511     az2_c        = PQfnumber( pgr, "az2");
512     active2_c    = PQfnumber( pgr, "active2");
513     sindex2_c    = PQfnumber( pgr, "sindex2");
514     stype2_c     = PQfnumber( pgr, "stype2");
515     
516     got_col_nums = 1;
517   }
518 
519 
520   //
521   // NULL string values come back as empty strings
522   // Mark the null flag but allocate the empty string anyway
523   //
524 
525   lspg_nextshot.dsdir_isnull = PQgetisnull( pgr, 0, dsdir_c);
526   if( lspg_nextshot.dsdir != NULL)
527     free( lspg_nextshot.dsdir);
528   lspg_nextshot.dsdir = strdup( PQgetvalue( pgr, 0, dsdir_c));
529 
530   lspg_nextshot.dspid_isnull = PQgetisnull( pgr, 0, dspid_c);
531   if( lspg_nextshot.dspid != NULL)
532     free( lspg_nextshot.dspid);
533   lspg_nextshot.dspid = strdup( PQgetvalue( pgr, 0, dspid_c));
534 
535   lspg_nextshot.dsoscaxis_isnull = PQgetisnull( pgr, 0, dsoscaxis_c);
536   if( lspg_nextshot.dsoscaxis != NULL)
537     free( lspg_nextshot.dsoscaxis);
538   lspg_nextshot.dsoscaxis = strdup( PQgetvalue( pgr, 0, dsoscaxis_c));
539 
540   lspg_nextshot.dsoscaxis2_isnull = PQgetisnull( pgr, 0, dsoscaxis2_c);
541   if( lspg_nextshot.dsoscaxis2 != NULL)
542     free( lspg_nextshot.dsoscaxis2);
543   lspg_nextshot.dsoscaxis2 = strdup( PQgetvalue( pgr, 0, dsoscaxis2_c));
544 
545   lspg_nextshot.sfn_isnull = PQgetisnull(pgr, 0, sfn_c);
546   if( lspg_nextshot.sfn != NULL)
547     free( lspg_nextshot.sfn);
548   lspg_nextshot.sfn = strdup( PQgetvalue( pgr, 0, sfn_c));
549 
550   lspg_nextshot.stype_isnull = PQgetisnull( pgr, 0, stype_c);
551   if( lspg_nextshot.stype != NULL)
552     free( lspg_nextshot.stype);
553   lspg_nextshot.stype = strdup( PQgetvalue( pgr, 0, stype_c));
554 
555   lspg_nextshot.stype2_isnull = PQgetisnull( pgr, 0, stype2_c);
556   if( lspg_nextshot.stype2 != NULL)
557     free( lspg_nextshot.stype2);
558   lspg_nextshot.stype2 = strdup( PQgetvalue( pgr, 0, stype2_c));
559 
560   //
561   // Probably shouldn't try to convert null number values
562   //
563   lspg_nextshot.dsowidth_isnull = PQgetisnull( pgr, 0, dsowidth_c);
564   if( lspg_nextshot.dsowidth_isnull == 0)
565     lspg_nextshot.dsowidth = atof( PQgetvalue( pgr,0, dsowidth_c));
566 
567   lspg_nextshot.dsexp_isnull = PQgetisnull( pgr, 0, dsexp_c);
568   if( lspg_nextshot.dsexp_isnull == 0)
569     lspg_nextshot.dsexp    = atof( PQgetvalue( pgr,0, dsexp_c));
570 
571   lspg_nextshot.sstart_isnull = PQgetisnull( pgr, 0, sstart_c);
572   if( lspg_nextshot.sstart_isnull == 0)
573     lspg_nextshot.sstart   = atof( PQgetvalue( pgr,0, sstart_c));
574 
575   lspg_nextshot.dsphi_isnull = PQgetisnull( pgr, 0, dsphi_c);
576   if( lspg_nextshot.dsphi_isnull == 0)
577     lspg_nextshot.dsphi    = atof( PQgetvalue( pgr,0, dsphi_c));
578 
579   lspg_nextshot.dsomega_isnull = PQgetisnull( pgr, 0, dsomega_c);
580   if( lspg_nextshot.dsomega_isnull == 0)
581     lspg_nextshot.dsomega  = atof( PQgetvalue( pgr,0, dsomega_c));
582 
583   lspg_nextshot.dskappa_isnull = PQgetisnull( pgr, 0, dskappa_c);
584   if( lspg_nextshot.dskappa_isnull == 0)
585     lspg_nextshot.dskappa  = atof( PQgetvalue( pgr,0, dskappa_c));
586 
587   lspg_nextshot.dsdist_isnull = PQgetisnull( pgr, 0, dsdist_c);
588   if( lspg_nextshot.dsdist_isnull == 0)
589     lspg_nextshot.dsdist   = atof( PQgetvalue( pgr,0, dsdist_c));
590 
591   lspg_nextshot.dsnrg_isnull = PQgetisnull( pgr, 0, dsnrg_c);
592   if( lspg_nextshot.dsnrg_isnull == 0)
593     lspg_nextshot.dsnrg    = atof( PQgetvalue( pgr,0, dsnrg_c));
594 
595   lspg_nextshot.cx_isnull = PQgetisnull( pgr, 0, cx_c);
596   if( lspg_nextshot.cx_isnull == 0)
597     lspg_nextshot.cx       = atof( PQgetvalue( pgr,0, cx_c));
598 
599   lspg_nextshot.cy_isnull = PQgetisnull( pgr, 0, cy_c);
600   if( lspg_nextshot.cy_isnull == 0)
601     lspg_nextshot.cy       = atof( PQgetvalue( pgr,0, cy_c));
602 
603   lspg_nextshot.ax_isnull = PQgetisnull( pgr, 0, ax_c);
604   if( lspg_nextshot.ax_isnull == 0)
605     lspg_nextshot.ax       = atof( PQgetvalue( pgr,0, ax_c));
606 
607   lspg_nextshot.ay_isnull = PQgetisnull( pgr, 0, ay_c);
608   if( lspg_nextshot.ay_isnull == 0)
609     lspg_nextshot.ay       = atof( PQgetvalue( pgr,0, ay_c));
610 
611   lspg_nextshot.az_isnull = PQgetisnull( pgr, 0, az_c);
612   if( lspg_nextshot.az_isnull == 0)
613     lspg_nextshot.az       = atof( PQgetvalue( pgr,0, az_c));
614   
615   lspg_nextshot.active_isnull = PQgetisnull( pgr, 0, active_c);
616   if( lspg_nextshot.active_isnull == 0)
617     lspg_nextshot.active = atoi( PQgetvalue( pgr, 0, active_c));
618 
619   lspg_nextshot.sindex_isnull = PQgetisnull( pgr, 0, sindex_c);
620   if( lspg_nextshot.sindex_isnull == 0)
621     lspg_nextshot.sindex = atoi( PQgetvalue( pgr, 0, sindex_c));
622 
623   lspg_nextshot.dshpid_isnull = PQgetisnull( pgr, 0, dshpid_c);
624   if( lspg_nextshot.dshpid_isnull == 0)
625     lspg_nextshot.dshpid = atoi( PQgetvalue( pgr, 0, dshpid_c));
626   
627   lspg_nextshot.skey_isnull = PQgetisnull( pgr, 0, skey_c);
628   if( lspg_nextshot.skey_isnull == 0)
629     lspg_nextshot.skey   = atoll( PQgetvalue( pgr, 0, skey_c));
630 
631   lspg_nextshot.dsowidth2_isnull = PQgetisnull( pgr, 0, dsowidth2_c);
632   if( lspg_nextshot.dsowidth2_isnull == 0)
633     lspg_nextshot.dsowidth2 = atof( PQgetvalue( pgr,0, dsowidth2_c));
634 
635   lspg_nextshot.dsexp2_isnull = PQgetisnull( pgr, 0, dsexp2_c);
636   if( lspg_nextshot.dsexp2_isnull == 0)
637     lspg_nextshot.dsexp2    = atof( PQgetvalue( pgr,0, dsexp2_c));
638 
639   lspg_nextshot.sstart2_isnull = PQgetisnull( pgr, 0, sstart2_c);
640   if( lspg_nextshot.sstart2_isnull == 0)
641     lspg_nextshot.sstart2   = atof( PQgetvalue( pgr,0, sstart2_c));
642 
643   lspg_nextshot.dsphi2_isnull = PQgetisnull( pgr, 0, dsphi2_c);
644   if( lspg_nextshot.dsphi2_isnull == 0)
645     lspg_nextshot.dsphi2    = atof( PQgetvalue( pgr,0, dsphi2_c));
646 
647   lspg_nextshot.dsomega2_isnull = PQgetisnull( pgr, 0, dsomega2_c);
648   if( lspg_nextshot.dsomega2_isnull == 0)
649     lspg_nextshot.dsomega2  = atof( PQgetvalue( pgr,0, dsomega2_c));
650 
651   lspg_nextshot.dskappa2_isnull = PQgetisnull( pgr, 0, dskappa2_c);
652   if( lspg_nextshot.dskappa2_isnull == 0)
653     lspg_nextshot.dskappa2  = atof( PQgetvalue( pgr,0, dskappa2_c));
654 
655   lspg_nextshot.dsdist2_isnull = PQgetisnull( pgr, 0, dsdist2_c);
656   if( lspg_nextshot.dsdist2_isnull == 0)
657     lspg_nextshot.dsdist2   = atof( PQgetvalue( pgr,0, dsdist2_c));
658 
659   lspg_nextshot.dsnrg2_isnull = PQgetisnull( pgr, 0, dsnrg2_c);
660   if( lspg_nextshot.dsnrg2_isnull == 0)
661     lspg_nextshot.dsnrg2    = atof( PQgetvalue( pgr,0, dsnrg2_c));
662 
663   lspg_nextshot.cx2_isnull = PQgetisnull( pgr, 0, cx2_c);
664   if( lspg_nextshot.cx2_isnull == 0)
665     lspg_nextshot.cx2       = atof( PQgetvalue( pgr,0, cx2_c));
666 
667   lspg_nextshot.cy2_isnull = PQgetisnull( pgr, 0, cy2_c);
668   if( lspg_nextshot.cy2_isnull == 0)
669     lspg_nextshot.cy2       = atof( PQgetvalue( pgr,0, cy2_c));
670 
671   lspg_nextshot.ax2_isnull = PQgetisnull( pgr, 0, ax2_c);
672   if( lspg_nextshot.ax2_isnull == 0)
673     lspg_nextshot.ax2       = atof( PQgetvalue( pgr,0, ax2_c));
674 
675   lspg_nextshot.ay2_isnull = PQgetisnull( pgr, 0, ay2_c);
676   if( lspg_nextshot.ay2_isnull == 0)
677     lspg_nextshot.ay2       = atof( PQgetvalue( pgr,0, ay2_c));
678 
679   lspg_nextshot.az2_isnull = PQgetisnull( pgr, 0, az2_c);
680   if( lspg_nextshot.az2_isnull == 0)
681     lspg_nextshot.az2       = atof( PQgetvalue( pgr,0, az2_c));
682   
683   lspg_nextshot.active2_isnull = PQgetisnull( pgr, 0, active2_c);
684   if( lspg_nextshot.active2_isnull == 0)
685     lspg_nextshot.active2 = atoi( PQgetvalue( pgr, 0, active2_c));
686 
687   lspg_nextshot.sindex2_isnull = PQgetisnull( pgr, 0, sindex2_c);
688   if( lspg_nextshot.sindex2_isnull == 0)
689     lspg_nextshot.sindex2 = atoi( PQgetvalue( pgr, 0, sindex2_c));
690 
691   lspg_nextshot.new_value_ready = 1;
692 
693   pthread_cond_signal( &(lspg_nextshot.cond));
694   pthread_mutex_unlock( &(lspg_nextshot.mutex));
695 
696 }
\end{DoxyCode}
\hypertarget{lspg_8c_a50458a014041a4118452802dfb303960}{
\index{lspg.c@{lspg.c}!lspg\_\-nextshot\_\-done@{lspg\_\-nextshot\_\-done}}
\index{lspg\_\-nextshot\_\-done@{lspg\_\-nextshot\_\-done}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-nextshot\_\-done}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-nextshot\_\-done ()}}
\label{lspg_8c_a50458a014041a4118452802dfb303960}


Called when the next shot query has been processed. 

Definition at line 726 of file lspg.c.


\begin{DoxyCode}
726                           {
727   pthread_mutex_unlock( &(lspg_nextshot.mutex));
728 }
\end{DoxyCode}
\hypertarget{lspg_8c_aff91db7d60e6c832684c023813e36dbf}{
\index{lspg.c@{lspg.c}!lspg\_\-nextshot\_\-init@{lspg\_\-nextshot\_\-init}}
\index{lspg\_\-nextshot\_\-init@{lspg\_\-nextshot\_\-init}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-nextshot\_\-init}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-nextshot\_\-init ()}}
\label{lspg_8c_aff91db7d60e6c832684c023813e36dbf}


Initialize the nextshot variable, mutex, and condition. 

Definition at line 700 of file lspg.c.


\begin{DoxyCode}
700                           {
701   memset( &lspg_nextshot, 0, sizeof( lspg_nextshot));
702   pthread_mutex_init( &(lspg_nextshot.mutex), NULL);
703   pthread_cond_init( &(lspg_nextshot.cond), NULL);
704 }
\end{DoxyCode}
\hypertarget{lspg_8c_a784a6de32a86fec9efb3ef3ae4b6e3ac}{
\index{lspg.c@{lspg.c}!lspg\_\-nextshot\_\-wait@{lspg\_\-nextshot\_\-wait}}
\index{lspg\_\-nextshot\_\-wait@{lspg\_\-nextshot\_\-wait}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-nextshot\_\-wait}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-nextshot\_\-wait ()}}
\label{lspg_8c_a784a6de32a86fec9efb3ef3ae4b6e3ac}


Wait for the next shot query to get processed. 

Definition at line 718 of file lspg.c.


\begin{DoxyCode}
718                           {
719   pthread_mutex_lock( &(lspg_nextshot.mutex));
720   while( lspg_nextshot.new_value_ready == 0)
721     pthread_cond_wait( &(lspg_nextshot.cond), &(lspg_nextshot.mutex));
722 }
\end{DoxyCode}
\hypertarget{lspg_8c_a581c18be0368425665a40b4b7f7d9714}{
\index{lspg.c@{lspg.c}!lspg\_\-pg\_\-connect@{lspg\_\-pg\_\-connect}}
\index{lspg\_\-pg\_\-connect@{lspg\_\-pg\_\-connect}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-pg\_\-connect}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-pg\_\-connect ()}}
\label{lspg_8c_a581c18be0368425665a40b4b7f7d9714}


Connect to the pg server. 

Definition at line 1426 of file lspg.c.


\begin{DoxyCode}
1426                        {
1427   PGresult *pgr;
1428   int wait_interval = 1;
1429   int connection_init = 0;
1430   int i, err;
1431 
1432   if( q == NULL)
1433     ls_pg_state = LS_PG_STATE_INIT;
1434 
1435   switch( ls_pg_state) {
1436   case LS_PG_STATE_INIT:
1437 
1438     if( lspg_time_sent.tv_sec != 0) {
1439       //
1440       // Reality check: if it's less the about 10 seconds since the last failed a
      ttempt
1441       // the just chill.
1442       //
1443       gettimeofday( &now, NULL);
1444       if( now.tv_sec - lspg_time_sent.tv_sec < 10) {
1445         return;
1446       }
1447     }
1448 
1449     q = PQconnectStart( "dbname=ls user=lsuser hostaddr=10.1.0.3");
1450     if( q == NULL) {
1451       lslogging_log_message( "Out of memory (lspg_pg_connect)");
1452       exit( -1);
1453     }
1454 
1455     err = PQstatus( q);
1456     if( err == CONNECTION_BAD) {
1457       lslogging_log_message( "Trouble connecting to database");
1458 
1459       gettimeofday( &lspg_time_sent, NULL);
1460       return;
1461     }
1462     err = PQsetnonblocking( q, 1);
1463     if( err != 0) {
1464       lslogging_log_message( "Odd, could not set database connection to nonblocki
      ng");
1465     }
1466 
1467     ls_pg_state = LS_PG_STATE_INIT_POLL;
1468     lspg_connectPoll_response = PGRES_POLLING_WRITING;
1469     //
1470     // set up the connection for poll
1471     //
1472     lspgfd.fd = PQsocket( q);
1473     break;
1474 
1475   case LS_PG_STATE_INIT_POLL:
1476     if( lspg_connectPoll_response == PGRES_POLLING_FAILED) {
1477       PQfinish( q);
1478       q = NULL;
1479       ls_pg_state = LS_PG_STATE_INIT;
1480     } else if( lspg_connectPoll_response == PGRES_POLLING_OK) {
1481       lspg_query_push( lspg_init_motors_cb, "select * from pmac.md2_getmotors()")
      ;
1482       lspg_query_push( NULL, "select pmac.md2_init()");
1483       lspg_query_push( lspg_zoom_lut_cb, "SELECT * FROM pmac.md2_zoom_lut()");
1484       lspg_query_push( lspg_flight_lut_cb, "SELECT * FROM pmac.md2_flight_lut()")
      ;
1485       lspg_query_push( lspg_blight_lut_cb, "SELECT * FROM pmac.md2_blight_lut()")
      ;
1486       lspg_query_push( lspg_scint_lut_cb,      "SELECT * FROM pmac.md2_scint_lut(
      )");
1487 
1488       ls_pg_state = LS_PG_STATE_IDLE;
1489     }
1490     break;
1491 
1492   case LS_PG_STATE_RESET:
1493     err = PQresetStart( q);
1494     if( err == 0) {
1495       PQfinish( q);
1496       q = NULL;
1497       ls_pg_state = LS_PG_STATE_INIT;
1498     } else {
1499       ls_pg_state = LS_PG_STATE_RESET_POLL;
1500       lspg_resetPoll_response = PGRES_POLLING_WRITING;
1501     }
1502     break;
1503 
1504   case LS_PG_STATE_RESET_POLL:
1505     if( lspg_resetPoll_response == PGRES_POLLING_FAILED) {
1506       PQfinish( q);
1507       q = NULL;
1508       ls_pg_state = LS_PG_STATE_INIT;
1509     } else if( lspg_resetPoll_response == PGRES_POLLING_OK) {
1510       lspg_query_push( lspg_init_motors_cb, "select * from pmac.md2_getmotors()")
      ;
1511       lspg_query_push( NULL, "select pmac.md2_init()");
1512       ls_pg_state = LS_PG_STATE_IDLE;
1513     }
1514     break;
1515   }
1516 }
\end{DoxyCode}
\hypertarget{lspg_8c_aa8d1fed4b461c2139a21826d524777d5}{
\index{lspg.c@{lspg.c}!lspg\_\-pg\_\-service@{lspg\_\-pg\_\-service}}
\index{lspg\_\-pg\_\-service@{lspg\_\-pg\_\-service}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-pg\_\-service}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-pg\_\-service (struct pollfd $\ast$ {\em evt})}}
\label{lspg_8c_aa8d1fed4b461c2139a21826d524777d5}


I/O control to/from the postgresql server. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em evt}]The pollfd object that we are responding to \end{DoxyParams}


Definition at line 1326 of file lspg.c.


\begin{DoxyCode}
1328                        {
1329   //
1330   // Currently just used to check for notifies
1331   // Other socket communication is done syncronously
1332   //
1333 
1334   if( evt->revents & POLLIN) {
1335     int err;
1336 
1337     if( ls_pg_state == LS_PG_STATE_INIT_POLL) {
1338       lspg_connectPoll_response = PQconnectPoll( q);
1339       if( lspg_connectPoll_response == PGRES_POLLING_FAILED) {
1340         ls_pg_state = LS_PG_STATE_RESET;
1341       }
1342       return;
1343     }
1344 
1345     if( ls_pg_state == LS_PG_STATE_RESET_POLL) {
1346       lspg_resetPoll_response = PQresetPoll( q);
1347       if( lspg_resetPoll_response == PGRES_POLLING_FAILED) {
1348         ls_pg_state = LS_PG_STATE_RESET;
1349       }
1350       return;
1351     }
1352 
1353 
1354     //
1355     // if in IDLE or RECV we need to call consumeInput first
1356     //
1357     if( ls_pg_state == LS_PG_STATE_IDLE) {
1358       err = PQconsumeInput( q);
1359       if( err != 1) {
1360         lslogging_log_message( "consume input failed: %s", PQerrorMessage( q));
1361         ls_pg_state == LS_PG_STATE_RESET;
1362         return;
1363       }
1364     }      
1365 
1366     if( ls_pg_state == LS_PG_STATE_RECV) {
1367       lspg_receive();
1368     }
1369 
1370     //
1371     // Check for notifies regardless of our state
1372     // Push as many requests as we have notifies.
1373     //
1374     {
1375       PGnotify *pgn;
1376 
1377       while( 1) {
1378         pgn = PQnotifies( q);
1379         if( pgn == NULL)
1380           break;
1381         
1382         if( strstr( pgn->relname, "_pmac") != NULL) {
1383           lspg_query_push( lspg_cmd_cb, "SELECT pmac.md2_queue_next()");
1384         } else if (strstr( pgn->relname, "_diff") != NULL) {
1385           lspg_query_push( lspg_nextaction_cb, "SELECT action FROM px.nextaction(
      )");
1386         } else if (strstr( pgn->relname, "_kvs") != NULL) {
1387           lspg_query_push( lspg_kvs_cb, "SELECT pmac.getkvs()");
1388         }
1389         PQfreemem( pgn);
1390       }
1391     }
1392   }
1393 
1394   if( evt->revents & POLLOUT) {
1395 
1396     if( ls_pg_state == LS_PG_STATE_INIT_POLL) {
1397       lspg_connectPoll_response = PQconnectPoll( q);
1398       if( lspg_connectPoll_response == PGRES_POLLING_FAILED) {
1399         ls_pg_state = LS_PG_STATE_RESET;
1400       }
1401       return;
1402     }
1403 
1404     if( ls_pg_state == LS_PG_STATE_RESET_POLL) {
1405       lspg_resetPoll_response = PQresetPoll( q);
1406       if( lspg_resetPoll_response == PGRES_POLLING_FAILED) {
1407         ls_pg_state = LS_PG_STATE_RESET;
1408       }
1409       return;
1410     }
1411 
1412 
1413     if( ls_pg_state == LS_PG_STATE_SEND) {
1414       lspg_send_next_query();
1415     }
1416 
1417     if( ls_pg_state == LS_PG_STATE_SEND_FLUSH) {
1418       lspg_flush();
1419     }
1420   }
1421 }
\end{DoxyCode}
\hypertarget{lspg_8c_ad5f3ec8f197cc330c83dba70f310533c}{
\index{lspg.c@{lspg.c}!lspg\_\-query\_\-next@{lspg\_\-query\_\-next}}
\index{lspg\_\-query\_\-next@{lspg\_\-query\_\-next}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-query\_\-next}]{\setlength{\rightskip}{0pt plus 5cm}{\bf lspg\_\-query\_\-queue\_\-t}$\ast$ lspg\_\-query\_\-next ()}}
\label{lspg_8c_ad5f3ec8f197cc330c83dba70f310533c}


Return the next item in the postgresql queue. If there is an item left in the queue then it is returned. Otherwise, NULL is returned. 

Definition at line 79 of file lspg.c.


\begin{DoxyCode}
79                                       {
80   lspg_query_queue_t *rtn;
81   
82   pthread_mutex_lock( &lspg_queue_mutex);
83 
84   if( lspg_query_queue_off == lspg_query_queue_on)
85     // Queue is empty
86     rtn = NULL;
87   else {
88     rtn = &(lspg_query_queue[(lspg_query_queue_off++) % LS_PG_QUERY_QUEUE_LENGTH]
      ); 
89     pthread_cond_signal( &lspg_queue_cond);
90   }
91   pthread_mutex_unlock( &lspg_queue_mutex);
92 
93   return rtn;
94 }
\end{DoxyCode}
\hypertarget{lspg_8c_a0bb9ef42da8fa21c4df48ec384ab69f4}{
\index{lspg.c@{lspg.c}!lspg\_\-query\_\-push@{lspg\_\-query\_\-push}}
\index{lspg\_\-query\_\-push@{lspg\_\-query\_\-push}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-query\_\-push}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-query\_\-push (void($\ast$)({\bf lspg\_\-query\_\-queue\_\-t} $\ast$, PGresult $\ast$) {\em cb}, \/  char $\ast$ {\em fmt}, \/   {\em ...})}}
\label{lspg_8c_a0bb9ef42da8fa21c4df48ec384ab69f4}


Place a query on the queue. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em cb}]Our callback function that deals with the response \item[\mbox{$\leftarrow$} {\em fmt}]Printf style function to generate the query \end{DoxyParams}


Definition at line 132 of file lspg.c.


\begin{DoxyCode}
136                        {
137   int idx;
138   va_list arg_ptr;
139 
140   pthread_mutex_lock( &lspg_queue_mutex);
141 
142   //
143   // Pause the thread while we service the queue
144   //
145   while( lspg_query_queue_on + 1 == lspg_query_queue_off) {
146     pthread_cond_wait( &lspg_queue_cond, &lspg_queue_mutex);
147   }
148 
149   idx = lspg_query_queue_on % LS_PG_QUERY_QUEUE_LENGTH;
150 
151   va_start( arg_ptr, fmt);
152   vsnprintf( lspg_query_queue[idx].qs, LS_PG_QUERY_STRING_LENGTH-1, fmt, arg_ptr)
      ;
153   va_end( arg_ptr);
154 
155   lspg_query_queue[idx].qs[LS_PG_QUERY_STRING_LENGTH - 1] = 0;
156   lspg_query_queue[idx].onResponse = cb;
157   lspg_query_queue_on++;
158 
159   pthread_kill( lspg_thread, SIGUSR1);
160   pthread_mutex_unlock( &lspg_queue_mutex);
161 };
\end{DoxyCode}
\hypertarget{lspg_8c_a3847589e641f7e16a0cd68ef30e37cca}{
\index{lspg.c@{lspg.c}!lspg\_\-query\_\-reply\_\-next@{lspg\_\-query\_\-reply\_\-next}}
\index{lspg\_\-query\_\-reply\_\-next@{lspg\_\-query\_\-reply\_\-next}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-query\_\-reply\_\-next}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-query\_\-reply\_\-next ()}}
\label{lspg_8c_a3847589e641f7e16a0cd68ef30e37cca}


Remove the oldest item in the queue. this is called only when there is nothing else to service the reply: this pop does not return anything. We use the ...reply\_\-peek function to return the next item in the reply queue 

Definition at line 103 of file lspg.c.


\begin{DoxyCode}
103                              {
104 
105   pthread_mutex_lock( &lspg_queue_mutex);
106 
107   if( lspg_query_queue_reply != lspg_query_queue_on)
108     lspg_query_queue_reply++;
109 
110   pthread_mutex_unlock( &lspg_queue_mutex);
111 }
\end{DoxyCode}
\hypertarget{lspg_8c_ae6bf4f54117bedf903360883bb32699f}{
\index{lspg.c@{lspg.c}!lspg\_\-query\_\-reply\_\-peek@{lspg\_\-query\_\-reply\_\-peek}}
\index{lspg\_\-query\_\-reply\_\-peek@{lspg\_\-query\_\-reply\_\-peek}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-query\_\-reply\_\-peek}]{\setlength{\rightskip}{0pt plus 5cm}{\bf lspg\_\-query\_\-queue\_\-t}$\ast$ lspg\_\-query\_\-reply\_\-peek ()}}
\label{lspg_8c_ae6bf4f54117bedf903360883bb32699f}


Return the next item in the reply queue but don't pop it since we may need it more than once. Call \hyperlink{lspg_8c_a3847589e641f7e16a0cd68ef30e37cca}{lspg\_\-query\_\-reply\_\-next()} when done. 

Definition at line 116 of file lspg.c.


\begin{DoxyCode}
116                                             {
117   lspg_query_queue_t *rtn;
118 
119   pthread_mutex_lock( &lspg_queue_mutex);
120 
121   if( lspg_query_queue_reply == lspg_query_queue_on)
122     rtn = NULL;
123   else
124     rtn = &(lspg_query_queue[(lspg_query_queue_reply) % LS_PG_QUERY_QUEUE_LENGTH]
      );
125 
126   pthread_mutex_unlock( &lspg_queue_mutex);
127   return rtn;
128 }
\end{DoxyCode}
\hypertarget{lspg_8c_a038c5af23469b789fc1c55d21cb43029}{
\index{lspg.c@{lspg.c}!lspg\_\-receive@{lspg\_\-receive}}
\index{lspg\_\-receive@{lspg\_\-receive}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-receive}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-receive ()}}
\label{lspg_8c_a038c5af23469b789fc1c55d21cb43029}


Receive a result of a query. 

Definition at line 1243 of file lspg.c.


\begin{DoxyCode}
1243                     {
1244   PGresult *pgr;
1245   lspg_query_queue_t *qqp;
1246   int err;
1247 
1248   err = PQconsumeInput( q);
1249   if( err != 1) {
1250     lslogging_log_message( "consume input failed: %s", PQerrorMessage( q));
1251     ls_pg_state == LS_PG_STATE_RESET;
1252     return;
1253   }
1254 
1255   //
1256   // We must call PQgetResult until it returns NULL before sending the next query
      
1257   // This implies that only one query can ever be active at a time and our queue
1258   // management should be simple
1259   //
1260   // We should be in the LS_PG_STATE_RECV here
1261   //
1262 
1263   while( !PQisBusy( q)) {
1264     pgr = PQgetResult( q);
1265     if( pgr == NULL) {
1266       lspg_query_reply_next();
1267       //
1268       // we are now done reading the response from the database
1269       //
1270       ls_pg_state = LS_PG_STATE_IDLE;
1271       break;
1272     } else {
1273       ExecStatusType es;
1274 
1275       qqp = lspg_query_reply_peek();
1276       es = PQresultStatus( pgr);
1277 
1278       if( es != PGRES_COMMAND_OK && es != PGRES_TUPLES_OK) {
1279         char *emess;
1280         emess = PQresultErrorMessage( pgr);
1281         if( emess != NULL && emess[0] != 0) {
1282           lslogging_log_message( "Error from query '%s':\n%s", qqp->qs, emess);
1283         }
1284       } else {
1285         //
1286         // Deal with the response
1287         //
1288         // If the response is likely to take awhile we should probably
1289         // add a new state and put something in the main look to run the onRespon
      se
1290         // routine in the main loop.  For now, though, we only expect very brief 
      onResponse routines
1291         //
1292         if( qqp != NULL && qqp->onResponse != NULL)
1293           qqp->onResponse( qqp, pgr);
1294       }
1295       PQclear( pgr);
1296     }
1297   }
1298 }
\end{DoxyCode}
\hypertarget{lspg_8c_a1adfdb5ca9fdb5060849d726bf540117}{
\index{lspg.c@{lspg.c}!lspg\_\-run@{lspg\_\-run}}
\index{lspg\_\-run@{lspg\_\-run}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-run}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-run ()}}
\label{lspg_8c_a1adfdb5ca9fdb5060849d726bf540117}


Start 'er runnin'. 

Definition at line 1667 of file lspg.c.


\begin{DoxyCode}
1667                 {
1668   pthread_create( &lspg_thread, NULL, lspg_worker, NULL);
1669 }
\end{DoxyCode}
\hypertarget{lspg_8c_a71db585552ea3f58a1c9ab3fbe62bb79}{
\index{lspg.c@{lspg.c}!lspg\_\-scint\_\-lut\_\-cb@{lspg\_\-scint\_\-lut\_\-cb}}
\index{lspg\_\-scint\_\-lut\_\-cb@{lspg\_\-scint\_\-lut\_\-cb}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-scint\_\-lut\_\-cb}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-scint\_\-lut\_\-cb ({\bf lspg\_\-query\_\-queue\_\-t} $\ast$ {\em qqp}, \/  PGresult $\ast$ {\em pgr})}}
\label{lspg_8c_a71db585552ea3f58a1c9ab3fbe62bb79}

\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em qqp}]Our query \item[\mbox{$\leftarrow$} {\em pgr}]Our result object \end{DoxyParams}


Definition at line 369 of file lspg.c.


\begin{DoxyCode}
372                           {
373   int i;
374   pthread_mutex_lock( &(fscint->mutex));
375   
376   fscint->nlut = PQntuples( pgr)/2;
377   fscint->lut  = calloc( 2*fscint->nlut, sizeof( double));
378   if( fscint->lut == NULL) {
379     lslogging_log_message( "lspg_scint_lut_cb: Out of memory");
380     pthread_mutex_unlock( &(fscint->mutex));
381   }
382   
383   for( i=0; i<PQntuples( pgr); i++) {
384     fscint->lut[i] = strtod( PQgetvalue( pgr, i, 0), NULL);
385   }
386 
387   pthread_mutex_unlock( &(fscint->mutex));
388 }
\end{DoxyCode}
\hypertarget{lspg_8c_a714b15e117ffe7bfce4f2f2ce4725b0a}{
\index{lspg.c@{lspg.c}!lspg\_\-send\_\-next\_\-query@{lspg\_\-send\_\-next\_\-query}}
\index{lspg\_\-send\_\-next\_\-query@{lspg\_\-send\_\-next\_\-query}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-send\_\-next\_\-query}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-send\_\-next\_\-query ()}}
\label{lspg_8c_a714b15e117ffe7bfce4f2f2ce4725b0a}


send the next queued query to the DB server 

Definition at line 1196 of file lspg.c.


\begin{DoxyCode}
1196                             {
1197   //
1198   // Normally we should be in the "send" state
1199   // but we can also send if we are servicing
1200   // a reply
1201   //
1202 
1203   lspg_query_queue_t *qqp;
1204   int err;
1205 
1206   qqp = lspg_query_next();
1207   if( qqp == NULL) {
1208     //
1209     // A send without a query?  Should never happen.
1210     // But at least we shouldn't segfault if it does.
1211     //
1212     return;
1213   }
1214 
1215   if( qqp->qs[0] == 0) {
1216     //
1217     // Do we really have to check this case?
1218     // It would only come up if we stupidly pushed an empty query string
1219     // or ran off the end of the queue
1220     //
1221     lslogging_log_message( "Popped empty query string.  Probably bad things are g
      oing on.");
1222 
1223     lspg_query_reply_next();
1224     ls_pg_state = LS_PG_STATE_IDLE;
1225   } else {
1226     err = PQsendQuery( q, qqp->qs);
1227     if( err == 0) {
1228       lslogging_log_message( "query failed: %s\n", PQerrorMessage( q));
1229 
1230       //
1231       // Don't wait for a reply, just reset the connection
1232       //
1233       lspg_query_reply_next();
1234       ls_pg_state == LS_PG_STATE_RESET;
1235     } else {
1236       ls_pg_state = LS_PG_STATE_SEND_FLUSH;
1237     }
1238   }
1239 }
\end{DoxyCode}
\hypertarget{lspg_8c_a4253474d4dd305aec0afdd5552b3ddd5}{
\index{lspg.c@{lspg.c}!lspg\_\-seq\_\-run\_\-prep\_\-all@{lspg\_\-seq\_\-run\_\-prep\_\-all}}
\index{lspg\_\-seq\_\-run\_\-prep\_\-all@{lspg\_\-seq\_\-run\_\-prep\_\-all}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-seq\_\-run\_\-prep\_\-all}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-seq\_\-run\_\-prep\_\-all (long long {\em skey}, \/  double {\em kappa}, \/  double {\em phi}, \/  double {\em cx}, \/  double {\em cy}, \/  double {\em ax}, \/  double {\em ay}, \/  double {\em az})}}
\label{lspg_8c_a4253474d4dd305aec0afdd5552b3ddd5}


Convinence function to call seq run prep. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em skey}]px.shots key for this image \item[\mbox{$\leftarrow$} {\em kappa}]current kappa postion \item[\mbox{$\leftarrow$} {\em phi}]current phi postition \item[\mbox{$\leftarrow$} {\em cx}]current center table x \item[\mbox{$\leftarrow$} {\em cy}]current center table y \item[\mbox{$\leftarrow$} {\em ax}]current alignment table x \item[\mbox{$\leftarrow$} {\em ay}]current alignment table y \item[\mbox{$\leftarrow$} {\em az}]current alignment table z \end{DoxyParams}


Definition at line 979 of file lspg.c.


\begin{DoxyCode}
988                              {
989   lspg_seq_run_prep_call( skey, kappa, phi, cx, cy, ax, ay, az);
990   lspg_seq_run_prep_wait();
991   lspg_seq_run_prep_done();
992 }
\end{DoxyCode}
\hypertarget{lspg_8c_af7d6efd861b152a371442791deb42bd3}{
\index{lspg.c@{lspg.c}!lspg\_\-seq\_\-run\_\-prep\_\-call@{lspg\_\-seq\_\-run\_\-prep\_\-call}}
\index{lspg\_\-seq\_\-run\_\-prep\_\-call@{lspg\_\-seq\_\-run\_\-prep\_\-call}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-seq\_\-run\_\-prep\_\-call}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-seq\_\-run\_\-prep\_\-call (long long {\em skey}, \/  double {\em kappa}, \/  double {\em phi}, \/  double {\em cx}, \/  double {\em cy}, \/  double {\em ax}, \/  double {\em ay}, \/  double {\em az})}}
\label{lspg_8c_af7d6efd861b152a371442791deb42bd3}


queue up the seq\_\-run\_\-prep query 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em skey}]px.shots key for this image \item[\mbox{$\leftarrow$} {\em kappa}]current kappa postion \item[\mbox{$\leftarrow$} {\em phi}]current phi postition \item[\mbox{$\leftarrow$} {\em cx}]current center table x \item[\mbox{$\leftarrow$} {\em cy}]current center table y \item[\mbox{$\leftarrow$} {\em ax}]current alignment table x \item[\mbox{$\leftarrow$} {\em ay}]current alignment table y \item[\mbox{$\leftarrow$} {\em az}]current alignment table z \end{DoxyParams}


Definition at line 945 of file lspg.c.


\begin{DoxyCode}
954                               {
955   pthread_mutex_lock( &(lspg_seq_run_prep.mutex));
956   lspg_seq_run_prep.new_value_ready = 0;
957   pthread_mutex_unlock( &(lspg_seq_run_prep.mutex));
958 
959   lspg_query_push( lspg_seq_run_prep_cb, "SELECT px.seq_run_prep( %lld, %.3f, %.3
      f, %.3f, %.3f, %.3f, %.3f, %.3f)",
960                    skey, kappa, phi, cx, cy, ax, ay, az);
961 }
\end{DoxyCode}
\hypertarget{lspg_8c_a11cda12050dc9a86188e15e2155a6013}{
\index{lspg.c@{lspg.c}!lspg\_\-seq\_\-run\_\-prep\_\-cb@{lspg\_\-seq\_\-run\_\-prep\_\-cb}}
\index{lspg\_\-seq\_\-run\_\-prep\_\-cb@{lspg\_\-seq\_\-run\_\-prep\_\-cb}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-seq\_\-run\_\-prep\_\-cb}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-seq\_\-run\_\-prep\_\-cb ({\bf lspg\_\-query\_\-queue\_\-t} $\ast$ {\em qqp}, \/  PGresult $\ast$ {\em pgr})}}
\label{lspg_8c_a11cda12050dc9a86188e15e2155a6013}


Callback for the seq\_\-run\_\-prep query. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em qqp}]The query item that generated this callback \item[\mbox{$\leftarrow$} {\em pgr}]The result of the query \end{DoxyParams}


Definition at line 933 of file lspg.c.


\begin{DoxyCode}
936                             {
937   pthread_mutex_lock( &(lspg_seq_run_prep.mutex));
938   lspg_seq_run_prep.new_value_ready = 1;
939   pthread_cond_signal( &(lspg_seq_run_prep.cond));
940   pthread_mutex_unlock( &(lspg_seq_run_prep.mutex));
941 }
\end{DoxyCode}
\hypertarget{lspg_8c_a472b09ddf716c80207f97e2bb5d37d66}{
\index{lspg.c@{lspg.c}!lspg\_\-seq\_\-run\_\-prep\_\-done@{lspg\_\-seq\_\-run\_\-prep\_\-done}}
\index{lspg\_\-seq\_\-run\_\-prep\_\-done@{lspg\_\-seq\_\-run\_\-prep\_\-done}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-seq\_\-run\_\-prep\_\-done}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-seq\_\-run\_\-prep\_\-done ()}}
\label{lspg_8c_a472b09ddf716c80207f97e2bb5d37d66}


Indicate we are done waiting. 

Definition at line 973 of file lspg.c.


\begin{DoxyCode}
973                               {
974   pthread_mutex_unlock( &(lspg_seq_run_prep.mutex));
975 }
\end{DoxyCode}
\hypertarget{lspg_8c_a31823ecb2b44d4a6674f804059a27bce}{
\index{lspg.c@{lspg.c}!lspg\_\-seq\_\-run\_\-prep\_\-init@{lspg\_\-seq\_\-run\_\-prep\_\-init}}
\index{lspg\_\-seq\_\-run\_\-prep\_\-init@{lspg\_\-seq\_\-run\_\-prep\_\-init}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-seq\_\-run\_\-prep\_\-init}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-seq\_\-run\_\-prep\_\-init ()}}
\label{lspg_8c_a31823ecb2b44d4a6674f804059a27bce}


Initialize the data collection object. 

Definition at line 925 of file lspg.c.


\begin{DoxyCode}
925                               {
926   lspg_seq_run_prep.new_value_ready = 0;
927   pthread_mutex_init( &(lspg_seq_run_prep.mutex), NULL);
928   pthread_cond_init(  &(lspg_seq_run_prep.cond),  NULL);
929 }
\end{DoxyCode}
\hypertarget{lspg_8c_ac0b01f501322432a8fa37f31898c3499}{
\index{lspg.c@{lspg.c}!lspg\_\-seq\_\-run\_\-prep\_\-wait@{lspg\_\-seq\_\-run\_\-prep\_\-wait}}
\index{lspg\_\-seq\_\-run\_\-prep\_\-wait@{lspg\_\-seq\_\-run\_\-prep\_\-wait}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-seq\_\-run\_\-prep\_\-wait}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-seq\_\-run\_\-prep\_\-wait ()}}
\label{lspg_8c_ac0b01f501322432a8fa37f31898c3499}


Wait for seq run prep query to return. 

Definition at line 965 of file lspg.c.


\begin{DoxyCode}
965                               {
966   pthread_mutex_lock( &(lspg_seq_run_prep.mutex));
967   while( lspg_seq_run_prep.new_value_ready == 0)
968     pthread_cond_wait( &(lspg_seq_run_prep.cond), &(lspg_seq_run_prep.mutex));
969 }
\end{DoxyCode}
\hypertarget{lspg_8c_a049f4422994aa2eb2b841ffb2937f895}{
\index{lspg.c@{lspg.c}!lspg\_\-sig\_\-service@{lspg\_\-sig\_\-service}}
\index{lspg\_\-sig\_\-service@{lspg\_\-sig\_\-service}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-sig\_\-service}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-sig\_\-service (struct pollfd $\ast$ {\em evt})}}
\label{lspg_8c_a049f4422994aa2eb2b841ffb2937f895}


Service a signal Signals here are treated as file descriptors and fits into our poll scheme. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em evt}]The pollfd object that triggered this call \end{DoxyParams}


Definition at line 1304 of file lspg.c.


\begin{DoxyCode}
1306                         {
1307   struct signalfd_siginfo fdsi;
1308 
1309   //
1310   // Really, we don't care about the signal,
1311   // it's just used to drop out of the poll
1312   // function when there is something for us
1313   // to do that didn't invovle something coming
1314   // from our postgresql server.
1315   //
1316   // This is accompished by the query_push function
1317   // to notify us that a new query is ready.
1318   //
1319 
1320   read( evt->fd, &fdsi, sizeof( struct signalfd_siginfo));
1321 
1322 }
\end{DoxyCode}
\hypertarget{lspg_8c_ab9780e15924a50b2a5545e10806000b3}{
\index{lspg.c@{lspg.c}!lspg\_\-wait\_\-for\_\-detector\_\-all@{lspg\_\-wait\_\-for\_\-detector\_\-all}}
\index{lspg\_\-wait\_\-for\_\-detector\_\-all@{lspg\_\-wait\_\-for\_\-detector\_\-all}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-wait\_\-for\_\-detector\_\-all}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-wait\_\-for\_\-detector\_\-all ()}}
\label{lspg_8c_ab9780e15924a50b2a5545e10806000b3}


Combined call to wait for the detector. 

Definition at line 789 of file lspg.c.


\begin{DoxyCode}
789                                   {
790   lspg_wait_for_detector_call();
791   lspg_wait_for_detector_wait();
792   lspg_wait_for_detector_done();
793 }
\end{DoxyCode}
\hypertarget{lspg_8c_a4b5222b859a44eae616804a1e990b86d}{
\index{lspg.c@{lspg.c}!lspg\_\-wait\_\-for\_\-detector\_\-call@{lspg\_\-wait\_\-for\_\-detector\_\-call}}
\index{lspg\_\-wait\_\-for\_\-detector\_\-call@{lspg\_\-wait\_\-for\_\-detector\_\-call}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-wait\_\-for\_\-detector\_\-call}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-wait\_\-for\_\-detector\_\-call ()}}
\label{lspg_8c_a4b5222b859a44eae616804a1e990b86d}


initiate the wait for detector query 

Definition at line 763 of file lspg.c.


\begin{DoxyCode}
763                                    {
764   pthread_mutex_lock( &(lspg_wait_for_detector.mutex));
765   lspg_wait_for_detector.new_value_ready = 0;
766   pthread_mutex_unlock( &(lspg_wait_for_detector.mutex));
767   
768   lspg_query_push( lspg_wait_for_detector_cb, "SELECT px.lock_detector_test_block
      ()");
769 }
\end{DoxyCode}
\hypertarget{lspg_8c_a5747c519d1aa4c310010a862cae8a823}{
\index{lspg.c@{lspg.c}!lspg\_\-wait\_\-for\_\-detector\_\-cb@{lspg\_\-wait\_\-for\_\-detector\_\-cb}}
\index{lspg\_\-wait\_\-for\_\-detector\_\-cb@{lspg\_\-wait\_\-for\_\-detector\_\-cb}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-wait\_\-for\_\-detector\_\-cb}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-wait\_\-for\_\-detector\_\-cb ({\bf lspg\_\-query\_\-queue\_\-t} $\ast$ {\em qqp}, \/  PGresult $\ast$ {\em pgr})}}
\label{lspg_8c_a5747c519d1aa4c310010a862cae8a823}


Callback for the wait for detector query. 

Definition at line 754 of file lspg.c.


\begin{DoxyCode}
754                                                                         {
755   pthread_mutex_lock( &(lspg_wait_for_detector.mutex));
756   lspg_wait_for_detector.new_value_ready = 1;
757   pthread_cond_signal(  &(lspg_wait_for_detector.cond));
758   pthread_mutex_unlock( &(lspg_wait_for_detector.mutex));
759 }
\end{DoxyCode}
\hypertarget{lspg_8c_abb3645dee7c4514b650ab02f27570a69}{
\index{lspg.c@{lspg.c}!lspg\_\-wait\_\-for\_\-detector\_\-done@{lspg\_\-wait\_\-for\_\-detector\_\-done}}
\index{lspg\_\-wait\_\-for\_\-detector\_\-done@{lspg\_\-wait\_\-for\_\-detector\_\-done}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-wait\_\-for\_\-detector\_\-done}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-wait\_\-for\_\-detector\_\-done ()}}
\label{lspg_8c_abb3645dee7c4514b650ab02f27570a69}


Done waiting for the detector. 

Definition at line 782 of file lspg.c.


\begin{DoxyCode}
782                                    {
783   pthread_mutex_unlock( &(lspg_wait_for_detector.mutex));
784 }
\end{DoxyCode}
\hypertarget{lspg_8c_a3517f8fbed91c998f6036284f9bd0c48}{
\index{lspg.c@{lspg.c}!lspg\_\-wait\_\-for\_\-detector\_\-init@{lspg\_\-wait\_\-for\_\-detector\_\-init}}
\index{lspg\_\-wait\_\-for\_\-detector\_\-init@{lspg\_\-wait\_\-for\_\-detector\_\-init}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-wait\_\-for\_\-detector\_\-init}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-wait\_\-for\_\-detector\_\-init ()}}
\label{lspg_8c_a3517f8fbed91c998f6036284f9bd0c48}


initialize the detector timing object 

Definition at line 746 of file lspg.c.


\begin{DoxyCode}
746                                    {
747   lspg_wait_for_detector.new_value_ready = 0;
748   pthread_mutex_init( &(lspg_wait_for_detector.mutex), NULL);
749   pthread_cond_init(  &(lspg_wait_for_detector.cond), NULL);
750 }
\end{DoxyCode}
\hypertarget{lspg_8c_af094e01be121ce8e14abb679abd17e19}{
\index{lspg.c@{lspg.c}!lspg\_\-wait\_\-for\_\-detector\_\-wait@{lspg\_\-wait\_\-for\_\-detector\_\-wait}}
\index{lspg\_\-wait\_\-for\_\-detector\_\-wait@{lspg\_\-wait\_\-for\_\-detector\_\-wait}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-wait\_\-for\_\-detector\_\-wait}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-wait\_\-for\_\-detector\_\-wait ()}}
\label{lspg_8c_af094e01be121ce8e14abb679abd17e19}


Pause the calling thread until the detector is ready Called by the MD2 thread. 

Definition at line 774 of file lspg.c.


\begin{DoxyCode}
774                                    {
775   pthread_mutex_lock( &(lspg_wait_for_detector.mutex));
776   while( lspg_wait_for_detector.new_value_ready == 0)
777     pthread_cond_wait( &(lspg_wait_for_detector.cond), &(lspg_wait_for_detector.
      mutex));
778 }
\end{DoxyCode}
\hypertarget{lspg_8c_aaf4fadd2943fa3a2ecb5d840e84d68fa}{
\index{lspg.c@{lspg.c}!lspg\_\-worker@{lspg\_\-worker}}
\index{lspg\_\-worker@{lspg\_\-worker}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-worker}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ lspg\_\-worker (void $\ast$ {\em dummy})}}
\label{lspg_8c_aaf4fadd2943fa3a2ecb5d840e84d68fa}


The main loop for the lspg thread. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em dummy}]Required by pthreads but unused \end{DoxyParams}


Definition at line 1575 of file lspg.c.


\begin{DoxyCode}
1577                     {
1578   static struct pollfd fda[2];  // 0=signal handler, 1=pg socket
1579   static int nfda = 0;
1580   static sigset_t our_sigset;
1581   int sigfd;
1582 
1583   sigemptyset( &our_sigset);
1584   sigaddset( &our_sigset, SIGUSR1);
1585 
1586 
1587   //
1588   // block ordinary signal mechanism
1589   //
1590   sigprocmask(SIG_BLOCK, &our_sigset, NULL);
1591 
1592     
1593   fda[0].fd = signalfd( -1, &our_sigset, SFD_NONBLOCK);
1594   if( fda[0].fd == -1) {
1595     char *es;
1596 
1597     es = strerror( errno);
1598     lslogging_log_message( "Signalfd trouble: %s", es);
1599   }
1600   fda[0].events = POLLIN;
1601 
1602   //
1603   //  make sure file descriptor is not legal until it's been conneceted
1604   //
1605   lspgfd.fd   = -1;
1606 
1607 
1608   while( 1) {
1609     int pollrtn;
1610     int poll_timeout_ms;
1611 
1612     lspg_next_state();
1613 
1614     if( lspgfd.fd == -1) {
1615       //
1616       // Here a connection to the database is not established.
1617       // Periodicaly try again.  Should possibly arrange to reconnect
1618       // to signalfd but that's unlikely to be nessesary.
1619       //
1620       nfda = 1;
1621       poll_timeout_ms = 10000;
1622       fda[1].revents = 0;
1623     } else {
1624       //
1625       // Arrange to peacfully do nothing until either the pg server sends us some
      thing
1626       // or someone pushs something onto our queue
1627       //
1628       nfda = 2;
1629       fda[1].fd      = lspgfd.fd;
1630       fda[1].events  = lspgfd.events;
1631       fda[1].revents = 0;
1632       poll_timeout_ms = -1;
1633     }
1634 
1635     pollrtn = poll( fda, nfda, poll_timeout_ms);
1636 
1637     if( pollrtn && fda[0].revents) {
1638       lspg_sig_service( &(fda[0]));
1639       pollrtn--;
1640     } 
1641     if( pollrtn && fda[1].revents) {
1642       lspg_pg_service( &(fda[1]));
1643       pollrtn--;
1644     } 
1645 
1646 
1647 
1648 
1649   }
1650 }
\end{DoxyCode}
\hypertarget{lspg_8c_af34559ab5624e1e68085dbcd9410c692}{
\index{lspg.c@{lspg.c}!lspg\_\-zoom\_\-lut\_\-cb@{lspg\_\-zoom\_\-lut\_\-cb}}
\index{lspg\_\-zoom\_\-lut\_\-cb@{lspg\_\-zoom\_\-lut\_\-cb}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-zoom\_\-lut\_\-cb}]{\setlength{\rightskip}{0pt plus 5cm}void lspg\_\-zoom\_\-lut\_\-cb ({\bf lspg\_\-query\_\-queue\_\-t} $\ast$ {\em qqp}, \/  PGresult $\ast$ {\em pgr})}}
\label{lspg_8c_af34559ab5624e1e68085dbcd9410c692}


Zoom motor look up table callback. 
\begin{DoxyParams}{Parameters}
\item[\mbox{$\leftarrow$} {\em qqp}]the queue item responsible for calling us \item[\mbox{$\leftarrow$} {\em pgr}]The Postgresql result object \end{DoxyParams}


Definition at line 346 of file lspg.c.


\begin{DoxyCode}
349                         {
350   int i;
351   
352   pthread_mutex_lock( &(zoom->mutex));
353 
354   zoom->nlut = PQntuples( pgr)/2;
355   zoom->lut  = calloc( 2*zoom->nlut, sizeof(double));
356   if( zoom->lut == NULL) {
357     lslogging_log_message( "Out of memmory (lspg_zoom_lut_cb)");
358     pthread_mutex_unlock( &(zoom->mutex));
359     return;
360   }
361   
362   for( i=0; i<PQntuples( pgr); i++) {
363     zoom->lut[i] = strtod( PQgetvalue( pgr, i, 0), NULL);
364   }
365 
366   pthread_mutex_unlock( &(zoom->mutex));
367 }
\end{DoxyCode}


\subsection{Variable Documentation}
\hypertarget{lspg_8c_a4937baac0cc78ea306d58b5f027867f1}{
\index{lspg.c@{lspg.c}!ls\_\-pg\_\-state@{ls\_\-pg\_\-state}}
\index{ls\_\-pg\_\-state@{ls\_\-pg\_\-state}!lspg.c@{lspg.c}}
\subsubsection[{ls\_\-pg\_\-state}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf ls\_\-pg\_\-state} = LS\_\-PG\_\-STATE\_\-INIT\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{lspg_8c_a4937baac0cc78ea306d58b5f027867f1}


State of the lspg state machine. 

Definition at line 39 of file lspg.c.\hypertarget{lspg_8c_a69ae04978986e6413ca7cefcb692b645}{
\index{lspg.c@{lspg.c}!lspg\_\-connectPoll\_\-response@{lspg\_\-connectPoll\_\-response}}
\index{lspg\_\-connectPoll\_\-response@{lspg\_\-connectPoll\_\-response}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-connectPoll\_\-response}]{\setlength{\rightskip}{0pt plus 5cm}PostgresPollingStatusType {\bf lspg\_\-connectPoll\_\-response}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{lspg_8c_a69ae04978986e6413ca7cefcb692b645}


Used to determine state while connecting. 

Definition at line 69 of file lspg.c.\hypertarget{lspg_8c_a7ef8a09203117578c9b2ce4719519f36}{
\index{lspg.c@{lspg.c}!lspg\_\-getcenter@{lspg\_\-getcenter}}
\index{lspg\_\-getcenter@{lspg\_\-getcenter}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-getcenter}]{\setlength{\rightskip}{0pt plus 5cm}{\bf lspg\_\-getcenter\_\-t} {\bf lspg\_\-getcenter}}}
\label{lspg_8c_a7ef8a09203117578c9b2ce4719519f36}


the getcenter object 

Definition at line 73 of file lspg.c.\hypertarget{lspg_8c_adbf3b3652c6531c3d194320d1abc1c80}{
\index{lspg.c@{lspg.c}!lspg\_\-lock\_\-detector@{lspg\_\-lock\_\-detector}}
\index{lspg\_\-lock\_\-detector@{lspg\_\-lock\_\-detector}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-lock\_\-detector}]{\setlength{\rightskip}{0pt plus 5cm}{\bf lspg\_\-lock\_\-detector\_\-t} {\bf lspg\_\-lock\_\-detector}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{lspg_8c_adbf3b3652c6531c3d194320d1abc1c80}


Definition at line 863 of file lspg.c.\hypertarget{lspg_8c_aaae7ce3ecd7d54a9e46c41d7a742a454}{
\index{lspg.c@{lspg.c}!lspg\_\-lock\_\-diffractometer@{lspg\_\-lock\_\-diffractometer}}
\index{lspg\_\-lock\_\-diffractometer@{lspg\_\-lock\_\-diffractometer}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-lock\_\-diffractometer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf lspg\_\-lock\_\-diffractometer\_\-t} {\bf lspg\_\-lock\_\-diffractometer}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{lspg_8c_aaae7ce3ecd7d54a9e46c41d7a742a454}


Definition at line 804 of file lspg.c.\hypertarget{lspg_8c_ad8d8e2f578ca79189a80c1fd5b60cefd}{
\index{lspg.c@{lspg.c}!lspg\_\-nextshot@{lspg\_\-nextshot}}
\index{lspg\_\-nextshot@{lspg\_\-nextshot}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-nextshot}]{\setlength{\rightskip}{0pt plus 5cm}{\bf lspg\_\-nextshot\_\-t} {\bf lspg\_\-nextshot}}}
\label{lspg_8c_ad8d8e2f578ca79189a80c1fd5b60cefd}


the nextshot object 

Definition at line 72 of file lspg.c.\hypertarget{lspg_8c_a357d9d98f0b8c9625ccebcebfcdce955}{
\index{lspg.c@{lspg.c}!lspg\_\-query\_\-queue@{lspg\_\-query\_\-queue}}
\index{lspg\_\-query\_\-queue@{lspg\_\-query\_\-queue}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-query\_\-queue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf lspg\_\-query\_\-queue\_\-t} {\bf lspg\_\-query\_\-queue}\mbox{[}LS\_\-PG\_\-QUERY\_\-QUEUE\_\-LENGTH\mbox{]}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{lspg_8c_a357d9d98f0b8c9625ccebcebfcdce955}


Our query queue. 

Definition at line 61 of file lspg.c.\hypertarget{lspg_8c_aca86bb77d6cecfae9251743f4171bafb}{
\index{lspg.c@{lspg.c}!lspg\_\-query\_\-queue\_\-off@{lspg\_\-query\_\-queue\_\-off}}
\index{lspg\_\-query\_\-queue\_\-off@{lspg\_\-query\_\-queue\_\-off}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-query\_\-queue\_\-off}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int {\bf lspg\_\-query\_\-queue\_\-off} = 0\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{lspg_8c_aca86bb77d6cecfae9251743f4171bafb}


The last item still being used (on == off means nothing in queue). 

Definition at line 63 of file lspg.c.\hypertarget{lspg_8c_a3cbe7f3161b3c1838ebc56a3bbcfd8a6}{
\index{lspg.c@{lspg.c}!lspg\_\-query\_\-queue\_\-on@{lspg\_\-query\_\-queue\_\-on}}
\index{lspg\_\-query\_\-queue\_\-on@{lspg\_\-query\_\-queue\_\-on}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-query\_\-queue\_\-on}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int {\bf lspg\_\-query\_\-queue\_\-on} = 0\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{lspg_8c_a3cbe7f3161b3c1838ebc56a3bbcfd8a6}


Next position to add something to the queue. 

Definition at line 62 of file lspg.c.\hypertarget{lspg_8c_a2603b071afdbff7c0924b13de2454264}{
\index{lspg.c@{lspg.c}!lspg\_\-query\_\-queue\_\-reply@{lspg\_\-query\_\-queue\_\-reply}}
\index{lspg\_\-query\_\-queue\_\-reply@{lspg\_\-query\_\-queue\_\-reply}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-query\_\-queue\_\-reply}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int {\bf lspg\_\-query\_\-queue\_\-reply} = 0\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{lspg_8c_a2603b071afdbff7c0924b13de2454264}


The current item being digested. Normally off $<$= reply $<$= on. Corner case of queue wrap arround works because we only increment and compare for equality. 

Definition at line 64 of file lspg.c.\hypertarget{lspg_8c_a61a308b6a37afd645beb422653b95baa}{
\index{lspg.c@{lspg.c}!lspg\_\-queue\_\-cond@{lspg\_\-queue\_\-cond}}
\index{lspg\_\-queue\_\-cond@{lspg\_\-queue\_\-cond}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-queue\_\-cond}]{\setlength{\rightskip}{0pt plus 5cm}pthread\_\-cond\_\-t {\bf lspg\_\-queue\_\-cond}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{lspg_8c_a61a308b6a37afd645beb422653b95baa}


keeps the queue from overflowing 

Definition at line 44 of file lspg.c.\hypertarget{lspg_8c_aed46a94106c583796e3a8ca0e89aa8e4}{
\index{lspg.c@{lspg.c}!lspg\_\-queue\_\-mutex@{lspg\_\-queue\_\-mutex}}
\index{lspg\_\-queue\_\-mutex@{lspg\_\-queue\_\-mutex}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-queue\_\-mutex}]{\setlength{\rightskip}{0pt plus 5cm}pthread\_\-mutex\_\-t {\bf lspg\_\-queue\_\-mutex}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{lspg_8c_aed46a94106c583796e3a8ca0e89aa8e4}


keep the queue from getting tangled 

Definition at line 43 of file lspg.c.\hypertarget{lspg_8c_a06c5a937e41a6c706a247777642ec1fb}{
\index{lspg.c@{lspg.c}!lspg\_\-resetPoll\_\-response@{lspg\_\-resetPoll\_\-response}}
\index{lspg\_\-resetPoll\_\-response@{lspg\_\-resetPoll\_\-response}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-resetPoll\_\-response}]{\setlength{\rightskip}{0pt plus 5cm}PostgresPollingStatusType {\bf lspg\_\-resetPoll\_\-response}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{lspg_8c_a06c5a937e41a6c706a247777642ec1fb}


Used to determine state while reconnecting. 

Definition at line 70 of file lspg.c.\hypertarget{lspg_8c_a1b0d9fc30bcea6905b075d2362149172}{
\index{lspg.c@{lspg.c}!lspg\_\-seq\_\-run\_\-prep@{lspg\_\-seq\_\-run\_\-prep}}
\index{lspg\_\-seq\_\-run\_\-prep@{lspg\_\-seq\_\-run\_\-prep}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-seq\_\-run\_\-prep}]{\setlength{\rightskip}{0pt plus 5cm}{\bf lspg\_\-seq\_\-run\_\-prep\_\-t} {\bf lspg\_\-seq\_\-run\_\-prep}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{lspg_8c_a1b0d9fc30bcea6905b075d2362149172}


Definition at line 921 of file lspg.c.\hypertarget{lspg_8c_a04eb0cda0d5e5afeae7c393b51689765}{
\index{lspg.c@{lspg.c}!lspg\_\-thread@{lspg\_\-thread}}
\index{lspg\_\-thread@{lspg\_\-thread}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-thread}]{\setlength{\rightskip}{0pt plus 5cm}pthread\_\-t {\bf lspg\_\-thread}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{lspg_8c_a04eb0cda0d5e5afeae7c393b51689765}


our worker thread 

Definition at line 42 of file lspg.c.\hypertarget{lspg_8c_a0dfc8d0410cd2d7f7da7a70d3ef88e58}{
\index{lspg.c@{lspg.c}!lspg\_\-wait\_\-for\_\-detector@{lspg\_\-wait\_\-for\_\-detector}}
\index{lspg\_\-wait\_\-for\_\-detector@{lspg\_\-wait\_\-for\_\-detector}!lspg.c@{lspg.c}}
\subsubsection[{lspg\_\-wait\_\-for\_\-detector}]{\setlength{\rightskip}{0pt plus 5cm}{\bf lspg\_\-wait\_\-for\_\-detector\_\-t} {\bf lspg\_\-wait\_\-for\_\-detector}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{lspg_8c_a0dfc8d0410cd2d7f7da7a70d3ef88e58}


Instance of the detector timing object. 

Definition at line 742 of file lspg.c.\hypertarget{lspg_8c_af3f897b8ffa020ca54289bc5b28cb64d}{
\index{lspg.c@{lspg.c}!lspgfd@{lspgfd}}
\index{lspgfd@{lspgfd}!lspg.c@{lspg.c}}
\subsubsection[{lspgfd}]{\setlength{\rightskip}{0pt plus 5cm}struct pollfd {\bf lspgfd}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{lspg_8c_af3f897b8ffa020ca54289bc5b28cb64d}


our poll info 

Definition at line 45 of file lspg.c.\hypertarget{lspg_8c_ad40ac52086f6b774928af45b09d54c6e}{
\index{lspg.c@{lspg.c}!now@{now}}
\index{now@{now}!lspg.c@{lspg.c}}
\subsubsection[{now}]{\setlength{\rightskip}{0pt plus 5cm}struct timeval lspg\_\-time\_\-sent {\bf now}\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{lspg_8c_ad40ac52086f6b774928af45b09d54c6e}


used to ensure we do not inundate the db server with connection requests 

Definition at line 40 of file lspg.c.\hypertarget{lspg_8c_a9012783dbbadf652a81649a289697cf3}{
\index{lspg.c@{lspg.c}!q@{q}}
\index{q@{q}!lspg.c@{lspg.c}}
\subsubsection[{q}]{\setlength{\rightskip}{0pt plus 5cm}PGconn$\ast$ {\bf q} = NULL\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{lspg_8c_a9012783dbbadf652a81649a289697cf3}


Database connector. 

Definition at line 68 of file lspg.c.