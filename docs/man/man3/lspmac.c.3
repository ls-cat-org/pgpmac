.TH "lspmac.c" 3 "Sun Dec 16 2012" "LS-CAT PGPMAC" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lspmac.c \- 
.PP
Routines concerned with communication with PMAC\&.  

.SH SYNOPSIS
.br
.PP
\fC#include 'pgpmac\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBmd2StatusStruct\fP"
.br
.RI "\fIThe block of memory retrieved in a status request\&. \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBLS_PMAC_STATE_RESET\fP   -1"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_DETACHED\fP   0"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_IDLE\fP   1"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_SC\fP   2"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_WACK_NFR\fP   3"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_WACK_CC\fP   4"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_WACK\fP   5"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_GMR\fP   6"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_CR\fP   7"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_RR\fP   8"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_WACK_RR\fP   9"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_GB\fP   10"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_WCR\fP   11"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_WGB\fP   12"
.br
.ti -1c
.RI "#define \fBLSPMAC_PRESET_REGEX\fP   '(\&.*\\\\\&.%s\\\\\&.presets)\\\\\&.([0-9]+)\\\\\&.(name|position)'"
.br
.RI "\fIRegex to pick out preset name and corresponding position\&. \fP"
.ti -1c
.RI "#define \fBPMACPORT\fP   1025"
.br
.RI "\fIThe PMAC (only) listens on this port\&. \fP"
.ti -1c
.RI "#define \fBpmac_cmd_size\fP   8"
.br
.RI "\fIPMAC command size in bytes\&. \fP"
.ti -1c
.RI "#define \fBVR_UPLOAD\fP   0xc0"
.br
.ti -1c
.RI "#define \fBVR_DOWNLOAD\fP   0x40"
.br
.ti -1c
.RI "#define \fBVR_PMAC_SENDLINE\fP   0xb0"
.br
.ti -1c
.RI "#define \fBVR_PMAC_GETLINE\fP   0xb1"
.br
.ti -1c
.RI "#define \fBVR_PMAC_FLUSH\fP   0xb3"
.br
.ti -1c
.RI "#define \fBVR_PMAC_GETMEM\fP   0xb4"
.br
.ti -1c
.RI "#define \fBVR_PMAC_SETMEM\fP   0xb5"
.br
.ti -1c
.RI "#define \fBVR_PMAC_SENDCTRLCHAR\fP   0xb6"
.br
.ti -1c
.RI "#define \fBVR_PMAC_SETBIT\fP   0xba"
.br
.ti -1c
.RI "#define \fBVR_PMAC_SETBITS\fP   0xbb"
.br
.ti -1c
.RI "#define \fBVR_PMAC_PORT\fP   0xbe"
.br
.ti -1c
.RI "#define \fBVR_PMAC_GETRESPONSE\fP   0xbf"
.br
.ti -1c
.RI "#define \fBVR_PMAC_READREADY\fP   0xc2"
.br
.ti -1c
.RI "#define \fBVR_CTRL_RESPONSE\fP   0xc4"
.br
.ti -1c
.RI "#define \fBVR_PMAC_GETBUFFER\fP   0xc5"
.br
.ti -1c
.RI "#define \fBVR_PMAC_WRITEBUFFER\fP   0xc6"
.br
.ti -1c
.RI "#define \fBVR_PMAC_WRITEERROR\fP   0xc7"
.br
.ti -1c
.RI "#define \fBVR_FWDOWNLOAD\fP   0xcb"
.br
.ti -1c
.RI "#define \fBVR_IPADDRESS\fP   0xe0"
.br
.ti -1c
.RI "#define \fBPMAC_MIN_CMD_TIME\fP   20000\&.0"
.br
.RI "\fIMinimum time between commands to the pmac\&. \fP"
.ti -1c
.RI "#define \fBPMAC_CMD_QUEUE_LENGTH\fP   2048"
.br
.RI "\fISize of the PMAC command queue\&. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBmd2StatusStruct\fP \fBmd2_status_t\fP"
.br
.RI "\fIThe block of memory retrieved in a status request\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "double \fBlspmac_lut\fP (int nlut, double *lut, double x)"
.br
.RI "\fILook up table support for motor positions (think x=zoom, y=light intensity) use a lookup table to find the 'counts' to move the motor to the requested position The look up table is a simple one dimensional array with the x values as even indicies and the y values as odd indices\&. \fP"
.ti -1c
.RI "double \fBlspmac_rlut\fP (int nlut, double *lut, double y)"
.br
.ti -1c
.RI "void \fBhex_dump\fP (int n, unsigned char *s)"
.br
.RI "\fIPrints a hex dump of the given data\&. \fP"
.ti -1c
.RI "void \fBcleanstr\fP (char *s)"
.br
.RI "\fIReplace \\r with \\n in null terminated string and print result to terminal\&. \fP"
.ti -1c
.RI "void \fBlsConnect\fP (char *ipaddr)"
.br
.RI "\fIConnect to the PMAC socket\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_push_queue\fP (\fBpmac_cmd_queue_t\fP *cmd)"
.br
.RI "\fIPut a new command on the queue\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_pop_queue\fP ()"
.br
.RI "\fIRemove the oldest queue item\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_pop_reply\fP ()"
.br
.RI "\fIRemove the next command queue item that is waiting for a reply\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_send_command\fP (int rqType, int rq, int wValue, int wIndex, int wLength, unsigned char *data, void(*responseCB)(\fBpmac_cmd_queue_t\fP *, int, unsigned char *), int no_reply)"
.br
.RI "\fICompose a packet and send it to the PMAC\&. \fP"
.ti -1c
.RI "void \fBlspmac_SockFlush\fP ()"
.br
.RI "\fIReset the PMAC socket from the PMAC side\&. \fP"
.ti -1c
.RI "void \fBlspmac_Reset\fP ()"
.br
.RI "\fIClear the queue and put the PMAC into a known state\&. \fP"
.ti -1c
.RI "void \fBlspmac_Error\fP (unsigned char *buff)"
.br
.RI "\fIThe service routing detected an error condition\&. \fP"
.ti -1c
.RI "void \fBlspmac_Service\fP (struct pollfd *evt)"
.br
.RI "\fIService routine for packet coming from the PMAC\&. \fP"
.ti -1c
.RI "void \fBlspmac_GetShortReplyCB\fP (\fBpmac_cmd_queue_t\fP *cmd, int nreceived, unsigned char *buff)"
.br
.RI "\fIReceive a reply that does not require multiple buffers\&. \fP"
.ti -1c
.RI "void \fBlspmac_SendControlReplyPrintCB\fP (\fBpmac_cmd_queue_t\fP *cmd, int nreceived, unsigned char *buff)"
.br
.RI "\fIReceive a reply to a control character Print a 'printable' version of the character to the terminal Followed by a hex dump of the response\&. \fP"
.ti -1c
.RI "void \fBlspmac_GetmemReplyCB\fP (\fBpmac_cmd_queue_t\fP *cmd, int nreceived, unsigned char *buff)"
.br
.RI "\fIService a reply to the getmem command\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_SockGetmem\fP (int offset, int nbytes)"
.br
.RI "\fIRequest a chunk of memory to be returned\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_SockSendline\fP (char *fmt,\&.\&.\&.)"
.br
.RI "\fISend a one line command\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_SockSendline_nr\fP (char *fmt,\&.\&.\&.)"
.br
.RI "\fISend a command and ignore the response\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_SockSendControlCharPrint\fP (char c)"
.br
.RI "\fISend a control character\&. \fP"
.ti -1c
.RI "void \fBlspmac_Getmem\fP ()"
.br
.RI "\fIRequest a block of double buffer memory\&. \fP"
.ti -1c
.RI "void \fBlspmac_bo_read\fP (\fBlspmac_motor_t\fP *mp)"
.br
.RI "\fIRead the state of a binary i/o motor This is the read method for the binary i/o motor class\&. \fP"
.ti -1c
.RI "void \fBlspmac_dac_read\fP (\fBlspmac_motor_t\fP *mp)"
.br
.RI "\fIRead a DAC motor position\&. \fP"
.ti -1c
.RI "void \fBlspmac_shutter_read\fP (\fBlspmac_motor_t\fP *mp)"
.br
.RI "\fIFast shutter read routine The shutter is mildly complicated in that we need to take into account the fact that the shutter can open and close again between status updates\&. \fP"
.ti -1c
.RI "void \fBlspmac_home1_queue\fP (\fBlspmac_motor_t\fP *mp)"
.br
.RI "\fIHome the motor\&. \fP"
.ti -1c
.RI "void \fBlspmac_home2_queue\fP (\fBlspmac_motor_t\fP *mp)"
.br
.RI "\fISecond stage of homing\&. \fP"
.ti -1c
.RI "double \fBlspmac_getPosition\fP (\fBlspmac_motor_t\fP *mp)"
.br
.RI "\fIget the motor position (with locking) \fP"
.ti -1c
.RI "void \fBlspmac_pmacmotor_read\fP (\fBlspmac_motor_t\fP *mp)"
.br
.RI "\fIRead the position and status of a normal PMAC motor\&. \fP"
.ti -1c
.RI "void \fBlspmac_get_status_cb\fP (\fBpmac_cmd_queue_t\fP *cmd, int nreceived, unsigned char *buff)"
.br
.RI "\fIService routing for status upate This updates positions and status information\&. \fP"
.ti -1c
.RI "void \fBlspmac_get_status\fP ()"
.br
.RI "\fIRequest a status update from the PMAC\&. \fP"
.ti -1c
.RI "void \fBlspmac_GetAllIVarsCB\fP (\fBpmac_cmd_queue_t\fP *cmd, int nreceived, unsigned char *buff)"
.br
.RI "\fIReceive the values of all the I variables Update our Postgresql database with the results\&. \fP"
.ti -1c
.RI "void \fBlspmac_GetAllIVars\fP ()"
.br
.RI "\fIRequest the values of all the I variables\&. \fP"
.ti -1c
.RI "void \fBlspmac_GetAllMVarsCB\fP (\fBpmac_cmd_queue_t\fP *cmd, int nreceived, unsigned char *buff)"
.br
.RI "\fIReceive the values of all the M variables Update our database with the results\&. \fP"
.ti -1c
.RI "void \fBlspmac_GetAllMVars\fP ()"
.br
.RI "\fIRequest the values of all the M variables\&. \fP"
.ti -1c
.RI "void \fBlspmac_sendcmd_nocb\fP (char *fmt,\&.\&.\&.)"
.br
.RI "\fISend a command that does not need to deal with the reply\&. \fP"
.ti -1c
.RI "void \fBlspmac_sendcmd\fP (void(*responseCB)(\fBpmac_cmd_queue_t\fP *, int, unsigned char *), char *fmt,\&.\&.\&.)"
.br
.RI "\fIPMAC command with call back\&. \fP"
.ti -1c
.RI "void \fBlspmac_next_state\fP ()"
.br
.RI "\fIState machine logic\&. \fP"
.ti -1c
.RI "void * \fBlspmac_worker\fP (void *dummy)"
.br
.RI "\fIOur lspmac worker thread\&. \fP"
.ti -1c
.RI "void \fBlspmac_movedac_queue\fP (\fBlspmac_motor_t\fP *mp, double requested_position)"
.br
.RI "\fIMove method for dac motor objects (ie, lights) \fP"
.ti -1c
.RI "void \fBlspmac_movezoom_queue\fP (\fBlspmac_motor_t\fP *mp, double requested_position)"
.br
.RI "\fIMove method for the zoom motor\&. \fP"
.ti -1c
.RI "void \fBlspmac_move_preset_queue\fP (\fBlspmac_motor_t\fP *mp, char *preset_name)"
.br
.RI "\fIMove a given motor to one of its preset positions\&. \fP"
.ti -1c
.RI "void \fBlspmac_moveabs_fshut_queue\fP (\fBlspmac_motor_t\fP *mp, double requested_position)"
.br
.RI "\fIMove method for the fast shutter\&. \fP"
.ti -1c
.RI "void \fBlspmac_moveabs_bo_queue\fP (\fBlspmac_motor_t\fP *mp, double requested_position)"
.br
.RI "\fIMove method for binary i/o motor objects\&. \fP"
.ti -1c
.RI "void \fBlspmac_moveabs_timed_queue\fP (\fBlspmac_motor_t\fP *mp, double start, double delta, double time)"
.br
.RI "\fItimed motor move \fP"
.ti -1c
.RI "void \fBlspmac_moveabs_frontlight_oo_queue\fP (\fBlspmac_motor_t\fP *mp, double pos)"
.br
.RI "\fI'move' frontlight on/off \fP"
.ti -1c
.RI "void \fBlspmac_moveabs_flight_factor_queue\fP (\fBlspmac_motor_t\fP *mp, double pos)"
.br
.ti -1c
.RI "void \fBlspmac_moveabs_blight_factor_queue\fP (\fBlspmac_motor_t\fP *mp, double pos)"
.br
.ti -1c
.RI "void \fBlspmac_video_rotate\fP (double secs)"
.br
.RI "\fISpecial motion program to collect centering video\&. \fP"
.ti -1c
.RI "void \fBlspmac_move_or_jog_abs_queue\fP (\fBlspmac_motor_t\fP *mp, double requested_position, int use_jog)"
.br
.RI "\fIMove method for normal stepper and servo motor objects\&. \fP"
.ti -1c
.RI "void \fBlspmac_move_or_jog_preset_queue\fP (\fBlspmac_motor_t\fP *mp, char *preset, int use_jog)"
.br
.RI "\fImove using a preset value \fP"
.ti -1c
.RI "void \fBlspmac_moveabs_queue\fP (\fBlspmac_motor_t\fP *mp, double requested_position)"
.br
.RI "\fIUse coordinate system motion program, if available, to move motor to requested position\&. \fP"
.ti -1c
.RI "void \fBlspmac_jogabs_queue\fP (\fBlspmac_motor_t\fP *mp, double requested_position)"
.br
.RI "\fIUse jog to move motor to requested position\&. \fP"
.ti -1c
.RI "void \fBlspmac_moveabs_wait\fP (\fBlspmac_motor_t\fP *mp)"
.br
.RI "\fIWait for motor to finish moving\&. \fP"
.ti -1c
.RI "void \fB_lspmac_motor_init\fP (\fBlspmac_motor_t\fP *d, char *name)"
.br
.RI "\fIHelper funciton for the init calls\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBlspmac_motor_init\fP (\fBlspmac_motor_t\fP *d, int wy, int wx, int *posp, int *stat1p, int *stat2p, char *wtitle, char *name, void(*moveAbs)(\fBlspmac_motor_t\fP *, double))"
.br
.RI "\fIInitialize a pmac stepper or servo motor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBlspmac_fshut_init\fP (\fBlspmac_motor_t\fP *d)"
.br
.RI "\fIInitalize the fast shutter motor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBlspmac_bo_init\fP (\fBlspmac_motor_t\fP *d, char *name, char *write_fmt, int *read_ptr, int read_mask)"
.br
.RI "\fIInitialize binary i/o motor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBlspmac_dac_init\fP (\fBlspmac_motor_t\fP *d, int *posp, char *mvar, char *name, void(*moveAbs)(\fBlspmac_motor_t\fP *, double))"
.br
.RI "\fIInitialize DAC motor Note that some motors require further initialization from a database query\&. \fP"
.ti -1c
.RI "void \fBlspmac_soft_motor_read\fP (\fBlspmac_motor_t\fP *p)"
.br
.RI "\fIDummy routine to read a soft motor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBlspmac_soft_motor_init\fP (\fBlspmac_motor_t\fP *d, char *name, void(*moveAbs)(\fBlspmac_motor_t\fP *, double))"
.br
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBlspmac_bi_init\fP (\fBlspmac_bi_t\fP *d, int *ptr, int mask, char *onEvent, char *offEvent)"
.br
.RI "\fIInitialize binary input\&. \fP"
.ti -1c
.RI "void \fBlspmac_init\fP (int ivarsflag, int mvarsflag)"
.br
.RI "\fIInitialize this module\&. \fP"
.ti -1c
.RI "void \fBlspmac_cryoSwitchChanged_cb\fP (char *event)"
.br
.ti -1c
.RI "void \fBlspmac_scint_inPosition_cb\fP (char *event)"
.br
.RI "\fIMaybe start drying off the scintilator\&. \fP"
.ti -1c
.RI "void \fBlspmac_backLight_up_cb\fP (char *event)"
.br
.RI "\fITurn on the backlight whenever it goes up\&. \fP"
.ti -1c
.RI "void \fBlspmac_backLight_down_cb\fP (char *event)"
.br
.RI "\fITurn off the backlight whenever it goes down\&. \fP"
.ti -1c
.RI "void \fBlspmac_light_zoom_cb\fP (char *event)"
.br
.RI "\fISet the backlight intensity whenever the zoom is changed (and the backlight is up) \fP"
.ti -1c
.RI "void \fBlspmac_scint_dried_cb\fP (char *event)"
.br
.RI "\fITurn off the dryer\&. \fP"
.ti -1c
.RI "void \fBlspmac_run\fP ()"
.br
.RI "\fIfind a postion for a given preset name \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static int \fBls_pmac_state\fP = \fBLS_PMAC_STATE_DETACHED\fP"
.br
.RI "\fICurrent state of the PMAC communications state machine\&. \fP"
.ti -1c
.RI "static \fBlsredis_obj_t\fP * \fBlspmac_md2_init\fP"
.br
.ti -1c
.RI "int \fBlspmac_shutter_state\fP"
.br
.RI "\fIState of the shutter, used to detect changes\&. \fP"
.ti -1c
.RI "int \fBlspmac_shutter_has_opened\fP"
.br
.RI "\fIIndicates that the shutter had opened, perhaps briefly even if the state did not change\&. \fP"
.ti -1c
.RI "pthread_mutex_t \fBlspmac_shutter_mutex\fP"
.br
.RI "\fICoordinates threads reading shutter status\&. \fP"
.ti -1c
.RI "pthread_cond_t \fBlspmac_shutter_cond\fP"
.br
.RI "\fIAllows waiting for the shutter status to change\&. \fP"
.ti -1c
.RI "pthread_mutex_t \fBlspmac_moving_mutex\fP"
.br
.RI "\fICoordinate moving motors between threads\&. \fP"
.ti -1c
.RI "pthread_cond_t \fBlspmac_moving_cond\fP"
.br
.RI "\fIWait for motor(s) to finish moving condition\&. \fP"
.ti -1c
.RI "int \fBlspmac_moving_flags\fP"
.br
.RI "\fIFlag used to implement motor moving condition\&. \fP"
.ti -1c
.RI "static int \fBomega_zero_search\fP = 0"
.br
.RI "\fIIndicate we'd really like to know when omega crosses zero\&. \fP"
.ti -1c
.RI "static double \fBomega_zero_velocity\fP = 0"
.br
.RI "\fIrate (cnts/sec) that omega was traveling when it crossed zero \fP"
.ti -1c
.RI "struct timespec \fBomega_zero_time\fP"
.br
.RI "\fITime we believe that omega crossed zero\&. \fP"
.ti -1c
.RI "static struct timespec \fBlspmac_status_time\fP"
.br
.RI "\fITime the status was read\&. \fP"
.ti -1c
.RI "static struct timespec \fBlspmac_status_last_time\fP"
.br
.RI "\fITime the status was read\&. \fP"
.ti -1c
.RI "static pthread_t \fBpmac_thread\fP"
.br
.RI "\fIour thread to manage access and communication to the pmac \fP"
.ti -1c
.RI "pthread_mutex_t \fBpmac_queue_mutex\fP"
.br
.RI "\fImanage access to the pmac command queue \fP"
.ti -1c
.RI "pthread_cond_t \fBpmac_queue_cond\fP"
.br
.RI "\fIwait for a command to be sent to PMAC before continuing \fP"
.ti -1c
.RI "static struct pollfd \fBpmacfd\fP"
.br
.RI "\fIour poll structure \fP"
.ti -1c
.RI "static int \fBgetivars\fP = 0"
.br
.RI "\fIflag set at initialization to send i vars to db \fP"
.ti -1c
.RI "static int \fBgetmvars\fP = 0"
.br
.RI "\fIflag set at initialization to send m vars to db \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP \fBlspmac_bis\fP [16]"
.br
.RI "\fIarray of binary inputs \fP"
.ti -1c
.RI "int \fBlspmac_nbis\fP = 0"
.br
.RI "\fInumber of active binary inputs \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP \fBlspmac_motors\fP [48]"
.br
.RI "\fIAll our motors\&. \fP"
.ti -1c
.RI "int \fBlspmac_nmotors\fP = 0"
.br
.RI "\fIThe number of motors we manage\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBomega\fP"
.br
.RI "\fIMD2 omega axis (the air bearing) \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBalignx\fP"
.br
.RI "\fIAlignment stage X\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBaligny\fP"
.br
.RI "\fIAlignment stage Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBalignz\fP"
.br
.RI "\fIAlignment stage X\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBanal\fP"
.br
.RI "\fIPolaroid analyzer motor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBzoom\fP"
.br
.RI "\fIOptical zoom\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBapery\fP"
.br
.RI "\fIAperture Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBaperz\fP"
.br
.RI "\fIAperture Z\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcapy\fP"
.br
.RI "\fICapillary Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcapz\fP"
.br
.RI "\fICapillary Z\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBscint\fP"
.br
.RI "\fIScintillator Z\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcenx\fP"
.br
.RI "\fICentering Table X\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBceny\fP"
.br
.RI "\fICentering Table Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBkappa\fP"
.br
.RI "\fIKappa\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBphi\fP"
.br
.RI "\fIPhi (not data collection axis) \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBfshut\fP"
.br
.RI "\fIFast shutter\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBflight\fP"
.br
.RI "\fIFront Light DAC\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBblight\fP"
.br
.RI "\fIBack Light DAC\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBfscint\fP"
.br
.RI "\fIScintillator Piezo DAC\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBblight_ud\fP"
.br
.RI "\fIBack light Up/Down actuator\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBflight_oo\fP"
.br
.RI "\fITurn front light on/off\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBblight_f\fP"
.br
.RI "\fIBack light scale factor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBflight_f\fP"
.br
.RI "\fIFront light scale factor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcryo\fP"
.br
.RI "\fIMove the cryostream towards or away from the crystal\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBdryer\fP"
.br
.RI "\fIblow air on the scintilator to dry it off \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBfluo\fP"
.br
.RI "\fIMove the fluorescence detector in/out\&. \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBcryo_switch\fP"
.br
.RI "\fIthat little toggle switch for the cryo \fP"
.ti -1c
.RI "static int \fBlinesReceived\fP =0"
.br
.RI "\fIcurrent number of lines received \fP"
.ti -1c
.RI "static unsigned char \fBdbmem\fP [64 *1024]"
.br
.RI "\fIdouble buffered memory \fP"
.ti -1c
.RI "static int \fBdbmemIn\fP = 0"
.br
.RI "\fInext location \fP"
.ti -1c
.RI "static struct timeval 
.br
pmac_time_sent \fBnow\fP"
.br
.RI "\fIused to ensure we do not send commands to the pmac too often\&. Only needed for non-DB commands\&. \fP"
.ti -1c
.RI "static \fBpmac_cmd_t\fP \fBrr_cmd\fP"
.br
.ti -1c
.RI "static \fBpmac_cmd_t\fP \fBgb_cmd\fP"
.br
.ti -1c
.RI "static \fBpmac_cmd_t\fP \fBcr_cmd\fP"
.br
.RI "\fIcommands to send out 'readready', 'getbuffer', controlresponse (initialized in main) \fP"
.ti -1c
.RI "static \fBpmac_cmd_queue_t\fP \fBethCmdQueue\fP [\fBPMAC_CMD_QUEUE_LENGTH\fP]"
.br
.RI "\fIPMAC command queue\&. \fP"
.ti -1c
.RI "static unsigned int \fBethCmdOn\fP = 0"
.br
.RI "\fIpoints to next empty PMAC command queue position \fP"
.ti -1c
.RI "static unsigned int \fBethCmdOff\fP = 0"
.br
.RI "\fIpoints to current command (or none if == ethCmdOn) \fP"
.ti -1c
.RI "static unsigned int \fBethCmdReply\fP = 0"
.br
.RI "\fIUsed like ethCmdOff only to deal with the pmac reply to a command\&. \fP"
.ti -1c
.RI "static char * \fBpmac_error_strs\fP []"
.br
.RI "\fIDecode the errors perhaps returned by the PMAC\&. \fP"
.ti -1c
.RI "static \fBmd2_status_t\fP \fBmd2_status\fP"
.br
.RI "\fIBuffer for MD2 Status\&. \fP"
.ti -1c
.RI "pthread_mutex_t \fBmd2_status_mutex\fP"
.br
.RI "\fISynchronize reading/writting status buffer\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Routines concerned with communication with PMAC\&. 

.PP
.nf
\date 2012
\author Keith Brister
\copyright All Rights Reserved
.fi
.PP
.PP
This is a state machine (surprise!) Lacking is support for writingbuffer, control writing and reading, as well as double buffered memory It looks like several different methods of managing PMAC communications are possible\&. Here is set up a queue of outgoing commands and deal completely with the result before sending the next\&. A full handshake of acknowledgements and 'readready' is expected\&.
.PP
State Description  -1 Reset the connection  0 Detached: need to connect to tcp port  1 Idle (waiting for a command to send to the pmac)  2 Send command  3 Waiting for command acknowledgement (no further response expected)  4 Waiting for control character acknowledgement (further response expected)  5 Waiting for command acknowledgement (further response expected)  6 Waiting for get memory response  7 Send controlresponse  8 Send readready  9 Waiting for acknowledgement of 'readready'  10 Send readbuffer  11 Waiting for control response  12 Waiting for readbuffer response 
.PP

.PP
Definition in file \fBlspmac\&.c\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define LS_PMAC_STATE_CR   7"

.PP
Definition at line 45 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_DETACHED   0"

.PP
Definition at line 38 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_GB   10"

.PP
Definition at line 48 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_GMR   6"

.PP
Definition at line 44 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_IDLE   1"

.PP
Definition at line 39 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_RESET   -1"

.PP
Definition at line 37 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_RR   8"

.PP
Definition at line 46 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_SC   2"

.PP
Definition at line 40 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_WACK   5"

.PP
Definition at line 43 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_WACK_CC   4"

.PP
Definition at line 42 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_WACK_NFR   3"

.PP
Definition at line 41 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_WACK_RR   9"

.PP
Definition at line 47 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_WCR   11"

.PP
Definition at line 49 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_WGB   12"

.PP
Definition at line 50 of file lspmac\&.c\&.
.SS "#define LSPMAC_PRESET_REGEX   '(\&.*\\\\\&.%s\\\\\&.presets)\\\\\&.([0-9]+)\\\\\&.(name|position)'"

.PP
Regex to pick out preset name and corresponding position\&. 
.PP
Definition at line 114 of file lspmac\&.c\&.
.SS "#define PMAC_CMD_QUEUE_LENGTH   2048"

.PP
Size of the PMAC command queue\&. 
.PP
Definition at line 158 of file lspmac\&.c\&.
.SS "#define pmac_cmd_size   8"

.PP
PMAC command size in bytes\&. 
.PP
Definition at line 124 of file lspmac\&.c\&.
.SS "#define PMAC_MIN_CMD_TIME   20000\&.0"

.PP
Minimum time between commands to the pmac\&. 
.PP
Definition at line 154 of file lspmac\&.c\&.
.SS "#define PMACPORT   1025"

.PP
The PMAC (only) listens on this port\&. 
.PP
Definition at line 118 of file lspmac\&.c\&.
.SS "#define VR_CTRL_RESPONSE   0xc4"

.PP
Definition at line 140 of file lspmac\&.c\&.
.SS "#define VR_DOWNLOAD   0x40"

.PP
Definition at line 127 of file lspmac\&.c\&.
.SS "#define VR_FWDOWNLOAD   0xcb"

.PP
Definition at line 144 of file lspmac\&.c\&.
.SS "#define VR_IPADDRESS   0xe0"

.PP
Definition at line 145 of file lspmac\&.c\&.
.SS "#define VR_PMAC_FLUSH   0xb3"

.PP
Definition at line 131 of file lspmac\&.c\&.
.SS "#define VR_PMAC_GETBUFFER   0xc5"

.PP
Definition at line 141 of file lspmac\&.c\&.
.SS "#define VR_PMAC_GETLINE   0xb1"

.PP
Definition at line 130 of file lspmac\&.c\&.
.SS "#define VR_PMAC_GETMEM   0xb4"

.PP
Definition at line 132 of file lspmac\&.c\&.
.SS "#define VR_PMAC_GETRESPONSE   0xbf"

.PP
Definition at line 138 of file lspmac\&.c\&.
.SS "#define VR_PMAC_PORT   0xbe"

.PP
Definition at line 137 of file lspmac\&.c\&.
.SS "#define VR_PMAC_READREADY   0xc2"

.PP
Definition at line 139 of file lspmac\&.c\&.
.SS "#define VR_PMAC_SENDCTRLCHAR   0xb6"

.PP
Definition at line 134 of file lspmac\&.c\&.
.SS "#define VR_PMAC_SENDLINE   0xb0"

.PP
Definition at line 129 of file lspmac\&.c\&.
.SS "#define VR_PMAC_SETBIT   0xba"

.PP
Definition at line 135 of file lspmac\&.c\&.
.SS "#define VR_PMAC_SETBITS   0xbb"

.PP
Definition at line 136 of file lspmac\&.c\&.
.SS "#define VR_PMAC_SETMEM   0xb5"

.PP
Definition at line 133 of file lspmac\&.c\&.
.SS "#define VR_PMAC_WRITEBUFFER   0xc6"

.PP
Definition at line 142 of file lspmac\&.c\&.
.SS "#define VR_PMAC_WRITEERROR   0xc7"

.PP
Definition at line 143 of file lspmac\&.c\&.
.SS "#define VR_UPLOAD   0xc0"

.PP
Definition at line 126 of file lspmac\&.c\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBmd2StatusStruct\fP  \fBmd2_status_t\fP"

.PP
The block of memory retrieved in a status request\&. 
.SH "Function Documentation"
.PP 
.SS "void _lspmac_motor_init (\fBlspmac_motor_t\fP *d, char *name)"

.PP
Helper funciton for the init calls\&. 
.PP
Definition at line 2369 of file lspmac\&.c\&.
.PP
.nf
                                                        {
  lspmac_nmotors++;

  pthread_mutex_init( &(d->mutex), NULL);
  pthread_cond_init(  &(d->cond), NULL);

  d->name                = strdup(name);
  d->u2c                 = lsredis_get_obj( '%s\&.u2c',               d->name);
  d->printf_fmt          = lsredis_get_obj( '%s\&.printf',            d->name);
  d->redis_fmt           = lsredis_get_obj( '%s\&.format',            d->name);
  d->unit                = lsredis_get_obj( '%s\&.unit',              d->name);
  d->max_speed           = lsredis_get_obj( '%s\&.max_speed',         d->name);
  d->max_accel           = lsredis_get_obj( '%s\&.max_accel',         d->name);
  d->motor_num           = lsredis_get_obj( '%s\&.motor_num',         d->name);
  d->coord_num           = lsredis_get_obj( '%s\&.coord_num',         d->name);
  d->axis                = lsredis_get_obj( '%s\&.axis',               d->name);
  d->home                = lsredis_get_obj( '%s\&.home',               d->name);
  d->active              = lsredis_get_obj( '%s\&.active',     d->name);
  d->active_init         = lsredis_get_obj( '%s\&.active_init',        d->name);
  d->inactive_init       = lsredis_get_obj( '%s\&.inactive_init',      d->name);

  d->update_resolution   = lsredis_get_obj( '%s\&.update_resolution', d->name);
  d->lut                 = NULL;
  d->nlut                = 0;
  d->homing              = 0;
  d->dac_mvar            = NULL;
  d->actual_pos_cnts_p   = NULL;
  d->status1_p           = NULL;
  d->status2_p           = NULL;
  d->win                 = NULL;
  d->read                = NULL;
}
.fi
.SS "void cleanstr (char *s)"

.PP
Replace \\r with \\n in null terminated string and print result to terminal\&. Needed to turn PMAC messages into something printable\&. \fBParameters:\fP
.RS 4
\fIs\fP String to print to terminal\&. 
.RE
.PP

.PP
Definition at line 451 of file lspmac\&.c\&.
.PP
.nf
                {
  int i;

  pthread_mutex_lock( &ncurses_mutex);

  for( i=0; i<strlen( s); i++) {
    if( s[i] == '\r')
      wprintw( term_output, '\n');
    else
      wprintw( term_output, '%c', s[i]);
  }

  pthread_mutex_unlock( &ncurses_mutex);
}
.fi
.SS "void hex_dump (intn, unsigned char *s)"

.PP
Prints a hex dump of the given data\&. Used to debug packet data\&. \fBParameters:\fP
.RS 4
\fIn\fP Number of bytes passed in s 
.br
\fIs\fP Data to dump 
.RE
.PP

.PP
Definition at line 423 of file lspmac\&.c\&.
.PP
.nf
                {

  int i;        // row counter
  int j;        // column counter

  pthread_mutex_lock( &ncurses_mutex);

  for( i=0; n > 0; i++) {
    for( j=0; j<16 && n > 0; j++) {
      if( j==8)
        wprintw( term_output, '  ');
      wprintw( term_output, ' %02x', *(s + 16*i + j));
      n--;
    }
    wprintw( term_output, '\n');
  }
  wprintw( term_output, '\n');

  pthread_mutex_unlock( &ncurses_mutex);
}
.fi
.SS "void lsConnect (char *ipaddr)"

.PP
Connect to the PMAC socket\&. Establish or reestablish communications\&. \fBParameters:\fP
.RS 4
\fIipaddr\fP String representation of the IP address (dot quad or FQN) 
.RE
.PP

.PP
Definition at line 472 of file lspmac\&.c\&.
.PP
.nf
                 {
  int psock;                    // our socket: value stored in pmacfda\&.fd
  int err;                      // error code from some system calls
  struct sockaddr_in *addrP;    // our address structure to connect to
  struct addrinfo ai_hints;     // required for getaddrinfo
  struct addrinfo *ai_resultP;  // linked list of address structures (we'll always pick the first)

  pmacfd\&.fd     = -1;
  pmacfd\&.events = 0;

  // Initial buffer(s)
  memset( &ai_hints,  0, sizeof( ai_hints));

  ai_hints\&.ai_family   = AF_INET;
  ai_hints\&.ai_socktype = SOCK_STREAM;


  //
  // get address
  //
  err = getaddrinfo( ipaddr, NULL, &ai_hints, &ai_resultP);
  if( err != 0) {

    lslogging_log_message( 'Could not find address: %s', gai_strerror( err));

    return;
  }


  addrP = (struct sockaddr_in *)ai_resultP->ai_addr;
  addrP->sin_port = htons( PMACPORT);


  psock = socket( PF_INET, SOCK_STREAM, 0);
  if( psock == -1) {
    lslogging_log_message( 'Could not create socket');
    return;
  }

  err = connect( psock, (const struct sockaddr *)addrP, sizeof( *addrP));
  if( err != 0) {
    lslogging_log_message( 'Could not connect socket: %s', strerror( errno));
    return;
  }

  ls_pmac_state = LS_PMAC_STATE_IDLE;
  pmacfd\&.fd     = psock;
  pmacfd\&.events = POLLIN;

}
.fi
.SS "void lspmac_backLight_down_cb (char *event)"

.PP
Turn off the backlight whenever it goes down\&. \fBParameters:\fP
.RS 4
\fIevent\fP Name of the event that called us 
.RE
.PP

.PP
Definition at line 2671 of file lspmac\&.c\&.
.PP
.nf
                                            {
  blight->moveAbs( blight, 0\&.0);
}
.fi
.SS "void lspmac_backLight_up_cb (char *event)"

.PP
Turn on the backlight whenever it goes up\&. \fBParameters:\fP
.RS 4
\fIevent\fP Name of the event that called us 
.RE
.PP

.PP
Definition at line 2662 of file lspmac\&.c\&.
.PP
.nf
                                          {
  int z;

  blight->moveAbs( blight, lspmac_getPosition( zoom));
}
.fi
.SS "\fBlspmac_bi_t\fP* lspmac_bi_init (\fBlspmac_bi_t\fP *d, int *ptr, intmask, char *onEvent, char *offEvent)"

.PP
Initialize binary input\&. 
.PP
Definition at line 2514 of file lspmac\&.c\&.
.PP
.nf
                                                                                                {
  lspmac_nbis++;
  pthread_mutex_init( &(d->mutex), NULL);
  d->ptr            = ptr;
  d->mask           = mask;
  d->changeEventOn  = strdup( onEvent);
  d->changeEventOff = strdup( offEvent);
  d->first_time     = 1;
}
.fi
.SS "\fBlspmac_motor_t\fP* lspmac_bo_init (\fBlspmac_motor_t\fP *d, char *name, char *write_fmt, int *read_ptr, intread_mask)"

.PP
Initialize binary i/o motor\&. \fBParameters:\fP
.RS 4
\fId\fP Our uninitialized motor object 
.br
\fIname\fP Name of motor to coordinate with DB 
.br
\fIwrite_fmt\fP Format string used to generate PMAC command to move motor 
.br
\fIread_ptr\fP Pointer to byte in md2_status to find position 
.br
\fIread_mask\fP Bitmask to find position in *read_ptr 
.RE
.PP

.PP
Definition at line 2450 of file lspmac\&.c\&.
.PP
.nf
                                  {

  _lspmac_motor_init( d, name);

  d->moveAbs           = lspmac_moveabs_bo_queue;
  d->read              = lspmac_bo_read;
  d->write_fmt         = strdup( write_fmt);
  d->read_ptr          = read_ptr;
  d->read_mask         = read_mask;

  return d;
}
.fi
.SS "void lspmac_bo_read (\fBlspmac_motor_t\fP *mp)"

.PP
Read the state of a binary i/o motor This is the read method for the binary i/o motor class\&. \fBParameters:\fP
.RS 4
\fImp\fP The motor 
.RE
.PP

.PP
Definition at line 1017 of file lspmac\&.c\&.
.PP
.nf
                      {
  char s[512];
  int pos, changed;

  pthread_mutex_lock( &(mp->mutex));

  pos = (*(mp->read_ptr) & mp->read_mask) == 0 ? 0 : 1;

  changed = pos != mp->position;
  mp->position = pos;

  // Not sure what kind of status makes sense to report
  mp->statuss[0] = 0;
  pthread_mutex_unlock( &(mp->mutex));

  if( changed)
    lsevents_send_event( '%s %d', mp->name, pos);
}
.fi
.SS "void lspmac_cryoSwitchChanged_cb (char *event)"

.PP
Definition at line 2624 of file lspmac\&.c\&.
.PP
.nf
                                               {
  int pos;

  pthread_mutex_lock( &(cryo->mutex));
  pos = cryo->position;
  pthread_mutex_unlock( &(cryo->mutex));

  cryo->moveAbs( cryo, pos ? 0\&.0 : 1\&.0);
}
.fi
.SS "\fBlspmac_motor_t\fP* lspmac_dac_init (\fBlspmac_motor_t\fP *d, int *posp, char *mvar, char *name, void(*)(\fBlspmac_motor_t\fP *, double)moveAbs)"

.PP
Initialize DAC motor Note that some motors require further initialization from a database query\&. For this reason this initialzation code must be run before the database queue is allowed to be processed\&. \fBParameters:\fP
.RS 4
\fId\fP Returns the (almost) initialized motor object [in,out] unitintialized motor 
.br
\fIposp\fP Location of current position 
.br
\fImvar\fP M variable, ie, 'M1200' 
.br
\fIname\fP name to coordinate with DB 
.br
\fImoveAbs\fP Method to use to move this motor 
.RE
.PP

.PP
Definition at line 2476 of file lspmac\&.c\&.
.PP
.nf
                                  {

  _lspmac_motor_init( d, name);
  d->moveAbs           = moveAbs;
  d->read              = lspmac_dac_read;
  d->actual_pos_cnts_p = posp;
  d->dac_mvar          = strdup(mvar);

  return d;
}
.fi
.SS "void lspmac_dac_read (\fBlspmac_motor_t\fP *mp)"

.PP
Read a DAC motor position\&. \fBParameters:\fP
.RS 4
\fImp\fP The motor 
.RE
.PP

.PP
Definition at line 1040 of file lspmac\&.c\&.
.PP
.nf
                       {
  int pos;
  double u2c;

  pthread_mutex_lock( &(mp->mutex));
  mp->actual_pos_cnts = *mp->actual_pos_cnts_p;
  u2c = lsredis_getd( mp->u2c);

  if( mp->nlut >0 && mp->lut != NULL) {
    if( u2c == 0\&.0)
      u2c = 1\&.0;
    mp->position = lspmac_rlut( mp->nlut, mp->lut, mp->actual_pos_cnts/u2c);
  } else {
    if( u2c != 0\&.0) {
      mp->position = mp->actual_pos_cnts / u2c;
    } else {
      mp->position = mp->actual_pos_cnts;
    }
  }

  // Not sure what kind of status makes sense to report
  mp->statuss[0] = 0;

  pthread_mutex_unlock( &(mp->mutex));
}
.fi
.SS "void lspmac_Error (unsigned char *buff)"

.PP
The service routing detected an error condition\&. Scan the response buffer for an error code and print it out\&. \fBParameters:\fP
.RS 4
\fIbuff\fP Buffer returned by PMAC perhaps containing a NULL terminated message\&. 
.RE
.PP

.PP
Definition at line 669 of file lspmac\&.c\&.
.PP
.nf
                    {
  int err;
  //
  // assume buff points to a 1400 byte array of stuff read from the pmac
  //

  if( buff[0] == 7 && buff[1] == 'E' && buff[2] == 'R' && buff[3] == 'R') {
    buff[7] = 0;  // For null termination
    err = atoi( &(buff[4]));
    if( err > 0 && err < 20) {
      lslogging_log_message( pmac_error_strs[err]);

      pthread_mutex_lock( &ncurses_mutex);
      wprintw( term_output, '\n%s\n', pmac_error_strs[err]);
      wnoutrefresh( term_output);
      wnoutrefresh( term_input);
      doupdate();
      pthread_mutex_unlock( &ncurses_mutex);
    }
  }
  lspmac_Reset();
}
.fi
.SS "\fBlspmac_motor_t\fP* lspmac_fshut_init (\fBlspmac_motor_t\fP *d)"

.PP
Initalize the fast shutter motor\&. \fBParameters:\fP
.RS 4
\fId\fP Our uninitialized motor object 
.RE
.PP

.PP
Definition at line 2434 of file lspmac\&.c\&.
.PP
.nf
                                    {

  _lspmac_motor_init( d, 'fastShutter');

  d->moveAbs           = lspmac_moveabs_fshut_queue;
  d->read              = lspmac_shutter_read;

  return d;
}
.fi
.SS "void lspmac_get_status ()"

.PP
Request a status update from the PMAC\&. 
.PP
Definition at line 1619 of file lspmac\&.c\&.
.PP
.nf
                         {
  lspmac_send_command( VR_UPLOAD, VR_PMAC_GETMEM, 0x400, 0, sizeof(md2_status_t), NULL, lspmac_get_status_cb, 0);
}
.fi
.SS "void lspmac_get_status_cb (\fBpmac_cmd_queue_t\fP *cmd, intnreceived, unsigned char *buff)"

.PP
Service routing for status upate This updates positions and status information\&. \fBParameters:\fP
.RS 4
\fIcmd\fP The command that generated this reply 
.br
\fInreceived\fP Number of bytes received 
.br
\fIbuff\fP The Big Byte Buffer 
.RE
.PP

.PP
Definition at line 1447 of file lspmac\&.c\&.
.PP
.nf
                            {
  static int cnt = 0;
  static char s[256];
  static struct timeval ts1, ts2;

  char *sp;
  int i, pos;
  lspmac_motor_t *mp;
  lspmac_bi_t    *bp;

  clock_gettime( CLOCK_REALTIME, &lspmac_status_time);

  if( cnt == 0) {
    gettimeofday( &ts1, NULL);
  }

  pthread_mutex_lock( &md2_status_mutex);
  memcpy( &md2_status, buff, sizeof(md2_status));
  pthread_mutex_unlock( &md2_status_mutex);


  //
  // track the coordinate system moving flags
  //
  pthread_mutex_lock( &lspmac_moving_mutex);
  if( md2_status\&.moving_flags != lspmac_moving_flags) {
    lslogging_log_message( 'lspmac_get_status_cb: new moving flag: %0x', md2_status\&.moving_flags);
    lspmac_moving_flags = md2_status\&.moving_flags;
    pthread_cond_signal( &lspmac_moving_cond);
  }
  pthread_mutex_unlock( &lspmac_moving_mutex);


  //
  // Read the motor positions
  //
  for( i=0; i<lspmac_nmotors; i++) {
    lspmac_motors[i]\&.read(&(lspmac_motors[i]));
  }

  //
  // Read the binary inputs and perhaps send an event
  //
  for( i=0; i<lspmac_nbis; i++) {
    bp = &(lspmac_bis[i]);
    
    pthread_mutex_lock( &(bp->mutex));

    pos = (*(bp->ptr) & bp->mask) == 0 ? 0 : 1;

    if( bp->first_time) {
      bp->first_time = 0;
      if( pos==1 && bp->changeEventOn != NULL && bp->changeEventOn[0] != 0)
        lsevents_send_event( lspmac_bis[i]\&.changeEventOn);
      if( pos==0 && bp->changeEventOff != NULL && bp->changeEventOff[0] != 0)
        lsevents_send_event( lspmac_bis[i]\&.changeEventOff);
    } else {
      if( pos != bp->previous) {
        if( pos==1 && bp->changeEventOn != NULL && bp->changeEventOn[0] != 0)
          lsevents_send_event( lspmac_bis[i]\&.changeEventOn);
        if( pos==0 && bp->changeEventOff != NULL && bp->changeEventOff[0] != 0)
          lsevents_send_event( lspmac_bis[i]\&.changeEventOff);
      }
    }
    bp->previous = pos;
    pthread_mutex_unlock( &(bp->mutex));
  }

  pthread_mutex_lock( &ncurses_mutex);

  // acc11c_1
  // mask  bit
  // 0x01  0    Air pressure OK
  // 0x02  1    Air bearing OK
  // 0x04  2    Cryo switch
  // 0x08  3
  // 0x10  4
  // 0x20  5
  // 0x40  6    Cryo is back

  //
  // acc11c_2
  // mask  bit
  // 0x01  0    Fluor Dector back
  // 0x02  1    Sample Detected
  // 0x04  2
  // 0x08  3
  // 0x10  4
  // 0x20  5    Etel Ready
  // 0x40  6    Etel On
  // 0x80  7    Etel Init OK

  if( md2_status\&.acc11c_2 & 0x01)
    mvwprintw( term_status2, 3, 10, '%*s', -8, 'Fluor Out');
  else
    mvwprintw( term_status2, 3, 10, '%*s', -8, 'Fluor In');

  if( md2_status\&.acc11c_5 & 0x08)
    mvwprintw( term_status2, 4, 1, '%*s', -(LS_DISPLAY_WINDOW_WIDTH-2), 'Dryer On');
  else
    mvwprintw( term_status2, 4, 1, '%*s', -(LS_DISPLAY_WINDOW_WIDTH-2), 'Dryer Off');

  if( md2_status\&.acc11c_2 & 0x02)
    mvwprintw( term_status2, 2, 1, '%*s', -(LS_DISPLAY_WINDOW_WIDTH-2), 'Cap Dectected');
  else
    mvwprintw( term_status2, 2, 1, '%*s', -(LS_DISPLAY_WINDOW_WIDTH-2), 'Cap Not Dectected');
  wnoutrefresh( term_status2);


  // acc11c_3
  // mask  bit
  // 0x01  0    Minikappa OK
  // 0x02  1
  // 0x04  2
  // 0x08  3    Arm Parked

  // acc11c_5
  // mask  bit
  // 0x01  0    Mag Off
  // 0x02  1    Condenser Out
  // 0x04  2    Cryo Back
  // 0x08  3    Dryer On
  // 0x10  4    FluoDet Out
  // 0x20  5
  // 0x40  6    1=SmartMag, 0=Permanent Mag
  //

  if( md2_status\&.acc11c_5 & 0x04)
    mvwprintw( term_status2, 3, 1, '%*s', -8, 'Cryo Out');
  else
    mvwprintw( term_status2, 3, 1, '%*s', -8, 'Cryo In ');

  // acc11c_6
  // mask   bit
  // 0x0080   7   Etel Enable
  // 0x0100   8   Fast Shutter Enable
  // 0x0200   9   Fast Shutter Manual Enable
  // 0x0400  10   Fast Shutter On



  if( md2_status\&.acc11c_5 & 0x02)
    mvwprintw( term_status,  3, 1, '%*s', -(LS_DISPLAY_WINDOW_WIDTH-2), 'Backlight Up');
  else
    mvwprintw( term_status,  3, 1, '%*s', -(LS_DISPLAY_WINDOW_WIDTH-2), 'Backlight Down');

  mvwprintw( term_status, 4, 1, 'Front: %*u', LS_DISPLAY_WINDOW_WIDTH-2-8, (int)flight->position);
  mvwprintw( term_status, 5, 1, 'Back: %*u', LS_DISPLAY_WINDOW_WIDTH-2-7,  (int)blight->position);
  mvwprintw( term_status, 6, 1, 'Piezo: %*u', LS_DISPLAY_WINDOW_WIDTH-2-8, (int)fscint->position);
  wnoutrefresh( term_status);

  wnoutrefresh( term_input);
  doupdate();
  pthread_mutex_unlock( &ncurses_mutex);

  /*
  if( ++cnt % 1000 == 0) {
    gettimeofday( &ts2, NULL);

    lslogging_log_message( 'Refresh Rate: %0\&.1f Hz', 1000000\&.*(cnt)/(ts2\&.tv_sec*1000000 + ts2\&.tv_usec - ts1\&.tv_sec*1000000 - ts1\&.tv_usec));

    cnt = 0;
  }
  */
}
.fi
.SS "void lspmac_GetAllIVars ()"

.PP
Request the values of all the I variables\&. 
.PP
Definition at line 1644 of file lspmac\&.c\&.
.PP
.nf
                          {
  static char *cmds = 'I0\&.\&.8191';
  lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDLINE, 0, 0, strlen( cmds), cmds, lspmac_GetAllIVarsCB, 0);
}
.fi
.SS "void lspmac_GetAllIVarsCB (\fBpmac_cmd_queue_t\fP *cmd, intnreceived, unsigned char *buff)"

.PP
Receive the values of all the I variables Update our Postgresql database with the results\&. \fBParameters:\fP
.RS 4
\fIcmd\fP The command that gave this response 
.br
\fInreceived\fP Number of bytes received 
.br
\fIbuff\fP The byte buffer 
.RE
.PP

.PP
Definition at line 1627 of file lspmac\&.c\&.
.PP
.nf
                            {
  static char qs[LS_PG_QUERY_STRING_LENGTH];
  char *sp;
  int i;
  for( i=0, sp=strtok(buff, '\r'); sp != NULL; sp=strtok( NULL, '\r'), i++) {
    snprintf( qs, sizeof( qs)-1, 'SELECT pmac\&.md2_ivar_set( %d, '%s')', i, sp);
    qs[sizeof( qs)-1]=0;
    lspg_query_push( NULL, qs);
  }
}
.fi
.SS "void lspmac_GetAllMVars ()"

.PP
Request the values of all the M variables\&. 
.PP
Definition at line 1669 of file lspmac\&.c\&.
.PP
.nf
                          {
  static char *cmds = 'M0\&.\&.8191->';
  lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDLINE, 0, 0, strlen( cmds), cmds, lspmac_GetAllMVarsCB, 0);
}
.fi
.SS "void lspmac_GetAllMVarsCB (\fBpmac_cmd_queue_t\fP *cmd, intnreceived, unsigned char *buff)"

.PP
Receive the values of all the M variables Update our database with the results\&. \fBParameters:\fP
.RS 4
\fIcmd\fP The command that started this 
.br
\fInreceived\fP Number of bytes received 
.br
\fIbuff\fP Our byte buffer 
.RE
.PP

.PP
Definition at line 1652 of file lspmac\&.c\&.
.PP
.nf
                            {
  static char qs[LS_PG_QUERY_STRING_LENGTH];
  char *sp;
  int i;
  for( i=0, sp=strtok(buff, '\r'); sp != NULL; sp=strtok( NULL, '\r'), i++) {
    snprintf( qs, sizeof( qs)-1, 'SELECT pmac\&.md2_mvar_set( %d, '%s')', i, sp);
    qs[sizeof( qs)-1]=0;
    lspg_query_push( NULL, qs);
  }
}
.fi
.SS "void lspmac_Getmem ()"

.PP
Request a block of double buffer memory\&. 
.PP
Definition at line 1008 of file lspmac\&.c\&.
.PP
.nf
                     {
  int nbytes;
  nbytes = (dbmemIn + 1400 > sizeof( dbmem)) ? sizeof( dbmem) - dbmemIn : 1400;
  lspmac_SockGetmem( dbmemIn, nbytes);
}
.fi
.SS "void lspmac_GetmemReplyCB (\fBpmac_cmd_queue_t\fP *cmd, intnreceived, unsigned char *buff)"

.PP
Service a reply to the getmem command\&. Not currently used\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcmd\fP Queue item this is a reply to 
.br
\fInreceived\fP Number of bytes received 
.br
\fIbuff\fP Buffer of bytes recieved 
.RE
.PP

.PP
Definition at line 939 of file lspmac\&.c\&.
.PP
.nf
                                                                                      {

  memcpy( &(dbmem[ntohs(cmd->pcmd\&.wValue)]), buff, nreceived);

  dbmemIn += nreceived;
  if( dbmemIn >= sizeof( dbmem)) {
    dbmemIn = 0;
  }
}
.fi
.SS "double lspmac_getPosition (\fBlspmac_motor_t\fP *mp)"

.PP
get the motor position (with locking) \fBParameters:\fP
.RS 4
\fImp\fP the motor object 
.RE
.PP

.PP
Definition at line 1236 of file lspmac\&.c\&.
.PP
.nf
                                               {
  double rtn;
  pthread_mutex_lock( &(mp->mutex));
  rtn = mp->position;
  pthread_mutex_unlock( &(mp->mutex));
  return rtn;
}
.fi
.SS "void lspmac_GetShortReplyCB (\fBpmac_cmd_queue_t\fP *cmd, intnreceived, unsigned char *buff)"

.PP
Receive a reply that does not require multiple buffers\&. \fBParameters:\fP
.RS 4
\fIcmd\fP Queue item this is a reply to 
.br
\fInreceived\fP Number of bytes received 
.br
\fIbuff\fP The buffer of bytes 
.RE
.PP

.PP
Definition at line 881 of file lspmac\&.c\&.
.PP
.nf
                              {

  char *sp;     // pointer to the command this is a reply to

  if( nreceived < 1400)
    buff[nreceived]=0;

  sp = (char *)(cmd->pcmd\&.bData);

  if( *buff == 0) {
    pthread_mutex_lock( &ncurses_mutex);
    wprintw( term_output, '%s\n', sp);
    pthread_mutex_unlock( &ncurses_mutex);
  } else {
    pthread_mutex_lock( &ncurses_mutex);
    wprintw( term_output, '%s: ', sp);
    pthread_mutex_unlock( &ncurses_mutex);
    cleanstr( buff);
  }
  wnoutrefresh( term_output);
  wnoutrefresh( term_input);
  doupdate();

  memset( cmd->pcmd\&.bData, 0, sizeof( cmd->pcmd\&.bData));
}
.fi
.SS "void lspmac_home1_queue (\fBlspmac_motor_t\fP *mp)"

.PP
Home the motor\&. \fBParameters:\fP
.RS 4
\fImp\fP motor we are concerned about 
.RE
.PP

.PP
Definition at line 1111 of file lspmac\&.c\&.
.PP
.nf
                          {
  char openloops[32];
  char *sp;
  int i;
  int motor_num;
  int coord_num;
  char **home;

  pthread_mutex_lock( &(mp->mutex));

  motor_num = lsredis_getl( mp->motor_num);
  coord_num = lsredis_getl( mp->coord_num);
  home      = lsredis_get_string_array( mp->home);
  
  // Each of the motors should have this defined
  // but let's not seg fault if home is missing
  //
  if( home == NULL || *home == NULL) {
    //
    // Note we are already initialized
    // so if we are here there is something wrong\&.
    //
    lslogging_log_message( 'lspmac_home1_queue: null or empty home strings for motor %s', mp->name);
    pthread_mutex_unlock( &(mp->mutex));
    return;
  }

  // We've already been called\&.  Don't home again until
  // we're finish with the last time\&.
  //
  if( mp->homing) {
    pthread_mutex_unlock( &(mp->mutex));
    return;
  }    


  //
  // Don't go on if any other motors in this coordinate system are homing\&.
  // It's possible to write the homing program to home all the motors in the coordinate
  // system\&.
  //
  if( coord_num > 0) {
    for( i=0; i<lspmac_nmotors; i++) {
      if( &(lspmac_motors[i]) == mp)
        continue;
      if( lsredis_getl(lspmac_motors[i]\&.coord_num) == coord_num) {
        if( lspmac_motors[i]\&.homing) {
          pthread_mutex_unlock( &(mp->mutex));
          return;
        }
      }
    }
  }
  mp->homing = 1;
       
  // This opens the control loop\&.
  // The status routine should notice this and the fact that
  // the homing flag is set and call on the home2 routine
  //
  // Only send the open loop command if we are not in
  // open loop mode already\&.  This test might prevent a race condition
  // where we've already moved the home2 routine (and queue the homing program motion)
  // before the open loop command is dequeued and acted on\&.
  //
  if( ~(mp->status1) & 0x040000) {
    snprintf( openloops, sizeof(openloops)-1, '#%d$*', motor_num);
    openloops[sizeof(openloops)-1] = 0;
    lspmac_SockSendline( openloops);
  }

  pthread_mutex_unlock( &(mp->mutex));
}
.fi
.SS "void lspmac_home2_queue (\fBlspmac_motor_t\fP *mp)"

.PP
Second stage of homing\&. \fBParameters:\fP
.RS 4
\fImp\fP motor we are concerned about 
.RE
.PP

.PP
Definition at line 1189 of file lspmac\&.c\&.
.PP
.nf
                          {

  char **spp;
  char **home;

  //
  // At this point we are in open loop\&.
  // Run the motor specific commands
  //

  pthread_mutex_lock( &(mp->mutex));

  home = lsredis_get_string_array( mp->home);

  //
  // We don't have any motors that have a null home text array so 
  // there is currently no need to worry about this case other than
  // not to seg fault
  //
  // Also, Only go on if the first homing phase has been started
  //
  if( home == NULL || mp->homing != 1) {
    pthread_mutex_unlock( &(mp->mutex));
    return;
  }

  for( spp = home; *spp != NULL; spp++) {

    pthread_mutex_lock( &ncurses_mutex);
    wprintw( term_output, 'home2 is queuing '%s'\n', *spp);
    wnoutrefresh( term_output);
    doupdate();
    pthread_mutex_unlock( &ncurses_mutex);

    lspmac_SockSendline( *spp);
  }

  mp->homing = 2;
  pthread_mutex_unlock( &(mp->mutex));
  
}
.fi
.SS "void lspmac_init (intivarsflag, intmvarsflag)"

.PP
Initialize this module\&. \fBParameters:\fP
.RS 4
\fIivarsflag\fP Set global flag to harvest i variables 
.br
\fImvarsflag\fP Set global flag to harvest m variables 
.RE
.PP

.PP
Definition at line 2528 of file lspmac\&.c\&.
.PP
.nf
                   {
  md2_status_t *p;

  // Set our global harvest flags
  getivars = ivarsflag;
  getmvars = mvarsflag;

  // All important status mutex
  pthread_mutex_init( &md2_status_mutex, NULL);

  //
  // Get the MD2 initialization strings
  //
  lspmac_md2_init = lsredis_get_obj( 'md2_pmac\&.init');

  //
  // Initialize the motor objects
  //

  p = &md2_status;

  omega  = lspmac_motor_init( &(lspmac_motors[ 0]), 0, 0, &p->omega_act_pos,     &p->omega_status_1,     &p->omega_status_2,     'Omega   #1 &1 A', 'omega',       lspmac_moveabs_queue);
  alignx = lspmac_motor_init( &(lspmac_motors[ 1]), 0, 1, &p->alignx_act_pos,    &p->alignx_status_1,    &p->alignx_status_2,    'Align X #2 &3 X', 'align\&.x',     lspmac_moveabs_queue);
  aligny = lspmac_motor_init( &(lspmac_motors[ 2]), 0, 2, &p->aligny_act_pos,    &p->aligny_status_1,    &p->aligny_status_2,    'Align Y #3 &3 Y', 'align\&.y',     lspmac_moveabs_queue);
  alignz = lspmac_motor_init( &(lspmac_motors[ 3]), 0, 3, &p->alignz_act_pos,    &p->alignz_status_1,    &p->alignz_status_2,    'Align Z #4 &3 Z', 'align\&.z',     lspmac_moveabs_queue);
  anal   = lspmac_motor_init( &(lspmac_motors[ 4]), 0, 4, &p->analyzer_act_pos,  &p->analyzer_status_1,  &p->analyzer_status_2,  'Anal    #5',      'lightPolar',  lspmac_moveabs_queue);
  zoom   = lspmac_motor_init( &(lspmac_motors[ 5]), 1, 0, &p->zoom_act_pos,      &p->zoom_status_1,      &p->zoom_status_2,      'Zoom    #6 &4 Z', 'cam\&.zoom',    lspmac_movezoom_queue);
  apery  = lspmac_motor_init( &(lspmac_motors[ 6]), 1, 1, &p->aperturey_act_pos, &p->aperturey_status_1, &p->aperturey_status_2, 'Aper Y  #7 &5 Y', 'appy',        lspmac_moveabs_queue);
  aperz  = lspmac_motor_init( &(lspmac_motors[ 7]), 1, 2, &p->aperturez_act_pos, &p->aperturez_status_1, &p->aperturez_status_2, 'Aper Z  #8 &5 Z', 'appz',        lspmac_moveabs_queue);
  capy   = lspmac_motor_init( &(lspmac_motors[ 8]), 1, 3, &p->capy_act_pos,      &p->capy_status_1,      &p->capy_status_2,      'Cap Y   #9 &5 U', 'capy',        lspmac_moveabs_queue);
  capz   = lspmac_motor_init( &(lspmac_motors[ 9]), 1, 4, &p->capz_act_pos,      &p->capz_status_1,      &p->capz_status_2,      'Cap Z  #10 &5 V', 'capz',        lspmac_moveabs_queue);
  scint  = lspmac_motor_init( &(lspmac_motors[10]), 2, 0, &p->scint_act_pos,     &p->scint_status_1,     &p->scint_status_2,     'Scin Z #11 &5 W', 'scint',       lspmac_moveabs_queue);
  cenx   = lspmac_motor_init( &(lspmac_motors[11]), 2, 1, &p->centerx_act_pos,   &p->centerx_status_1,   &p->centerx_status_2,   'Cen X  #17 &2 X', 'centering\&.x', lspmac_moveabs_queue);
  ceny   = lspmac_motor_init( &(lspmac_motors[12]), 2, 2, &p->centery_act_pos,   &p->centery_status_1,   &p->centery_status_2,   'Cen Y  #18 &2 Y', 'centering\&.y', lspmac_moveabs_queue);
  kappa  = lspmac_motor_init( &(lspmac_motors[13]), 2, 3, &p->kappa_act_pos,     &p->kappa_status_1,     &p->kappa_status_2,     'Kappa  #19 &7 X', 'kappa',       lspmac_moveabs_queue);
  phi    = lspmac_motor_init( &(lspmac_motors[14]), 2, 4, &p->phi_act_pos,       &p->phi_status_1,       &p->phi_status_2,       'Phi    #20 &7 Y', 'phi',         lspmac_moveabs_queue);

  fshut  = lspmac_fshut_init( &(lspmac_motors[15]));
  flight = lspmac_dac_init( &(lspmac_motors[16]), &p->front_dac,   'M1200', 'frontLight\&.intensity', lspmac_movedac_queue);
  blight = lspmac_dac_init( &(lspmac_motors[17]), &p->back_dac,    'M1201', 'backLight\&.intensity',  lspmac_movedac_queue);
  fscint = lspmac_dac_init( &(lspmac_motors[18]), &p->scint_piezo, 'M1203', 'scint\&.focus',          lspmac_movedac_queue);

  blight_ud = lspmac_bo_init( &(lspmac_motors[19]), 'backLight',  'M1101=%d', &(md2_status\&.acc11c_5), 0x02);
  cryo      = lspmac_bo_init( &(lspmac_motors[20]), 'cryo',       'M1102=%d', &(md2_status\&.acc11c_5), 0x04);
  dryer     = lspmac_bo_init( &(lspmac_motors[21]), 'dryer',      'M1103=%d', &(md2_status\&.acc11c_5), 0x08);
  fluo      = lspmac_bo_init( &(lspmac_motors[22]), 'fluo',       'M1008=%d', &(md2_status\&.acc11c_2), 0x01);
  flight_oo = lspmac_soft_motor_init( &(lspmac_motors[23]), 'frontLight',        lspmac_moveabs_frontlight_oo_queue);
  blight_f  = lspmac_soft_motor_init( &(lspmac_motors[24]), 'backLight\&.factor',  lspmac_moveabs_blight_factor_queue);
  flight_f  = lspmac_soft_motor_init( &(lspmac_motors[25]), 'frontLight\&.factor', lspmac_moveabs_flight_factor_queue);

  cryo_switch = lspmac_bi_init( &(lspmac_bis[0]), &(md2_status\&.acc11c_1), 0x04, 'CryoSwitchChanged', 'CryoSwitchChanged');

  //
  // Initialize several commands that get called, perhaps, alot
  //
  rr_cmd\&.RequestType = VR_UPLOAD;
  rr_cmd\&.Request     = VR_PMAC_READREADY;
  rr_cmd\&.wValue      = 0;
  rr_cmd\&.wIndex      = 0;
  rr_cmd\&.wLength     = htons(2);
  memset( rr_cmd\&.bData, 0, sizeof(rr_cmd\&.bData));

  gb_cmd\&.RequestType = VR_UPLOAD;
  gb_cmd\&.Request     = VR_PMAC_GETBUFFER;
  gb_cmd\&.wValue      = 0;
  gb_cmd\&.wIndex      = 0;
  gb_cmd\&.wLength     = htons(1400);
  memset( gb_cmd\&.bData, 0, sizeof(gb_cmd\&.bData));

  cr_cmd\&.RequestType = VR_UPLOAD;
  cr_cmd\&.Request     = VR_CTRL_RESPONSE;
  cr_cmd\&.wValue      = 0;
  cr_cmd\&.wIndex      = 0;
  cr_cmd\&.wLength     = htons(1400);
  memset( cr_cmd\&.bData, 0, sizeof(cr_cmd\&.bData));

  //
  // Initialize some mutexs and conditions
  //

  pthread_mutex_init( &pmac_queue_mutex, NULL);
  pthread_cond_init(  &pmac_queue_cond, NULL);

  lspmac_shutter_state = 0;                             // assume the shutter is now closed: not a big deal if we are wrong
  pthread_mutex_init( &lspmac_shutter_mutex, NULL);
  pthread_cond_init(  &lspmac_shutter_cond, NULL);
  pmacfd\&.fd = -1;

  pthread_mutex_init( &lspmac_moving_mutex, NULL);
  pthread_cond_init(  &lspmac_moving_cond, NULL);
}
.fi
.SS "void lspmac_jogabs_queue (\fBlspmac_motor_t\fP *mp, doublerequested_position)"

.PP
Use jog to move motor to requested position\&. \fBParameters:\fP
.RS 4
\fImp\fP The motor to move 
.br
\fIrequested_position\fP Where to move it 
.RE
.PP

.PP
Definition at line 2291 of file lspmac\&.c\&.
.PP
.nf
                            {
  
  lspmac_move_or_jog_abs_queue( mp, requested_position, 1);
}
.fi
.SS "void lspmac_light_zoom_cb (char *event)"

.PP
Set the backlight intensity whenever the zoom is changed (and the backlight is up) \fBParameters:\fP
.RS 4
\fIevent\fP Name of the event that calledus 
.RE
.PP

.PP
Definition at line 2678 of file lspmac\&.c\&.
.PP
.nf
                                        {
  double z;

  z = lspmac_getPosition( zoom);
  if( lspmac_getPosition( flight_oo) != 0\&.0) {
      flight->moveAbs( flight, z);
    } else {
      flight->moveAbs( flight, 0\&.0);
    }
  if( lspmac_getPosition( blight_ud) != 0\&.0) {
    blight->moveAbs( blight, z);
  } else {
    blight->moveAbs( blight, 0\&.0);
  }
}
.fi
.SS "double lspmac_lut (intnlut, double *lut, doublex)"

.PP
Look up table support for motor positions (think x=zoom, y=light intensity) use a lookup table to find the 'counts' to move the motor to the requested position The look up table is a simple one dimensional array with the x values as even indicies and the y values as odd indices\&. Returns: y value \fBParameters:\fP
.RS 4
\fInlut\fP number of entries in lookup table 
.br
\fIlut\fP The lookup table: even indicies are the x values, odd are the y's 
.br
\fIx\fP The x value we are looking up\&. 
.RE
.PP

.PP
Definition at line 310 of file lspmac\&.c\&.
.PP
.nf
                    {
  int i, foundone;
  double m;
  double y1, y2, x1, x2, y;

  foundone = 0;
  if( lut != NULL && nlut > 1) {
    for( i=0; i < 2*nlut; i += 2) {
      x1 = lut[i];
      y1 = lut[i+1];
      if( i < 2*nlut - 2) {
        x2 = lut[i+2];
        y2 = lut[i+3];
      }

      //
      // First one too big?  Use the y value of the first element
      //
      if( i == 0 && x1 > x) {
        y = y1;
        foundone = 1;
        break;
      }

      //
      // Look for equality
      //
      if( x1 == x) {
        y = y1;
        foundone = 1;
        break;
      }

      //
      // Maybe interpolate
      //
      if( (i < 2*nlut-2) && x < x2) {
        m = (y2 - y1) / (x2 - x1);
        y = m*(x - x1) + y1;
        foundone = 1;
        break;
      }
    }
    if( foundone == 0) {
      // must be bigger than the last entry
      //
      //
      y = lut[2*(nlut-1) + 1];
    }
    return y;
  }
  return 0\&.0;
}
.fi
.SS "\fBlspmac_motor_t\fP* lspmac_motor_init (\fBlspmac_motor_t\fP *d, intwy, intwx, int *posp, int *stat1p, int *stat2p, char *wtitle, char *name, void(*)(\fBlspmac_motor_t\fP *, double)moveAbs)"

.PP
Initialize a pmac stepper or servo motor\&. \fBParameters:\fP
.RS 4
\fId\fP An uninitialize motor object 
.br
\fIwy\fP Curses status window row index 
.br
\fIwx\fP Curses status window column index 
.br
\fIposp\fP Pointer to position status 
.br
\fIstat1p\fP Pointer to 1st status word 
.br
\fIstat2p\fP Pointer to 2nd status word 
.br
\fIwtitle\fP Title for this motor (to display) 
.br
\fIname\fP This motor's name 
.br
\fImoveAbs\fP Method to use to move this motor 
.RE
.PP

.PP
Definition at line 2405 of file lspmac\&.c\&.
.PP
.nf
                                    {

  _lspmac_motor_init( d, name);

  d->moveAbs             = moveAbs;
  d->read                = lspmac_pmacmotor_read;
  d->actual_pos_cnts_p   = posp;
  d->status1_p           = stat1p;
  d->status2_p           = stat2p;
  d->win = newwin( LS_DISPLAY_WINDOW_HEIGHT, LS_DISPLAY_WINDOW_WIDTH, wy*LS_DISPLAY_WINDOW_HEIGHT, wx*LS_DISPLAY_WINDOW_WIDTH);
  box( d->win, 0, 0);
  mvwprintw( d->win, 1, 1, '%s', wtitle);
  wnoutrefresh( d->win);

  return d;
}
.fi
.SS "void lspmac_move_or_jog_abs_queue (\fBlspmac_motor_t\fP *mp, doublerequested_position, intuse_jog)"

.PP
Move method for normal stepper and servo motor objects\&. < buffer to send to pmac
.PP
< coordinate system bit
.PP
< the requested position in units of 'counts'
.PP
< motor and coordinate system;
.PP
< our axis \fBParameters:\fP
.RS 4
\fImp\fP The motor to move 
.br
\fIrequested_position\fP Where to move it 
.br
\fIuse_jog\fP 1 to force jog, 0 for motion prog 
.RE
.PP

.PP
Definition at line 2143 of file lspmac\&.c\&.
.PP
.nf
                            {
  char s[512];                  
  int q100;                     
  int requested_pos_cnts;       
  int coord_num, motor_num;     
  char *axis;                   
  double u2c;

  pthread_mutex_lock( &(mp->mutex));

  u2c       = lsredis_getd(   mp->u2c);
  motor_num = lsredis_getl(   mp->motor_num);
  coord_num = lsredis_getl(   mp->coord_num);
  axis      = lsredis_getstr( mp->axis);

  if( u2c == 0\&.0) {
    //
    // Shouldn't try moving a motor that has no units defined
    //
    pthread_mutex_unlock( &(mp->mutex));
    return;
  }
  mp->requested_position = requested_position;
  mp->not_done    = 1;
  mp->motion_seen = 0;
  mp->requested_pos_cnts = u2c * requested_position;  
  requested_pos_cnts = mp->requested_pos_cnts;

  if( use_jog || axis == NULL || *axis == 0) {
    use_jog = 1;
  } else {
    use_jog = 0;
    q100 = 1 << (coord_num -1);
  }

  pthread_mutex_unlock( &(mp->mutex));

  if( use_jog) {
    snprintf( s, sizeof(s)-1, '#%d j=%d', motor_num, requested_pos_cnts);
  } else {

    //
    // Make sure the coordinate system is not moving something, wait if it is
    // TODO: put in a timeout so we have a way out if something goes wrong
    // TODO: are we sure this thread is not the one moving it?
    //
    pthread_mutex_lock( &lspmac_moving_mutex);
    lslogging_log_message( 'lspmac_moveabs_queue: waiting for previous moves to end\&.  lspmac_moving_flags = %0x', lspmac_moving_flags);
    while( (lspmac_moving_flags & q100) != 0)
      pthread_cond_wait( &lspmac_moving_cond, &lspmac_moving_mutex);
    pthread_mutex_unlock( &lspmac_moving_mutex);
    lslogging_log_message( 'lspmac_moveabs_queue: Done\&.  lspmac_moving_flags = %0x', lspmac_moving_flags);

    //
    // Set the 'we are moving this coordinate system' flag
    //
    lspmac_SockSendline( 'M5075=(M5075 | %d)', q100);
    
    switch( *axis) {
    case 'A':
      snprintf( s, sizeof(s)-1, '&%d Q16=%d Q100=%d B146R', coord_num, requested_pos_cnts, q100);
      break;

    case 'B':
      snprintf( s, sizeof(s)-1, '&%d Q17=%d Q100=%d B147R', coord_num, requested_pos_cnts, q100);
      break;

    case 'C':
      snprintf( s, sizeof(s)-1, '&%d Q18=%d Q100=%d B148R', coord_num, requested_pos_cnts, q100);
      break;
    case 'X':
      snprintf( s, sizeof(s)-1, '&%d Q10=%d Q100=%d B140R', coord_num, requested_pos_cnts, q100);
      break;

    case 'Y':
      snprintf( s, sizeof(s)-1, '&%d Q11=%d Q100=%d B141R', coord_num, requested_pos_cnts, q100);
      break;

    case 'Z':
      snprintf( s, sizeof(s)-1, '&%d Q12=%d Q100=%d B142R', coord_num, requested_pos_cnts, q100);
      break;

    case 'U':
      snprintf( s, sizeof(s)-1, '&%d Q13=%d Q100=%d B143R', coord_num, requested_pos_cnts, q100);
      break;

    case 'V':
      snprintf( s, sizeof(s)-1, '&%d Q14=%d Q100=%d B144R', coord_num, requested_pos_cnts, q100);
      break;

    case 'W':
      snprintf( s, sizeof(s)-1, '&%d Q15=%d Q100=%d B145R', coord_num, requested_pos_cnts, q100);
      break;
    }

    //
    // Make sure the flag has been seen
    //
    pthread_mutex_lock( &lspmac_moving_mutex);
    lslogging_log_message( 'lspmac_moveabs_queue: waiting for moving flag to propagate\&.  lspmac_moving_flags = %0x', lspmac_moving_flags);
    while( (lspmac_moving_flags & q100) == 0)
      pthread_cond_wait( &lspmac_moving_cond, &lspmac_moving_mutex);
    pthread_mutex_unlock( &lspmac_moving_mutex);
    lslogging_log_message( 'lspmac_moveabs_queue: Done\&.  lspmac_moving_flags = %0x', lspmac_moving_flags);
  }
  pthread_mutex_lock( &(mp->mutex));
  mp->pq = lspmac_SockSendline_nr( s);
  pthread_mutex_unlock( &(mp->mutex));

  free( axis);
}
.fi
.SS "void lspmac_move_or_jog_preset_queue (\fBlspmac_motor_t\fP *mp, char *preset, intuse_jog)"

.PP
move using a preset value \fBParameters:\fP
.RS 4
\fImp\fP Our motor 
.br
\fIpreset\fP the name of the preset 
.br
\fIuse_jog\fP [in[ 1 to force jog, 0 to try motion prog 
.RE
.PP

.PP
Definition at line 2261 of file lspmac\&.c\&.
.PP
.nf
                                       {
  double pos;
  int err;

  if( preset == NULL || *preset == 0)
    return;

  err = lsredis_find_preset( mp->name, preset, &pos);

  if( err != 0)
    lspmac_move_or_jog_abs_queue( mp, pos, use_jog);
}
.fi
.SS "void lspmac_move_preset_queue (\fBlspmac_motor_t\fP *mp, char *preset_name)"

.PP
Move a given motor to one of its preset positions\&. No movement if the preset is not found\&. 
.PP
\fBParameters:\fP
.RS 4
\fImp\fP lspmac motor pointer 
.br
\fIname\fP Name of the preset to use 
.RE
.PP

.PP
Definition at line 1928 of file lspmac\&.c\&.
.PP
.nf
                                                                      {
  double pos;
  int err;

  lslogging_log_message( 'lspmac_move_preset_queue: Called with motor %s and preset named '%s'', mp->name, preset_name);

  err = lsredis_find_preset( mp->name, preset_name, &pos);
  if( err == 0)
    return;

  mp->moveAbs( mp, pos);
  lslogging_log_message( 'lspmac_move_preset_queue: moving %s to preset '%s' (%f)', mp->name, preset_name, pos);
}
.fi
.SS "void lspmac_moveabs_blight_factor_queue (\fBlspmac_motor_t\fP *mp, doublepos)"

.PP
Definition at line 2092 of file lspmac\&.c\&.
.PP
.nf
                                                                         {
  char *fmt;

  if( pos >= 60 && pos <= 140) {
    pthread_mutex_lock( &(mp->mutex));
    *mp->actual_pos_cnts_p = pos;
    mp->position =           pos;
    pthread_mutex_unlock( &(mp->mutex));

    pthread_mutex_lock( &(blight->mutex));
    fmt = lsredis_getstr( blight->redis_fmt);
    lsredis_setstr( blight->u2c, fmt, pos / 100\&.0);
    free( fmt);
    pthread_mutex_unlock( &(blight->mutex));

    blight->moveAbs( blight, lspmac_getPosition( zoom));
  }
}
.fi
.SS "void lspmac_moveabs_bo_queue (\fBlspmac_motor_t\fP *mp, doublerequested_position)"

.PP
Move method for binary i/o motor objects\&. \fBParameters:\fP
.RS 4
\fImp\fP A binary i/o motor object 
.br
\fIrequested_position\fP a 1 or a 0 request to move 
.RE
.PP

.PP
Definition at line 1976 of file lspmac\&.c\&.
.PP
.nf
                                {


  pthread_mutex_lock( &(mp->mutex));
  mp->requested_position = requested_position == 0\&.0 ? 0\&.0 : 1\&.0;
  mp->requested_pos_cnts = requested_position == 0\&.0 ? 0 : 1;

  mp->not_done    = 1;
  mp->motion_seen = 0;
  mp->pq = lspmac_SockSendline_nr( mp->write_fmt, mp->requested_pos_cnts);


  pthread_mutex_unlock( &(mp->mutex));

}
.fi
.SS "void lspmac_moveabs_flight_factor_queue (\fBlspmac_motor_t\fP *mp, doublepos)"

.PP
Definition at line 2071 of file lspmac\&.c\&.
.PP
.nf
                                                                         {
  char *fmt;

  if( pos >= 60 && pos <= 140) {
    pthread_mutex_lock( &(mp->mutex));
    *mp->actual_pos_cnts_p = pos;
    mp->position =           pos;
    pthread_mutex_unlock( &(mp->mutex));

    pthread_mutex_lock( &(flight->mutex));

    fmt = lsredis_getstr( flight->redis_fmt);
    lsredis_setstr( flight->u2c, fmt, pos / 100\&.0);
    free( fmt);

    pthread_mutex_unlock( &(flight->mutex));

    flight->moveAbs( flight, lspmac_getPosition( zoom));
  }
}
.fi
.SS "void lspmac_moveabs_frontlight_oo_queue (\fBlspmac_motor_t\fP *mp, doublepos)"

.PP
'move' frontlight on/off 
.PP
Definition at line 2059 of file lspmac\&.c\&.
.PP
.nf
                                                                         {
  pthread_mutex_lock( &(mp->mutex));
  *mp->actual_pos_cnts_p = pos;
  mp->position =           pos;
  pthread_mutex_unlock( &(mp->mutex));
  if( pos == 0\&.0) {
    flight->moveAbs( flight, 0\&.0);
  } else {
    flight->moveAbs( flight, lspmac_getPosition( zoom));
  }
}
.fi
.SS "void lspmac_moveabs_fshut_queue (\fBlspmac_motor_t\fP *mp, doublerequested_position)"

.PP
Move method for the fast shutter\&. Slightly more complicated than a binary io as some flags need to be set up\&. \fBParameters:\fP
.RS 4
\fImp\fP The fast shutter motor instance 
.br
\fIrequested_position\fP 1 (open) or 0 (close), really 
.RE
.PP

.PP
Definition at line 1949 of file lspmac\&.c\&.
.PP
.nf
                                  {
  pthread_mutex_lock( &(mp->mutex));

  mp->requested_position = requested_position;
  mp->not_done    = 1;
  mp->motion_seen = 0;
  mp->requested_pos_cnts = requested_position;
  if( requested_position != 0) {
    //
    // ScanEnable=0, ManualEnable=1, ManualOn=1
    //
    mp->pq = lspmac_SockSendline_nr( 'M1124=0 M1125=1 M1126=1');
  } else {
    //
    // ManualOn=0, ManualEnable=0, ScanEnable=1
    //
    mp->pq = lspmac_SockSendline_nr( 'M1126=0 M1125=0 M1124=1');
  }

  pthread_mutex_unlock( &(mp->mutex));
}
.fi
.SS "void lspmac_moveabs_queue (\fBlspmac_motor_t\fP *mp, doublerequested_position)"

.PP
Use coordinate system motion program, if available, to move motor to requested position\&. \fBParameters:\fP
.RS 4
\fImp\fP The motor to move 
.br
\fIrequested_position\fP Where to move it 
.RE
.PP

.PP
Definition at line 2281 of file lspmac\&.c\&.
.PP
.nf
                            {
  
  lspmac_move_or_jog_abs_queue( mp, requested_position, 0);
}
.fi
.SS "void lspmac_moveabs_timed_queue (\fBlspmac_motor_t\fP *mp, doublestart, doubledelta, doubletime)"

.PP
timed motor move \fBParameters:\fP
.RS 4
\fImp\fP Our motor object 
.br
\fIstart\fP Beginning of motion 
.br
\fIdelta\fP Distance to move 
.br
\fItime\fP to move it in (secs) 
.RE
.PP
< Flags needed for wait routine 
.PP
Definition at line 2002 of file lspmac\&.c\&.
.PP
.nf
                                  {
  // 240                LS-CAT Timed X move
  //            Q10    = Starting X value (cnts)
  //            Q11    = Delta X value   (cnts)
  //            Q12    = Time to run between the two points (mSec)
  //            Q13    = Acceleration time (msecs)
  //            Q100   = 1 << (coord sys no - 1)

  int q10;       // Starting value (counts)
  int q11;       // Delta (counts)
  int q12;       // Time to run (msecs)
  int q13;       // Acceleration time (msecs)
  int q100;      // 1 << (coord sys no - 1)
  int coord_num; // our coordinate number
  char s[512];   // PMAC command string buffer
  double u2c;
  double max_accel;

  pthread_mutex_lock( &(mp->mutex));

  u2c       = lsredis_getd( mp->u2c);
  max_accel = lsredis_getd( mp->max_accel);
  coord_num = lsredis_getl( mp->coord_num);

  if( u2c == 0\&.0 || time <= 0\&.0 || max_accel <= 0\&.0) {
    //
    // Shouldn't try moving a motor that has bad motion parameters
    //
    pthread_mutex_unlock( &(mp->mutex));
    return;
  }

  mp->not_done    = 1;          
  mp->motion_seen = 0;

  mp->requested_position = start + delta;
  mp->requested_pos_cnts = u2c * mp->requested_position;
  q10 = mp->requested_pos_cnts;
  q11 = u2c * delta;
  q12 = 1000 * time;
  q13 = q11 / q12 / max_accel;
  q100 = 1 << (coord_num - 1);
  pthread_mutex_unlock( &(mp->mutex));

  snprintf( s, sizeof(s)-1, '&%d Q10=%d Q11=%d Q12=%d Q13=%d Q100=%d B240R', coord_num, q10, q11, q12, q13, q100);
  pthread_mutex_lock( &(mp->mutex));
  mp->pq = lspmac_SockSendline_nr( s);
  pthread_mutex_unlock( &(mp->mutex));
}
.fi
.SS "void lspmac_moveabs_wait (\fBlspmac_motor_t\fP *mp)"

.PP
Wait for motor to finish moving\&. Assume motion already queued, now just wait \fBParameters:\fP
.RS 4
\fImp\fP The motor object to wait for 
.RE
.PP

.PP
Definition at line 2303 of file lspmac\&.c\&.
.PP
.nf
                           {
  struct timespec wt;
  int return_code;
  pmac_cmd_queue_t *pq;

  //
  // Copy the queue item for the most recent move request
  //
  pthread_mutex_lock( &(mp->mutex));
  pq = mp->pq;
  pthread_mutex_unlock( &(mp->mutex));

  pthread_mutex_lock( &pmac_queue_mutex);
  //
  // wait for the command to be sent
  //
  while( pq->time_sent\&.tv_sec==0)
    pthread_cond_wait( &pmac_queue_cond, &pmac_queue_mutex);

  //
  // set the timeout to be long enough after we sent the motion request to ensure that
  // we will have read back the motor moving status but not so long that the timeout causes
  // problems;
  //
  wt\&.tv_sec  = pq->time_sent\&.tv_sec;
  wt\&.tv_nsec = pq->time_sent\&.tv_nsec + 500000000;

  pthread_mutex_unlock( &pmac_queue_mutex);

  if( wt\&.tv_nsec >= 1000000000) {
    wt\&.tv_nsec -= 1000000000;
    wt\&.tv_sec += 1;
  }

  //
  // wait for the motion to have started
  // This will time out if the motion ends before we can read the status back
  // hence the added complication of time stamp of the sent packet\&.
  //

  return_code=0;

  pthread_mutex_lock( &(mp->mutex));
  while( mp->motion_seen == 0 && return_code == 0)
    return_code = pthread_cond_timedwait( &(mp->cond), &(mp->mutex), &wt);

  if( return_code == 0) {
    //
    // wait for the motion that we know has started to finish
    //
    while( mp->not_done)
      pthread_cond_wait( &(mp->cond), &(mp->mutex));
  }

  //
  // if return code was not 0 then we know we shouldn't wait for not_done flag\&.
  // In this case the motion ended before we read the status registers
  //
  pthread_mutex_unlock( &(mp->mutex));

}
.fi
.SS "void lspmac_movedac_queue (\fBlspmac_motor_t\fP *mp, doublerequested_position)"

.PP
Move method for dac motor objects (ie, lights) \fBParameters:\fP
.RS 4
\fImp\fP Our motor 
.br
\fIrequested_position\fP Desired x postion (look up and send y position) 
.RE
.PP

.PP
Definition at line 1858 of file lspmac\&.c\&.
.PP
.nf
                            {
  char s[512];
  double y;
  double u2c;

  pthread_mutex_lock( &(mp->mutex));

  u2c = lsredis_getd( mp->u2c);
  mp->requested_position = requested_position;

  if( mp->nlut > 0 && mp->lut != NULL) {
    mp->requested_pos_cnts = u2c * lspmac_lut( mp->nlut, mp->lut, requested_position);
    mp->not_done    = 1;
    mp->motion_seen = 0;


    //
    //  By convention requested_pos_cnts scales from 0 to 100
    //  for the lights u2c converts this to 0 to 16,000
    //  for the scintilator focus this is   0 to 32,000
    //
    snprintf( s, sizeof(s)-1, '%s=%d', mp->dac_mvar, mp->requested_pos_cnts);
    mp->pq = lspmac_SockSendline_nr( s);

  }

  pthread_mutex_unlock( &(mp->mutex));
}
.fi
.SS "void lspmac_movezoom_queue (\fBlspmac_motor_t\fP *mp, doublerequested_position)"

.PP
Move method for the zoom motor\&. \fBParameters:\fP
.RS 4
\fImp\fP the zoom motor 
.br
\fIrequested_position\fP our desired zoom 
.RE
.PP

.PP
Definition at line 1893 of file lspmac\&.c\&.
.PP
.nf
                             {
  char s[512];
  double y;
  int motor_num;

  pthread_mutex_lock( &(mp->mutex));

  motor_num = lsredis_getl( mp->motor_num);

  mp->requested_position = requested_position;

  if( mp->nlut > 0 && mp->lut != NULL) {
    y = lspmac_lut( mp->nlut, mp->lut, requested_position);

    mp->requested_pos_cnts = (int)y;
    mp->not_done    = 1;
    mp->motion_seen = 0;


    snprintf( s, sizeof(s)-1, '#%d j=%d', motor_num, mp->requested_pos_cnts);
    mp->pq = lspmac_SockSendline_nr( s);

  }
  pthread_mutex_unlock( &(mp->mutex));

}
.fi
.SS "void lspmac_next_state ()"

.PP
State machine logic\&. Given the current state, generate the next one 
.PP
Definition at line 1717 of file lspmac\&.c\&.
.PP
.nf
                         {


  //
  // Connect to the pmac and perhaps initialize it\&.
  // OK, this is slightly more than just the state
  // machine logic\&.\&.\&.
  //
  if( ls_pmac_state == LS_PMAC_STATE_DETACHED) {
    //
    // TODO (eventually)
    // This ip address wont change in a single PMAC installation
    // We'll need to audit the code if we decide to implement
    // multiple PMACs so might as well wait til then\&.
    //
    lsConnect( '192\&.6\&.94\&.5');

    //
    // If the connect was successful we can proceed with the initialization
    //
    if( ls_pmac_state != LS_PMAC_STATE_DETACHED) {
      lspmac_SockFlush();
      
      //
      // Harvest the I and M variables in case we need them
      // one day\&.
      //
      if( getmvars) {
        lspmac_GetAllMVars();
        getmvars = 0;
      }
      
      if( getivars) {
        lspmac_GetAllIVars();
        getivars = 0;
      }
    }
  }

  //
  // Check the command queue and perhaps go to the 'Send Command' state\&.
  //
  if( ls_pmac_state == LS_PMAC_STATE_IDLE && ethCmdOn != ethCmdOff)
    ls_pmac_state = LS_PMAC_STATE_SC;


  //
  // Set the events flag
  // to tell poll what we are waiting for\&.
  //
  switch( ls_pmac_state) {
  case LS_PMAC_STATE_DETACHED:
    //
    // there shouldn't be a valid fd, so ignore the events
    //
    pmacfd\&.events = 0;
    break;

  case LS_PMAC_STATE_IDLE:
    if( ethCmdOn == ethCmdOff) {
      //
      // Anytime we are idle we want to
      // get the status of the PMAC
      //

      lspmac_get_status();
    }



  //
  // These state require that we listen for packets
  //
  case LS_PMAC_STATE_WACK_NFR:
  case LS_PMAC_STATE_WACK:
  case LS_PMAC_STATE_WACK_CC:
  case LS_PMAC_STATE_WACK_RR:
  case LS_PMAC_STATE_WCR:
  case LS_PMAC_STATE_WGB:
  case LS_PMAC_STATE_GMR:
    pmacfd\&.events = POLLIN;
    break;
    
  //
  // These state require that we send packets out\&.
  //
  case LS_PMAC_STATE_SC:
  case LS_PMAC_STATE_CR:
  case LS_PMAC_STATE_RR:
  case LS_PMAC_STATE_GB:
    //
    // Sad fact: PMAC will fail to process commands if we send them too quickly\&.
    // We deal with that by waiting a tad before we let poll tell us the PMAC socket is ready to write\&.
    //
    gettimeofday( &now, NULL);
    if(  ((now\&.tv_sec * 1000000\&. + now\&.tv_usec) - (pmac_time_sent\&.tv_sec * 1000000\&. + pmac_time_sent\&.tv_usec)) < PMAC_MIN_CMD_TIME) {
      pmacfd\&.events = 0;
    } else {
      pmacfd\&.events = POLLOUT;
    }
    break;
  }
}
.fi
.SS "void lspmac_pmacmotor_read (\fBlspmac_motor_t\fP *mp)"

.PP
Read the position and status of a normal PMAC motor\&. \fBParameters:\fP
.RS 4
\fImp\fP Our motor 
.RE
.PP

.PP
Definition at line 1247 of file lspmac\&.c\&.
.PP
.nf
                             {
  char s[512], *sp;
  int homing1, homing2;
  double u2c;
  int motor_num;
  char *fmt;
  pthread_mutex_lock( &(mp->mutex));

  //
  // if this time and last time were both 'in position'
  // and the position changed significantly then log the event
  //
  // On E omega has been observed to change by 0x10000 on its own
  // with no real motion\&.
  //
  if( mp->status2 & 1 && mp->status2 == *mp->status2_p && abs( mp->actual_pos_cnts - *mp->actual_pos_cnts_p) > 256) {
    //    lslogging_log_message( 'Instantaneous change: %s old status1: %0x, new status1: %0x, old status2: %0x, new status2: %0x, old cnts: %0x, new cnts: %0x',
    //                     mp->name, mp->status1, *mp->status1_p, mp->status2, *mp->status2_p, mp->actual_pos_cnts, *mp->actual_pos_cnts_p);

    //
    // At this point we'll just log the event and return
    // There is no reason to believe the change is real\&.
    //
    // There is a non-zero probability that the first value is the bad one and any value afterwards will be taken as
    // wrong\&.  Homing (or moving) the motor should fix this\&.  There is a non-zero probably that it can happen
    // two or more times in a row after moving\&.
    //
    // TODO: account for the case where mp->actual_pos_cnts is the bad value\&.
    //
    // TODO: Is this a problem when the motor is moving?  Can we detect it?
    //
    // TODO: Think of the correct change value here (currently 256) that works for all motors
    // or have this value configurable
    //
    pthread_mutex_unlock( &(mp->mutex));
    return;
  }


  // Send an event if inPosition has changed
  //
  if( (mp->status2 & 0x000001) != (*mp->status2_p & 0x000001)) {
    lsevents_send_event( '%s %s', mp->name, (*mp->status2_p & 0x000001) ? 'In Position' : 'Moving');
  }

  // Get some values we might need later
  //
  u2c       = lsredis_getd( mp->u2c);
  motor_num = lsredis_getl( mp->motor_num);

  //
  // maybe look for omega zero crossing
  //
  if( motor_num == 1 && omega_zero_search && *mp->actual_pos_cnts_p >=0 && mp->actual_pos_cnts < 0) {
    int secs, nsecs;

    if( omega_zero_velocity > 0\&.0) {
      secs = *mp->actual_pos_cnts_p / omega_zero_velocity;
      nsecs = (*mp->actual_pos_cnts_p / omega_zero_velocity - secs) * 1000000000;


      omega_zero_time\&.tv_sec = lspmac_status_time\&.tv_sec  - secs;
      omega_zero_time\&.tv_nsec= lspmac_status_time\&.tv_nsec;
      if( omega_zero_time\&.tv_nsec < nsecs) {
        omega_zero_time\&.tv_sec  -= 1;
        omega_zero_time\&.tv_nsec += 1000000000;
      }
      omega_zero_time\&.tv_nsec -= nsecs;

      lsevents_send_event( 'omega crossed zero');
      lslogging_log_message('lspmac_motor_read: omega zero secs %d  nsecs %d ozt\&.tv_sec %ld  ozt\&.tv_nsec  %ld, motor cnts %d',
                            secs, nsecs, omega_zero_time\&.tv_sec, omega_zero_time\&.tv_nsec, *mp->actual_pos_cnts_p);
    }
    omega_zero_search = 0;
  }


  // Make local copies so we can inspect them in other threads
  // without having to grab the status mutex
  //
  mp->status1 = *mp->status1_p;
  mp->status2 = *mp->status2_p;
  mp->actual_pos_cnts = *mp->actual_pos_cnts_p;

  //
  // See if we are done moving, ie, in position
  //
  if( mp->status2 & 0x000001) {
    if( mp->not_done) {
      mp->not_done = 0;
      pthread_cond_signal( &(mp->cond));
    }
  } else if( mp->not_done == 0) {
    mp->not_done = 1;
  }

  // See if the motor is moving
  //
  //                move timer                  homing
  //                  123456                    123456
  if( mp->status1 & 0x020000 || mp->status1 & 0x000400) {
    if( mp->motion_seen == 0) {
      mp->motion_seen = 1;
      pthread_cond_signal( &(mp->cond));
    }
  }

  mvwprintw( mp->win, 2, 1, '%*s', LS_DISPLAY_WINDOW_WIDTH-2, ' ');
  mvwprintw( mp->win, 2, 1, '%*d cts', LS_DISPLAY_WINDOW_WIDTH-6, mp->actual_pos_cnts);
  mvwprintw( mp->win, 3, 1, '%*s', LS_DISPLAY_WINDOW_WIDTH-2, ' ');

  if( mp->nlut >0 && mp->lut != NULL) {
    mp->position = lspmac_rlut( mp->nlut, mp->lut, mp->actual_pos_cnts);
  } else {
    if( u2c != 0\&.0) {
      mp->position = mp->actual_pos_cnts / u2c;
    } else {
      mp->position = mp->actual_pos_cnts;
    }
  }

  fmt = lsredis_getstr( mp->printf_fmt);
  snprintf( s, sizeof(s)-1, fmt, 8, mp->position);
  free( fmt);

  // set flag if we are not homed
  homing1 = 0;
  //                        ~(homed flag)
  if( mp->homing == 0  && (~mp->status2 & 0x000400) != 0) {
    homing1 = 1;
  }

  // set flag if we are homing and in open loop
  homing2 = 0;
  //                         open loop
  if( mp->homing == 1 && (mp->status1 & 0x040000) != 0) {
    homing2 = 1;
  }
  // maybe reset homing flag
  //                        homed flag                       in position flag
  if( mp->homing == 2 && (mp->status2 & 0x000400 != 0) && (mp->status2 & 0x000001 != 0))
    mp->homing = 0;


  s[sizeof(s)-1] = 0;
  mvwprintw( mp->win, 3, 1, '%*s', LS_DISPLAY_WINDOW_WIDTH-6, s);

  mvwprintw( mp->win, 4, 1, '%*x', LS_DISPLAY_WINDOW_WIDTH-2, mp->status1);
  mvwprintw( mp->win, 5, 1, '%*x', LS_DISPLAY_WINDOW_WIDTH-2, mp->status2);
  sp = '';
  if( mp->status2 & 0x000002)
    sp = 'Following Warning';
  else if( mp->status2 & 0x000004)
    sp = 'Following Error';
  else if( mp->status2 & 0x000020)
    sp = 'I2T Amp Fault';
  else if( mp->status2 & 0x000008)
    sp = 'Amp\&. Fault';
  else if( mp->status2 & 0x000800)
    sp = 'Stopped on Limit';
  else if( mp->status1 & 0x040000)
    sp = 'Open Loop';
  else if( ~(mp->status1) & 0x080000)
    sp = 'Motor Disabled';
  else if( mp->status1 & 0x000400)
    sp = 'Homing';
  else if( (mp->status1 & 0x600000) == 0x600000)
    sp = 'Both Limits Tripped';
  else if( mp->status1 & 0x200000)
    sp = 'Positive Limit';
  else if( mp->status1 & 0x400000)
    sp = 'Negative Limit';
  else if( ~(mp->status2) & 0x000400)
    sp = 'Not Homed';
  else if( mp->status2 & 0x000001)
    sp = 'In Position';

  mvwprintw( mp->win, 6, 1, '%*s', LS_DISPLAY_WINDOW_WIDTH-2, sp);
  wnoutrefresh( mp->win);
  
  strncpy( mp->statuss, sp, sizeof( mp->statuss)-1);
  mp->statuss[sizeof(mp->statuss)-1] = 0;

  pthread_mutex_unlock( &(mp->mutex));

  if( homing1)
    lspmac_home1_queue( mp);

  if( homing2)
    lspmac_home2_queue( mp);

  lspmac_status_last_time\&.tv_sec  = lspmac_status_time\&.tv_sec;
  lspmac_status_last_time\&.tv_nsec = lspmac_status_time\&.tv_nsec;
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_pop_queue ()"

.PP
Remove the oldest queue item\&. Used to send command to PMAC\&. Note that there is a separate reply index to ensure we've know to what command a reply is refering\&. Returns the item\&. 
.PP
Definition at line 556 of file lspmac\&.c\&.
.PP
.nf
                                     {
  pmac_cmd_queue_t *rtn;

  pthread_mutex_lock( &pmac_queue_mutex);

  if( ethCmdOn == ethCmdOff)
    rtn = NULL;
  else {
    rtn = &(ethCmdQueue[(ethCmdOff++) % PMAC_CMD_QUEUE_LENGTH]);
    clock_gettime( CLOCK_REALTIME, &(rtn->time_sent));
  }
  pthread_mutex_unlock( &pmac_queue_mutex);
  return rtn;
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_pop_reply ()"

.PP
Remove the next command queue item that is waiting for a reply\&. We always need a reply to know we are done with a given command\&. Returns the item\&. 
.PP
Definition at line 576 of file lspmac\&.c\&.
.PP
.nf
                                     {
  pmac_cmd_queue_t *rtn;

  pthread_mutex_lock( &pmac_queue_mutex);

  if( ethCmdOn == ethCmdReply)
    rtn = NULL;
  else
    rtn = &(ethCmdQueue[(ethCmdReply++) % PMAC_CMD_QUEUE_LENGTH]);

  pthread_mutex_unlock( &pmac_queue_mutex);
  return rtn;
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_push_queue (\fBpmac_cmd_queue_t\fP *cmd)"

.PP
Put a new command on the queue\&. Pointer is returned so caller can evaluate the time command was actually sent\&. \fBParameters:\fP
.RS 4
\fIcmd\fP Command to send to the PMAC 
.RE
.PP

.PP
Definition at line 532 of file lspmac\&.c\&.
.PP
.nf
                                      {
  pmac_cmd_queue_t *rtn;

  pthread_mutex_lock( &pmac_queue_mutex);
  rtn = &(ethCmdQueue[(ethCmdOn++) % PMAC_CMD_QUEUE_LENGTH]);
  memcpy( rtn, cmd, sizeof( pmac_cmd_queue_t));
  rtn->time_sent\&.tv_sec  = 0;
  rtn->time_sent\&.tv_nsec = 0;
  pthread_cond_signal( &pmac_queue_cond);
  pthread_mutex_unlock( &pmac_queue_mutex);

  return rtn;
}
.fi
.SS "void lspmac_Reset ()"

.PP
Clear the queue and put the PMAC into a known state\&. 
.PP
Definition at line 653 of file lspmac\&.c\&.
.PP
.nf
                    {
  ls_pmac_state = LS_PMAC_STATE_IDLE;

  // clear queue
  ethCmdReply = ethCmdOn;
  ethCmdOff   = ethCmdOn;

  lspmac_SockFlush();
}
.fi
.SS "double lspmac_rlut (intnlut, double *lut, doubley)"
\fBParameters:\fP
.RS 4
\fInlut\fP number of entries in lookup table 
.br
\fIlut\fP our lookup table 
.br
\fIy\fP the y value for which we need an x 
.RE
.PP

.PP
Definition at line 368 of file lspmac\&.c\&.
.PP
.nf
                     {
  int i, foundone, up;
  double m;
  double y1, y2, x1, x2, x;

  foundone = 0;
  if( lut != NULL && nlut > 1) {

    if( lut[1] < lut[2*nlut-1])
      up = 1;
    else
      up = 0;

    for( i=0; i < 2*nlut; i += 2) {
      x1 = lut[i];
      y1 = lut[i+1];
      if( i < 2*nlut - 2) {
        x2 = lut[i+2];
        y2 = lut[i+3];
      }
      if( i==0 && ( up ? y1 > y : y1 < y)) {
        x = x1;
        foundone = 1;
        break;
      }
      if( y1 == y) {
        x = x1;
        foundone = 1;
        break;
      }
      if( (i < 2*nlut-2) && (up ? y < y2 : y > y2)) {
        m = (x2 - x1) / (y2 - y1);
        x = m * (y - y1) + x1;
        foundone = 1;
        break;
      }
    }
    if( foundone == 0 ) {
      x = lut[2*(nlut-1)];
    }
    return x;
  }
  return 0\&.0;
}
.fi
.SS "void lspmac_run ()"

.PP
find a postion for a given preset name \fBParameters:\fP
.RS 4
\fImp\fP Motor pointer 
.br
\fIname\fP The preset to search for 
.br
\fIerr\fP set to non-zero on error, ignored if nullStart up the lspmac thread 
.RE
.PP

.PP
Definition at line 2714 of file lspmac\&.c\&.
.PP
.nf
                  {
  char **inits;
  lspmac_motor_t *mp;
  int i;
  int active;

  pthread_create( &pmac_thread, NULL, lspmac_worker, NULL);

  lsevents_add_listener( 'CryoSwitchChanged',    lspmac_cryoSwitchChanged_cb);
  lsevents_add_listener( 'scint In Position',    lspmac_scint_inPosition_cb);
  lsevents_add_listener( 'scintDried',           lspmac_scint_dried_cb);
  lsevents_add_listener( 'backLight 1',          lspmac_backLight_up_cb);
  lsevents_add_listener( 'backLight 0',          lspmac_backLight_down_cb);
  lsevents_add_listener( 'cam\&.zoom In Position', lspmac_light_zoom_cb);

  //
  // Initialize the MD2 pmac (ie, turn on the right plcc's etc)
  //
  for( inits = lsredis_get_string_array(lspmac_md2_init); *inits != NULL; inits++) {
    lspmac_SockSendline( *inits);
    //    lslogging_log_message( 'lspmac_init: pmac init '%s'', *inits);
  }
  
  //
  // Initialize the pmac's support for each motor
  // (ie, set the various flag for when a motor is active or not)
  //
  for( i=0; i<lspmac_nmotors; i++) {
    mp = &(lspmac_motors[i]);
    active = lsredis_getb( mp->active);

    // if there is a problem with 'active' then don't do anything
    // On the other hand, various combinations of yes/no true/fals 1/0 should work
    //
    switch( active) {
    case 1:
      inits = lsredis_get_string_array( mp->active_init);
      break;

    case 0:
      inits = lsredis_get_string_array( mp->active_init);
      break;

    default:
      inits = NULL;
    }

    if( inits != NULL) {
      while( *inits != NULL) {
        lspmac_SockSendline( *inits);
        //      lslogging_log_message( 'lspmac_init: %s init '%s'', mp->name, *inits);
        inits++;
      }
    }
  }
}
.fi
.SS "void lspmac_scint_dried_cb (char *event)"

.PP
Turn off the dryer\&. \fBParameters:\fP
.RS 4
\fIevent\fP required by protocol 
.RE
.PP

.PP
Definition at line 2698 of file lspmac\&.c\&.
.PP
.nf
                                         {
  lslogging_log_message( 'lspmac_scint_dried_cb: Stopping dryer');
  dryer->moveAbs( dryer, 0\&.0);
}
.fi
.SS "void lspmac_scint_inPosition_cb (char *event)"

.PP
Maybe start drying off the scintilator\&. \fBParameters:\fP
.RS 4
\fIevent\fP required by protocol 
.RE
.PP

.PP
Definition at line 2637 of file lspmac\&.c\&.
.PP
.nf
                                              {
  double pos;
  double cover;
  int err;

  pthread_mutex_lock( &(scint->mutex));
  pos = scint->position;
  err = lsredis_find_preset( scint->name, 'Cover', &pos);
  pthread_mutex_unlock( &(scint->mutex));

  lslogging_log_message( 'lspmac_scint_inPosition_cb: pos %f, cover %f, diff %f, err %d', pos, cover, fabs( pos-cover), err);

  if( err == 0)
    return;

  if( fabs( pos - cover) <= 0\&.1) {
    dryer->moveAbs( dryer, 1\&.0);
    lslogging_log_message( 'lspmac_scint_inPosition_cb: Starting dryer');
    lstimer_add_timer( 'scintDried', 1, 120, 0);
  }
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_send_command (intrqType, intrq, intwValue, intwIndex, intwLength, unsigned char *data, void(*)(\fBpmac_cmd_queue_t\fP *, int, unsigned char *)responseCB, intno_reply)"

.PP
Compose a packet and send it to the PMAC\&. This is the meat of the PMAC communications routines\&. The queued command is returned\&. \fBParameters:\fP
.RS 4
\fIrqType\fP VR_UPLOAD or VR_DOWNLOAD 
.br
\fIrq\fP PMAC command (see PMAC User Manual 
.br
\fIwValue\fP Command argument 1 
.br
\fIwIndex\fP Command argument 2 
.br
\fIwLength\fP Length of data array 
.br
\fIdata\fP Data array (or NULL) 
.br
\fIresponseCB\fP Function to call when a response is read from the PMAC 
.br
\fIno_reply\fP Flag, non-zero means no reply is expected 
.RE
.PP

.PP
Definition at line 594 of file lspmac\&.c\&.
.PP
.nf
                                        {
  static pmac_cmd_queue_t cmd;

  cmd\&.pcmd\&.RequestType = rqType;
  cmd\&.pcmd\&.Request     = rq;
  cmd\&.pcmd\&.wValue      = htons(wValue);
  cmd\&.pcmd\&.wIndex      = htons(wIndex);
  cmd\&.pcmd\&.wLength     = htons(wLength);
  cmd\&.onResponse       = responseCB;
  cmd\&.no_reply          = no_reply;

  //
  // Setting the message buff bData requires a bit more care to avoid over filling it
  // or sending garbage in the unused bytes\&.
  //

  if( wLength > sizeof( cmd\&.pcmd\&.bData)) {
    //
    // Bad things happen if we do not catch this case\&.
    //
    lslogging_log_message( 'Message Length %d longer than maximum of %ld, aborting', wLength, sizeof( cmd\&.pcmd\&.bData));
    exit( -1);
  }
  if( data == NULL) {
    memset( cmd\&.pcmd\&.bData, 0, sizeof( cmd\&.pcmd\&.bData));
  } else {
    //
    // This could leave bData non-null terminated\&.  I do not know if this is a problem\&.
    //
    if( wLength > 0)
      memcpy( cmd\&.pcmd\&.bData, data, wLength);
    if( wLength < sizeof( cmd\&.pcmd\&.bData))
      memset( cmd\&.pcmd\&.bData + wLength, 0, sizeof( cmd\&.pcmd\&.bData) - wLength);
  }

  return lspmac_push_queue( &cmd);
}
.fi
.SS "void lspmac_sendcmd (void(*)(\fBpmac_cmd_queue_t\fP *, int, unsigned char *)responseCB, char *fmt, \&.\&.\&.)"

.PP
PMAC command with call back\&. \fBParameters:\fP
.RS 4
\fIresponseCB\fP our callback routine 
.br
\fIfmt\fP printf style format string 
.RE
.PP

.PP
Definition at line 1697 of file lspmac\&.c\&.
.PP
.nf
                          {
  static char tmps[1024];
  va_list arg_ptr;

  va_start( arg_ptr, fmt);
  vsnprintf( tmps, sizeof(tmps)-1, fmt, arg_ptr);
  tmps[sizeof(tmps)-1]=0;
  va_end( arg_ptr);

  lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDLINE, 0, 0, strlen(tmps), tmps, responseCB, 0);
}
.fi
.SS "void lspmac_sendcmd_nocb (char *fmt, \&.\&.\&.)"

.PP
Send a command that does not need to deal with the reply\&. \fBParameters:\fP
.RS 4
\fIfmt\fP A printf style format string 
.RE
.PP

.PP
Definition at line 1678 of file lspmac\&.c\&.
.PP
.nf
                           {
  static char tmps[1024];
  va_list arg_ptr;

  va_start( arg_ptr, fmt);
  vsnprintf( tmps, sizeof(tmps)-1, fmt, arg_ptr);
  tmps[sizeof(tmps)-1]=0;
  va_end( arg_ptr);

  lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDLINE, 0, 0, strlen(tmps), tmps, NULL, 0);
}
.fi
.SS "void lspmac_SendControlReplyPrintCB (\fBpmac_cmd_queue_t\fP *cmd, intnreceived, unsigned char *buff)"

.PP
Receive a reply to a control character Print a 'printable' version of the character to the terminal Followed by a hex dump of the response\&. \fBParameters:\fP
.RS 4
\fIcmd\fP Queue item this is a reply to 
.br
\fInreceived\fP Number of bytes received 
.br
\fIbuff\fP Buffer of bytes received 
.RE
.PP

.PP
Definition at line 915 of file lspmac\&.c\&.
.PP
.nf
                                      {
  pthread_mutex_lock( &ncurses_mutex);
  wprintw( term_output, 'control-%c: ', '@'+ ntohs(cmd->pcmd\&.wValue));
  pthread_mutex_unlock( &ncurses_mutex);
  hex_dump( nreceived, buff);
  pthread_mutex_lock( &ncurses_mutex);
  wnoutrefresh( term_output);
  wnoutrefresh( term_input);
  doupdate();
  pthread_mutex_unlock( &ncurses_mutex);
}
.fi
.SS "void lspmac_Service (struct pollfd *evt)"

.PP
Service routine for packet coming from the PMAC\&. All communications is asynchronous so this is the only place incomming packets are handled \fBParameters:\fP
.RS 4
\fIevt\fP pollfd object returned by poll 
.RE
.PP

.PP
Definition at line 700 of file lspmac\&.c\&.
.PP
.nf
                      {
  static unsigned char *receiveBuffer = NULL;   // the buffer inwhich to stick our incomming characters
  static int receiveBufferSize = 0;             // size of receiveBuffer
  static int receiveBufferIn = 0;               // next location to write to in receiveBuffer
  pmac_cmd_queue_t *cmd;                        // maybe the command we are servicing
  ssize_t nsent, nread;                         // nbytes dealt with
  int i;                                        // loop counter
  int foundEOCR;                                // end of command response flag

  if( evt->revents & (POLLERR | POLLHUP | POLLNVAL)) {
    if( evt->fd != -1) {
      close( evt->fd);
      evt->fd = -1;
    }
    ls_pmac_state = LS_PMAC_STATE_DETACHED;
    return;
  }


  if( evt->revents & POLLOUT) {

    switch( ls_pmac_state) {
    case LS_PMAC_STATE_DETACHED:
      break;
    case LS_PMAC_STATE_IDLE:
      break;

    case LS_PMAC_STATE_SC:
      cmd = lspmac_pop_queue();
      if( cmd != NULL) {
        if( cmd->pcmd\&.Request == VR_PMAC_GETMEM) {
          nsent = send( evt->fd, cmd, pmac_cmd_size, 0);
          if( nsent != pmac_cmd_size) {
            lslogging_log_message( 'Could only send %d of %d bytes\&.\&.\&.\&.Not good\&.', (int)nsent, (int)(pmac_cmd_size));
          }
        } else {
          nsent = send( evt->fd, cmd, pmac_cmd_size + ntohs(cmd->pcmd\&.wLength), 0);
          gettimeofday( &pmac_time_sent, NULL);
          if( nsent != pmac_cmd_size + ntohs(cmd->pcmd\&.wLength)) {
            lslogging_log_message( 'Could only send %d of %d bytes\&.\&.\&.\&.Not good\&.', (int)nsent, (int)(pmac_cmd_size + ntohs(cmd->pcmd\&.wLength)));
          }
        }
      }
      if( cmd->pcmd\&.Request == VR_PMAC_SENDCTRLCHAR)
        ls_pmac_state = LS_PMAC_STATE_WACK_CC;
      else if( cmd->pcmd\&.Request == VR_PMAC_GETMEM)
        ls_pmac_state = LS_PMAC_STATE_GMR;
      else if( cmd->no_reply == 0)
        ls_pmac_state = LS_PMAC_STATE_WACK;
      else
        ls_pmac_state = LS_PMAC_STATE_WACK_NFR;
      break;

    case LS_PMAC_STATE_CR:
      nsent = send( evt->fd, &cr_cmd, pmac_cmd_size, 0);
      gettimeofday( &pmac_time_sent, NULL);
      ls_pmac_state = LS_PMAC_STATE_WCR;
      break;

    case LS_PMAC_STATE_RR:
      nsent = send( evt->fd, &rr_cmd, pmac_cmd_size, 0);
      gettimeofday( &pmac_time_sent, NULL);
      ls_pmac_state = LS_PMAC_STATE_WACK_RR;
      break;

    case LS_PMAC_STATE_GB:
      nsent = send( evt->fd, &gb_cmd, pmac_cmd_size, 0);
      gettimeofday( &pmac_time_sent, NULL);
      ls_pmac_state = LS_PMAC_STATE_WGB;
      break;
    }
  }

  if( evt->revents & POLLIN) {

    if( receiveBufferSize - receiveBufferIn < 1400) {
      unsigned char *newbuff;

      receiveBufferSize += 1400;
      newbuff = calloc( receiveBufferSize, sizeof( unsigned char));
      if( newbuff == NULL) {
        lslogging_log_message( 'Out of memory');
        exit( -1);
      }
      if( receiveBuffer != NULL) {
        memcpy( newbuff, receiveBuffer, receiveBufferIn);
        free(receiveBuffer);
      }
      receiveBuffer = newbuff;
    }

    nread = read( evt->fd, receiveBuffer + receiveBufferIn, 1400);

    foundEOCR = 0;
    if( ls_pmac_state == LS_PMAC_STATE_GMR) {
      //
      // get memory returns binary stuff, don't try to parse it
      //
      receiveBufferIn += nread;
    } else {
      //
      // other commands end in 6 if OK, 7 if not
      //
      for( i=receiveBufferIn; i<receiveBufferIn+nread; i++) {
        if( receiveBuffer[i] == 7) {
          //
          // Error condition
          //
          lspmac_Error( &(receiveBuffer[i]));
          receiveBufferIn = 0;
          return;
        }
        if( receiveBuffer[i] == 6) {
          //
          // End of command response
          //
          foundEOCR = 1;
          receiveBuffer[i] = 0;
          break;
        }
      }
      receiveBufferIn = i;
    }

    cmd = NULL;

    switch( ls_pmac_state) {
    case LS_PMAC_STATE_WACK_NFR:
      receiveBuffer[--receiveBufferIn] = 0;
      cmd = lspmac_pop_reply();
      ls_pmac_state = LS_PMAC_STATE_IDLE;
      break;
    case LS_PMAC_STATE_WACK:
      receiveBuffer[--receiveBufferIn] = 0;
      ls_pmac_state = LS_PMAC_STATE_RR;
      break;
    case LS_PMAC_STATE_WACK_CC:
      receiveBuffer[--receiveBufferIn] = 0;
      ls_pmac_state = LS_PMAC_STATE_CR;
      break;
    case LS_PMAC_STATE_WACK_RR:
      receiveBufferIn -= 2;
      if( receiveBuffer[receiveBufferIn])
        ls_pmac_state = LS_PMAC_STATE_GB;
      else
        ls_pmac_state = LS_PMAC_STATE_RR;
      receiveBuffer[receiveBufferIn] = 0;
      break;
    case LS_PMAC_STATE_GMR:
      cmd = lspmac_pop_reply();
      ls_pmac_state = LS_PMAC_STATE_IDLE;
      break;

    case LS_PMAC_STATE_WCR:
      cmd = lspmac_pop_reply();
      ls_pmac_state = LS_PMAC_STATE_IDLE;
      break;
    case LS_PMAC_STATE_WGB:
      if( foundEOCR) {
        cmd = lspmac_pop_reply();
        ls_pmac_state = LS_PMAC_STATE_IDLE;
      } else {
        ls_pmac_state = LS_PMAC_STATE_RR;
      }
      break;
    }


    if( cmd != NULL && cmd->onResponse != NULL) {
      cmd->onResponse( cmd, receiveBufferIn, receiveBuffer);
      receiveBufferIn = 0;
    }
  }
}
.fi
.SS "void lspmac_shutter_read (\fBlspmac_motor_t\fP *mp)"

.PP
Fast shutter read routine The shutter is mildly complicated in that we need to take into account the fact that the shutter can open and close again between status updates\&. This means that we need to rely on a PCL program running in the PMAC to monitor the shutter state and let us know that this has happened\&. \fBParameters:\fP
.RS 4
\fImp\fP The motor object associated with the fast shutter 
.RE
.PP

.PP
Definition at line 1074 of file lspmac\&.c\&.
.PP
.nf
                           {
  //
  // track the shutter state and signal if it has changed
  //
  pthread_mutex_lock( &lspmac_shutter_mutex);
  if( md2_status\&.fs_has_opened && !lspmac_shutter_has_opened && !md2_status\&.fs_is_open) {
    //
    // Here the shutter opened and closed again before we got the memo
    // Treat it as a shutter closed event
    //
    pthread_cond_signal( &lspmac_shutter_cond);
  }
  lspmac_shutter_has_opened = md2_status\&.fs_has_opened;

  if( lspmac_shutter_state !=  md2_status\&.fs_is_open) {
    lspmac_shutter_state = md2_status\&.fs_is_open;
    pthread_cond_signal( &lspmac_shutter_cond);
  }

  if( md2_status\&.fs_is_open) {
    mvwprintw( term_status2, 1, 1, 'Shutter Open  ');
    mp->position = 1;
  } else {
    mvwprintw( term_status2, 1, 1, 'Shutter Closed');
    mp->position = 0;
  }

  // Not sure what kind of status makes sense to report
  mp->statuss[0] = 0;

  pthread_mutex_unlock( &lspmac_shutter_mutex);
}
.fi
.SS "void lspmac_SockFlush ()"

.PP
Reset the PMAC socket from the PMAC side\&. Puts the PMAC into a known communications state 
.PP
Definition at line 646 of file lspmac\&.c\&.
.PP
.nf
                        {
  lspmac_send_command( VR_DOWNLOAD, VR_PMAC_FLUSH, 0, 0, 0, NULL, NULL, 1);
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_SockGetmem (intoffset, intnbytes)"

.PP
Request a chunk of memory to be returned\&. Not currently used \fBParameters:\fP
.RS 4
\fIoffset\fP Offset in PMAC Double Buffer 
.br
\fInbytes\fP Number of bytes to request 
.RE
.PP

.PP
Definition at line 952 of file lspmac\&.c\&.
.PP
.nf
                                       {
  return lspmac_send_command( VR_UPLOAD,   VR_PMAC_GETMEM, offset, 0, nbytes, NULL, lspmac_GetmemReplyCB, 0);
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_SockSendControlCharPrint (charc)"

.PP
Send a control character\&. \fBParameters:\fP
.RS 4
\fIc\fP The control character to send 
.RE
.PP

.PP
Definition at line 1000 of file lspmac\&.c\&.
.PP
.nf
                                                    {
  return lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDCTRLCHAR, c, 0, 0, NULL, lspmac_SendControlReplyPrintCB, 0);
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_SockSendline (char *fmt, \&.\&.\&.)"

.PP
Send a one line command\&. Uses printf style arguments\&. \fBParameters:\fP
.RS 4
\fIfmt\fP Printf style format string 
.RE
.PP

.PP
Definition at line 962 of file lspmac\&.c\&.
.PP
.nf
                                         {
  va_list arg_ptr;
  char payload[1400];

  va_start( arg_ptr, fmt);
  vsnprintf( payload, sizeof(payload)-1, fmt, arg_ptr);
  payload[ sizeof(payload)-1] = 0;
  va_end( arg_ptr);

  lslogging_log_message( payload);

  return lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDLINE, 0, 0, strlen( payload), payload, lspmac_GetShortReplyCB, 0);
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_SockSendline_nr (char *fmt, \&.\&.\&.)"

.PP
Send a command and ignore the response\&. \fBParameters:\fP
.RS 4
\fIfmt\fP Printf style format string 
.RE
.PP

.PP
Definition at line 981 of file lspmac\&.c\&.
.PP
.nf
                                           {
  va_list arg_ptr;
  char s[512];

  va_start( arg_ptr, fmt);
  vsnprintf( s, sizeof(s)-1, fmt, arg_ptr);
  s[sizeof(s)-1] = 0;
  va_end( arg_ptr);

  lslogging_log_message( s);

  return lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDLINE, 0, 0, strlen( s), s, NULL, 1);
}
.fi
.SS "\fBlspmac_motor_t\fP* lspmac_soft_motor_init (\fBlspmac_motor_t\fP *d, char *name, void(*)(\fBlspmac_motor_t\fP *, double)moveAbs)"

.PP
Definition at line 2501 of file lspmac\&.c\&.
.PP
.nf
                                                                                                                  {

  _lspmac_motor_init( d, name);

  d->moveAbs      = moveAbs;
  d->read         = lspmac_soft_motor_read;
  d->actual_pos_cnts_p = calloc( sizeof(int), 1);
  *d->actual_pos_cnts_p = 0;
}
.fi
.SS "void lspmac_soft_motor_read (\fBlspmac_motor_t\fP *p)"

.PP
Dummy routine to read a soft motor\&. 
.PP
Definition at line 2496 of file lspmac\&.c\&.
.PP
.nf
                                                {

}
.fi
.SS "void lspmac_video_rotate (doublesecs)"

.PP
Special motion program to collect centering video\&. 
.PP
Definition at line 2114 of file lspmac\&.c\&.
.PP
.nf
                                       {
  double q10;           // starting position (counts)
  double q11;           // delta counts
  double q12;           // milliseconds to run over delta
  
  double u2c;

  if( secs <= 0\&.0)
    return;

  omega_zero_search = 1;

  pthread_mutex_lock( &(omega->mutex));
  u2c = lsredis_getd( omega->u2c);

  q10 = 0;
  q11 = 360\&.0 * u2c;
  q12 = 1000 * secs;
  

  omega_zero_velocity = 360\&.0 * u2c / secs;      // counts/second to back calculate zero crossing time

  omega->pq = lspmac_SockSendline_nr( '&1 Q10=%\&.1f Q11=%\&.1f Q12=%\&.1f Q13=(I117) Q14=(I116) B240R', q10, q11, q12);
  pthread_mutex_unlock( &(omega->mutex));
}
.fi
.SS "void* lspmac_worker (void *dummy)"

.PP
Our lspmac worker thread\&. \fBParameters:\fP
.RS 4
\fIdummy\fP Unused but required by pthread library 
.RE
.PP

.PP
Definition at line 1824 of file lspmac\&.c\&.
.PP
.nf
                      {

  while( 1) {
    int pollrtn;

    lspmac_next_state();

    if( pmacfd\&.fd == -1) {
      sleep( 10);       // The pmac is not connected\&.  Should we warn someone?
      //
      // This just puts us into a holding pattern until the pmac becomes connected again
      //
      // TODO:
      // Check PMAC initialization logic and our queues to ensure that it is sane to
      // re-initialize things\&.  Probably bad things will happen\&.
      //
      continue;
    }

    pollrtn = poll( &pmacfd, 1, 10);
    if( pollrtn) {
      lspmac_Service( &pmacfd);
    }
  }
}
.fi
.SH "Variable Documentation"
.PP 
.SS "\fBlspmac_motor_t\fP* alignx"

.PP
Alignment stage X\&. 
.PP
Definition at line 83 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* aligny"

.PP
Alignment stage Y\&. 
.PP
Definition at line 84 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* alignz"

.PP
Alignment stage X\&. 
.PP
Definition at line 85 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* anal"

.PP
Polaroid analyzer motor\&. 
.PP
Definition at line 86 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* apery"

.PP
Aperture Y\&. 
.PP
Definition at line 88 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* aperz"

.PP
Aperture Z\&. 
.PP
Definition at line 89 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* blight"

.PP
Back Light DAC\&. 
.PP
Definition at line 100 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* blight_f"

.PP
Back light scale factor\&. 
.PP
Definition at line 105 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* blight_ud"

.PP
Back light Up/Down actuator\&. 
.PP
Definition at line 103 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* capy"

.PP
Capillary Y\&. 
.PP
Definition at line 90 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* capz"

.PP
Capillary Z\&. 
.PP
Definition at line 91 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* cenx"

.PP
Centering Table X\&. 
.PP
Definition at line 93 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* ceny"

.PP
Centering Table Y\&. 
.PP
Definition at line 94 of file lspmac\&.c\&.
.SS "\fBpmac_cmd_t\fP cr_cmd\fC [static]\fP"

.PP
commands to send out 'readready', 'getbuffer', controlresponse (initialized in main) 
.PP
Definition at line 159 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* cryo"

.PP
Move the cryostream towards or away from the crystal\&. 
.PP
Definition at line 107 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* cryo_switch"

.PP
that little toggle switch for the cryo 
.PP
Definition at line 111 of file lspmac\&.c\&.
.SS "unsigned char dbmem[64 *1024]\fC [static]\fP"

.PP
double buffered memory 
.PP
Definition at line 149 of file lspmac\&.c\&.
.SS "int dbmemIn = 0\fC [static]\fP"

.PP
next location 
.PP
Definition at line 150 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* dryer"

.PP
blow air on the scintilator to dry it off 
.PP
Definition at line 108 of file lspmac\&.c\&.
.SS "unsigned int ethCmdOff = 0\fC [static]\fP"

.PP
points to current command (or none if == ethCmdOn) 
.PP
Definition at line 162 of file lspmac\&.c\&.
.SS "unsigned int ethCmdOn = 0\fC [static]\fP"

.PP
points to next empty PMAC command queue position 
.PP
Definition at line 161 of file lspmac\&.c\&.
.SS "\fBpmac_cmd_queue_t\fP ethCmdQueue[\fBPMAC_CMD_QUEUE_LENGTH\fP]\fC [static]\fP"

.PP
PMAC command queue\&. 
.PP
Definition at line 160 of file lspmac\&.c\&.
.SS "unsigned int ethCmdReply = 0\fC [static]\fP"

.PP
Used like ethCmdOff only to deal with the pmac reply to a command\&. 
.PP
Definition at line 163 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* flight"

.PP
Front Light DAC\&. 
.PP
Definition at line 99 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* flight_f"

.PP
Front light scale factor\&. 
.PP
Definition at line 106 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* flight_oo"

.PP
Turn front light on/off\&. 
.PP
Definition at line 104 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* fluo"

.PP
Move the fluorescence detector in/out\&. 
.PP
Definition at line 109 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* fscint"

.PP
Scintillator Piezo DAC\&. 
.PP
Definition at line 101 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* fshut"

.PP
Fast shutter\&. 
.PP
Definition at line 98 of file lspmac\&.c\&.
.SS "\fBpmac_cmd_t\fP gb_cmd\fC [static]\fP"

.PP
Definition at line 159 of file lspmac\&.c\&.
.SS "int getivars = 0\fC [static]\fP"

.PP
flag set at initialization to send i vars to db 
.PP
Definition at line 74 of file lspmac\&.c\&.
.SS "int getmvars = 0\fC [static]\fP"

.PP
flag set at initialization to send m vars to db 
.PP
Definition at line 75 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* kappa"

.PP
Kappa\&. 
.PP
Definition at line 95 of file lspmac\&.c\&.
.SS "int linesReceived =0\fC [static]\fP"

.PP
current number of lines received 
.PP
Definition at line 148 of file lspmac\&.c\&.
.SS "int ls_pmac_state = \fBLS_PMAC_STATE_DETACHED\fP\fC [static]\fP"

.PP
Current state of the PMAC communications state machine\&. 
.PP
Definition at line 51 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP lspmac_bis[16]"

.PP
array of binary inputs 
.PP
Definition at line 77 of file lspmac\&.c\&.
.SS "\fBlsredis_obj_t\fP* lspmac_md2_init\fC [static]\fP"

.PP
Definition at line 53 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP lspmac_motors[48]"

.PP
All our motors\&. 
.PP
Definition at line 80 of file lspmac\&.c\&.
.SS "pthread_cond_t lspmac_moving_cond"

.PP
Wait for motor(s) to finish moving condition\&. 
.PP
Definition at line 60 of file lspmac\&.c\&.
.SS "int lspmac_moving_flags"

.PP
Flag used to implement motor moving condition\&. 
.PP
Definition at line 61 of file lspmac\&.c\&.
.SS "pthread_mutex_t lspmac_moving_mutex"

.PP
Coordinate moving motors between threads\&. 
.PP
Definition at line 59 of file lspmac\&.c\&.
.SS "int lspmac_nbis = 0"

.PP
number of active binary inputs 
.PP
Definition at line 78 of file lspmac\&.c\&.
.SS "int lspmac_nmotors = 0"

.PP
The number of motors we manage\&. 
.PP
Definition at line 81 of file lspmac\&.c\&.
.SS "pthread_cond_t lspmac_shutter_cond"

.PP
Allows waiting for the shutter status to change\&. 
.PP
Definition at line 58 of file lspmac\&.c\&.
.SS "int lspmac_shutter_has_opened"

.PP
Indicates that the shutter had opened, perhaps briefly even if the state did not change\&. 
.PP
Definition at line 56 of file lspmac\&.c\&.
.SS "pthread_mutex_t lspmac_shutter_mutex"

.PP
Coordinates threads reading shutter status\&. 
.PP
Definition at line 57 of file lspmac\&.c\&.
.SS "int lspmac_shutter_state"

.PP
State of the shutter, used to detect changes\&. 
.PP
Definition at line 55 of file lspmac\&.c\&.
.SS "struct timespec lspmac_status_last_time\fC [static]\fP"

.PP
Time the status was read\&. 
.PP
Definition at line 67 of file lspmac\&.c\&.
.SS "struct timespec lspmac_status_time\fC [static]\fP"

.PP
Time the status was read\&. 
.PP
Definition at line 66 of file lspmac\&.c\&.
.SS "\fBmd2_status_t\fP md2_status\fC [static]\fP"

.PP
Buffer for MD2 Status\&. 
.PP
Definition at line 297 of file lspmac\&.c\&.
.SS "pthread_mutex_t md2_status_mutex"

.PP
Synchronize reading/writting status buffer\&. 
.PP
Definition at line 298 of file lspmac\&.c\&.
.SS "struct timeval pmac_time_sent now\fC [static]\fP"

.PP
used to ensure we do not send commands to the pmac too often\&. Only needed for non-DB commands\&. 
.PP
Definition at line 155 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* omega"

.PP
MD2 omega axis (the air bearing) 
.PP
Definition at line 82 of file lspmac\&.c\&.
.SS "int omega_zero_search = 0\fC [static]\fP"

.PP
Indicate we'd really like to know when omega crosses zero\&. 
.PP
Definition at line 63 of file lspmac\&.c\&.
.SS "struct timespec omega_zero_time"

.PP
Time we believe that omega crossed zero\&. 
.PP
Definition at line 65 of file lspmac\&.c\&.
.SS "double omega_zero_velocity = 0\fC [static]\fP"

.PP
rate (cnts/sec) that omega was traveling when it crossed zero 
.PP
Definition at line 64 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* phi"

.PP
Phi (not data collection axis) 
.PP
Definition at line 96 of file lspmac\&.c\&.
.SS "char* pmac_error_strs[]\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
  'ERR000: Unknown error',
  'ERR001: Command not allowed during program execution',
  'ERR002: Password error',
  'ERR003: Data error or unrecognized command',
  'ERR004: Illegal character',
  'ERR005: Command not allowed unless buffer is open',
  'ERR006: No room in buffer for command',
  'ERR007: Buffer already in use',
  'ERR008: MACRO auziliary communication error',
  'ERR009: Program structure error (e\&.g\&. ENDIF without IF)',
  'ERR010: Both overtravel limits set for a motor in the C\&.S\&.',
  'ERR011: Previous move not completed',
  'ERR012: A motor in the coordinate system is open-loop',
  'ERR013: A motor in the coordinate system is not activated',
  'ERR014: No motors in the coordinate system',
  'ERR015: Not pointer to valid program buffer',
  'ERR016: Running improperly structure program (e\&.g\&. missing ENDWHILE)',
  'ERR017: Trying to resume after H or Q with motors out of stopped position',
  'ERR018: Attempt to perform phase reference during move, move during phase reference, or enabling with phase clock error',
  'ERR019: Illegal position-chage command while moves stored in CCBUFFER'
}
.fi
.PP
Decode the errors perhaps returned by the PMAC\&. 
.PP
Definition at line 166 of file lspmac\&.c\&.
.SS "pthread_cond_t pmac_queue_cond"

.PP
wait for a command to be sent to PMAC before continuing 
.PP
Definition at line 71 of file lspmac\&.c\&.
.SS "pthread_mutex_t pmac_queue_mutex"

.PP
manage access to the pmac command queue 
.PP
Definition at line 70 of file lspmac\&.c\&.
.SS "pthread_t pmac_thread\fC [static]\fP"

.PP
our thread to manage access and communication to the pmac 
.PP
Definition at line 69 of file lspmac\&.c\&.
.SS "struct pollfd pmacfd\fC [static]\fP"

.PP
our poll structure 
.PP
Definition at line 72 of file lspmac\&.c\&.
.SS "\fBpmac_cmd_t\fP rr_cmd\fC [static]\fP"

.PP
Definition at line 159 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* scint"

.PP
Scintillator Z\&. 
.PP
Definition at line 92 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* zoom"

.PP
Optical zoom\&. 
.PP
Definition at line 87 of file lspmac\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for LS-CAT PGPMAC from the source code\&.
