.TH "lslogging.c" 3 "Sun Feb 17 2013" "LS-CAT PGPMAC" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lslogging.c \- 
.PP
Logs messages to a file\&.  

.SH SYNOPSIS
.br
.PP
\fC#include 'pgpmac\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBlslogging_queue_struct\fP"
.br
.RI "\fIOur log object: time and message\&. \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBLSLOGGING_FILE_NAME\fP   '/tmp/pgpmac\&.log'"
.br
.RI "\fIFull name of the log file\&. \fP"
.ti -1c
.RI "#define \fBLSLOGGING_MSG_LENGTH\fP   2048"
.br
.RI "\fIFixed maximum length messages to keep some form of sanity\&. \fP"
.ti -1c
.RI "#define \fBLSLOGGING_QUEUE_LENGTH\fP   8192"
.br
.RI "\fIModest length queue\&. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct 
.br
\fBlslogging_queue_struct\fP \fBlslogging_queue_t\fP"
.br
.RI "\fIOur log object: time and message\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBlslogging_init\fP ()"
.br
.RI "\fIInitialize the lslogging objects\&. \fP"
.ti -1c
.RI "void \fBlslogging_log_message\fP (char *fmt,\&.\&.\&.)"
.br
.RI "\fIThe routine everyone will be talking about\&. \fP"
.ti -1c
.RI "void \fBlslogging_event_cb\fP (char *event)"
.br
.RI "\fILog most events\&. \fP"
.ti -1c
.RI "void * \fBlslogging_worker\fP (void *dummy)"
.br
.RI "\fIService the queue, write to the file\&. \fP"
.ti -1c
.RI "void \fBlslogging_run\fP ()"
.br
.RI "\fIStart up the worker thread\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static pthread_t \fBlslogging_thread\fP"
.br
.RI "\fIour thread \fP"
.ti -1c
.RI "static pthread_mutex_t \fBlslogging_mutex\fP"
.br
.RI "\fImutex to keep the various threads from adding to the queue at the exact same time \fP"
.ti -1c
.RI "static pthread_cond_t \fBlslogging_cond\fP"
.br
.RI "\fIWe'll spend most of our time waiting for this condition's signal\&. \fP"
.ti -1c
.RI "static FILE * \fBlslogging_file\fP"
.br
.RI "\fIour log file object \fP"
.ti -1c
.RI "static \fBlslogging_queue_t\fP \fBlslogging_queue\fP [\fBLSLOGGING_QUEUE_LENGTH\fP]"
.br
.RI "\fIOur entire queue\&. Right here\&. Every message we'll ever write\&. \fP"
.ti -1c
.RI "static unsigned int \fBlslogging_on\fP = 0"
.br
.RI "\fInext location to add to the queue \fP"
.ti -1c
.RI "static unsigned int \fBlslogging_off\fP = 0"
.br
.RI "\fInext location to remove from the queue \fP"
.in -1c
.SH "Detailed Description"
.PP 
Logs messages to a file\&. 

\fBDate:\fP
.RS 4
2012 
.RE
.PP
\fBAuthor:\fP
.RS 4
Keith Brister 
.RE
.PP
\fBCopyright:\fP
.RS 4
All Rights Reserved 
.RE
.PP

.PP
Definition in file \fBlslogging\&.c\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define LSLOGGING_FILE_NAME   '/tmp/pgpmac\&.log'"

.PP
Full name of the log file\&. Probably should be in /var/log/pgpmac\&. 
.PP
Definition at line 16 of file lslogging\&.c\&.
.SS "#define LSLOGGING_MSG_LENGTH   2048"

.PP
Fixed maximum length messages to keep some form of sanity\&. 
.PP
Definition at line 20 of file lslogging\&.c\&.
.SS "#define LSLOGGING_QUEUE_LENGTH   8192"

.PP
Modest length queue\&. 
.PP
Definition at line 30 of file lslogging\&.c\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBlslogging_queue_struct\fP  \fBlslogging_queue_t\fP"

.PP
Our log object: time and message\&. 
.SH "Function Documentation"
.PP 
.SS "void lslogging_event_cb (char *event)"

.PP
Log most events\&. 
.PP
Definition at line 76 of file lslogging\&.c\&.
.PP
.nf
                                      {
  if( strcmp( event, 'Timer Update KVs') != 0 && strstr( event, 'accepted')==NULL && strstr( event, 'queued')==NULL) {
    lslogging_log_message( 'EVENT: %s', event);
  }
}
.fi
.SS "void lslogging_init ()"

.PP
Initialize the lslogging objects\&. 
.PP
Definition at line 37 of file lslogging\&.c\&.
.PP
.nf
                      {
  pthread_mutex_init( &lslogging_mutex, NULL);
  pthread_cond_init(  &lslogging_cond, NULL);

  lslogging_file = fopen( LSLOGGING_FILE_NAME, 'w');
}
.fi
.SS "void lslogging_log_message (char *fmt, \&.\&.\&.)"

.PP
The routine everyone will be talking about\&. \fBParameters:\fP
.RS 4
\fIfmt\fP A printf style formating string\&. 
.br
\fI\&.\&.\&.\fP The arguments specified by fmt 
.RE
.PP

.PP
Definition at line 48 of file lslogging\&.c\&.
.PP
.nf
                                            {
  char msg[LSLOGGING_MSG_LENGTH];
  struct timespec theTime;
  va_list arg_ptr;
  unsigned int on;

  clock_gettime( CLOCK_REALTIME, &theTime);

  va_start( arg_ptr, fmt);
  vsnprintf( msg, sizeof(msg)-1, fmt, arg_ptr);
  va_end( arg_ptr);
  msg[sizeof(msg)-1]=0;

  pthread_mutex_lock( &lslogging_mutex);
  
  on = (lslogging_on++) % LSLOGGING_QUEUE_LENGTH;
  strncpy( lslogging_queue[on]\&.lmsg, msg, LSLOGGING_MSG_LENGTH - 1);
  lslogging_queue[on]\&.lmsg[LSLOGGING_MSG_LENGTH-1] = 0;
  
  memcpy( &(lslogging_queue[on]\&.ltime), &theTime, sizeof(theTime));

  pthread_cond_signal(  &lslogging_cond);
  pthread_mutex_unlock( &lslogging_mutex);
  
}
.fi
.SS "void lslogging_run ()"

.PP
Start up the worker thread\&. 
.PP
Definition at line 116 of file lslogging\&.c\&.
.PP
.nf
                     {
  pthread_create( &lslogging_thread, NULL, &lslogging_worker, NULL);
  lslogging_log_message( 'Start up');
  lsevents_add_listener( '\&.+', lslogging_event_cb);
}
.fi
.SS "void* lslogging_worker (void *dummy)"

.PP
Service the queue, write to the file\&. \fBParameters:\fP
.RS 4
\fIdummy\fP Required by protocol but unused 
.RE
.PP

.PP
Definition at line 85 of file lslogging\&.c\&.
.PP
.nf
                        {


  struct tm coarsetime;
  char tstr[64];
  unsigned int msecs;
  unsigned int off;

  pthread_mutex_lock( &lslogging_mutex);

  while( 1) {
    while( lslogging_on == lslogging_off) {
      pthread_cond_wait( &lslogging_cond, &lslogging_mutex);
    }
    
    off = (lslogging_off++) % LSLOGGING_QUEUE_LENGTH;
    localtime_r( &(lslogging_queue[off]\&.ltime\&.tv_sec), &coarsetime);
    strftime( tstr, sizeof(tstr)-1, '%Y-%m-%d %H:%M:%S', &coarsetime);
    tstr[sizeof(tstr)-1] = 0;
    msecs = lslogging_queue[off]\&.ltime\&.tv_nsec / 1000;
    fprintf( lslogging_file, '%s\&.%\&.06u  %s\n', tstr, msecs, lslogging_queue[off]\&.lmsg);
    fflush( lslogging_file);

    pgpmac_printf( '%s\n', lslogging_queue[off]\&.lmsg);
  }
}
.fi
.SH "Variable Documentation"
.PP 
.SS "pthread_cond_t lslogging_cond\fC [static]\fP"

.PP
We'll spend most of our time waiting for this condition's signal\&. 
.PP
Definition at line 12 of file lslogging\&.c\&.
.SS "FILE* lslogging_file\fC [static]\fP"

.PP
our log file object 
.PP
Definition at line 17 of file lslogging\&.c\&.
.SS "pthread_mutex_t lslogging_mutex\fC [static]\fP"

.PP
mutex to keep the various threads from adding to the queue at the exact same time 
.PP
Definition at line 11 of file lslogging\&.c\&.
.SS "unsigned int lslogging_off = 0\fC [static]\fP"

.PP
next location to remove from the queue 
.PP
Definition at line 34 of file lslogging\&.c\&.
.SS "unsigned int lslogging_on = 0\fC [static]\fP"

.PP
next location to add to the queue 
.PP
Definition at line 33 of file lslogging\&.c\&.
.SS "\fBlslogging_queue_t\fP lslogging_queue[\fBLSLOGGING_QUEUE_LENGTH\fP]\fC [static]\fP"

.PP
Our entire queue\&. Right here\&. Every message we'll ever write\&. 
.PP
Definition at line 31 of file lslogging\&.c\&.
.SS "pthread_t lslogging_thread\fC [static]\fP"

.PP
our thread 
.PP
Definition at line 10 of file lslogging\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for LS-CAT PGPMAC from the source code\&.
