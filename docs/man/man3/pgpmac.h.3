.TH "pgpmac.h" 3 "Tue Jan 29 2013" "LS-CAT PGPMAC" \" -*- nroff -*-
.ad l
.nh
.SH NAME
pgpmac.h \- 
.PP
Headers for the entire pgpmac project\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <stdint\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include <sys/socket\&.h>\fP
.br
\fC#include <netdb\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <netinet/in\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br
\fC#include <poll\&.h>\fP
.br
\fC#include <libpq-fe\&.h>\fP
.br
\fC#include <ncurses\&.h>\fP
.br
\fC#include <math\&.h>\fP
.br
\fC#include <pthread\&.h>\fP
.br
\fC#include <signal\&.h>\fP
.br
\fC#include <sys/signalfd\&.h>\fP
.br
\fC#include <sys/time\&.h>\fP
.br
\fC#include <time\&.h>\fP
.br
\fC#include <getopt\&.h>\fP
.br
\fC#include <regex\&.h>\fP
.br
\fC#include <hiredis/hiredis\&.h>\fP
.br
\fC#include <hiredis/async\&.h>\fP
.br
\fC#include <search\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBlsredis_obj_struct\fP"
.br
.RI "\fIRedis Object Basic object whose value is sychronized with our redis db\&. \fP"
.ti -1c
.RI "struct \fBtagEthernetCmd\fP"
.br
.RI "\fIPMAC ethernet packet definition\&. \fP"
.ti -1c
.RI "struct \fBlspmac_cmd_queue_struct\fP"
.br
.RI "\fIPMAC command queue item\&. \fP"
.ti -1c
.RI "struct \fBlspmac_motor_struct\fP"
.br
.RI "\fIMotor information\&. \fP"
.ti -1c
.RI "struct \fBlspmac_bi_struct\fP"
.br
.RI "\fIStorage for binary inputs\&. \fP"
.ti -1c
.RI "struct \fBlspgQueryQueueStruct\fP"
.br
.RI "\fIStore each query along with it's callback function\&. \fP"
.ti -1c
.RI "struct \fBlspg_waitcryo_struct\fP"
.br
.ti -1c
.RI "struct \fBlspg_getcurrentsampleid_struct\fP"
.br
.ti -1c
.RI "struct \fBlspg_demandairrights_struct\fP"
.br
.ti -1c
.RI "struct \fBlspg_getcenter_struct\fP"
.br
.RI "\fIStorage for getcenter query Used for the md2 ROTATE command that generates the centering movies\&. \fP"
.ti -1c
.RI "struct \fBlspg_starttransfer_struct\fP"
.br
.RI "\fIreturns 1 if transfer can continue 0 to abort \fP"
.ti -1c
.RI "struct \fBlspg_nextsample_struct\fP"
.br
.RI "\fIReturns the next sample number Just a 32 bit int (Ha!, take that, nextshot!) \fP"
.ti -1c
.RI "struct \fBlspg_nextshot_struct\fP"
.br
.RI "\fIStorage definition for nextshot query\&. \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fB_GNU_SOURCE\fP"
.br
.ti -1c
.RI "#define \fBLS_DISPLAY_WINDOW_HEIGHT\fP   8"
.br
.RI "\fINumber of status box rows\&. \fP"
.ti -1c
.RI "#define \fBLS_DISPLAY_WINDOW_WIDTH\fP   24"
.br
.RI "\fINumber of status box columns\&. \fP"
.ti -1c
.RI "#define \fBLS_PG_QUERY_STRING_LENGTH\fP   1024"
.br
.RI "\fIFixed length postgresql query strings\&. Queries should all be function calls so this is not as weird as one might think\&. \fP"
.ti -1c
.RI "#define \fBLSEVENTS_EVENT_LENGTH\fP   256"
.br
.RI "\fIFixed length for event names: simplifies string handling\&. \fP"
.ti -1c
.RI "#define \fBMD2CMDS_CMD_LENGTH\fP   32"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBlsredis_obj_struct\fP \fBlsredis_obj_t\fP"
.br
.RI "\fIRedis Object Basic object whose value is sychronized with our redis db\&. \fP"
.ti -1c
.RI "typedef struct \fBtagEthernetCmd\fP \fBpmac_cmd_t\fP"
.br
.RI "\fIPMAC ethernet packet definition\&. \fP"
.ti -1c
.RI "typedef struct 
.br
\fBlspmac_cmd_queue_struct\fP \fBpmac_cmd_queue_t\fP"
.br
.RI "\fIPMAC command queue item\&. \fP"
.ti -1c
.RI "typedef struct \fBlspmac_motor_struct\fP \fBlspmac_motor_t\fP"
.br
.RI "\fIMotor information\&. \fP"
.ti -1c
.RI "typedef struct \fBlspmac_bi_struct\fP \fBlspmac_bi_t\fP"
.br
.RI "\fIStorage for binary inputs\&. \fP"
.ti -1c
.RI "typedef struct \fBlspgQueryQueueStruct\fP \fBlspg_query_queue_t\fP"
.br
.RI "\fIStore each query along with it's callback function\&. \fP"
.ti -1c
.RI "typedef struct \fBlspg_waitcryo_struct\fP \fBlspg_waitcryo_t\fP"
.br
.ti -1c
.RI "typedef struct 
.br
\fBlspg_getcurrentsampleid_struct\fP \fBlspg_getcurrentsampleid_t\fP"
.br
.ti -1c
.RI "typedef struct 
.br
\fBlspg_demandairrights_struct\fP \fBlspg_demandairrights_t\fP"
.br
.ti -1c
.RI "typedef struct 
.br
\fBlspg_getcenter_struct\fP \fBlspg_getcenter_t\fP"
.br
.RI "\fIStorage for getcenter query Used for the md2 ROTATE command that generates the centering movies\&. \fP"
.ti -1c
.RI "typedef struct 
.br
\fBlspg_starttransfer_struct\fP \fBlspg_starttransfer_t\fP"
.br
.RI "\fIreturns 1 if transfer can continue 0 to abort \fP"
.ti -1c
.RI "typedef struct 
.br
\fBlspg_nextsample_struct\fP \fBlspg_nextsample_t\fP"
.br
.RI "\fIReturns the next sample number Just a 32 bit int (Ha!, take that, nextshot!) \fP"
.ti -1c
.RI "typedef struct \fBlspg_nextshot_struct\fP \fBlspg_nextshot_t\fP"
.br
.RI "\fIStorage definition for nextshot query\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "double \fBlspmac_getPosition\fP (\fBlspmac_motor_t\fP *)"
.br
.RI "\fIget the motor position (with locking) \fP"
.ti -1c
.RI "char ** \fBlspg_array2ptrs\fP (char *)"
.br
.RI "\fIreturns a null terminated list of strings parsed from postgresql array \fP"
.ti -1c
.RI "char ** \fBlsredis_get_string_array\fP (\fBlsredis_obj_t\fP *p)"
.br
.ti -1c
.RI "void \fBlspmac_SockSendDPline\fP (char *, char *fmt,\&.\&.\&.)"
.br
.RI "\fIprepare (queue up) a line to send the dpram ascii command interface \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_SockSendline\fP (char *, char *,\&.\&.\&.)"
.br
.RI "\fISend a one line command\&. \fP"
.ti -1c
.RI "\fBlsredis_obj_t\fP * \fBlsredis_get_obj\fP (char *,\&.\&.\&.)"
.br
.ti -1c
.RI "char * \fBlsredis_getstr\fP (\fBlsredis_obj_t\fP *p)"
.br
.RI "\fIreturn a copy of the key's string value \fP"
.ti -1c
.RI "void \fBPmacSockSendline\fP (char *s)"
.br
.ti -1c
.RI "unsigned int \fBlspg_nextsample_all\fP (int *err)"
.br
.ti -1c
.RI "char \fBlsredis_getc\fP (\fBlsredis_obj_t\fP *p)"
.br
.ti -1c
.RI "long int \fBlsredis_getl\fP (\fBlsredis_obj_t\fP *p)"
.br
.ti -1c
.RI "void \fBlsevents_add_listener\fP (char *, void(*cb)(char *))"
.br
.RI "\fIAdd a callback routine to listen for a specific event\&. \fP"
.ti -1c
.RI "void \fBlsevents_init\fP ()"
.br
.RI "\fIInitialize this module\&. \fP"
.ti -1c
.RI "void \fBlsevents_remove_listener\fP (char *, void(*cb)(char *))"
.br
.RI "\fIRemove a listener previously added with lsevents_add_listener\&. \fP"
.ti -1c
.RI "void \fBlsevents_run\fP ()"
.br
.RI "\fIStart up the thread and get out of the way\&. \fP"
.ti -1c
.RI "void \fBlsevents_send_event\fP (char *,\&.\&.\&.)"
.br
.RI "\fICall the callback routines for the given event\&. \fP"
.ti -1c
.RI "void \fBlslogging_init\fP ()"
.br
.RI "\fIInitialize the lslogging objects\&. \fP"
.ti -1c
.RI "void \fBlslogging_log_message\fP (char *fmt,\&.\&.\&.)"
.br
.RI "\fIThe routine everyone will be talking about\&. \fP"
.ti -1c
.RI "void \fBlslogging_run\fP ()"
.br
.RI "\fIStart up the worker thread\&. \fP"
.ti -1c
.RI "void \fBlspg_demandairrights_all\fP ()"
.br
.RI "\fIdo nothing until we get airrights \fP"
.ti -1c
.RI "void \fBlspg_getcenter_call\fP ()"
.br
.RI "\fIRequest a getcenter query\&. \fP"
.ti -1c
.RI "void \fBlspg_getcenter_done\fP ()"
.br
.RI "\fIDone with getcenter query\&. \fP"
.ti -1c
.RI "void \fBlspg_getcenter_wait\fP ()"
.br
.RI "\fIWait for a getcenter query to return\&. \fP"
.ti -1c
.RI "void \fBlspg_getcurrentsampleid_wait_for_id\fP (unsigned int test)"
.br
.ti -1c
.RI "void \fBlspg_init\fP ()"
.br
.RI "\fIInitiallize the lspg module\&. \fP"
.ti -1c
.RI "void \fBlspg_nextshot_call\fP ()"
.br
.RI "\fIQueue up a nextshot query\&. \fP"
.ti -1c
.RI "void \fBlspg_nextshot_done\fP ()"
.br
.RI "\fICalled when the next shot query has been processed\&. \fP"
.ti -1c
.RI "void \fBlspg_nextshot_wait\fP ()"
.br
.RI "\fIWait for the next shot query to get processed\&. \fP"
.ti -1c
.RI "void \fBlspg_query_push\fP (void(*cb)(\fBlspg_query_queue_t\fP *, PGresult *), char *fmt,\&.\&.\&.)"
.br
.RI "\fIPlace a query on the queue\&. \fP"
.ti -1c
.RI "void \fBlspg_run\fP ()"
.br
.RI "\fIStart 'er runnin'\&. \fP"
.ti -1c
.RI "void \fBlspg_seq_run_prep_all\fP (long long skey, double \fBkappa\fP, double \fBphi\fP, double cx, double cy, double ax, double ay, double az)"
.br
.RI "\fIConvinence function to call seq run prep\&. \fP"
.ti -1c
.RI "void \fBlspg_starttransfer_call\fP (unsigned int nextsample, int \fBsample_detected\fP, double ax, double ay, double az, double horz, double vert, double esttime)"
.br
.ti -1c
.RI "void \fBlspg_starttransfer_done\fP ()"
.br
.ti -1c
.RI "void \fBlspg_starttransfer_wait\fP ()"
.br
.ti -1c
.RI "void \fBlspg_waitcryo_all\fP ()"
.br
.RI "\fIno need to get fancy with the wait cryo command It should not return until the robot is almost ready for air rights \fP"
.ti -1c
.RI "void \fBlspg_waitcryo_cb\fP (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"
.br
.ti -1c
.RI "void \fBlspg_zoom_lut_call\fP ()"
.br
.ti -1c
.RI "int \fBlspmac_getBIPosition\fP (\fBlspmac_bi_t\fP *)"
.br
.RI "\fIget binary input value \fP"
.ti -1c
.RI "void \fBlspmac_home1_queue\fP (\fBlspmac_motor_t\fP *mp)"
.br
.RI "\fIHome the motor\&. \fP"
.ti -1c
.RI "void \fBlspmac_abort\fP ()"
.br
.RI "\fIabort motion and try to recover \fP"
.ti -1c
.RI "void \fBlspmac_init\fP (int, int)"
.br
.RI "\fIInitialize this module\&. \fP"
.ti -1c
.RI "int \fBlspmac_jogabs_queue\fP (\fBlspmac_motor_t\fP *, double)"
.br
.RI "\fIUse jog to move motor to requested position\&. \fP"
.ti -1c
.RI "int \fBlspmac_move_or_jog_abs_queue\fP (\fBlspmac_motor_t\fP *mp, double requested_position, int use_jo)"
.br
.RI "\fIMove method for normal stepper and servo motor objects Returns non-zero on abort, zero if OK\&. \fP"
.ti -1c
.RI "int \fBlspmac_move_or_jog_preset_queue\fP (\fBlspmac_motor_t\fP *, char *, int)"
.br
.RI "\fImove using a preset value returns 0 on success, non-zero on error \fP"
.ti -1c
.RI "void \fBlspmac_move_or_jog_queue\fP (\fBlspmac_motor_t\fP *, double, int)"
.br
.ti -1c
.RI "int \fBlspmac_move_preset_queue\fP (\fBlspmac_motor_t\fP *mp, char *preset_name)"
.br
.RI "\fIMove a given motor to one of its preset positions\&. \fP"
.ti -1c
.RI "int \fBlspmac_moveabs_queue\fP (\fBlspmac_motor_t\fP *, double)"
.br
.RI "\fIUse coordinate system motion program, if available, to move motor to requested position\&. \fP"
.ti -1c
.RI "int \fBlspmac_moveabs_wait\fP (\fBlspmac_motor_t\fP *mp, double timeout)"
.br
.RI "\fIWait for motor to finish moving\&. \fP"
.ti -1c
.RI "void \fBlspmac_run\fP ()"
.br
.RI "\fIStart up the lspmac thread\&. \fP"
.ti -1c
.RI "void \fBlspmac_video_rotate\fP (double secs)"
.br
.RI "\fISpecial motion program to collect centering video\&. \fP"
.ti -1c
.RI "int \fBlsredis_cmpnstr\fP (\fBlsredis_obj_t\fP *p, char *s, int n)"
.br
.ti -1c
.RI "int \fBlsredis_cmpstr\fP (\fBlsredis_obj_t\fP *p, char *s)"
.br
.ti -1c
.RI "int \fBlsredis_find_preset\fP (char *base, char *preset_name, double *dval)"
.br
.ti -1c
.RI "int \fBlsredis_getb\fP (\fBlsredis_obj_t\fP *p)"
.br
.ti -1c
.RI "double \fBlsredis_getd\fP (\fBlsredis_obj_t\fP *p)"
.br
.ti -1c
.RI "void \fBlsredis_init\fP (char *pub, char *re, char *head)"
.br
.RI "\fIInitialize this module, that is, set up the connections\&. \fP"
.ti -1c
.RI "int \fBlsredis_regexec\fP (const regex_t *preg, \fBlsredis_obj_t\fP *p, size_t nmatch, regmatch_t *pmatch, int eflags)"
.br
.ti -1c
.RI "void \fBlsredis_run\fP ()"
.br
.ti -1c
.RI "void \fBlsredis_setstr\fP (\fBlsredis_obj_t\fP *p, char *fmt,\&.\&.\&.)"
.br
.RI "\fISet the value and update redis\&. \fP"
.ti -1c
.RI "void \fBlstimer_add_timer\fP (char *, int, unsigned long int, unsigned long int)"
.br
.RI "\fICreate a timer\&. \fP"
.ti -1c
.RI "void \fBlstimer_init\fP ()"
.br
.RI "\fIInitialize the timer list and pthread stuff\&. \fP"
.ti -1c
.RI "void \fBlstimer_run\fP ()"
.br
.RI "\fIStart up our thread\&. \fP"
.ti -1c
.RI "void \fBlsupdate_init\fP ()"
.br
.ti -1c
.RI "void \fBlsupdate_run\fP ()"
.br
.ti -1c
.RI "void \fBmd2cmds_init\fP ()"
.br
.RI "\fIInitialize the md2cmds module\&. \fP"
.ti -1c
.RI "void \fBmd2cmds_run\fP ()"
.br
.RI "\fIStart up the thread\&. \fP"
.ti -1c
.RI "void \fBpgpmac_printf\fP (char *fmt,\&.\&.\&.)"
.br
.RI "\fITerminal output routine ala printf\&. \fP"
.ti -1c
.RI "void \fBlstest_main\fP ()"
.br
.ti -1c
.RI "int \fBlspmac_est_move_time\fP (double *est_time, int *mmask, \fBlspmac_motor_t\fP *mp_1, int jog_1, char *preset_1, double end_point_1,\&.\&.\&.)"
.br
.RI "\fIMove the motors and estimate the time it'll take to finish the job\&. \fP"
.ti -1c
.RI "int \fBlspmac_est_move_time_wait\fP (double move_time, int mmask)"
.br
.RI "\fIwait for motion to stop returns non-zero if the wait timed out \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBlspg_waitcryo_t\fP \fBlspg_waitcryo\fP"
.br
.RI "\fIsignal the robot \fP"
.ti -1c
.RI "\fBlspg_getcurrentsampleid_t\fP \fBlspg_getcurrentsampleid\fP"
.br
.RI "\fIour currentsample id \fP"
.ti -1c
.RI "\fBlspg_demandairrights_t\fP \fBlspg_demandairrights\fP"
.br
.RI "\fIour demandairrights object \fP"
.ti -1c
.RI "\fBlspg_getcenter_t\fP \fBlspg_getcenter\fP"
.br
.RI "\fIthe getcenter object \fP"
.ti -1c
.RI "\fBlspg_starttransfer_t\fP \fBlspg_starttransfer\fP"
.br
.RI "\fIstart a sample transfer \fP"
.ti -1c
.RI "\fBlspg_nextsample_t\fP \fBlspg_nextsample\fP"
.br
.RI "\fIthe very next sample \fP"
.ti -1c
.RI "\fBlspg_nextshot_t\fP \fBlspg_nextshot\fP"
.br
.RI "\fIthe nextshot object \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP \fBlspmac_motors\fP []"
.br
.RI "\fIAll our motors\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBomega\fP"
.br
.RI "\fIMD2 omega axis (the air bearing) \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBalignx\fP"
.br
.RI "\fIAlignment stage X\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBaligny\fP"
.br
.RI "\fIAlignment stage Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBalignz\fP"
.br
.RI "\fIAlignment stage X\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBanal\fP"
.br
.RI "\fIPolaroid analyzer motor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBzoom\fP"
.br
.RI "\fIOptical zoom\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBapery\fP"
.br
.RI "\fIAperture Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBaperz\fP"
.br
.RI "\fIAperture Z\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcapy\fP"
.br
.RI "\fICapillary Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcapz\fP"
.br
.RI "\fICapillary Z\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBscint\fP"
.br
.RI "\fIScintillator Z\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcenx\fP"
.br
.RI "\fICentering Table X\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBceny\fP"
.br
.RI "\fICentering Table Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBkappa\fP"
.br
.RI "\fIKappa\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBphi\fP"
.br
.RI "\fIPhi (not data collection axis) \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBfshut\fP"
.br
.RI "\fIFast shutter\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBflight\fP"
.br
.RI "\fIFront Light DAC\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBblight\fP"
.br
.RI "\fIBack Light DAC\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBfscint\fP"
.br
.RI "\fIScintillator Piezo DAC\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBsmart_mag_oo\fP"
.br
.RI "\fISmart Magnet on/off\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBblight_ud\fP"
.br
.RI "\fIBack light Up/Down actuator\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcryo\fP"
.br
.RI "\fIMove the cryostream towards or away from the crystal\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBdryer\fP"
.br
.RI "\fIblow air on the scintilator to dry it off \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBfluo\fP"
.br
.RI "\fIMove the fluorescence detector in/out\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBflight_oo\fP"
.br
.RI "\fITurn front light on/off\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBblight_f\fP"
.br
.RI "\fIBack light scale factor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBflight_f\fP"
.br
.RI "\fIFront light scale factor\&. \fP"
.ti -1c
.RI "int \fBlspmac_nmotors\fP"
.br
.RI "\fIThe number of motors we manage\&. \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBlp_air\fP"
.br
.RI "\fILow pressure air OK\&. \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBhp_air\fP"
.br
.RI "\fIHigh pressure air OK\&. \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBcryo_switch\fP"
.br
.RI "\fIthat little toggle switch for the cryo \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBblight_down\fP"
.br
.RI "\fIBacklight is down\&. \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBblight_up\fP"
.br
.RI "\fIBacklight is up\&. \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBcryo_back\fP"
.br
.RI "\fIcryo is in the back position \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBfluor_back\fP"
.br
.RI "\fIfluor is in the back position \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBsample_detected\fP"
.br
.RI "\fIsmart magnet detected sample \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBetel_ready\fP"
.br
.RI "\fIETEL is ready\&. \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBetel_on\fP"
.br
.RI "\fIETEL is on\&. \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBetel_init_ok\fP"
.br
.RI "\fIETEL initialized OK\&. \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBminikappa_ok\fP"
.br
.RI "\fIMinikappa is OK (whatever that means) \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBsmart_mag_on\fP"
.br
.RI "\fIsmart magnet is on \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBarm_parked\fP"
.br
.RI "\fI(whose arm? parked where?) \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBshutter_open\fP"
.br
.RI "\fIshutter is open (note in pmc says this is a slow input) \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBsmart_mag_off\fP"
.br
.RI "\fIsmart magnet is off \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBsmart_mag_err\fP"
.br
.RI "\fIsmart magnet error (coil broken perhaps) \fP"
.ti -1c
.RI "struct timespec \fBomega_zero_time\fP"
.br
.RI "\fITime we believe that omega crossed zero\&. \fP"
.ti -1c
.RI "WINDOW * \fBterm_output\fP"
.br
.RI "\fIplace to print stuff out \fP"
.ti -1c
.RI "WINDOW * \fBterm_input\fP"
.br
.RI "\fIplace to put the cursor \fP"
.ti -1c
.RI "WINDOW * \fBterm_status\fP"
.br
.RI "\fIshutter, lamp, air, etc status \fP"
.ti -1c
.RI "WINDOW * \fBterm_status2\fP"
.br
.RI "\fIshutter, lamp, air, etc status \fP"
.ti -1c
.RI "pthread_mutex_t \fBncurses_mutex\fP"
.br
.RI "\fIallow more than one thread access to the screen \fP"
.ti -1c
.RI "pthread_cond_t \fBmd2cmds_cond\fP"
.br
.RI "\fIcondition to signal when it's time to run an md2 command \fP"
.ti -1c
.RI "pthread_mutex_t \fBmd2cmds_mutex\fP"
.br
.RI "\fImutex for the condition \fP"
.ti -1c
.RI "pthread_cond_t \fBmd2cmds_pg_cond\fP"
.br
.ti -1c
.RI "pthread_mutex_t \fBmd2cmds_pg_mutex\fP"
.br
.ti -1c
.RI "pthread_mutex_t \fBpmac_queue_mutex\fP"
.br
.RI "\fImanage access to the pmac command queue \fP"
.ti -1c
.RI "pthread_cond_t \fBpmac_queue_cond\fP"
.br
.RI "\fIwait for a command to be sent to PMAC before continuing \fP"
.ti -1c
.RI "pthread_mutex_t \fBlspmac_shutter_mutex\fP"
.br
.RI "\fICoordinates threads reading shutter status\&. \fP"
.ti -1c
.RI "pthread_cond_t \fBlspmac_shutter_cond\fP"
.br
.RI "\fIAllows waiting for the shutter status to change\&. \fP"
.ti -1c
.RI "int \fBlspmac_shutter_state\fP"
.br
.RI "\fIState of the shutter, used to detect changes\&. \fP"
.ti -1c
.RI "int \fBlspmac_shutter_has_opened\fP"
.br
.RI "\fIIndicates that the shutter had opened, perhaps briefly even if the state did not change\&. \fP"
.ti -1c
.RI "pthread_mutex_t \fBlspmac_moving_mutex\fP"
.br
.RI "\fICoordinate moving motors between threads\&. \fP"
.ti -1c
.RI "pthread_cond_t \fBlspmac_moving_cond\fP"
.br
.RI "\fIWait for motor(s) to finish moving condition\&. \fP"
.ti -1c
.RI "int \fBlspmac_moving_flags\fP"
.br
.RI "\fIFlag used to implement motor moving condition\&. \fP"
.ti -1c
.RI "pthread_mutex_t \fBmd2_status_mutex\fP"
.br
.RI "\fISynchronize reading/writting status buffer\&. \fP"
.ti -1c
.RI "char \fBmd2cmds_cmd\fP []"
.br
.RI "\fIour command; \fP"
.ti -1c
.RI "\fBlsredis_obj_t\fP * \fBmd2cmds_md_status_code\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Headers for the entire pgpmac project\&. 

\fBDate:\fP
.RS 4
2012 
.RE
.PP
\fBAuthor:\fP
.RS 4
Keith Brister 
.RE
.PP
\fBCopyright:\fP
.RS 4
All Rights Reserved 
.RE
.PP

.PP
Definition in file \fBpgpmac\&.h\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define _GNU_SOURCE"

.PP
Definition at line 7 of file pgpmac\&.h\&.
.SS "#define LS_DISPLAY_WINDOW_HEIGHT   8"

.PP
Number of status box rows\&. 
.PP
Definition at line 57 of file pgpmac\&.h\&.
.SS "#define LS_DISPLAY_WINDOW_WIDTH   24"

.PP
Number of status box columns\&. 
.PP
Definition at line 61 of file pgpmac\&.h\&.
.SS "#define LS_PG_QUERY_STRING_LENGTH   1024"

.PP
Fixed length postgresql query strings\&. Queries should all be function calls so this is not as weird as one might think\&. 
.PP
Definition at line 64 of file pgpmac\&.h\&.
.SS "#define LSEVENTS_EVENT_LENGTH   256"

.PP
Fixed length for event names: simplifies string handling\&. 
.PP
Definition at line 67 of file pgpmac\&.h\&.
.SS "#define MD2CMDS_CMD_LENGTH   32"

.PP
Definition at line 486 of file pgpmac\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBlspg_demandairrights_struct\fP  \fBlspg_demandairrights_t\fP"

.SS "typedef struct \fBlspg_getcenter_struct\fP  \fBlspg_getcenter_t\fP"

.PP
Storage for getcenter query Used for the md2 ROTATE command that generates the centering movies\&. 
.SS "typedef struct \fBlspg_getcurrentsampleid_struct\fP  \fBlspg_getcurrentsampleid_t\fP"

.SS "typedef struct \fBlspg_nextsample_struct\fP  \fBlspg_nextsample_t\fP"

.PP
Returns the next sample number Just a 32 bit int (Ha!, take that, nextshot!) 
.SS "typedef struct \fBlspg_nextshot_struct\fP  \fBlspg_nextshot_t\fP"

.PP
Storage definition for nextshot query\&. The next shot query returns all the information needed to collect the next data frame\&. Since SQL allows for null fields independently from blank strings a separate integer is used as a flag for this case\&. This adds to the program complexity but allows for some important cases\&. Suck it up\&.definition of the next image to be taken (and the one after that, too!) 
.SS "typedef struct \fBlspgQueryQueueStruct\fP  \fBlspg_query_queue_t\fP"

.PP
Store each query along with it's callback function\&. All calls are asynchronous 
.SS "typedef struct \fBlspg_starttransfer_struct\fP  \fBlspg_starttransfer_t\fP"

.PP
returns 1 if transfer can continue 0 to abort 
.SS "typedef struct \fBlspg_waitcryo_struct\fP  \fBlspg_waitcryo_t\fP"

.SS "typedef struct \fBlspmac_bi_struct\fP  \fBlspmac_bi_t\fP"

.PP
Storage for binary inputs\&. 
.SS "typedef struct \fBlspmac_motor_struct\fP  \fBlspmac_motor_t\fP"

.PP
Motor information\&. A catchall for motors and motor like objects\&. Not all members are used by all objects\&. 
.SS "typedef struct \fBlsredis_obj_struct\fP  \fBlsredis_obj_t\fP"

.PP
Redis Object Basic object whose value is sychronized with our redis db\&. 
.SS "typedef struct \fBlspmac_cmd_queue_struct\fP  \fBpmac_cmd_queue_t\fP"

.PP
PMAC command queue item\&. Command queue items are fixed length to simplify memory management\&. 
.SS "typedef struct \fBtagEthernetCmd\fP  \fBpmac_cmd_t\fP"

.PP
PMAC ethernet packet definition\&. Taken directly from the Delta Tau documentation\&. 
.SH "Function Documentation"
.PP 
.SS "void lsevents_add_listener (char *event, void(*)(char *)cb)"

.PP
Add a callback routine to listen for a specific event\&. \fBParameters:\fP
.RS 4
\fIevent\fP the name of the event to listen for 
.br
\fIcb\fP the routine to call 
.RE
.PP

.PP
Definition at line 75 of file lsevents\&.c\&.
.PP
.nf
                                                             {
  lsevents_listener_t *new;
  int err;
  char *errbuf;
  int nerrbuf;



  new = calloc( 1, sizeof( lsevents_listener_t));
  if( new == NULL) {
    lslogging_log_message( 'lsevents_add_listener: out of memory');
    exit( -1);
  }

  err = regcomp( &new->re, event, REG_EXTENDED | REG_NOSUB);
  if( err != 0) {
    nerrbuf = regerror( err, &new->re, NULL, 0);
    errbuf = calloc( nerrbuf, sizeof( char));
    if( errbuf == NULL) {
      lslogging_log_message( 'lsevents_add_listener: out of memory (re)');
      exit( -1);
    }
    regerror( err, &new->re, errbuf, nerrbuf);
    lslogging_log_message( 'lsevents_add_listener: %s', errbuf);
    free( errbuf);
    free( new);
    return;
  }

  new->raw_regexp = strdup( event);
  new->cb   = cb;

  pthread_mutex_lock( &lsevents_listener_mutex);
  new->next = lsevents_listeners_p;
  lsevents_listeners_p = new;
  pthread_mutex_unlock( &lsevents_listener_mutex);

  lslogging_log_message( 'lsevents_add_listener: added listener for event %s', event);

}
.fi
.SS "void lsevents_init ()"

.PP
Initialize this module\&. 
.PP
Definition at line 214 of file lsevents\&.c\&.
.PP
.nf
                     {
  pthread_mutex_init( &lsevents_queue_mutex, NULL);
  pthread_cond_init(  &lsevents_queue_cond, NULL);
  pthread_mutex_init( &lsevents_listener_mutex, NULL);
}
.fi
.SS "void lsevents_remove_listener (char *event, void(*)(char *)cb)"

.PP
Remove a listener previously added with lsevents_add_listener\&. \fBParameters:\fP
.RS 4
\fIevent\fP The name of the event 
.br
\fIcb\fP The callback routine to remove 
.RE
.PP

.PP
Definition at line 120 of file lsevents\&.c\&.
.PP
.nf
                                                                {
  
  lsevents_listener_t *last, *current;

  //
  // Find the listener to remove
  // and unlink it from the list
  //
  pthread_mutex_lock( &lsevents_listener_mutex);
  last = NULL;
  for( current = lsevents_listeners_p; current != NULL; current = current->next) {
    if( strcmp( last->raw_regexp, event) == 0 && last->cb == cb) {
      if( last == NULL) {
        lsevents_listeners_p = current->next;
      } else {
        last->next = current->next;
      }
      break;
    }
  }
  pthread_mutex_unlock( &lsevents_listener_mutex);

  //
  // Now remove it
  //
  if( current != NULL) {
    if( current->raw_regexp != NULL)
      free( current->raw_regexp);
    free(current);
  }
}
.fi
.SS "void lsevents_run ()"

.PP
Start up the thread and get out of the way\&. 
.PP
Definition at line 222 of file lsevents\&.c\&.
.PP
.nf
                    {
  pthread_create( &lsevents_thread, NULL, lsevents_worker, NULL);
}
.fi
.SS "void lsevents_send_event (char *fmt, \&.\&.\&.)"

.PP
Call the callback routines for the given event\&. \fBParameters:\fP
.RS 4
\fIfmt\fP a printf style formating string 
.br
\fI\&.\&.\&.\fP list of arguments specified by the format string 
.RE
.PP

.PP
Definition at line 45 of file lsevents\&.c\&.
.PP
.nf
                                          {
  char event[LSEVENTS_EVENT_LENGTH];
  va_list arg_ptr;

  va_start( arg_ptr, fmt);
  vsnprintf( event, sizeof(event)-1, fmt, arg_ptr);
  event[sizeof(event)-1]=0;
  va_end( arg_ptr);

  pthread_mutex_lock( &lsevents_queue_mutex);

  lslogging_log_message( 'lsevents_send_event: %s', event);


  // maybe wait for room on the queue
  while( (lsevents_queue_on + 1) % LSEVENTS_QUEUE_LENGTH == lsevents_queue_off % LSEVENTS_QUEUE_LENGTH)
    pthread_cond_wait( &lsevents_queue_cond, &lsevents_queue_mutex);
  
  lsevents_queue[(lsevents_queue_on++) % LSEVENTS_QUEUE_LENGTH]\&.evp = strdup(event);

  pthread_cond_signal(  &lsevents_queue_cond);
  pthread_mutex_unlock( &lsevents_queue_mutex);

}
.fi
.SS "void lslogging_init ()"

.PP
Initialize the lslogging objects\&. 
.PP
Definition at line 37 of file lslogging\&.c\&.
.PP
.nf
                      {
  pthread_mutex_init( &lslogging_mutex, NULL);
  pthread_cond_init(  &lslogging_cond, NULL);

  lslogging_file = fopen( LSLOGGING_FILE_NAME, 'w');
}
.fi
.SS "void lslogging_log_message (char *fmt, \&.\&.\&.)"

.PP
The routine everyone will be talking about\&. \fBParameters:\fP
.RS 4
\fIfmt\fP A printf style formating string\&. 
.br
\fI\&.\&.\&.\fP The arguments specified by fmt 
.RE
.PP

.PP
Definition at line 48 of file lslogging\&.c\&.
.PP
.nf
                                            {
  char msg[LSLOGGING_MSG_LENGTH];
  struct timespec theTime;
  va_list arg_ptr;
  unsigned int on;

  clock_gettime( CLOCK_REALTIME, &theTime);

  va_start( arg_ptr, fmt);
  vsnprintf( msg, sizeof(msg)-1, fmt, arg_ptr);
  va_end( arg_ptr);
  msg[sizeof(msg)-1]=0;

  pthread_mutex_lock( &lslogging_mutex);
  
  on = (lslogging_on++) % LSLOGGING_QUEUE_LENGTH;
  strncpy( lslogging_queue[on]\&.lmsg, msg, LSLOGGING_MSG_LENGTH - 1);
  lslogging_queue[on]\&.lmsg[LSLOGGING_MSG_LENGTH-1] = 0;
  
  memcpy( &(lslogging_queue[on]\&.ltime), &theTime, sizeof(theTime));

  pthread_cond_signal(  &lslogging_cond);
  pthread_mutex_unlock( &lslogging_mutex);
  
}
.fi
.SS "void lslogging_run ()"

.PP
Start up the worker thread\&. 
.PP
Definition at line 105 of file lslogging\&.c\&.
.PP
.nf
                     {
  pthread_create( &lslogging_thread, NULL, &lslogging_worker, NULL);
  lslogging_log_message( 'Start up');
}
.fi
.SS "char** lspg_array2ptrs (char *)"

.PP
returns a null terminated list of strings parsed from postgresql array 
.PP
Definition at line 161 of file lspg\&.c\&.
.PP
.nf
                                 {
  char **rtn, *sp, *acums;
  int i, n, inquote, havebackslash, rtni;;
  int mxsz;
  
  inquote       = 0;
  havebackslash = 0;

  // Despense with the null input condition before we complicate the code below
  if( a == NULL || a[0] != '{' || a[strlen(a)-1] != '}')
    return NULL;

  // Count the maximum number of strings
  // Actual number will be less if there are quoted commas
  //
  n = 1;
  for( i=0; a[i]; i++) {
    if( a[i] == ',')
      n++;
  }
  //
  // The maximum size of any string is the length of a (+1)
  //
  mxsz = strlen(a) + 1;

  // This is the accumulation string to make up the array elements
  acums = (char *)calloc( mxsz, sizeof( char));
  if( acums == NULL) {
    lslogging_log_message( 'lspg_array2ptrs: out of memory (acums)');
    exit( 1);
  }
  
  //
  // allocate storage for the pointer array and the null terminator
  //
  rtn = (char **)calloc( n+1, sizeof( char *));
  if( rtn == NULL) {
    lslogging_log_message( 'lspg_array2ptrs: out of memory (rtn)');
    exit( 1);
  }
  rtni = 0;
  
  // Go through and create the individual strings
  sp = acums;
  *sp = 0;

  inquote = 0;
  havebackslash = 0;
  for( i=1; a[i] != 0; i++) {
    switch( a[i]) {
    case ''':
      if( havebackslash) {
        // a quoted quote\&.  Cool
        //
        *(sp++) = a[i];
        *sp = 0;
        havebackslash = 0;
      } else {
        // Toggle the flag
        inquote = 1 - inquote;
      }
      break;

    case '\\':
      if( havebackslash) {
        *(sp++) = a[i];
        *sp = 0;
        havebackslash = 0;
      } else {
        havebackslash = 1;
      }
      break;

    case ',':
      if( inquote || havebackslash) {
        *(sp++) = a[i];
        *sp = 0;
        havebackslash = 0;
      } else {
        rtn[rtni++] = strdup( acums);
        sp = acums;
      }
      break;
      
    case '}':
      if( inquote || havebackslash) {
        *(sp++) = a[i];
        *sp = 0;
        havebackslash = 0;
      } else {
        rtn[rtni++] = strdup( acums);
        rtn[rtni]   = NULL;
        free( acums);
        return( rtn);
      }
      break;

    default:
      *(sp++) = a[i];
      *sp = 0;
      havebackslash = 0;
    }
  }
  //
  // Getting here means the final '}' was missing
  // Probably we should throw an error or log it or something\&.
  // Through out the last entry since this there is not resonable expectation that
  // we should be parsing it anyway\&.
  //
  rtn[rtni]   = NULL;
  free( acums);
  return( rtn);
}
.fi
.SS "void lspg_demandairrights_all ()"

.PP
do nothing until we get airrights 
.PP
Definition at line 556 of file lspg\&.c\&.
.PP
.nf
                                {
  lspg_demandairrights_call();
  lspg_demandairrights_wait();
  // there is no 'done' version
}
.fi
.SS "void lspg_getcenter_call ()"

.PP
Request a getcenter query\&. 
.PP
Definition at line 1177 of file lspg\&.c\&.
.PP
.nf
                           {
  pthread_mutex_lock( &lspg_getcenter\&.mutex);
  lspg_getcenter\&.new_value_ready = 0;
  pthread_mutex_unlock( &lspg_getcenter\&.mutex);

  lspg_query_push( lspg_getcenter_cb, 'SELECT * FROM px\&.getcenter2()');
}
.fi
.SS "void lspg_getcenter_done ()"

.PP
Done with getcenter query\&. 
.PP
Definition at line 1195 of file lspg\&.c\&.
.PP
.nf
                           {
  pthread_mutex_unlock( &(lspg_getcenter\&.mutex));
}
.fi
.SS "void lspg_getcenter_wait ()"

.PP
Wait for a getcenter query to return\&. 
.PP
Definition at line 1187 of file lspg\&.c\&.
.PP
.nf
                           {
  pthread_mutex_lock( &(lspg_getcenter\&.mutex));
  while( lspg_getcenter\&.new_value_ready == 0)
    pthread_cond_wait( &(lspg_getcenter\&.cond), &(lspg_getcenter\&.mutex));
}
.fi
.SS "void lspg_getcurrentsampleid_wait_for_id (unsigned inttest)"

.PP
Definition at line 393 of file lspg\&.c\&.
.PP
.nf
                                                             {
  pthread_mutex_lock( &lspg_getcurrentsampleid\&.mutex);
  while( lspg_getcurrentsampleid\&.getcurrentsampleid != test)
    pthread_cond_wait( &lspg_getcurrentsampleid\&.cond, &lspg_getcurrentsampleid\&.mutex);
    
  pthread_mutex_unlock( &lspg_getcurrentsampleid\&.mutex);
}
.fi
.SS "void lspg_init ()"

.PP
Initiallize the lspg module\&. 
.PP
Definition at line 1759 of file lspg\&.c\&.
.PP
.nf
                 {
  pthread_mutex_init( &lspg_queue_mutex, NULL);
  pthread_cond_init( &lspg_queue_cond, NULL);

  lspg_demandairrights_init();
  lspg_getcenter_init();
  lspg_getcurrentsampleid_init();
  lspg_lock_detector_init();
  lspg_lock_diffractometer_init();
  lspg_nextsample_init();
  lspg_nextshot_init();
  lspg_seq_run_prep_init();
  lspg_starttransfer_init();
  lspg_wait_for_detector_init();
  lspg_waitcryo_init();
}
.fi
.SS "unsigned int lspg_nextsample_all (int *err)"

.PP
Definition at line 468 of file lspg\&.c\&.
.PP
.nf
                                            {
  unsigned int rtn;

  lspg_nextsample_call();
  lspg_nextsample_wait();

  if( lspg_nextsample\&.no_rows_returned) {
    rtn = 0;
    *err = 1;
  } else {
    if( lspg_nextsample\&.nextsample_isnull) {
      rtn = 0;
      *err = 1;
    } else {
      rtn = lspg_nextsample\&.nextsample;
      *err = 0;
    }
  }
  lspg_nextsample_done();

  return rtn;
}
.fi
.SS "void lspg_nextshot_call ()"

.PP
Queue up a nextshot query\&. 
.PP
Definition at line 824 of file lspg\&.c\&.
.PP
.nf
                          {
  pthread_mutex_lock( &(lspg_nextshot\&.mutex));
  lspg_nextshot\&.new_value_ready = 0;
  pthread_mutex_unlock( &(lspg_nextshot\&.mutex));
  
  lspg_query_push( lspg_nextshot_cb, 'SELECT * FROM px\&.nextshot2()');
}
.fi
.SS "void lspg_nextshot_done ()"

.PP
Called when the next shot query has been processed\&. 
.PP
Definition at line 842 of file lspg\&.c\&.
.PP
.nf
                          {
  pthread_mutex_unlock( &(lspg_nextshot\&.mutex));
}
.fi
.SS "void lspg_nextshot_wait ()"

.PP
Wait for the next shot query to get processed\&. 
.PP
Definition at line 834 of file lspg\&.c\&.
.PP
.nf
                          {
  pthread_mutex_lock( &(lspg_nextshot\&.mutex));
  while( lspg_nextshot\&.new_value_ready == 0)
    pthread_cond_wait( &(lspg_nextshot\&.cond), &(lspg_nextshot\&.mutex));
}
.fi
.SS "void lspg_query_push (void(*)(\fBlspg_query_queue_t\fP *, PGresult *)cb, char *fmt, \&.\&.\&.)"

.PP
Place a query on the queue\&. \fBParameters:\fP
.RS 4
\fIcb\fP Our callback function that deals with the response 
.br
\fIfmt\fP Printf style function to generate the query 
.RE
.PP

.PP
Definition at line 234 of file kvredis\&.c\&.
.PP
.nf
                       {
  int idx;
  va_list arg_ptr;


  //
  // Pause the thread while we service the queue
  //
  if( (lspg_query_queue_on + 1) % LS_PG_QUERY_QUEUE_LENGTH == lspg_query_queue_off % LS_PG_QUERY_QUEUE_LENGTH) {
    fprintf( stderr, 'lspg_query_push: queue is full\&.  Ignoring query \'%s\'\n', fmt);
    return;
  }

  idx = lspg_query_queue_on % LS_PG_QUERY_QUEUE_LENGTH;

  va_start( arg_ptr, fmt);
  vsnprintf( lspg_query_queue[idx]\&.qs, LS_PG_QUERY_STRING_LENGTH-1, fmt, arg_ptr);
  va_end( arg_ptr);

  lspg_query_queue[idx]\&.qs[LS_PG_QUERY_STRING_LENGTH - 1] = 0;
  lspg_query_queue[idx]\&.onResponse = cb;
  lspg_query_queue_on++;

};
.fi
.SS "void lspg_run ()"

.PP
Start 'er runnin'\&. 
.PP
Definition at line 1778 of file lspg\&.c\&.
.PP
.nf
                {
  pthread_create( &lspg_thread, NULL, lspg_worker, NULL);
  lsevents_add_listener( 'Sample(Detected|Absent)', lspmac_sample_detector_cb);

}
.fi
.SS "void lspg_seq_run_prep_all (long longskey, doublekappa, doublephi, doublecx, doublecy, doubleax, doubleay, doubleaz)"

.PP
Convinence function to call seq run prep\&. \fBParameters:\fP
.RS 4
\fIskey\fP px\&.shots key for this image 
.br
\fIkappa\fP current kappa postion 
.br
\fIphi\fP current phi postition 
.br
\fIcx\fP current center table x 
.br
\fIcy\fP current center table y 
.br
\fIax\fP current alignment table x 
.br
\fIay\fP current alignment table y 
.br
\fIaz\fP current alignment table z 
.RE
.PP

.PP
Definition at line 1095 of file lspg\&.c\&.
.PP
.nf
                             {
  lspg_seq_run_prep_call( skey, kappa, phi, cx, cy, ax, ay, az);
  lspg_seq_run_prep_wait();
  lspg_seq_run_prep_done();
}
.fi
.SS "void lspg_starttransfer_call (unsigned intnextsample, intsample_detected, doubleax, doubleay, doubleaz, doublehorz, doublevert, doubleesttime)"

.PP
Definition at line 302 of file lspg\&.c\&.
.PP
.nf
                                                                                                                                                       {
  pthread_mutex_lock( &(lspg_starttransfer\&.mutex));
  lspg_starttransfer\&.new_value_ready = 0;
  pthread_mutex_unlock( &(lspg_starttransfer\&.mutex));

  lspg_query_push( lspg_starttransfer_cb, 'SELECT px\&.starttransfer( %d, %d, %\&.3f, %\&.3f, %\&.3f, %\&.3f, %\&.3f, %\&.3f',
                   nextsample, sample_detected, ax, ay, az, horz, vert, esttime);
}
.fi
.SS "void lspg_starttransfer_done ()"

.PP
Definition at line 317 of file lspg\&.c\&.
.PP
.nf
                               {
  pthread_mutex_unlock( &(lspg_starttransfer\&.mutex));
}
.fi
.SS "void lspg_starttransfer_wait ()"

.PP
Definition at line 311 of file lspg\&.c\&.
.PP
.nf
                               {
  pthread_mutex_lock( &(lspg_starttransfer\&.mutex));
  while( lspg_starttransfer\&.new_value_ready == 0)
    pthread_cond_wait( &(lspg_starttransfer\&.cond), &(lspg_starttransfer\&.mutex));
}
.fi
.SS "void lspg_waitcryo_all ()"

.PP
no need to get fancy with the wait cryo command It should not return until the robot is almost ready for air rights 
.PP
Definition at line 507 of file lspg\&.c\&.
.PP
.nf
                         {
  pthread_mutex_lock( &lspg_waitcryo\&.mutex);
  lspg_waitcryo\&.new_value_ready = 0;

  lspg_query_push( lspg_waitcryo_cb, 'SELECT px\&.waitcryo())');

  while( lspg_waitcryo\&.new_value_ready == 0)
    pthread_cond_wait( &lspg_waitcryo\&.cond, &lspg_waitcryo\&.mutex);

  pthread_mutex_unlock( &lspg_waitcryo\&.mutex);
}
.fi
.SS "void lspg_waitcryo_cb (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"

.PP
Definition at line 497 of file lspg\&.c\&.
.PP
.nf
                                                               {
  pthread_mutex_lock( &lspg_waitcryo\&.mutex);
  lspg_waitcryo\&.new_value_ready = 1;
  pthread_cond_signal( &lspg_waitcryo\&.cond);
  pthread_mutex_unlock( &lspg_waitcryo\&.mutex);
}
.fi
.SS "void lspg_zoom_lut_call ()"

.SS "void lspmac_abort ()"

.PP
abort motion and try to recover 
.PP
Definition at line 2021 of file lspmac\&.c\&.
.PP
.nf
                    {
  //
  // Stop everything!  (consider ^O instead of ^A)
  //
  lspmac_SockSendDPControlChar( 'Abort Request', 0x01);

}
.fi
.SS "int lspmac_est_move_time (double *est_time, int *mmask, \fBlspmac_motor_t\fP *mp_1, intjog_1, char *preset_1, doubleend_point_1, \&.\&.\&.)"

.PP
Move the motors and estimate the time it'll take to finish the job\&. Returns the estimate time and the coordinate system mask to waite for 
.PP
\fBParameters:\fP
.RS 4
\fIest_time\fP Returns number of seconds we estimate the move(s) will take 
.br
\fImmask\fP Mask of coordinate systems we are trying to move, excluding jogs\&. Used to wait for motions to complete 
.br
\fImp_1\fP Pointer to first motor 
.br
\fIjog_1\fP 1 to force a jog, 0 to try a motion program DO NOT MIX JOGS AND MOTION PROGRAMS IN THE SAME COORDINATE SYSTEM! 
.br
\fIpreset_1\fP Name of preset we'd like to move to or NULL if end_point_1 should be used instead 
.br
\fIend_point_1\fP End point for the first motor\&. Ignored if preset_1 is non null and identifies a valid preset for this motor 
.br
\fI\&.\&.\&.\fP Perhaps more quads of motors, jog flags, preset names, and end points\&. End is a NULL motor pointer MUST END ARG LIST WITH NULL 
.RE
.PP
< units to counts
.PP
< The total distance we need to go
.PP
< Our maximum velocity
.PP
< Our maximum acceleration
.PP
< Total time for this motor
.PP
< coordinate system motion flags 
.PP
Definition at line 2617 of file lspmac\&.c\&.
.PP
.nf
                                                                                                                                  {
  static char axes[] = 'XYZUVWABC';
  static int qs[9];
  static lspmac_combined_move_t motions[32];

  int j;
  va_list arg_ptr;
  lspmac_motor_t *mp;
  double ep, maybe_ep;
  char *ps;
  double
    min_pos,
    max_pos,
    neutral_pos,
    u2c,                
    D,                  
    V,                  
    A,                  
    Tt;                 
  int err;
  int jog;
  int i;
  int m5075;            

  // reset our coordinate flags and command strings
  //
  for( i=0; i<32; i++) {
    motions[i]\&.moveme = 0;
  }
  m5075 = 0;

  //
  // Initialze first iteration
  //
  *est_time = 0\&.0;
  mp  = mp_1;
  ps  = preset_1;
  ep  = end_point_1;
  jog = jog_1;

  va_start( arg_ptr, end_point_1);
  while( 1) {
    /*
     :                  |       Constant       |
     :                  |<---   Velocity   --->|
     :                  |       Time (Ct)      |
   V :                   ----------------------              ---------
   e :                 /                        \               ^
   l :                /                          \              |
   o :               /                            \             |
   c :              /                              \            V
   i :             /                                \           |
   t :            /                                  \          |
   y :___________/\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\_________v___________
                 |      |         Time              
                 |      |
              -->|      |<-- Acceleration Time  (At)
                 |
                 |<-----    Total  Time (Tt)  ------->|

      Assumption 1: We can replace S curve acceleration with linear acceleration
                    for the purposes of distance and time calculations for the timeout
                    period that we are attempting to calculate here\&.

     Ct  = Constant Velocity Time\&.  The time spent at constant velocity\&.

     At  = Acceleration Time\&.  Time spent accelerating at either end of the ramp, that is,
          1/2 the total time spent accelerating and decelerating\&.

     D   = the total distance we need to travel

     V   = constant velocity\&.  Here we use the motor's maximum velocity\&.

     A   = the motor acceleration, Here it's the maximum acceleration\&.

         V = A * At   

     or  At = V/A

      The Total Time (Tt) is

          Tt = Ct + 2 * At



      If we had infinite acceleration the total time would be D/V\&.  To account for finite acceleration we just need to
      adjust this for the average velocity while accelerating (0\&.5 V)\&.  This neatly adds a single V/A term:

      (1)     Tt = D/V  + V/A

      When the distance is short, we need a different calculation:

        D = 0\&.5 * A * T1^2  + 0\&.5 * A * T2^2  (T1 = acceleration time and T2 = deceleration time)

      or, since total time  Tt = T1 + T2 and T1 = T2,

        D = A * (0\&.5*Tt)^2

      or
      
      (2)    Tt = 2 * sqrt( D/A)


      When we accelerate to the maximum speed the time it takes is V/A so the distance we travel (Da) is

         Da = 0\&.5 * A * (V/A)^2

      or

        Da = 0\&.5 * V^2 / A

      So when D > 2 * Da, or

       D > V^2 / A
         
      we need to use equation (1) otherwise we need to use equation (2)

     */

    Tt = 0\&.0;
    if( mp != NULL && mp->max_speed != NULL && mp->max_accel != NULL && mp->u2c != NULL) {

      //
      // get the real endpoint if a preset was mentioned
      //
      if( ps != NULL && *ps != 0) {
        err = lsredis_find_preset( mp->name, ps, &maybe_ep);
        if( err != 0)
          ep = maybe_ep;
      }

      u2c = lsredis_getd( mp->u2c);

      if( u2c <= 0\&.0)
        continue;

      D = ep - lspmac_getPosition( mp);                         // User units
      V = lsredis_getd( mp->max_speed) / u2c * 1000\&.;            // User units per second
      A = lsredis_getd( mp->max_accel) / u2c * 1000\&. * 1000;     // User units per second per second


      neutral_pos = lsredis_getd( mp->neutral_pos);
      min_pos     = lsredis_getd( mp->min_pos) - neutral_pos;
      max_pos     = lsredis_getd( mp->max_pos) - neutral_pos;

      if( ep < min_pos || ep > max_pos) {
        lslogging_log_message( 'lspmac_est_move_time: Motor %s Requested position %f out of range: min=%f, max=%f', mp->name, ep, min_pos, max_pos);
        lsevents_send_event( '%s Move Aborted', mp->name);
        return 1;
      }

      //
      // Don't bother with motors without velocity or acceleration defined
      //
      if( V > 0\&.0 && A > 0\&.0) {
        if( fabs(D) > V*V/A) {
          //
          // Normal ramp up, constant velocity, and ramp down
          //
          Tt = fabs(D)/V + V/A;
        } else {
          //
          // Never reach constantanve velocity, just ramp up a bit and back down
          //
          Tt = 2\&.0 * sqrt( fabs(D)/A);
        }

        lslogging_log_message( 'lspmac_est_move_time: Motor: %s  D: %f  VV/A: %f  Tt: %f', mp->name, D, V*V/A, Tt);
      }  else {
        //
        // TODO: insert move time based for DAC or BO motor like objects;
        // For now assume 100 msec;
        //
        Tt = 0\&.1;
      }

      // Perhaps flag a coordinate system
      //
      // We can move a motor that's not in a coordinate system but we cannot move a motor that is but does not
      // have an axis defined if we are also moving one that does\&.  It's a limitation, I guess\&.
      //
      if( jog != 1 &&
          mp->coord_num != NULL && lsredis_getl( mp->coord_num) > 0 && lsredis_getl( mp->coord_num) <= 16 &&
          mp->motor_num != NULL && lsredis_getl( mp->motor_num) > 0 && mp->axis != NULL && lsredis_getc( mp->axis) != 0) {
        int axis;
        int motor_num;

        motor_num = lsredis_getl( mp->motor_num);

        axis = lsredis_getc( mp->axis);
        for( j=0; j<sizeof(axes); j++) {
          if( axis == axes[j])
            break;
        }

        if( j < sizeof( axes)) {
          //
          // Store the motion request for a normal PMAC motor
          //
          int cn;
          int in_position_band;

          cn = lsredis_getl( mp->coord_num);
          in_position_band = lsredis_getl( mp->in_position_band);

          motions[motor_num - 1]\&.coord_num = cn;
          motions[motor_num - 1]\&.axis      = j;
          motions[motor_num - 1]\&.Delta     = D * u2c;
          //
          // Don't ask to run a motion program if we are already where we want to be
          //
          // Deadband is 10 counts except for zoom which is 100\&.
          // We use Ixx28 In-Position Band which has units of 1/16 count
          //
          //
          if( abs(motions[motor_num - 1]\&.Delta)*16 >= in_position_band) {
            m5075 |= 1 << (cn - 1);
            motions[motor_num - 1]\&.moveme    = 1;
          }       
        }
      } else {
        //
        // Here we are dealling with a DAC or BO motor or just want to jog\&.
        //
        if( mp->jogAbs( mp, lspmac_getPosition( mp) + D)) {
          lslogging_log_message( 'lspmac_est_move_time: motor %s failed to queue move of distance %f from %f', mp->name, D, lspmac_getPosition(mp));
          lsevents_send_event( 'Move Aborted');
          return 1;
        }
      }
      //
      // Update the estimated time
      //
      *est_time = *est_time < Tt ? Tt : *est_time;
      
      lslogging_log_message( 'lspmac_est_move_time: est_time=%f', *est_time);

    }


    mp = va_arg( arg_ptr, lspmac_motor_t *);
    if( mp == NULL)
      break;

    jog = va_arg( arg_ptr, int);
    ps  = va_arg( arg_ptr, char *);
    ep  = va_arg( arg_ptr, double);
  }
  va_end( arg_ptr);

  
  // Call the motion program(s)
  {
    char s[256];
    int foundone;
    int err;
    int moving_flags;
    struct timespec timeout;

    if( m5075 != 0) {
      *mmask |= m5075;  // Tell the caller about our new mask

      pthread_mutex_lock( &lspmac_moving_mutex);
      if( (lspmac_moving_flags & m5075) != m5075)
        lspmac_SockSendDPline( NULL, 'M5075=(M5075 | %d)', m5075);

      clock_gettime( CLOCK_REALTIME, &timeout);
      //
      timeout\&.tv_sec += 2;       // 2 seconds should be more than enough time to set the flags
      err = 0;
      while( err == 0 && (lspmac_moving_flags & m5075) != m5075)
        err = pthread_cond_timedwait( &lspmac_moving_cond, &lspmac_moving_mutex, &timeout);
      moving_flags = lspmac_moving_flags;
      pthread_mutex_unlock( &lspmac_moving_mutex);

      if( err == ETIMEDOUT) {
        lslogging_log_message( 'lspmac_est_move_time: Timed out waiting for moving flags\&.  lspmac_moving_flags = %0x', moving_flags);
        lsevents_send_event( '%s Move Aborted Combined Motors');
        return 1;
      }
    }


    for( i=1; i<=16; i++) {
      //
      // Loop over coordinate systems
      //
      foundone = 0;

      for( j=0; j<9; j++)
        qs[j] = 0;

      for( j=0; j<31; j++) {
        //
        // Loop over motors
        //
        if( motions[j]\&.moveme && motions[j]\&.coord_num == i) {
          if( abs(motions[j]\&.Delta) > 0) {
            qs[(int)(motions[j]\&.axis)] = motions[j]\&.Delta;
            foundone=1;
          }
        }
      }
      
      if( foundone) {
        sprintf( s, '&%d Q40=%d Q41=%d Q42=%d Q43=%d Q44=%d Q45=%d Q46=%d Q47=%d Q48=%d Q49=%\&.1f Q100=%d B180R',
                 i, qs[0], qs[1], qs[2], qs[3], qs[4], qs[5], qs[6], qs[7], qs[8], *est_time * 1000\&., 1 << (i-1));

        lspmac_SockSendDPline( NULL, s);

      }
    }
  }
  return 0;
}
.fi
.SS "int lspmac_est_move_time_wait (doublemove_time, intmmask)"

.PP
wait for motion to stop returns non-zero if the wait timed out \fBParameters:\fP
.RS 4
\fImove_time\fP The time out in seconds 
.br
\fImmask\fP A coordinate system mask to wait for
.RE
.PP
Both values are returned from lspmac_est_move_time 
.PP
Definition at line 2941 of file lspmac\&.c\&.
.PP
.nf
                                                            {
  int err;
  double isecs, fsecs;
  struct timespec timeout;

  clock_gettime( CLOCK_REALTIME, &timeout);
  fsecs = modf( move_time, &isecs);
  timeout\&.tv_sec  += (long)floor(isecs);
  timeout\&.tv_nsec += (long)floor(fsecs * 1\&.e9);
  timeout\&.tv_sec  += timeout\&.tv_nsec / 1000000000;
  timeout\&.tv_nsec %= 1000000000;

  err = 0;
  pthread_mutex_lock( &lspmac_moving_mutex);
  while( err == 0 && (lspmac_moving_flags & mmask) != 0)
    err = pthread_cond_timedwait( &lspmac_moving_cond, &lspmac_moving_mutex, &timeout);
  pthread_mutex_unlock( &lspmac_moving_mutex);

  if( err != 0) {
    if( err == ETIMEDOUT) {
      lslogging_log_message( 'lstest_lspmac_est_move_time: timed out waiting %f seconds', move_time);
    }
    return 1;
  }
  return 0;
}
.fi
.SS "int lspmac_getBIPosition (\fBlspmac_bi_t\fP *)"

.PP
get binary input value 
.PP
Definition at line 1588 of file lspmac\&.c\&.
.PP
.nf
                                            {
  int rtn;
  pthread_mutex_lock( &bip->mutex);
  rtn = bip->position;
  pthread_mutex_unlock( &bip->mutex);
  return rtn;
}
.fi
.SS "double lspmac_getPosition (\fBlspmac_motor_t\fP *mp)"

.PP
get the motor position (with locking) \fBParameters:\fP
.RS 4
\fImp\fP the motor object 
.RE
.PP

.PP
Definition at line 1345 of file lspmac\&.c\&.
.PP
.nf
                                               {
  double rtn;
  pthread_mutex_lock( &(mp->mutex));
  rtn = mp->position;
  pthread_mutex_unlock( &(mp->mutex));
  return rtn;
}
.fi
.SS "void lspmac_home1_queue (\fBlspmac_motor_t\fP *mp)"

.PP
Home the motor\&. \fBParameters:\fP
.RS 4
\fImp\fP motor we are concerned about 
.RE
.PP

.PP
Definition at line 1211 of file lspmac\&.c\&.
.PP
.nf
                          {
  int i;
  int motor_num;
  int coord_num;
  char **home;

  pthread_mutex_lock( &(mp->mutex));

  motor_num = lsredis_getl( mp->motor_num);
  coord_num = lsredis_getl( mp->coord_num);
  home      = lsredis_get_string_array( mp->home);
  
  // Each of the motors should have this defined
  // but let's not seg fault if home is missing
  //
  if( home == NULL || *home == NULL) {
    //
    // Note we are already initialized
    // so if we are here there is something wrong\&.
    //
    lslogging_log_message( 'lspmac_home1_queue: null or empty home strings for motor %s', mp->name);
    pthread_mutex_unlock( &(mp->mutex));
    return;
  }

  // We've already been called\&.  Don't home again until
  // we're finish with the last time\&.
  //
  if( mp->homing) {
    pthread_mutex_unlock( &(mp->mutex));
    return;
  }    


  //
  // Don't go on if any other motors in this coordinate system are homing\&.
  // It's possible to write the homing program to home all the motors in the coordinate
  // system\&.  TODO  (hint hint)
  //
  if( coord_num > 0) {
    for( i=0; i<lspmac_nmotors; i++) {
      if( &(lspmac_motors[i]) == mp)
        continue;
      if( lsredis_getl(lspmac_motors[i]\&.coord_num) == coord_num) {
        int nogo;
        nogo = 0;
        pthread_mutex_lock( &(lspmac_motors[i]\&.mutex));
        //
        //  Don't go on if
        //
        //    we are homing         or      ( not in position                while     in open loop)
        //
        if( lspmac_motors[i]\&.homing || (((lspmac_motors[i]\&.status2 & 0x01)==0) && ((lspmac_motors[i]\&.status1 & 0x040000) != 0)))
          nogo = 1;
        pthread_mutex_unlock( &(lspmac_motors[i]\&.mutex));
        if( nogo) {
          pthread_mutex_unlock( &(mp->mutex));
          return;
        }
      }
    }
  }
  mp->homing   = 1;
  mp->not_done = 1;     // set up waiting for cond
  mp->motion_seen = 0;
  // This opens the control loop\&.
  // The status routine should notice this and the fact that
  // the homing flag is set and call on the home2 routine
  //
  // Only send the open loop command if we are not in
  // open loop mode already\&.  This test might prevent a race condition
  // where we've already moved the home2 routine (and queue the homing program motion)
  // before the open loop command is dequeued and acted on\&.
  //
  if( ~(mp->status1) & 0x040000) {
    lspmac_SockSendDPline( mp->name, '#%d$*', motor_num);
  }

  pthread_mutex_unlock( &(mp->mutex));

  lsevents_send_event( '%s Homing', mp->name);
}
.fi
.SS "void lspmac_init (int, int)"

.PP
Initialize this module\&. 
.PP
Definition at line 3477 of file lspmac\&.c\&.
.PP
.nf
                   {
  md2_status_t *p;
  pthread_mutexattr_t mutex_initializer;

  // Set our global harvest flags
  getivars = ivarsflag;
  getmvars = mvarsflag;

  // Use recursive mutexs
  //
  pthread_mutexattr_init( &mutex_initializer);
  pthread_mutexattr_settype( &mutex_initializer, PTHREAD_MUTEX_RECURSIVE);

  // All important status mutex
  pthread_mutex_init( &md2_status_mutex, &mutex_initializer);

  //
  // Get the MD2 initialization strings
  //
  //  lspmac_md2_init = lsredis_get_obj( 'md2_pmac\&.init');  // hard coded now\&.

  //
  // Initialize the motor objects
  //

  p = &md2_status;

  omega  = lspmac_motor_init( &(lspmac_motors[ 0]), 0, 0, &p->omega_act_pos,     &p->omega_status_1,     &p->omega_status_2,     'Omega   #1 &1 X', 'omega',       lspmac_moveabs_queue, lspmac_jogabs_queue);
  alignx = lspmac_motor_init( &(lspmac_motors[ 1]), 0, 1, &p->alignx_act_pos,    &p->alignx_status_1,    &p->alignx_status_2,    'Align X #2 &3 X', 'align\&.x',     lspmac_moveabs_queue, lspmac_jogabs_queue);
  aligny = lspmac_motor_init( &(lspmac_motors[ 2]), 0, 2, &p->aligny_act_pos,    &p->aligny_status_1,    &p->aligny_status_2,    'Align Y #3 &3 Y', 'align\&.y',     lspmac_moveabs_queue, lspmac_jogabs_queue);
  alignz = lspmac_motor_init( &(lspmac_motors[ 3]), 0, 3, &p->alignz_act_pos,    &p->alignz_status_1,    &p->alignz_status_2,    'Align Z #4 &3 Z', 'align\&.z',     lspmac_moveabs_queue, lspmac_jogabs_queue);
  anal   = lspmac_motor_init( &(lspmac_motors[ 4]), 0, 4, &p->analyzer_act_pos,  &p->analyzer_status_1,  &p->analyzer_status_2,  'Anal    #5',      'lightPolar',  lspmac_moveabs_queue, lspmac_jogabs_queue);
  zoom   = lspmac_motor_init( &(lspmac_motors[ 5]), 1, 0, &p->zoom_act_pos,      &p->zoom_status_1,      &p->zoom_status_2,      'Zoom    #6 &4 Z', 'cam\&.zoom',    lspmac_movezoom_queue, lspmac_movezoom_queue);
  apery  = lspmac_motor_init( &(lspmac_motors[ 6]), 1, 1, &p->aperturey_act_pos, &p->aperturey_status_1, &p->aperturey_status_2, 'Aper Y  #7 &5 Y', 'appy',        lspmac_moveabs_queue, lspmac_jogabs_queue);
  aperz  = lspmac_motor_init( &(lspmac_motors[ 7]), 1, 2, &p->aperturez_act_pos, &p->aperturez_status_1, &p->aperturez_status_2, 'Aper Z  #8 &5 Z', 'appz',        lspmac_moveabs_queue, lspmac_jogabs_queue);
  capy   = lspmac_motor_init( &(lspmac_motors[ 8]), 1, 3, &p->capy_act_pos,      &p->capy_status_1,      &p->capy_status_2,      'Cap Y   #9 &5 U', 'capy',        lspmac_moveabs_queue, lspmac_jogabs_queue);
  capz   = lspmac_motor_init( &(lspmac_motors[ 9]), 1, 4, &p->capz_act_pos,      &p->capz_status_1,      &p->capz_status_2,      'Cap Z  #10 &5 V', 'capz',        lspmac_moveabs_queue, lspmac_jogabs_queue);
  scint  = lspmac_motor_init( &(lspmac_motors[10]), 2, 0, &p->scint_act_pos,     &p->scint_status_1,     &p->scint_status_2,     'Scin Z #11 &5 W', 'scint',       lspmac_moveabs_queue, lspmac_jogabs_queue);
  cenx   = lspmac_motor_init( &(lspmac_motors[11]), 2, 1, &p->centerx_act_pos,   &p->centerx_status_1,   &p->centerx_status_2,   'Cen X  #17 &2 X', 'centering\&.x', lspmac_moveabs_queue, lspmac_jogabs_queue);
  ceny   = lspmac_motor_init( &(lspmac_motors[12]), 2, 2, &p->centery_act_pos,   &p->centery_status_1,   &p->centery_status_2,   'Cen Y  #18 &2 Y', 'centering\&.y', lspmac_moveabs_queue, lspmac_jogabs_queue);
  kappa  = lspmac_motor_init( &(lspmac_motors[13]), 2, 3, &p->kappa_act_pos,     &p->kappa_status_1,     &p->kappa_status_2,     'Kappa  #19 &7 X', 'kappa',       lspmac_moveabs_queue, lspmac_jogabs_queue);
  phi    = lspmac_motor_init( &(lspmac_motors[14]), 2, 4, &p->phi_act_pos,       &p->phi_status_1,       &p->phi_status_2,       'Phi    #20 &7 Y', 'phi',         lspmac_moveabs_queue, lspmac_jogabs_queue);

  fshut  = lspmac_fshut_init( &(lspmac_motors[15]));
  flight = lspmac_dac_init( &(lspmac_motors[16]), &p->front_dac,   'M1200', 'frontLight\&.intensity', lspmac_movedac_queue);
  blight = lspmac_dac_init( &(lspmac_motors[17]), &p->back_dac,    'M1201', 'backLight\&.intensity',  lspmac_movedac_queue);
  fscint = lspmac_dac_init( &(lspmac_motors[18]), &p->scint_piezo, 'M1203', 'scint\&.focus',          lspmac_movedac_queue);

  smart_mag_oo  = lspmac_bo_init( &(lspmac_motors[19]), 'smartMagnet','M1100=%d', &(md2_status\&.acc11c_5), 0x01);
  blight_ud     = lspmac_bo_init( &(lspmac_motors[20]), 'backLight',  'M1101=%d', &(md2_status\&.acc11c_5), 0x02);
  cryo          = lspmac_bo_init( &(lspmac_motors[21]), 'cryo',       'M1102=%d', &(md2_status\&.acc11c_5), 0x04);
  dryer         = lspmac_bo_init( &(lspmac_motors[22]), 'dryer',      'M1103=%d', &(md2_status\&.acc11c_5), 0x08);
  fluo          = lspmac_bo_init( &(lspmac_motors[23]), 'fluo',       'M1104=%d', &(md2_status\&.acc11c_5), 0x10);
  flight_oo     = lspmac_soft_motor_init( &(lspmac_motors[24]), 'frontLight',        lspmac_moveabs_frontlight_oo_queue);
  blight_f      = lspmac_soft_motor_init( &(lspmac_motors[25]), 'backLight\&.factor',  lspmac_moveabs_blight_factor_queue);
  flight_f      = lspmac_soft_motor_init( &(lspmac_motors[26]), 'frontLight\&.factor', lspmac_moveabs_flight_factor_queue);

  lp_air          = lspmac_bi_init( &(lspmac_bis[ 0]), &(md2_status\&.acc11c_1),  0x01, 'Low Pressure Air OK',  'Low Pressure Air Failed');
  hp_air          = lspmac_bi_init( &(lspmac_bis[ 1]), &(md2_status\&.acc11c_1),  0x02, 'High Pressure Air OK', 'High Pressure Air Failed');
  cryo_switch     = lspmac_bi_init( &(lspmac_bis[ 2]), &(md2_status\&.acc11c_1),  0x04, 'CryoSwitchChanged',    'CryoSwitchChanged');
  blight_down     = lspmac_bi_init( &(lspmac_bis[ 3]), &(md2_status\&.acc11c_1),  0x08, 'Backlight Down',       'Backlight Not Down');
  blight_up       = lspmac_bi_init( &(lspmac_bis[ 4]), &(md2_status\&.acc11c_1),  0x10, 'Backlight Up',         'Backlight Not Up');
  cryo_back       = lspmac_bi_init( &(lspmac_bis[ 5]), &(md2_status\&.acc11c_1),  0x40, 'Cryo Back',            'Cryo Not Back');
  fluor_back      = lspmac_bi_init( &(lspmac_bis[ 6]), &(md2_status\&.acc11c_2),  0x01, 'Fluor\&. Det\&. Parked',   'Fluor\&. Det\&. Not Parked');
  sample_detected = lspmac_bi_init( &(lspmac_bis[ 7]), &(md2_status\&.acc11c_2),  0x02, 'SamplePresent',        'SampleAbsent');
  etel_ready      = lspmac_bi_init( &(lspmac_bis[ 8]), &(md2_status\&.acc11c_2),  0x20, 'ETEL Ready',           'ETEL Not Ready');
  etel_on         = lspmac_bi_init( &(lspmac_bis[ 9]), &(md2_status\&.acc11c_2),  0x40, 'ETEL On',              'ETEL Off');
  etel_init_ok    = lspmac_bi_init( &(lspmac_bis[10]), &(md2_status\&.acc11c_2),  0x80, 'ETEL Init OK',         'ETEL Init Not OK');
  minikappa_ok    = lspmac_bi_init( &(lspmac_bis[11]), &(md2_status\&.acc11c_3),  0x01, 'Minikappa OK',         'Minikappa Not OK');
  smart_mag_on    = lspmac_bi_init( &(lspmac_bis[12]), &(md2_status\&.acc11c_3),  0x04, 'Smart Magnet On',      'Smart Magnet Not On');
  arm_parked      = lspmac_bi_init( &(lspmac_bis[13]), &(md2_status\&.acc11c_3),  0x08, 'Arm Parked',           'Arm Not Parked');
  smart_mag_err   = lspmac_bi_init( &(lspmac_bis[14]), &(md2_status\&.acc11c_3),  0x10, 'Smart Magnet Error',   'Smart Magnet OK');
  shutter_open    = lspmac_bi_init( &(lspmac_bis[15]), &(md2_status\&.acc11c_3), 0x100, 'Shutter Open',         'Shutter Not Open');
  smart_mag_off   = lspmac_bi_init( &(lspmac_bis[16]), &(md2_status\&.acc11c_5),  0x01, 'Smart Magnet Off',     'Smart Magnet Not Off');
  

  //
  // Initialize several commands that get called, perhaps, alot
  //
  

  rr_cmd\&.RequestType = VR_UPLOAD;
  rr_cmd\&.Request     = VR_PMAC_READREADY;
  rr_cmd\&.wValue      = 0;
  rr_cmd\&.wIndex      = 0;
  rr_cmd\&.wLength     = htons(2);
  memset( rr_cmd\&.bData, 0, sizeof(rr_cmd\&.bData));

  gb_cmd\&.RequestType = VR_UPLOAD;
  gb_cmd\&.Request     = VR_PMAC_GETBUFFER;
  gb_cmd\&.wValue      = 0;
  gb_cmd\&.wIndex      = 0;
  gb_cmd\&.wLength     = htons(1400);
  memset( gb_cmd\&.bData, 0, sizeof(gb_cmd\&.bData));

  cr_cmd\&.RequestType = VR_UPLOAD;
  cr_cmd\&.Request     = VR_CTRL_RESPONSE;
  cr_cmd\&.wValue      = 0;
  cr_cmd\&.wIndex      = 0;
  cr_cmd\&.wLength     = htons(1400);
  memset( cr_cmd\&.bData, 0, sizeof(cr_cmd\&.bData));

  //
  // Initialize some mutexs and conditions
  //


  pthread_mutex_init( &pmac_queue_mutex, &mutex_initializer);
  pthread_cond_init(  &pmac_queue_cond, NULL);

  lspmac_shutter_state = 0;                             // assume the shutter is now closed: not a big deal if we are wrong
  pthread_mutex_init( &lspmac_shutter_mutex, &mutex_initializer);
  pthread_cond_init(  &lspmac_shutter_cond, NULL);
  pmacfd\&.fd = -1;

  pthread_mutex_init( &lspmac_moving_mutex, &mutex_initializer);
  pthread_cond_init(  &lspmac_moving_cond, NULL);

  pthread_mutex_init( &lspmac_ascii_mutex, &mutex_initializer);

  pthread_mutex_init( &lspmac_ascii_buffers_mutex, &mutex_initializer);

  //
  // clear the ascii communications buffers
  //
  {
    uint32_t cc;
    cc = 0;
    lspmac_send_command( VR_UPLOAD, VR_PMAC_SETMEM, 0x0e9e, 0, 4, (char *)&cc, NULL, 1, NULL);

    cc = 0x18;
    lspmac_send_command( VR_UPLOAD, VR_PMAC_SETMEM, 0x0e9e, 0, 4, (char *)&cc, NULL, 1, NULL);
  }

  lspmac_SockSendDPline( NULL, 'I5=0');
  lspmac_SockSendDPline( NULL, 'ENABLE PLCC 0,2');
  lspmac_SockSendDPline( NULL, 'DISABLE PLCC 1');
  lspmac_SockSendDPline( NULL, 'I5=3');
}
.fi
.SS "int lspmac_jogabs_queue (\fBlspmac_motor_t\fP *, double)"

.PP
Use jog to move motor to requested position\&. 
.PP
Definition at line 3209 of file lspmac\&.c\&.
.PP
.nf
                            {
  
  return lspmac_move_or_jog_abs_queue( mp, requested_position, 1);
}
.fi
.SS "int lspmac_move_or_jog_abs_queue (\fBlspmac_motor_t\fP *mp, doublerequested_position, intuse_jo)"

.PP
Move method for normal stepper and servo motor objects Returns non-zero on abort, zero if OK\&. < format string for coordinate system move
.PP
< coordinate system bit
.PP
< the requested position in units of 'counts'
.PP
< motor and coordinate system;
.PP
< our axis \fBParameters:\fP
.RS 4
\fImp\fP The motor to move 
.br
\fIrequested_position\fP Where to move it 
.br
\fIuse_jo\fP 1 to force jog, 0 for motion prog 
.RE
.PP

.PP
Definition at line 2975 of file lspmac\&.c\&.
.PP
.nf
                            {
  char *fmt;                    
  int q100;                     
  int requested_pos_cnts;       
  int coord_num, motor_num;     
  char *axis;                   
  double u2c;
  double neutral_pos;
  double min_pos, max_pos;
  int pos_limit_hit, neg_limit_hit, in_position_band;
  struct timespec timeout, now;
  int err;

  pthread_mutex_lock( &(mp->mutex));

  u2c              = lsredis_getd(   mp->u2c);
  motor_num        = lsredis_getl(   mp->motor_num);
  coord_num        = lsredis_getl(   mp->coord_num);
  axis             = lsredis_getstr( mp->axis);
  neutral_pos      = lsredis_getd(   mp->neutral_pos);
  min_pos          = lsredis_getd(   mp->min_pos) - neutral_pos;
  max_pos          = lsredis_getd(   mp->max_pos) - neutral_pos;
  pos_limit_hit    = lsredis_getd(   mp->pos_limit_hit);
  neg_limit_hit    = lsredis_getd(   mp->neg_limit_hit);
  in_position_band = lsredis_getl(   mp->in_position_band);

  if( u2c == 0\&.0 || requested_position < min_pos || requested_position > max_pos) {
    //
    // Shouldn't try moving a motor that's in trouble
    //
    pthread_mutex_unlock( &(mp->mutex));
    lslogging_log_message( 'lspmac_move_or_jog_abs_queue: %s  u2c=%f  requested position=%f  min allowed=%f  max allowed=%f', mp->name, u2c, requested_position, min_pos, max_pos);
    lsevents_send_event( '%s Move Aborted', mp->name);
    return 1;
  }

  if( (neg_limit_hit && (requested_position < mp->position)) || (pos_limit_hit && (requested_position > mp->position))) {
    pthread_mutex_unlock( &(mp->mutex));
    lslogging_log_message( 'lspmac_move_or_jog_abs_queue: %s Moving wrong way on limit: requested position=%f  current position=%f  low limit=%d high limit=%d',
                           mp->name, requested_position, mp->position, neg_limit_hit, pos_limit_hit);
    lsevents_send_event( '%s Move Aborted', mp->name);
    return 2;
  }


  mp->requested_position = requested_position;
  if( mp->nlut > 0 && mp->lut != NULL) {
    mp->requested_pos_cnts = (int)lspmac_lut( mp->nlut, mp->lut, requested_position);
  } else {
    mp->requested_pos_cnts = u2c * (requested_position + neutral_pos);
  }
  requested_pos_cnts = mp->requested_pos_cnts;

  if( (abs( requested_pos_cnts - mp->actual_pos_cnts) * 16 < in_position_band) || (lsredis_getb( mp->active) != 1)) {
    //
    // Lie and say we moved even though we didn't\&.  Who will know? We are within the deadband or not active\&.
    //
    mp->not_done     = 0;
    mp->motion_seen  = 1;
    mp->command_sent = 1;

    if( lsredis_getb( mp->active) != 1) {
      //
      // fake the motion for simulated motors
      //
      mp->position = requested_position;
      mp->actual_pos_cnts = requested_pos_cnts;
    }
    pthread_mutex_unlock( &(mp->mutex));
    return 0;
  }

  mp->not_done     = 1;
  mp->motion_seen  = 0;
  mp->command_sent = 0;

  if( use_jog || axis == NULL || *axis == 0) {
    use_jog = 1;
  } else {
    use_jog = 0;
    q100 = 1 << (coord_num -1);
  }


  pthread_mutex_unlock( &(mp->mutex));

  if( !use_jog) {
    //
    // Make sure the coordinate system is not moving something, wait if it is
    //
    pthread_mutex_lock( &lspmac_moving_mutex);

    clock_gettime( CLOCK_REALTIME, &now);
    //
    // TODO: Have all moves estimate how long they'll take and use that here
    //
    timeout\&.tv_sec  = now\&.tv_sec + 60\&.0;           // a long timeout, but we might really be moving something that takes this long (or longer)
    timeout\&.tv_nsec = now\&.tv_nsec;

    err = 0;
    while( err == 0 &&  (lspmac_moving_flags & q100) != 0)
      err = pthread_cond_timedwait( &lspmac_moving_cond, &lspmac_moving_mutex, &timeout);
    
    pthread_mutex_unlock( &lspmac_moving_mutex);

    if( err == ETIMEDOUT) {
      lslogging_log_message( 'lspmac_move_or_jog_abs_queue: Timed Out\&.  lspmac_moving_flags = %0x', lspmac_moving_flags);
      lsevents_send_event( '%s Move Aborted', mp->name);
      return 1;
    }

    //
    // Set the 'we are moving this coordinate system' flag
    //
    lspmac_SockSendDPline( NULL, 'M5075=(M5075 | %d)', q100);
    
    switch( *axis) {
    case 'A':
      fmt = '&%d Q16=%d Q100=%d B146R';
      break;

    case 'B':
      fmt = '&%d Q17=%d Q100=%d B147R';
      break;

    case 'C':
      fmt = '&%d Q18=%d Q100=%d B148R';
      break;
    case 'X':
      fmt = '&%d Q10=%d Q100=%d B140R';
      break;

    case 'Y':
      fmt = '&%d Q11=%d Q100=%d B141R';
      break;

    case 'Z':
      fmt = '&%d Q12=%d Q100=%d B142R';
      break;

    case 'U':
      fmt = '&%d Q13=%d Q100=%d B143R';
      break;

    case 'V':
      fmt = '&%d Q14=%d Q100=%d B144R';
      break;

    case 'W':
      fmt = '&%d Q15=%d Q100=%d B145R';
      break;
    }

    //
    // Make sure the flag has been seen
    //

    clock_gettime( CLOCK_REALTIME, &now);
    timeout\&.tv_sec  = now\&.tv_sec + 4\&.0;            // also a long timeout\&.  This should really only take a few milliseconds on a slow day
    timeout\&.tv_nsec = now\&.tv_nsec;

    pthread_mutex_lock( &lspmac_moving_mutex);

    err = 0;
    while( err == 0 && (lspmac_moving_flags & q100) == 0)
      err = pthread_cond_timedwait( &lspmac_moving_cond, &lspmac_moving_mutex, &timeout);
    pthread_mutex_unlock( &lspmac_moving_mutex);

    if( err == ETIMEDOUT) {
      lslogging_log_message( 'lspmac_move_or_jog_abs_queue: Did not see flag propagate\&.  Move aborted\&.');
      lsevents_send_event( '%s Move Aborted', mp->name);
      return 1;
    }
  }

  pthread_mutex_lock( &(mp->mutex));
  if( use_jog) {
    lspmac_SockSendDPline( mp->name, '#%d j=%d', motor_num, requested_pos_cnts);
  } else {
    lspmac_SockSendDPline( mp->name, fmt, coord_num, requested_pos_cnts, q100);
  }
  pthread_mutex_unlock( &(mp->mutex));

  free( axis);

  return 0;
}
.fi
.SS "int lspmac_move_or_jog_preset_queue (\fBlspmac_motor_t\fP *, char *, int)"

.PP
move using a preset value returns 0 on success, non-zero on error 
.PP
Definition at line 3170 of file lspmac\&.c\&.
.PP
.nf
                                       {
  double pos;
  int err;
  int rtn;

  if( preset == NULL || *preset == 0) {
    lsevents_send_event( '%s Move Aborted', mp->name);
    return 0;
  }

  err = lsredis_find_preset( mp->name, preset, &pos);

  if( err != 0)
    rtn = lspmac_move_or_jog_abs_queue( mp, pos, use_jog);
  else {
    lsevents_send_event( '%s Move Aborted', mp->name);
    rtn = 1;
  }
  return rtn;
}
.fi
.SS "void lspmac_move_or_jog_queue (\fBlspmac_motor_t\fP *, double, int)"

.SS "int lspmac_move_preset_queue (\fBlspmac_motor_t\fP *mp, char *preset_name)"

.PP
Move a given motor to one of its preset positions\&. No movement if the preset is not found\&. 
.PP
\fBParameters:\fP
.RS 4
\fImp\fP lspmac motor pointer 
.br
\fIpreset_name\fP Name of the preset to use 
.RE
.PP

.PP
Definition at line 2360 of file lspmac\&.c\&.
.PP
.nf
                                                                     {
  double pos;
  int err;

  lslogging_log_message( 'lspmac_move_preset_queue: Called with motor %s and preset named '%s'', mp->name, preset_name);

  err = lsredis_find_preset( mp->name, preset_name, &pos);
  if( err == 0)
    return 1;

  err = mp->jogAbs( mp, pos);
  if( !err)
    lslogging_log_message( 'lspmac_move_preset_queue: moving %s to preset '%s' (%f)', mp->name, preset_name, pos);
  //
  // the abort event should have been sent in moveAbs
  //
  return err;
}
.fi
.SS "int lspmac_moveabs_queue (\fBlspmac_motor_t\fP *, double)"

.PP
Use coordinate system motion program, if available, to move motor to requested position\&. 
.PP
Definition at line 3198 of file lspmac\&.c\&.
.PP
.nf
                            {
  
  return lspmac_move_or_jog_abs_queue( mp, requested_position, 0);
}
.fi
.SS "int lspmac_moveabs_wait (\fBlspmac_motor_t\fP *mp, doubletimeout_secs)"

.PP
Wait for motor to finish moving\&. Assume motion already queued, now just wait
.PP
\fBParameters:\fP
.RS 4
\fImp\fP The motor object to wait for 
.br
\fItimeout_secs\fP The number of seconds to wait for\&. Fractional values fine\&. 
.RE
.PP

.PP
Definition at line 3224 of file lspmac\&.c\&.
.PP
.nf
                                                                  {
  struct timespec timeout, now;
  double isecs, fsecs;
  int err;

  //
  // Copy the queue item for the most recent move request
  //
  clock_gettime( CLOCK_REALTIME, &now);

  fsecs = modf( timeout_secs, &isecs);

  timeout\&.tv_sec  = now\&.tv_sec  + (long)floor( isecs);
  timeout\&.tv_nsec = now\&.tv_nsec + (long)floor( fsecs * 1\&.0e9);
  
  timeout\&.tv_sec  += timeout\&.tv_nsec / 1000000000;
  timeout\&.tv_nsec %= 1000000000;

  err = 0;
  pthread_mutex_lock( &(mp->mutex));
  
  while( err == 0 && mp->command_sent == 0)
    err = pthread_cond_timedwait( &mp->cond, &mp->mutex, &timeout);
  pthread_mutex_unlock( &(mp->mutex));
  if( err != 0) {
    if( err != ETIMEDOUT) {
      lslogging_log_message( 'lspmac_moveabs_wait: unexpected error from timedwait %d  tv_sec %ld   tv_nsec %ld', err, timeout\&.tv_sec, timeout\&.tv_nsec);
    }
    return 1;
  }

  //
  // wait for the motion to have started
  // This will time out if the motion ends before we can read the status back
  // hence the added complication of time stamp of the sent packet\&.

  err = 0;
  pthread_mutex_lock( &(mp->mutex));
  while( err == 0 && mp->motion_seen == 0)
    err = pthread_cond_timedwait( &(mp->cond), &(mp->mutex), &timeout);
  
  if( err != 0) {
    if( err != ETIMEDOUT) {
      lslogging_log_message( 'lspmac_moveabs_wait: unexpected error from timedwait: %d  tv_sec %ld   tv_nsec %ld', err, timeout\&.tv_sec, timeout\&.tv_nsec);
    }
    pthread_mutex_unlock( &(mp->mutex));
    return 1;
  }

  //
  // wait for the motion that we know has started to finish
  //
  err = 0;
  while( err == 0 && mp->not_done)
    err = pthread_cond_timedwait( &(mp->cond), &(mp->mutex), &timeout);

  
  if( err != 0) {
    if( err != ETIMEDOUT) {
      lslogging_log_message( 'lspmac_moveabs_wait: unexpected error from timedwait: %d  tv_sec %ld   tv_nsec %ld', err, timeout\&.tv_sec, timeout\&.tv_nsec);
    }
    pthread_mutex_unlock( &(mp->mutex));
    return 1;
  }

  //
  // if return code was not 0 then we know we shouldn't wait for not_done flag\&.
  // In this case the motion ended before we read the status registers
  //
  pthread_mutex_unlock( &(mp->mutex));
  return 0;
}
.fi
.SS "void lspmac_run ()"

.PP
Start up the lspmac thread\&. 
.PP
Definition at line 3856 of file lspmac\&.c\&.
.PP
.nf
                  {
  char **inits;
  lspmac_motor_t *mp;
  char evts[64];
  int i;
  int active;
  int motor_num;

  pthread_create( &pmac_thread, NULL, lspmac_worker, NULL);

  lsevents_add_listener( 'CryoSwitchChanged',    lspmac_cryoSwitchChanged_cb);
  lsevents_add_listener( 'scint In Position',    lspmac_scint_inPosition_cb);
  lsevents_add_listener( 'scintDried',           lspmac_scint_dried_cb);
  lsevents_add_listener( 'backLight 1',          lspmac_backLight_up_cb);
  lsevents_add_listener( 'backLight 0',          lspmac_backLight_down_cb);
  lsevents_add_listener( 'cam\&.zoom In Position', lspmac_light_zoom_cb);

  for( i=0; i<lspmac_nmotors; i++) {
    snprintf( evts, sizeof( evts)-1, '%s command accepted', lspmac_motors[i]\&.name);
    evts[sizeof(evts)-1] = 0;
    lsevents_add_listener( evts, lspmac_command_done_cb);
  }



  lspmac_zoom_lut_setup();
  lspmac_flight_lut_setup();
  lspmac_blight_lut_setup();
  lspmac_fscint_lut_setup();

  //
  // Clear the command interfaces
  //
  lspmac_SockSendControlCharPrint( NULL, '\x18');
  {
    uint32_t cc;
    cc = 0;
    lspmac_send_command( VR_UPLOAD, VR_PMAC_SETMEM, 0x0e9e, 0, 4, (char *)&cc, NULL, 1, NULL);

    cc = 0x18;
    lspmac_send_command( VR_UPLOAD, VR_PMAC_SETMEM, 0x0e9e, 0, 4, (char *)&cc, NULL, 1, NULL);
  }

  //
  // Initialize the MD2 pmac (ie, turn on the right plcc's etc)
  //
  /*
  for( inits = lsredis_get_string_array(lspmac_md2_init); *inits != NULL; inits++) {
    lspmac_SockSendDPline( NULL, *inits);
  }
  */

  //
  // Initialize the pmac's support for each motor
  // (ie, set the various flag for when a motor is active or not)
  //
  for( i=0; i<lspmac_nmotors; i++) {
    mp        = &(lspmac_motors[i]);
    active    = lsredis_getb( mp->active);
    motor_num = lsredis_getl( mp->motor_num);

    if( motor_num >= 1 && motor_num <= 32) {
      
      //
      // Set the PMAC to be consistant with redis
      //
      lspmac_SockSendDPline( NULL, 'I%d16=%f I%d17=%f I%d28=%d', motor_num, lsredis_getd( mp->max_speed), motor_num, lsredis_getd( mp->max_accel), motor_num, lsredis_getl( mp->in_position_band));
    }    

    // if there is a problem with 'active' then don't do anything
    // On the other hand, various combinations of yes/no true/fals 1/0 should work
    //
    switch( active) {
    case 1:
      inits = lsredis_get_string_array( mp->active_init);
      break;

    case 0:
      inits = lsredis_get_string_array( mp->inactive_init);
      break;

    default:
      lslogging_log_message( 'lspmac_run: motor %s is neither active nor inactive (!?)', mp->name);
      inits = NULL;
    }
    if( inits != NULL) {
      while( *inits != NULL) {
        lspmac_SockSendDPline( NULL, *inits);
        inits++;
      }
    }
  }
}
.fi
.SS "void lspmac_SockSendDPline (char *, char *fmt, \&.\&.\&.)"

.PP
prepare (queue up) a line to send the dpram ascii command interface 
.PP
Definition at line 1958 of file lspmac\&.c\&.
.PP
.nf
                                                         {
  va_list arg_ptr;
  uint32_t index;
  char *pl;
  
  pthread_mutex_lock( &lspmac_ascii_mutex);
  index = lspmac_dpascii_on++ % LSPMAC_DPASCII_QUEUE_LENGTH;

  pl = lspmac_dpascii_queue[index]\&.pl;

  va_start( arg_ptr, fmt);
  vsnprintf( pl, 159, fmt, arg_ptr);
  pl[159] = 0;
  va_end( arg_ptr);

  lspmac_dpascii_queue[index]\&.event = event;

  pthread_mutex_unlock( &lspmac_ascii_mutex);
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_SockSendline (char *event, char *fmt, \&.\&.\&.)"

.PP
Send a one line command\&. Uses printf style arguments\&. \fBParameters:\fP
.RS 4
\fIevent\fP base name for events 
.br
\fIfmt\fP Printf style format string 
.RE
.PP

.PP
Definition at line 1066 of file lspmac\&.c\&.
.PP
.nf
                                         {
  va_list arg_ptr;
  char payload[1400];

  va_start( arg_ptr, fmt);
  vsnprintf( payload, sizeof(payload)-1, fmt, arg_ptr);
  payload[ sizeof(payload)-1] = 0;
  va_end( arg_ptr);

  lslogging_log_message( payload);

  return lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDLINE, 0, 0, strlen( payload), payload, lspmac_GetShortReplyCB, 0, event);
}
.fi
.SS "void lspmac_video_rotate (doublesecs)"

.PP
Special motion program to collect centering video\&. 
.PP
Definition at line 2577 of file lspmac\&.c\&.
.PP
.nf
                                       {
  double q10;           // starting position (counts)
  double q11;           // delta counts
  double q12;           // milliseconds to run over delta
  
  double u2c;
  double neutral_pos;

  if( secs <= 0\&.0)
    return;

  omega_zero_search = 1;

  pthread_mutex_lock( &(omega->mutex));
  u2c         = lsredis_getd( omega->u2c);
  neutral_pos = lsredis_getd( omega->neutral_pos);

  q10 = neutral_pos * u2c;
  q11 = 360\&.0 * u2c;
  q12 = 1000 * secs;
  

  omega_zero_velocity = 360\&.0 * u2c / secs;      // counts/second to back calculate zero crossing time

  lspmac_SockSendDPline( omega->name, '&1 Q10=%\&.1f Q11=%\&.1f Q12=%\&.1f Q13=(I117) Q14=(I116) B240R', q10, q11, q12);
  pthread_mutex_unlock( &(omega->mutex));
}
.fi
.SS "int lsredis_cmpnstr (\fBlsredis_obj_t\fP *p, char *s, intn)"

.PP
Definition at line 236 of file lsredis\&.c\&.
.PP
.nf
                                                       {
  int rtn;
  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0)
    pthread_cond_wait( &p->cond, &p->mutex);
  
  rtn = strncmp( p->value, s, n);
  pthread_mutex_unlock( &p->mutex);
  return rtn;
}
.fi
.SS "int lsredis_cmpstr (\fBlsredis_obj_t\fP *p, char *s)"

.PP
Definition at line 225 of file lsredis\&.c\&.
.PP
.nf
                                               {
  int rtn;
  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0)
    pthread_cond_wait( &p->cond, &p->mutex);
  
  rtn = strcmp( p->value, s);
  pthread_mutex_unlock( &p->mutex);
  return rtn;
}
.fi
.SS "int lsredis_find_preset (char *base, char *preset_name, double *dval)"

.PP
Definition at line 756 of file lsredis\&.c\&.
.PP
.nf
                                                                      {
  char s[512];
  int i;
  int err;
  ENTRY htab_input, *htab_output;
  lsredis_obj_t *p;

  i = 0;
  for( i=0; i<1024; i++) {
    snprintf( s, sizeof( s)-1, '%s\&.%s\&.presets\&.%d\&.name', lsredis_head, base, i);
    s[sizeof(s)-1] = 0;
    htab_input\&.key  = s;
    htab_input\&.data = NULL;
    err = hsearch_r( htab_input, FIND, &htab_output, &lsredis_htab);
    if( err == 0) {
      // We've run out of names to look for: done
      lslogging_log_message( 'lsredis_find_preset: no preset for motor %s named '%s'', base, preset_name);
      *dval = 0\&.0;
      return 0;
    }

    // Check if we have a match
    p = htab_output->data;
    if( lsredis_cmpstr( p, preset_name)==0) {
      // got a match, now look for the position
      snprintf( s, sizeof( s)-1, '%s\&.%s\&.presets\&.%d\&.position', lsredis_head, base, i);
      s[sizeof(s)-1] = 0;
      htab_input\&.key = s;
      htab_input\&.data = NULL;
      err = hsearch_r( htab_input, FIND, &htab_output, &lsredis_htab);
      if( err == 0) {
        // Name but not position? odd\&.
        lslogging_log_message( 'lsredis_find_preset: Error, motor %s preset '%s' has no position defined', base, preset_name);
        *dval = 0\&.0;
        return 0;
      }
      p = htab_output->data;
      *dval = lsredis_getd( p);
      return 1;
    }
  }
  // How'd we get here?
  // did someone really define that many presets?  And then looked for one that's not there?
  *dval = 0;
  return 0;
}
.fi
.SS "\fBlsredis_obj_t\fP* lsredis_get_obj (char *, \&.\&.\&.)"

.PP
Definition at line 524 of file lsredis\&.c\&.
.PP
.nf
                                                {
  lsredis_obj_t *rtn;
  va_list arg_ptr;
  char k[512];
  char *kp;
  int nkp;

  va_start( arg_ptr, fmt);
  vsnprintf( k, sizeof(k)-1, fmt, arg_ptr);
  k[sizeof(k)-1] = 0;
  va_end( arg_ptr);

  nkp = strlen(k) + strlen( lsredis_head) + 16;         // 16 is overkill\&. I know\&. Get over it\&.
  kp = calloc( nkp, sizeof( char));
  if( kp == NULL) {
    lslogging_log_message( 'lsredis_get_obj: Out of memory');
    exit( -1);
  }
  
  snprintf( kp, nkp-1, '%s\&.%s', lsredis_head, k);
  kp[nkp-1] = 0;

  pthread_mutex_lock( &lsredis_mutex);
  while( lsredis_running == 0)
    pthread_cond_wait( &lsredis_cond, &lsredis_mutex);

  rtn = _lsredis_get_obj( kp);
  pthread_mutex_unlock( &lsredis_mutex);

  free( kp);
  return rtn;
}
.fi
.SS "char** lsredis_get_string_array (\fBlsredis_obj_t\fP *p)"

.PP
Definition at line 365 of file lsredis\&.c\&.
.PP
.nf
                                                   {
  char **rtn;

  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0)
    pthread_cond_wait( &p->cond, &p->mutex);

  rtn = p->avalue;
  pthread_mutex_unlock( &p->mutex);
  
  return rtn;
}
.fi
.SS "int lsredis_getb (\fBlsredis_obj_t\fP *p)"

.PP
Definition at line 378 of file lsredis\&.c\&.
.PP
.nf
                                    {
  int rtn;

  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0)
    pthread_cond_wait( &p->cond, &p->mutex);

  rtn = p->bvalue;
  pthread_mutex_unlock( &p->mutex);
  
  return rtn;
}  
.fi
.SS "char lsredis_getc (\fBlsredis_obj_t\fP *p)"

.PP
Definition at line 391 of file lsredis\&.c\&.
.PP
.nf
                                     {
  int rtn;

  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0)
    pthread_cond_wait( &p->cond, &p->mutex);

  rtn = p->cvalue;
  pthread_mutex_unlock( &p->mutex);
  
  return rtn;
}  
.fi
.SS "double lsredis_getd (\fBlsredis_obj_t\fP *p)"

.PP
Definition at line 339 of file lsredis\&.c\&.
.PP
.nf
                                       {
  double rtn;

  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0)
    pthread_cond_wait( &p->cond, &p->mutex);

  rtn = p->dvalue;
  pthread_mutex_unlock( &p->mutex);
  
  return rtn;
}
.fi
.SS "long int lsredis_getl (\fBlsredis_obj_t\fP *p)"

.PP
Definition at line 352 of file lsredis\&.c\&.
.PP
.nf
                                         {
  long int rtn;

  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0)
    pthread_cond_wait( &p->cond, &p->mutex);

  rtn = p->lvalue;
  pthread_mutex_unlock( &p->mutex);
  
  return rtn;
}  
.fi
.SS "char* lsredis_getstr (\fBlsredis_obj_t\fP *p)"

.PP
return a copy of the key's string value 
.PP
Definition at line 263 of file lsredis\&.c\&.
.PP
.nf
                                        {
  char *rtn;

  //
  // Have to use strdup since we cannot guarantee that p->value won't be freed while the caller is still using it
  //
  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0)
    pthread_cond_wait( &p->cond, &p->mutex);

  rtn = strdup(p->value);
  pthread_mutex_unlock( &p->mutex);
  return rtn;
}
.fi
.SS "void lsredis_init (char *pub, char *re, char *head)"

.PP
Initialize this module, that is, set up the connections\&. \fBParameters:\fP
.RS 4
\fIpub\fP Publish under this (unique) name 
.br
\fIre\fP Regular expression to select keys we want to mirror 
.br
\fIhead\fP Prepend this (+ a dot) to the beginning of requested objects 
.RE
.PP

.PP
Definition at line 810 of file lsredis\&.c\&.
.PP
.nf
                                                    {
  int err;
  int nerrmsg;
  char *errmsg;

  //
  // set up hash map to store redis objects
  //
  err = hcreate_r( 8192, &lsredis_htab);
  if( err == 0) {
    lslogging_log_message( 'lsredis_init: Cannot create hash table\&.  Really bad things are going to happen\&.  hcreate_r returned %d', err);
  }

  lsredis_head      = strdup( head);
  lsredis_publisher = strdup( pub);

  
  pthread_cond_init( &lsredis_cond, NULL);

  subac = redisAsyncConnect('127\&.0\&.0\&.1', 6379);
  if( subac->err) {
    lslogging_log_message( 'Error: %s', subac->errstr);
  }

  subfd\&.fd           = subac->c\&.fd;
  subfd\&.events       = 0;
  subac->ev\&.data     = &subfd;
  subac->ev\&.addRead  = lsredis_addRead;
  subac->ev\&.delRead  = lsredis_delRead;
  subac->ev\&.addWrite = lsredis_addWrite;
  subac->ev\&.delWrite = lsredis_delWrite;
  subac->ev\&.cleanup  = lsredis_cleanup;

  roac = redisAsyncConnect('127\&.0\&.0\&.1', 6379);
  if( roac->err) {
    lslogging_log_message( 'Error: %s', roac->errstr);
  }

  rofd\&.fd           = roac->c\&.fd;
  rofd\&.events       = 0;
  roac->ev\&.data     = &rofd;
  roac->ev\&.addRead  = lsredis_addRead;
  roac->ev\&.delRead  = lsredis_delRead;
  roac->ev\&.addWrite = lsredis_addWrite;
  roac->ev\&.delWrite = lsredis_delWrite;
  roac->ev\&.cleanup  = lsredis_cleanup;

  //wrac = redisAsyncConnect('10\&.1\&.0\&.3', 6379);
  wrac = redisAsyncConnect('127\&.0\&.0\&.1', 6379);
  if( wrac->err) {
    lslogging_log_message( 'Error: %s', wrac->errstr);
  }

  wrfd\&.fd           = wrac->c\&.fd;
  wrfd\&.events       = 0;
  wrac->ev\&.data     = &wrfd;
  wrac->ev\&.addRead  = lsredis_addRead;
  wrac->ev\&.delRead  = lsredis_delRead;
  wrac->ev\&.addWrite = lsredis_addWrite;
  wrac->ev\&.delWrite = lsredis_delWrite;
  wrac->ev\&.cleanup  = lsredis_cleanup;

  err = regcomp( &lsredis_key_select_regex, re, REG_EXTENDED);
  if( err != 0) {
    nerrmsg = regerror( err, &lsredis_key_select_regex, NULL, 0);
    if( nerrmsg > 0) {
      errmsg = calloc( nerrmsg, sizeof( char));
      nerrmsg = regerror( err, &lsredis_key_select_regex, errmsg, nerrmsg);
      lslogging_log_message( 'lsredis_select: %s', errmsg);
      free( errmsg);
    }
  }
}
.fi
.SS "int lsredis_regexec (const regex_t *preg, \fBlsredis_obj_t\fP *p, size_tnmatch, regmatch_t *pmatch, inteflags)"

.PP
Definition at line 247 of file lsredis\&.c\&.
.PP
.nf
                                                                                                           {
  int rtn;

  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0) 
    pthread_cond_wait( &p->cond, &p->mutex);

  rtn = regexec( preg, p->value, nmatch, pmatch, eflags);

  pthread_mutex_unlock( &p->mutex);

  return rtn;
}
.fi
.SS "void lsredis_run ()"

.PP
Definition at line 1014 of file lsredis\&.c\&.
.PP
.nf
                   {
  pthread_create( &lsredis_thread, NULL, lsredis_worker, NULL);
}
.fi
.SS "void lsredis_setstr (\fBlsredis_obj_t\fP *p, char *fmt, \&.\&.\&.)"

.PP
Set the value and update redis\&. Note that lsredis_set_value sets the value based on redis while here we set redis based on the value Arbitray maximum string length set here\&. TODO: Probably this limit should be removed at some point\&.
.PP
redisAsyncCommandArgv used instead of redisAsyncCommand 'cause it's easier (and possible) to deal with strings that would otherwise cause hiredis to emit a bad command, like those containing spaces\&. < up the count of times we need to see ourselves published before we start listening to others again
.PP
< Unlock to prevent deadlock in case the service routine needs to set our value
.PP
< redisAsyncCommandArgv shouldn't need to access this after it's made up it's packet (before it returns) so we should be OK with this location disappearing soon\&. 
.PP
Definition at line 288 of file lsredis\&.c\&.
.PP
.nf
                                                       {
  va_list arg_ptr;
  char v[512];
  char *argv[4];

  va_start( arg_ptr, fmt);
  vsnprintf( v, sizeof(v)-1, fmt, arg_ptr);
  v[sizeof(v)-1] = 0;
  va_end( arg_ptr);
  
  pthread_mutex_lock( &p->mutex);

  //
  // Don't send an update if a good value has not changed
  //
  if( p->valid && strcmp( v, p->value) == 0) {
    // nothing to do
    pthread_mutex_unlock( &p->mutex);
    return;
  }

  p->wait_for_me++;                     
  pthread_mutex_unlock( &p->mutex);     


  argv[0] = 'HSET';
  argv[1] = p->key;
  argv[2] = 'VALUE';
  argv[3] = v;          


  pthread_mutex_lock( &lsredis_mutex);
  while( lsredis_running == 0)
    pthread_cond_wait( &lsredis_cond, &lsredis_mutex);

  redisAsyncCommand( wrac, NULL, NULL, 'MULTI');
  redisAsyncCommandArgv( wrac, NULL, NULL, 4, (const char **)argv, NULL);

  redisAsyncCommand( wrac, NULL, NULL, 'PUBLISH %s %s', lsredis_publisher, p->key);
  redisAsyncCommand( wrac, NULL, NULL, 'EXEC');
  pthread_mutex_unlock( &lsredis_mutex);

  // Assume redis will take exactly the value we sent it
  //
  pthread_mutex_lock( &p->mutex);
  _lsredis_set_value( p, v);
  pthread_cond_signal( &p->cond);
  pthread_mutex_unlock( &p->mutex);
}
.fi
.SS "void lstest_main ()"

.PP
Definition at line 92 of file lstest\&.c\&.
.PP
.nf
                   {
  lstest_lspmac_est_move_time();
}
.fi
.SS "void lstimer_add_timer (char *event, intshots, unsigned long intsecs, unsigned long intnsecs)"

.PP
Create a timer\&. \fBParameters:\fP
.RS 4
\fIevent\fP Name of the event to send when the timer goes off 
.br
\fIshots\fP Number of times to run\&. 0 means never, -1 means forever 
.br
\fIsecs\fP Number of seconds to wait 
.br
\fInsecs\fP Number of nano-seconds to run in addition to secs 
.RE
.PP

.PP
Definition at line 50 of file lstimer\&.c\&.
.PP
.nf
                                                                                                 {
  int i;
  struct timespec now;


  // Time we were called\&.  Delay is based on call time, not queued time
  //
  clock_gettime( CLOCK_REALTIME, &now);
  

  pthread_mutex_lock( &lstimer_mutex);

  for( i=0; i<LSTIMER_LIST_LENGTH; i++) {
    if( lstimer_list[i]\&.shots == 0)
      break;
  }

  if( i == LSTIMER_LIST_LENGTH) {
    pthread_mutex_unlock( &lstimer_mutex);
    
    lslogging_log_message( 'lstimer_add_timer: out of timers for event: %s, shots: %d,  secs: %u, nsecs: %u',
                          event, shots, secs, nsecs);
    return;
  }

  strncpy( lstimer_list[i]\&.event, event, LSEVENTS_EVENT_LENGTH - 1);
  lstimer_list[i]\&.event[LSEVENTS_EVENT_LENGTH - 1] = 0;
  lstimer_list[i]\&.shots        = shots;
  lstimer_list[i]\&.delay_secs   = secs;
  lstimer_list[i]\&.delay_nsecs  = nsecs;

  lstimer_list[i]\&.next_secs    = secs + now\&.tv_sec + (now\&.tv_nsec + nsecs) / 1000000000;
  lstimer_list[i]\&.next_nsecs   = (now\&.tv_nsec + nsecs) % 1000000000;
  lstimer_list[i]\&.last_secs    = 0;
  lstimer_list[i]\&.last_nsecs   = 0;
  
  lstimer_list[i]\&.ncalls       = 0;
  lstimer_list[i]\&.init_secs    = now\&.tv_sec;
  lstimer_list[i]\&.init_nsecs   = now\&.tv_nsec;

  if( shots != 0) {
    lstimer_active_timers++;
    new_timer++;
  }

  pthread_cond_signal(  &lstimer_cond);
  pthread_mutex_unlock( &lstimer_mutex);
}
.fi
.SS "void lstimer_init ()"

.PP
Initialize the timer list and pthread stuff\&. 
.PP
Definition at line 259 of file lstimer\&.c\&.
.PP
.nf
                    {
  int i;

  for( i=0; i<LSTIMER_LIST_LENGTH; i++) {
    lstimer_list[i]\&.shots = 0;
  }


  pthread_mutex_init( &lstimer_mutex, NULL);
  pthread_cond_init(  &lstimer_cond, NULL);
}
.fi
.SS "void lstimer_run ()"

.PP
Start up our thread\&. 
.PP
Definition at line 273 of file lstimer\&.c\&.
.PP
.nf
                   {
  pthread_create( &lstimer_thread, NULL, lstimer_worker, NULL);
}
.fi
.SS "void lsupdate_init ()"

.SS "void lsupdate_run ()"

.SS "void md2cmds_init ()"

.PP
Initialize the md2cmds module\&. 
.PP
Definition at line 1433 of file md2cmds\&.c\&.
.PP
.nf
                    {
  ENTRY hloader, *hrtnval;
  int i, err;

  pthread_mutexattr_t mutex_initializer;

  pthread_mutexattr_init( &mutex_initializer);
  pthread_mutexattr_settype( &mutex_initializer, PTHREAD_MUTEX_RECURSIVE);

  pthread_mutex_init( &md2cmds_mutex, &mutex_initializer);
  pthread_cond_init( &md2cmds_cond, NULL);


  pthread_mutex_init( &md2cmds_moving_mutex, &mutex_initializer);
  pthread_cond_init(  &md2cmds_moving_cond, NULL);

  pthread_mutex_init( &md2cmds_homing_mutex, &mutex_initializer);
  pthread_cond_init(  &md2cmds_homing_cond, NULL);

  md2cmds_md_status_code = lsredis_get_obj( 'md2_status_code');
  lsredis_setstr( md2cmds_md_status_code, '7');

  hcreate_r( 32, &md2cmds_hmap);
  for( i=0; i<sizeof(md2cmds_cmd_kvs)/sizeof(md2cmds_cmd_kvs[0]); i++) {
    hloader\&.key  = md2cmds_cmd_kvs[i]\&.k;
    hloader\&.data = md2cmds_cmd_kvs[i]\&.v;
    err = hsearch_r( hloader, ENTER, &hrtnval, &md2cmds_hmap);
    if( err == 0) {
      lslogging_log_message( 'md2cmds_init: hsearch_r returned an error for item %d: %s', i, strerror( errno));
    }
  }

}
.fi
.SS "void md2cmds_run ()"

.PP
Start up the thread\&. 
.PP
Definition at line 1469 of file md2cmds\&.c\&.
.PP
.nf
                   {
  pthread_create( &md2cmds_thread, NULL,              md2cmds_worker, NULL);
  lsevents_add_listener( 'omega crossed zero',        md2cmds_rotate_cb);
  lsevents_add_listener( 'omega In Position',         md2cmds_maybe_rotate_done_cb);
  lsevents_add_listener( '\&.+ (Moving|In Position)',   md2cmds_maybe_done_moving_cb);
  lsevents_add_listener( '(\&.+) (Homing|Homed)',       md2cmds_maybe_done_homing_cb);
  lsevents_add_listener( 'capz (Moving|In Position)', md2cmds_time_capz_cb);
  lsevents_add_listener( 'Coordsys 1 Stopped',        md2cmds_coordsys_1_stopped_cb);
  lsevents_add_listener( 'Coordsys 2 Stopped',        md2cmds_coordsys_2_stopped_cb);
  lsevents_add_listener( 'Coordsys 3 Stopped',        md2cmds_coordsys_3_stopped_cb);
  lsevents_add_listener( 'Coordsys 4 Stopped',        md2cmds_coordsys_4_stopped_cb);
  lsevents_add_listener( 'Coordsys 5 Stopped',        md2cmds_coordsys_5_stopped_cb);
  lsevents_add_listener( 'Coordsys 7 Stopped',        md2cmds_coordsys_7_stopped_cb);
}
.fi
.SS "void pgpmac_printf (char *fmt, \&.\&.\&.)"

.PP
Terminal output routine ala printf\&. \fBParameters:\fP
.RS 4
\fIfmt\fP Printf style formating string 
.RE
.PP

.PP
Definition at line 330 of file pgpmac\&.c\&.
.PP
.nf
                     {
  va_list arg_ptr;

  pthread_mutex_lock( &ncurses_mutex);

  va_start( arg_ptr, fmt);
  vwprintw( term_output, fmt, arg_ptr);
  va_end( arg_ptr);

  wnoutrefresh( term_output);
  wnoutrefresh( term_input);
  doupdate();

  pthread_mutex_unlock( &ncurses_mutex);

}
.fi
.SS "void PmacSockSendline (char *s)"

.SH "Variable Documentation"
.PP 
.SS "\fBlspmac_motor_t\fP* alignx"

.PP
Alignment stage X\&. 
.PP
Definition at line 90 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* aligny"

.PP
Alignment stage Y\&. 
.PP
Definition at line 91 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* alignz"

.PP
Alignment stage X\&. 
.PP
Definition at line 92 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* anal"

.PP
Polaroid analyzer motor\&. 
.PP
Definition at line 93 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* apery"

.PP
Aperture Y\&. 
.PP
Definition at line 95 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* aperz"

.PP
Aperture Z\&. 
.PP
Definition at line 96 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* arm_parked"

.PP
(whose arm? parked where?) 
.PP
Definition at line 133 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* blight"

.PP
Back Light DAC\&. 
.PP
Definition at line 107 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* blight_down"

.PP
Backlight is down\&. 
.PP
Definition at line 123 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* blight_f"

.PP
Back light scale factor\&. 
.PP
Definition at line 116 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* blight_ud"

.PP
Back light Up/Down actuator\&. 
.PP
Definition at line 111 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* blight_up"

.PP
Backlight is up\&. 
.PP
Definition at line 124 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* capy"

.PP
Capillary Y\&. 
.PP
Definition at line 97 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* capz"

.PP
Capillary Z\&. 
.PP
Definition at line 98 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* cenx"

.PP
Centering Table X\&. 
.PP
Definition at line 100 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* ceny"

.PP
Centering Table Y\&. 
.PP
Definition at line 101 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* cryo"

.PP
Move the cryostream towards or away from the crystal\&. 
.PP
Definition at line 112 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* cryo_back"

.PP
cryo is in the back position 
.PP
Definition at line 125 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* cryo_switch"

.PP
that little toggle switch for the cryo 
.PP
Definition at line 122 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* dryer"

.PP
blow air on the scintilator to dry it off 
.PP
Definition at line 113 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* etel_init_ok"

.PP
ETEL initialized OK\&. 
.PP
Definition at line 130 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* etel_on"

.PP
ETEL is on\&. 
.PP
Definition at line 129 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* etel_ready"

.PP
ETEL is ready\&. 
.PP
Definition at line 128 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* flight"

.PP
Front Light DAC\&. 
.PP
Definition at line 106 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* flight_f"

.PP
Front light scale factor\&. 
.PP
Definition at line 117 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* flight_oo"

.PP
Turn front light on/off\&. 
.PP
Definition at line 115 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* fluo"

.PP
Move the fluorescence detector in/out\&. 
.PP
Definition at line 114 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* fluor_back"

.PP
fluor is in the back position 
.PP
Definition at line 126 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* fscint"

.PP
Scintillator Piezo DAC\&. 
.PP
Definition at line 108 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* fshut"

.PP
Fast shutter\&. 
.PP
Definition at line 105 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* hp_air"

.PP
High pressure air OK\&. 
.PP
Definition at line 121 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* kappa"

.PP
Kappa\&. 
.PP
Definition at line 102 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* lp_air"

.PP
Low pressure air OK\&. 
.PP
Definition at line 120 of file lspmac\&.c\&.
.SS "\fBlspg_demandairrights_t\fP lspg_demandairrights"

.PP
our demandairrights object 
.PP
Definition at line 66 of file lspg\&.c\&.
.SS "\fBlspg_getcenter_t\fP lspg_getcenter"

.PP
the getcenter object 
.PP
Definition at line 65 of file lspg\&.c\&.
.SS "\fBlspg_getcurrentsampleid_t\fP lspg_getcurrentsampleid"

.PP
our currentsample id 
.PP
Definition at line 67 of file lspg\&.c\&.
.SS "\fBlspg_nextsample_t\fP lspg_nextsample"

.PP
the very next sample 
.PP
Definition at line 63 of file lspg\&.c\&.
.SS "\fBlspg_nextshot_t\fP lspg_nextshot"

.PP
the nextshot object 
.PP
Definition at line 64 of file lspg\&.c\&.
.SS "\fBlspg_starttransfer_t\fP lspg_starttransfer"

.PP
start a sample transfer 
.PP
Definition at line 68 of file lspg\&.c\&.
.SS "\fBlspg_waitcryo_t\fP lspg_waitcryo"

.PP
signal the robot 
.PP
Definition at line 69 of file lspg\&.c\&.
.SS "\fBlspmac_motor_t\fP lspmac_motors[]"

.PP
All our motors\&. 
.PP
Definition at line 87 of file lspmac\&.c\&.
.SS "pthread_cond_t lspmac_moving_cond"

.PP
Wait for motor(s) to finish moving condition\&. 
.PP
Definition at line 64 of file lspmac\&.c\&.
.SS "int lspmac_moving_flags"

.PP
Flag used to implement motor moving condition\&. 
.PP
Definition at line 65 of file lspmac\&.c\&.
.SS "pthread_mutex_t lspmac_moving_mutex"

.PP
Coordinate moving motors between threads\&. 
.PP
Definition at line 63 of file lspmac\&.c\&.
.SS "int lspmac_nmotors"

.PP
The number of motors we manage\&. 
.PP
Definition at line 88 of file lspmac\&.c\&.
.SS "pthread_cond_t lspmac_shutter_cond"

.PP
Allows waiting for the shutter status to change\&. 
.PP
Definition at line 62 of file lspmac\&.c\&.
.SS "int lspmac_shutter_has_opened"

.PP
Indicates that the shutter had opened, perhaps briefly even if the state did not change\&. 
.PP
Definition at line 60 of file lspmac\&.c\&.
.SS "pthread_mutex_t lspmac_shutter_mutex"

.PP
Coordinates threads reading shutter status\&. 
.PP
Definition at line 61 of file lspmac\&.c\&.
.SS "int lspmac_shutter_state"

.PP
State of the shutter, used to detect changes\&. 
.PP
Definition at line 59 of file lspmac\&.c\&.
.SS "pthread_mutex_t md2_status_mutex"

.PP
Synchronize reading/writting status buffer\&. 
.PP
Definition at line 341 of file lspmac\&.c\&.
.SS "char md2cmds_cmd[]"

.PP
our command; 
.PP
Definition at line 24 of file md2cmds\&.c\&.
.SS "pthread_cond_t md2cmds_cond"

.PP
condition to signal when it's time to run an md2 command 
.PP
Definition at line 10 of file md2cmds\&.c\&.
.SS "\fBlsredis_obj_t\fP* md2cmds_md_status_code"

.PP
Definition at line 26 of file md2cmds\&.c\&.
.SS "pthread_mutex_t md2cmds_mutex"

.PP
mutex for the condition 
.PP
Definition at line 11 of file md2cmds\&.c\&.
.SS "pthread_cond_t md2cmds_pg_cond"

.SS "pthread_mutex_t md2cmds_pg_mutex"

.SS "\fBlspmac_bi_t\fP* minikappa_ok"

.PP
Minikappa is OK (whatever that means) 
.PP
Definition at line 131 of file lspmac\&.c\&.
.SS "pthread_mutex_t ncurses_mutex"

.PP
allow more than one thread access to the screen 
.PP
Definition at line 242 of file pgpmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* omega"

.PP
MD2 omega axis (the air bearing) 
.PP
Definition at line 89 of file lspmac\&.c\&.
.SS "struct timespec omega_zero_time"

.PP
Time we believe that omega crossed zero\&. 
.PP
Definition at line 72 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* phi"

.PP
Phi (not data collection axis) 
.PP
Definition at line 103 of file lspmac\&.c\&.
.SS "pthread_cond_t pmac_queue_cond"

.PP
wait for a command to be sent to PMAC before continuing 
.PP
Definition at line 78 of file lspmac\&.c\&.
.SS "pthread_mutex_t pmac_queue_mutex"

.PP
manage access to the pmac command queue 
.PP
Definition at line 77 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* sample_detected"

.PP
smart magnet detected sample 
.PP
Definition at line 127 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* scint"

.PP
Scintillator Z\&. 
.PP
Definition at line 99 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* shutter_open"

.PP
shutter is open (note in pmc says this is a slow input) 
.PP
Definition at line 134 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* smart_mag_err"

.PP
smart magnet error (coil broken perhaps) 
.PP
Definition at line 135 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* smart_mag_off"

.PP
smart magnet is off 
.PP
Definition at line 136 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* smart_mag_on"

.PP
smart magnet is on 
.PP
Definition at line 132 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* smart_mag_oo"

.PP
Smart Magnet on/off\&. 
.PP
Definition at line 110 of file lspmac\&.c\&.
.SS "WINDOW* term_input"

.PP
place to put the cursor 
.PP
Definition at line 238 of file pgpmac\&.c\&.
.SS "WINDOW* term_output"

.PP
place to print stuff out 
.PP
Definition at line 237 of file pgpmac\&.c\&.
.SS "WINDOW* term_status"

.PP
shutter, lamp, air, etc status 
.PP
Definition at line 239 of file pgpmac\&.c\&.
.SS "WINDOW* term_status2"

.PP
shutter, lamp, air, etc status 
.PP
Definition at line 240 of file pgpmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* zoom"

.PP
Optical zoom\&. 
.PP
Definition at line 94 of file lspmac\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for LS-CAT PGPMAC from the source code\&.
