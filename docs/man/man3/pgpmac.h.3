.TH "pgpmac.h" 3 "Thu Nov 29 2012" "LS-CAT PGPMAC" \" -*- nroff -*-
.ad l
.nh
.SH NAME
pgpmac.h \- 
.PP
Headers for the entire pgpmac project\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <stdio\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include <sys/socket\&.h>\fP
.br
\fC#include <netdb\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <netinet/in\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br
\fC#include <poll\&.h>\fP
.br
\fC#include <libpq-fe\&.h>\fP
.br
\fC#include <ncurses\&.h>\fP
.br
\fC#include <math\&.h>\fP
.br
\fC#include <pthread\&.h>\fP
.br
\fC#include <signal\&.h>\fP
.br
\fC#include <sys/signalfd\&.h>\fP
.br
\fC#include <sys/time\&.h>\fP
.br
\fC#include <time\&.h>\fP
.br
\fC#include <getopt\&.h>\fP
.br
\fC#include <regex\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBtagEthernetCmd\fP"
.br
.RI "\fIPMAC ethernet packet definition\&. \fP"
.ti -1c
.RI "struct \fBlspmac_cmd_queue_struct\fP"
.br
.RI "\fIPMAC command queue item\&. \fP"
.ti -1c
.RI "struct \fBlskvs_kvs_struct\fP"
.br
.RI "\fIStorage for the key value pairs\&. \fP"
.ti -1c
.RI "struct \fBlskvs_kvs_list_struct\fP"
.br
.RI "\fIA second linked list type to handle private lists of KVs\&. \fP"
.ti -1c
.RI "struct \fBlspmac_motor_struct\fP"
.br
.RI "\fIMotor information\&. \fP"
.ti -1c
.RI "struct \fBlspmac_bi_struct\fP"
.br
.RI "\fIStorage for binary inputs\&. \fP"
.ti -1c
.RI "struct \fBlspg_getcenter_struct\fP"
.br
.RI "\fIStorage for getcenter query Used for the md2 ROTATE command that generates the centering movies\&. \fP"
.ti -1c
.RI "struct \fBlspg_nextshot_struct\fP"
.br
.RI "\fIStorage definition for nextshot query\&. \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBLS_DISPLAY_WINDOW_HEIGHT\fP   8"
.br
.RI "\fINumber of status box rows\&. \fP"
.ti -1c
.RI "#define \fBLS_DISPLAY_WINDOW_WIDTH\fP   24"
.br
.RI "\fINumber of status box columns\&. \fP"
.ti -1c
.RI "#define \fBLS_PG_QUERY_STRING_LENGTH\fP   1024"
.br
.RI "\fIFixed length postgresql query strings\&. Queries should all be function calls so this is not as weird as one might think\&. \fP"
.ti -1c
.RI "#define \fBLSEVENTS_EVENT_LENGTH\fP   32"
.br
.RI "\fIFixed length for event names: simplifies string handling\&. \fP"
.ti -1c
.RI "#define \fBMD2CMDS_CMD_LENGTH\fP   32"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBtagEthernetCmd\fP \fBpmac_cmd_t\fP"
.br
.RI "\fIPMAC ethernet packet definition\&. \fP"
.ti -1c
.RI "typedef struct 
.br
\fBlspmac_cmd_queue_struct\fP \fBpmac_cmd_queue_t\fP"
.br
.RI "\fIPMAC command queue item\&. \fP"
.ti -1c
.RI "typedef struct \fBlskvs_kvs_struct\fP \fBlskvs_kvs_t\fP"
.br
.RI "\fIStorage for the key value pairs\&. \fP"
.ti -1c
.RI "typedef struct 
.br
\fBlskvs_kvs_list_struct\fP \fBlskvs_kvs_list_t\fP"
.br
.RI "\fIA second linked list type to handle private lists of KVs\&. \fP"
.ti -1c
.RI "typedef struct \fBlspmac_motor_struct\fP \fBlspmac_motor_t\fP"
.br
.RI "\fIMotor information\&. \fP"
.ti -1c
.RI "typedef struct \fBlspmac_bi_struct\fP \fBlspmac_bi_t\fP"
.br
.RI "\fIStorage for binary inputs\&. \fP"
.ti -1c
.RI "typedef struct 
.br
\fBlspg_getcenter_struct\fP \fBlspg_getcenter_t\fP"
.br
.RI "\fIStorage for getcenter query Used for the md2 ROTATE command that generates the centering movies\&. \fP"
.ti -1c
.RI "typedef struct \fBlspg_nextshot_struct\fP \fBlspg_nextshot_t\fP"
.br
.RI "\fIStorage definition for nextshot query\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "double \fBlspmac_getPosition\fP (\fBlspmac_motor_t\fP *)"
.br
.RI "\fIget the motor position (with locking) \fP"
.ti -1c
.RI "void \fBPmacSockSendline\fP (char *s)"
.br
.ti -1c
.RI "void \fBpgpmac_printf\fP (char *fmt,\&.\&.\&.)"
.br
.RI "\fITerminal output routine ala printf\&. \fP"
.ti -1c
.RI "void \fBlspg_init\fP ()"
.br
.RI "\fIInitiallize the lspg module\&. \fP"
.ti -1c
.RI "void \fBlspg_run\fP ()"
.br
.RI "\fIStart 'er runnin'\&. \fP"
.ti -1c
.RI "void \fBlspg_seq_run_prep_all\fP (long long skey, double \fBkappa\fP, double \fBphi\fP, double cx, double cy, double ax, double ay, double az)"
.br
.RI "\fIConvinence function to call seq run prep\&. \fP"
.ti -1c
.RI "void \fBlspg_zoom_lut_call\fP ()"
.br
.ti -1c
.RI "void \fBlspmac_init\fP (int, int)"
.br
.RI "\fIInitialize this module\&. \fP"
.ti -1c
.RI "void \fBlspmac_run\fP ()"
.br
.RI "\fIStart up the lspmac thread\&. \fP"
.ti -1c
.RI "void \fBlspmac_move_or_jog_queue\fP (\fBlspmac_motor_t\fP *, double, int)"
.br
.ti -1c
.RI "void \fBlspmac_move_or_jog_preset_queue\fP (\fBlspmac_motor_t\fP *, char *, int)"
.br
.RI "\fImove using a preset value \fP"
.ti -1c
.RI "void \fBlspmac_moveabs_queue\fP (\fBlspmac_motor_t\fP *, double)"
.br
.RI "\fIUse coordinate system motion program, if available, to move motor to requested position\&. \fP"
.ti -1c
.RI "void \fBlspmac_jogabs_queue\fP (\fBlspmac_motor_t\fP *, double)"
.br
.RI "\fIUse jog to move motor to requested position\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_SockSendline\fP (char *,\&.\&.\&.)"
.br
.RI "\fISend a one line command\&. \fP"
.ti -1c
.RI "void \fBlsupdate_init\fP ()"
.br
.RI "\fIInitialize this module\&. \fP"
.ti -1c
.RI "void \fBmd2cmds_init\fP ()"
.br
.RI "\fIInitialize the md2cmds module\&. \fP"
.ti -1c
.RI "void \fBmd2cmds_run\fP ()"
.br
.RI "\fIStart up the thread\&. \fP"
.ti -1c
.RI "void \fBlsupdate_run\fP ()"
.br
.RI "\fIrun the update routines \fP"
.ti -1c
.RI "void \fBlsevents_init\fP ()"
.br
.RI "\fIInitialize this module\&. \fP"
.ti -1c
.RI "void \fBlsevents_run\fP ()"
.br
.RI "\fIStart up the thread and get out of the way\&. \fP"
.ti -1c
.RI "void \fBlsevents_send_event\fP (char *,\&.\&.\&.)"
.br
.RI "\fICall the callback routines for the given event\&. \fP"
.ti -1c
.RI "void \fBlsevents_add_listener\fP (char *, void(*cb)(char *))"
.br
.RI "\fIAdd a callback routine to listen for a specific event\&. \fP"
.ti -1c
.RI "void \fBlsevents_remove_listener\fP (char *, void(*cb)(char *))"
.br
.RI "\fIRemove a listener previously added with lsevents_add_listener\&. \fP"
.ti -1c
.RI "void \fBlstimer_init\fP ()"
.br
.RI "\fIInitialize the timer list and pthread stuff\&. \fP"
.ti -1c
.RI "void \fBlstimer_run\fP ()"
.br
.RI "\fIStart up our thread\&. \fP"
.ti -1c
.RI "void \fBlstimer_add_timer\fP (char *, int, unsigned long int, unsigned long int)"
.br
.ti -1c
.RI "void \fBlskvs_regcomp\fP (regex_t *preg, int cflags, char *fmt,\&.\&.\&.)"
.br
.RI "\fIUtility wrapper for regcomp providing printf style formating\&. \fP"
.ti -1c
.RI "double \fBlskvs_find_preset_position\fP (\fBlspmac_motor_t\fP *mp, char *name, int *err)"
.br
.RI "\fIfind a postion for a given preset name \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBlspg_getcenter_t\fP \fBlspg_getcenter\fP"
.br
.RI "\fIthe getcenter object \fP"
.ti -1c
.RI "\fBlspg_nextshot_t\fP \fBlspg_nextshot\fP"
.br
.RI "\fIthe nextshot object \fP"
.ti -1c
.RI "\fBlskvs_kvs_t\fP * \fBlskvs_kvs\fP"
.br
.RI "\fIour list (or at least the start of it \fP"
.ti -1c
.RI "pthread_rwlock_t \fBlskvs_rwlock\fP"
.br
.RI "\fIneeded to protect the list \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP \fBlspmac_motors\fP []"
.br
.RI "\fIAll our motors\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBomega\fP"
.br
.RI "\fIMD2 omega axis (the air bearing) \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBalignx\fP"
.br
.RI "\fIAlignment stage X\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBaligny\fP"
.br
.RI "\fIAlignment stage Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBalignz\fP"
.br
.RI "\fIAlignment stage X\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBanal\fP"
.br
.RI "\fIPolaroid analyzer motor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBzoom\fP"
.br
.RI "\fIOptical zoom\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBapery\fP"
.br
.RI "\fIAperture Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBaperz\fP"
.br
.RI "\fIAperture Z\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcapy\fP"
.br
.RI "\fICapillary Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcapz\fP"
.br
.RI "\fICapillary Z\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBscint\fP"
.br
.RI "\fIScintillator Z\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcenx\fP"
.br
.RI "\fICentering Table X\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBceny\fP"
.br
.RI "\fICentering Table Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBkappa\fP"
.br
.RI "\fIKappa\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBphi\fP"
.br
.RI "\fIPhi (not data collection axis) \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBfshut\fP"
.br
.RI "\fIFast shutter\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBflight\fP"
.br
.RI "\fIFront Light DAC\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBblight\fP"
.br
.RI "\fIBack Light DAC\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBfscint\fP"
.br
.RI "\fIScintillator Piezo DAC\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBblight_ud\fP"
.br
.RI "\fIBack light Up/Down actuator\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBflight_oo\fP"
.br
.RI "\fITurn front light on/off\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBblight_f\fP"
.br
.RI "\fIBack light scale factor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBflight_f\fP"
.br
.RI "\fIFront light scale factor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcryo\fP"
.br
.RI "\fIMove the cryostream towards or away from the crystal\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBdryer\fP"
.br
.RI "\fIblow air on the scintilator to dry it off \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBfluo\fP"
.br
.RI "\fIMove the fluorescence detector in/out\&. \fP"
.ti -1c
.RI "int \fBlspmac_nmotors\fP"
.br
.RI "\fIThe number of motors we manage\&. \fP"
.ti -1c
.RI "struct timespec \fBomega_zero_time\fP"
.br
.RI "\fITime we believe that omega crossed zero\&. \fP"
.ti -1c
.RI "WINDOW * \fBterm_output\fP"
.br
.RI "\fIplace to print stuff out \fP"
.ti -1c
.RI "WINDOW * \fBterm_input\fP"
.br
.RI "\fIplace to put the cursor \fP"
.ti -1c
.RI "WINDOW * \fBterm_status\fP"
.br
.RI "\fIshutter, lamp, air, etc status \fP"
.ti -1c
.RI "WINDOW * \fBterm_status2\fP"
.br
.RI "\fIshutter, lamp, air, etc status \fP"
.ti -1c
.RI "pthread_mutex_t \fBncurses_mutex\fP"
.br
.RI "\fIallow more than one thread access to the screen \fP"
.ti -1c
.RI "pthread_cond_t \fBmd2cmds_cond\fP"
.br
.RI "\fIcondition to signal when it's time to run an md2 command \fP"
.ti -1c
.RI "pthread_mutex_t \fBmd2cmds_mutex\fP"
.br
.RI "\fImutex for the condition \fP"
.ti -1c
.RI "pthread_cond_t \fBmd2cmds_pg_cond\fP"
.br
.ti -1c
.RI "pthread_mutex_t \fBmd2cmds_pg_mutex\fP"
.br
.ti -1c
.RI "pthread_mutex_t \fBpmac_queue_mutex\fP"
.br
.RI "\fImanage access to the pmac command queue \fP"
.ti -1c
.RI "pthread_cond_t \fBpmac_queue_cond\fP"
.br
.RI "\fIwait for a command to be sent to PMAC before continuing \fP"
.ti -1c
.RI "pthread_mutex_t \fBlspmac_shutter_mutex\fP"
.br
.RI "\fICoordinates threads reading shutter status\&. \fP"
.ti -1c
.RI "pthread_cond_t \fBlspmac_shutter_cond\fP"
.br
.RI "\fIAllows waiting for the shutter status to change\&. \fP"
.ti -1c
.RI "int \fBlspmac_shutter_state\fP"
.br
.RI "\fIState of the shutter, used to detect changes\&. \fP"
.ti -1c
.RI "int \fBlspmac_shutter_has_opened\fP"
.br
.RI "\fIIndicates that the shutter had opened, perhaps briefly even if the state did not change\&. \fP"
.ti -1c
.RI "pthread_mutex_t \fBlspmac_moving_mutex\fP"
.br
.RI "\fICoordinate moving motors between threads\&. \fP"
.ti -1c
.RI "pthread_cond_t \fBlspmac_moving_cond\fP"
.br
.RI "\fIWait for motor(s) to finish moving condition\&. \fP"
.ti -1c
.RI "int \fBlspmac_moving_flags\fP"
.br
.RI "\fIFlag used to implement motor moving condition\&. \fP"
.ti -1c
.RI "pthread_mutex_t \fBmd2_status_mutex\fP"
.br
.RI "\fISynchronize reading/writting status buffer\&. \fP"
.ti -1c
.RI "char \fBmd2cmds_cmd\fP []"
.br
.RI "\fIour command; \fP"
.in -1c
.SH "Detailed Description"
.PP 
Headers for the entire pgpmac project\&. 

\fBDate:\fP
.RS 4
2012 
.RE
.PP
\fBAuthor:\fP
.RS 4
Keith Brister 
.RE
.PP
\fBCopyright:\fP
.RS 4
All Rights Reserved 
.RE
.PP

.PP
Definition in file \fBpgpmac\&.h\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define LS_DISPLAY_WINDOW_HEIGHT   8"

.PP
Number of status box rows\&. 
.PP
Definition at line 30 of file pgpmac\&.h\&.
.SS "#define LS_DISPLAY_WINDOW_WIDTH   24"

.PP
Number of status box columns\&. 
.PP
Definition at line 34 of file pgpmac\&.h\&.
.SS "#define LS_PG_QUERY_STRING_LENGTH   1024"

.PP
Fixed length postgresql query strings\&. Queries should all be function calls so this is not as weird as one might think\&. 
.PP
Definition at line 37 of file pgpmac\&.h\&.
.SS "#define LSEVENTS_EVENT_LENGTH   32"

.PP
Fixed length for event names: simplifies string handling\&. 
.PP
Definition at line 40 of file pgpmac\&.h\&.
.SS "#define MD2CMDS_CMD_LENGTH   32"

.PP
Definition at line 385 of file pgpmac\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBlskvs_kvs_list_struct\fP  \fBlskvs_kvs_list_t\fP"

.PP
A second linked list type to handle private lists of KVs\&. Developed to support lists of preset motor positions\&. 
.SS "typedef struct \fBlskvs_kvs_struct\fP  \fBlskvs_kvs_t\fP"

.PP
Storage for the key value pairs\&. the k's and v's are strings and to keep the memory management less crazy we'll calloc some space for these strings and only free and re-calloc if we need more space later\&. Only the values are ever going to be resized\&. 
.SS "typedef struct \fBlspg_getcenter_struct\fP  \fBlspg_getcenter_t\fP"

.PP
Storage for getcenter query Used for the md2 ROTATE command that generates the centering movies\&. 
.SS "typedef struct \fBlspg_nextshot_struct\fP  \fBlspg_nextshot_t\fP"

.PP
Storage definition for nextshot query\&. The next shot query returns all the information needed to collect the next data frame\&. Since SQL allows for null fields independently from blank strings a separate integer is used as a flag for this case\&. This adds to the program complexity but allows for some important cases\&. Suck it up\&.definition of the next image to be taken (and the one after that, too!) 
.SS "typedef struct \fBlspmac_bi_struct\fP  \fBlspmac_bi_t\fP"

.PP
Storage for binary inputs\&. 
.SS "typedef struct \fBlspmac_motor_struct\fP  \fBlspmac_motor_t\fP"

.PP
Motor information\&. A catchall for motors and motor like objects\&. Not all members are used by all objects\&. 
.SS "typedef struct \fBlspmac_cmd_queue_struct\fP  \fBpmac_cmd_queue_t\fP"

.PP
PMAC command queue item\&. Command queue items are fixed length to simplify memory management\&. 
.SS "typedef struct \fBtagEthernetCmd\fP  \fBpmac_cmd_t\fP"

.PP
PMAC ethernet packet definition\&. Taken directly from the Delta Tau documentation\&. 
.SH "Function Documentation"
.PP 
.SS "void lsevents_add_listener (char *event, void(*)(char *)cb)"

.PP
Add a callback routine to listen for a specific event\&. \fBParameters:\fP
.RS 4
\fIevent\fP the name of the event to listen for 
.br
\fIcb\fP the routine to call 
.RE
.PP

.PP
Definition at line 76 of file lsevents\&.c\&.
.PP
.nf
                                                             {
  lsevents_listener_t *new;

  new = calloc( 1, sizeof( lsevents_listener_t));
  if( new == NULL) {
    lslogging_log_message( 'lsevents_add_listener: out of memory');
    exit( -1);
  }

  strncpy( new->event, event, LSEVENTS_EVENT_LENGTH);
  new->event[LSEVENTS_EVENT_LENGTH-1] = 0;
  new->cb   = cb;

  pthread_mutex_lock( &lsevents_listener_mutex);
  new->next = lsevents_listeners_p;
  lsevents_listeners_p = new;
  pthread_mutex_unlock( &lsevents_listener_mutex);

  lslogging_log_message( 'lsevents_add_listener: added listener for event %s', event);

}
.fi
.SS "void lsevents_init ()"

.PP
Initialize this module\&. 
.PP
Definition at line 187 of file lsevents\&.c\&.
.PP
.nf
                     {
  pthread_mutex_init( &lsevents_queue_mutex, NULL);
  pthread_cond_init(  &lsevents_queue_cond, NULL);
  pthread_mutex_init( &lsevents_listener_mutex, NULL);
}
.fi
.SS "void lsevents_remove_listener (char *event, void(*)(char *)cb)"

.PP
Remove a listener previously added with lsevents_add_listener\&. \fBParameters:\fP
.RS 4
\fIevent\fP The name of the event 
.br
\fIcb\fP The callback routine to remove 
.RE
.PP

.PP
Definition at line 102 of file lsevents\&.c\&.
.PP
.nf
                                                                {
  
  lsevents_listener_t *last, *current;

  //
  // Find the listener to remove
  // and unlink it from the list
  //
  pthread_mutex_lock( &lsevents_listener_mutex);
  last = NULL;
  for( current = lsevents_listeners_p; current != NULL; current = current->next) {
    if( strcmp( last->event, event) == 0 && last->cb == cb) {
      if( last == NULL) {
        lsevents_listeners_p = current->next;
      } else {
        last->next = current->next;
      }
      break;
    }
  }
  pthread_mutex_unlock( &lsevents_listener_mutex);

  //
  // Now remove it
  // TODO: use saner memory management where we allocate many listeners at a time
  // as an array and then just flag the ones that are used
  //
  if( current != NULL) {
    if( current->event != NULL)
      free( current->event);
    free(current);
  }
}
.fi
.SS "void lsevents_run ()"

.PP
Start up the thread and get out of the way\&. 
.PP
Definition at line 195 of file lsevents\&.c\&.
.PP
.nf
                    {
  pthread_create( &lsevents_thread, NULL, lsevents_worker, NULL);
}
.fi
.SS "void lsevents_send_event (char *fmt, \&.\&.\&.)"

.PP
Call the callback routines for the given event\&. \fBParameters:\fP
.RS 4
\fIfmt\fP a printf style formating string 
.br
\fI\&.\&.\&.\fP list of arguments specified by the format string 
.RE
.PP

.PP
Definition at line 44 of file lsevents\&.c\&.
.PP
.nf
                                          {
  char event[LSEVENTS_EVENT_LENGTH];
  char *sp;
  va_list arg_ptr;

  va_start( arg_ptr, fmt);
  vsnprintf( event, sizeof(event)-1, fmt, arg_ptr);
  event[sizeof(event)-1]=0;
  va_end( arg_ptr);

  lslogging_log_message( 'lsevents_send_event: %s', event);

  pthread_mutex_lock( &lsevents_queue_mutex);

  // maybe wait for room on the queue
  while( lsevents_queue_on + 1 == lsevents_queue_off)
    pthread_cond_wait( &lsevents_queue_cond, &lsevents_queue_mutex);
  
  sp = lsevents_queue[(lsevents_queue_on++) % LSEVENTS_QUEUE_LENGTH]\&.event;
  strncpy( sp, event, LSEVENTS_EVENT_LENGTH);
  sp[LSEVENTS_EVENT_LENGTH - 1] = 0;

  pthread_cond_signal(  &lsevents_queue_cond);
  pthread_mutex_unlock( &lsevents_queue_mutex);

}
.fi
.SS "double lskvs_find_preset_position (\fBlspmac_motor_t\fP *mp, char *name, int *err)"

.PP
find a postion for a given preset name \fBParameters:\fP
.RS 4
\fImp\fP Motor pointer 
.br
\fIname\fP The preset to search for 
.br
\fIerr\fP set to non-zero on error, ignored if null 
.RE
.PP

.PP
Definition at line 21 of file lskvs\&.c\&.
.PP
.nf
                                                                             {
  regmatch_t pmatch[4], qmatch[4];
  double rtn;
  lskvs_kvs_list_t
    *position_kv = NULL,
    *name_kv     = NULL;
  int e;

  *err = -4;
  if( name == NULL || *name == 0)
    return 0\&.0;

  *err = 0;
  for( name_kv = mp->presets; name_kv != NULL; name_kv = name_kv->next) {
    if( strcmp( name, name_kv->kvs->v) == 0) {
      //
      // We found the correct preset, now get the index
      //
      e = regexec( &(mp->preset_regex), name_kv->kvs->k, 4, pmatch, 0);
      if( e != 0) {
        lslogging_log_message( 'lskvs_find_preset_position: could not parse name key '%s'', name_kv->kvs->k);
        if( err != NULL)
          *err = e;
        return 0\&.0;
      }

      for( position_kv = mp->presets; position_kv != NULL; position_kv = position_kv->next) {
        if( position_kv == name_kv)
          continue;

        e = regexec( &(mp->preset_regex), position_kv->kvs->k, 4, qmatch, 0);
        if( e != 0) {
          lslogging_log_message( 'lskvs_find_preset_position: could not parse position key '%s'', position_kv->kvs->k);
          if( err != NULL)
            *err = e;
          return 0\&.0;
        }

        if( strncmp( name_kv->kvs->k, position_kv->kvs->k, qmatch[2]\&.rm_eo + 1) == 0) {
          break;
        }
      }
      if( position_kv != NULL)
        break;
    }
  }

  if( name_kv != NULL || position_kv != NULL) {
    errno = 0;
    rtn = strtod( position_kv->kvs->v, NULL);
    if( errno != 0) {
      lslogging_log_message( 'lskvs_find_preset_position: bad preset value for motor %s, preset %s, value '%s'', mp->name, name, position_kv->kvs->v);
      if( err != NULL)
        *err = -2;
      return 0\&.0;
    }
    return rtn;
  }
  lslogging_log_message( 'lskvs_find_preset_position: could not find preset for motor %s, preset %s', mp->name, name);
  if( err != NULL)
    *err = -3;
  return 0\&.0;
}
.fi
.SS "void lskvs_regcomp (regex_t *preg, intcflags, char *fmt, \&.\&.\&.)"

.PP
Utility wrapper for regcomp providing printf style formating\&. \fBParameters:\fP
.RS 4
\fIpreg\fP Buffer for the compile regex object 
.br
\fIcflags\fP See regcomp man page 
.br
\fIfmt\fP Printf style formating string 
.br
\fI\&.\&.\&.\fP Argument list specified by fmt 
.RE
.PP
< no reason our search strings should ever be this big 
.PP
Definition at line 92 of file lskvs\&.c\&.
.PP
.nf
                                                               {
  struct regerror_struct {
    int errcode;
    char *errstr;
  };
  static struct regerror_struct regerrors[] = {
    { REG_BADBR,    'Invalid use of back reference operator\&.'},
    { REG_BADPAT,   'Invalid use of pattern operators such as group or list\&.'},
    { REG_BADRPT,   'Invalid use of repetition operators such as using '*' as the first character\&.'},
    { REG_EBRACE,   'Un-matched brace interval operators\&.'},
    { REG_EBRACK,   'Un-matched bracket list operators\&.'},
    { REG_ECOLLATE, 'Invalid collating element\&.'},
    { REG_ECTYPE,   'Unknown character class name\&.'},
    { REG_EEND,     'Non specific error\&.  This is not defined by POSIX\&.2\&.'},
    { REG_EESCAPE,  'Trailing backslash\&.'},
    { REG_EPAREN,   'Un-matched parenthesis group operators\&.'},
    { REG_ERANGE,   'Invalid use of the range operator, e\&.g\&., the ending point of the range occurs prior to the starting point\&.'},
    { REG_ESIZE,    'Compiled regular expression requires a pattern buffer larger than 64Kb\&.  This is not defined by POSIX\&.2\&.'},
    { REG_ESPACE,   'The regex routines ran out of memory\&.'},
    { REG_ESUBREG,  'Invalid back reference to a subexpression\&.'},
    { 0,            'No errors'}
  };



  va_list arg_ptr;
  char s[512];          
  int err;

  va_start( arg_ptr, fmt);
  vsnprintf( s, sizeof(s)-1, fmt, arg_ptr);
  s[ sizeof(s)-1] = 0;
  va_end( arg_ptr);

  err = regcomp( preg, s, cflags);
  if( err != 0) {
    int i;

    for( i=0; regerrors[i]\&.errcode != 0; i++)
      if( regerrors[i]\&.errcode == err)
        break;

    if( regerrors[i]\&.errcode != 0) {
      lslogging_log_message( 'lskvs_regcomp: could not compile regular experssion '%s'', s);
      lslogging_log_message( 'lskvs_regcomp: regcomp returned %d: %s', err, regerrors[i]);
    }
  }
}
.fi
.SS "void lspg_init ()"

.PP
Initiallize the lspg module\&. 
.PP
Definition at line 1664 of file lspg\&.c\&.
.PP
.nf
                 {
  pthread_mutex_init( &lspg_queue_mutex, NULL);
  pthread_cond_init( &lspg_queue_cond, NULL);
  lspg_nextshot_init();
  lspg_getcenter_init();
  lspg_wait_for_detector_init();
  lspg_lock_diffractometer_init();
  lspg_lock_detector_init();
}
.fi
.SS "void lspg_run ()"

.PP
Start 'er runnin'\&. 
.PP
Definition at line 1676 of file lspg\&.c\&.
.PP
.nf
                {
  pthread_create( &lspg_thread, NULL, lspg_worker, NULL);
}
.fi
.SS "void lspg_seq_run_prep_all (long longskey, doublekappa, doublephi, doublecx, doublecy, doubleax, doubleay, doubleaz)"

.PP
Convinence function to call seq run prep\&. \fBParameters:\fP
.RS 4
\fIskey\fP px\&.shots key for this image 
.br
\fIkappa\fP current kappa postion 
.br
\fIphi\fP current phi postition 
.br
\fIcx\fP current center table x 
.br
\fIcy\fP current center table y 
.br
\fIax\fP current alignment table x 
.br
\fIay\fP current alignment table y 
.br
\fIaz\fP current alignment table z 
.RE
.PP

.PP
Definition at line 984 of file lspg\&.c\&.
.PP
.nf
                             {
  lspg_seq_run_prep_call( skey, kappa, phi, cx, cy, ax, ay, az);
  lspg_seq_run_prep_wait();
  lspg_seq_run_prep_done();
}
.fi
.SS "void lspg_zoom_lut_call ()"

.SS "double lspmac_getPosition (\fBlspmac_motor_t\fP *mp)"

.PP
get the motor position (with locking) \fBParameters:\fP
.RS 4
\fImp\fP the motor object 
.RE
.PP

.PP
Definition at line 1227 of file lspmac\&.c\&.
.PP
.nf
                                               {
  double rtn;
  pthread_mutex_lock( &(mp->mutex));
  rtn = mp->position;
  pthread_mutex_unlock( &(mp->mutex));
  return rtn;
}
.fi
.SS "void lspmac_init (int, int)"

.PP
Initialize this module\&. 
.PP
Definition at line 2557 of file lspmac\&.c\&.
.PP
.nf
                   {
  md2_status_t *p;

  // Set our global harvest flags
  getivars = ivarsflag;
  getmvars = mvarsflag;

  // All important status mutex
  pthread_mutex_init( &md2_status_mutex, NULL);

  //
  // Initialize the motor objects
  //

  p = &md2_status;

  omega  = lspmac_motor_init( &(lspmac_motors[ 0]),  1, 0, 0, &p->omega_act_pos,     &p->omega_status_1,     &p->omega_status_2,     'Omega   #1 &1 A', 'omega',       lspmac_moveabs_queue);
  alignx = lspmac_motor_init( &(lspmac_motors[ 1]),  2, 0, 1, &p->alignx_act_pos,    &p->alignx_status_1,    &p->alignx_status_2,    'Align X #2 &3 X', 'align\&.x',     lspmac_moveabs_queue);
  aligny = lspmac_motor_init( &(lspmac_motors[ 2]),  3, 0, 2, &p->aligny_act_pos,    &p->aligny_status_1,    &p->aligny_status_2,    'Align Y #3 &3 Y', 'align\&.y',     lspmac_moveabs_queue);
  alignz = lspmac_motor_init( &(lspmac_motors[ 3]),  4, 0, 3, &p->alignz_act_pos,    &p->alignz_status_1,    &p->alignz_status_2,    'Align Z #4 &3 Z', 'align\&.z',     lspmac_moveabs_queue);
  anal   = lspmac_motor_init( &(lspmac_motors[ 4]),  5, 0, 4, &p->analyzer_act_pos,  &p->analyzer_status_1,  &p->analyzer_status_2,  'Anal    #5',      'lightPolar',  lspmac_moveabs_queue);
  zoom   = lspmac_motor_init( &(lspmac_motors[ 5]),  6, 1, 0, &p->zoom_act_pos,      &p->zoom_status_1,      &p->zoom_status_2,      'Zoom    #6 &4 Z', 'cam\&.zoom',    lspmac_movezoom_queue);
  apery  = lspmac_motor_init( &(lspmac_motors[ 6]),  7, 1, 1, &p->aperturey_act_pos, &p->aperturey_status_1, &p->aperturey_status_2, 'Aper Y  #7 &5 Y', 'appy',        lspmac_moveabs_queue);
  aperz  = lspmac_motor_init( &(lspmac_motors[ 7]),  8, 1, 2, &p->aperturez_act_pos, &p->aperturez_status_1, &p->aperturez_status_2, 'Aper Z  #8 &5 Z', 'appz',        lspmac_moveabs_queue);
  capy   = lspmac_motor_init( &(lspmac_motors[ 8]),  9, 1, 3, &p->capy_act_pos,      &p->capy_status_1,      &p->capy_status_2,      'Cap Y   #9 &5 U', 'capy',        lspmac_moveabs_queue);
  capz   = lspmac_motor_init( &(lspmac_motors[ 9]), 10, 1, 4, &p->capz_act_pos,      &p->capz_status_1,      &p->capz_status_2,      'Cap Z  #10 &5 V', 'capz',        lspmac_moveabs_queue);
  scint  = lspmac_motor_init( &(lspmac_motors[10]), 11, 2, 0, &p->scint_act_pos,     &p->scint_status_1,     &p->scint_status_2,     'Scin Z #11 &5 W', 'scint',       lspmac_moveabs_queue);
  cenx   = lspmac_motor_init( &(lspmac_motors[11]), 17, 2, 1, &p->centerx_act_pos,   &p->centerx_status_1,   &p->centerx_status_2,   'Cen X  #17 &2 X', 'centering\&.x', lspmac_moveabs_queue);
  ceny   = lspmac_motor_init( &(lspmac_motors[12]), 18, 2, 2, &p->centery_act_pos,   &p->centery_status_1,   &p->centery_status_2,   'Cen Y  #18 &2 Y', 'centering\&.y', lspmac_moveabs_queue);
  kappa  = lspmac_motor_init( &(lspmac_motors[13]), 19, 2, 3, &p->kappa_act_pos,     &p->kappa_status_1,     &p->kappa_status_2,     'Kappa  #19 &7 X', 'kappa',       lspmac_moveabs_queue);
  phi    = lspmac_motor_init( &(lspmac_motors[14]), 20, 2, 4, &p->phi_act_pos,       &p->phi_status_1,       &p->phi_status_2,       'Phi    #20 &7 Y', 'phi',         lspmac_moveabs_queue);

  fshut  = lspmac_fshut_init( &(lspmac_motors[15]));
  flight = lspmac_dac_init( &(lspmac_motors[16]), &p->front_dac,   160\&.0, 'M1200', 'frontLight\&.intensity', lspmac_movedac_queue);
  blight = lspmac_dac_init( &(lspmac_motors[17]), &p->back_dac,    160\&.0, 'M1201', 'backLight\&.intensity',  lspmac_movedac_queue);
  fscint = lspmac_dac_init( &(lspmac_motors[18]), &p->scint_piezo, 320\&.0, 'M1203', 'scint\&.focus',          lspmac_movedac_queue);

  blight_ud = lspmac_bo_init( &(lspmac_motors[19]), 'backLight',  'M1101=%d', &(md2_status\&.acc11c_5), 0x02);
  cryo      = lspmac_bo_init( &(lspmac_motors[20]), 'cryo',       'M1102=%d', &(md2_status\&.acc11c_5), 0x04);
  dryer     = lspmac_bo_init( &(lspmac_motors[21]), 'dryer',      'M1103=%d', &(md2_status\&.acc11c_5), 0x08);
  fluo      = lspmac_bo_init( &(lspmac_motors[22]), 'fluo',       'M1008=%d', &(md2_status\&.acc11c_2), 0x01);
  flight_oo = lspmac_soft_motor_init( &(lspmac_motors[23]), 'frontLight',        1\&.0, lspmac_moveabs_frontlight_oo_queue);
  blight_f  = lspmac_soft_motor_init( &(lspmac_motors[24]), 'backLight\&.factor',  1\&.0, lspmac_moveabs_blight_factor_queue);
  flight_f  = lspmac_soft_motor_init( &(lspmac_motors[25]), 'frontLight\&.factor', 1\&.0, lspmac_moveabs_flight_factor_queue);

  cryo_switch = lspmac_bi_init( &(lspmac_bis[0]), &(md2_status\&.acc11c_1), 0x04, 'CryoSwitchChanged', 'CryoSwitchChanged');

  //
  // Initialize several commands that get called, perhaps, alot
  //
  rr_cmd\&.RequestType = VR_UPLOAD;
  rr_cmd\&.Request     = VR_PMAC_READREADY;
  rr_cmd\&.wValue      = 0;
  rr_cmd\&.wIndex      = 0;
  rr_cmd\&.wLength     = htons(2);
  memset( rr_cmd\&.bData, 0, sizeof(rr_cmd\&.bData));

  gb_cmd\&.RequestType = VR_UPLOAD;
  gb_cmd\&.Request     = VR_PMAC_GETBUFFER;
  gb_cmd\&.wValue      = 0;
  gb_cmd\&.wIndex      = 0;
  gb_cmd\&.wLength     = htons(1400);
  memset( gb_cmd\&.bData, 0, sizeof(gb_cmd\&.bData));

  cr_cmd\&.RequestType = VR_UPLOAD;
  cr_cmd\&.Request     = VR_CTRL_RESPONSE;
  cr_cmd\&.wValue      = 0;
  cr_cmd\&.wIndex      = 0;
  cr_cmd\&.wLength     = htons(1400);
  memset( cr_cmd\&.bData, 0, sizeof(cr_cmd\&.bData));

  //
  // Initialize some mutexs and conditions
  //

  pthread_mutex_init( &pmac_queue_mutex, NULL);
  pthread_cond_init(  &pmac_queue_cond, NULL);

  lspmac_shutter_state = 0;                             // assume the shutter is now closed: not a big deal if we are wrong
  pthread_mutex_init( &lspmac_shutter_mutex, NULL);
  pthread_cond_init(  &lspmac_shutter_cond, NULL);
  pmacfd\&.fd = -1;

  pthread_mutex_init( &lspmac_moving_mutex, NULL);
  pthread_cond_init(  &lspmac_moving_cond, NULL);
}
.fi
.SS "void lspmac_jogabs_queue (\fBlspmac_motor_t\fP *, double)"

.PP
Use jog to move motor to requested position\&. 
.PP
Definition at line 2289 of file lspmac\&.c\&.
.PP
.nf
                            {
  
  lspmac_move_or_jog_abs_queue( mp, requested_position, 1);
}
.fi
.SS "void lspmac_move_or_jog_preset_queue (\fBlspmac_motor_t\fP *, char *, int)"

.PP
move using a preset value 
.PP
Definition at line 2258 of file lspmac\&.c\&.
.PP
.nf
                                       {
  double pos;
  int err;

  if( preset == NULL || *preset == 0)
    return;

  pthread_mutex_lock( &(mp->mutex));
  pos = lskvs_find_preset_position( mp, preset, &err);
  pthread_mutex_unlock( &(mp->mutex));

  lspmac_move_or_jog_abs_queue( mp, pos, use_jog);
}
.fi
.SS "void lspmac_move_or_jog_queue (\fBlspmac_motor_t\fP *, double, int)"

.SS "void lspmac_moveabs_queue (\fBlspmac_motor_t\fP *, double)"

.PP
Use coordinate system motion program, if available, to move motor to requested position\&. 
.PP
Definition at line 2279 of file lspmac\&.c\&.
.PP
.nf
                            {
  
  lspmac_move_or_jog_abs_queue( mp, requested_position, 0);
}
.fi
.SS "void lspmac_run ()"

.PP
Start up the lspmac thread\&. 
.PP
Definition at line 2771 of file lspmac\&.c\&.
.PP
.nf
                  {
  pthread_create( &pmac_thread, NULL, lspmac_worker, NULL);
  lsevents_add_listener( 'NewKV', lspmac_newKV_cb);
  lsevents_add_listener( 'CryoSwitchChanged', lspmac_cryoSwitchChanged_cb);
  lsevents_add_listener( 'scint In Position', lspmac_scint_inPosition_cb);
  lsevents_add_listener( 'scintDried',        lspmac_scint_dried_cb);
  lsevents_add_listener( 'backLight 1',       lspmac_backLight_up_cb);
  lsevents_add_listener( 'backLight 0',       lspmac_backLight_down_cb);
  lsevents_add_listener( 'cam\&.zoom In Position',  lspmac_light_zoom_cb);
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_SockSendline (char *fmt, \&.\&.\&.)"

.PP
Send a one line command\&. Uses printf style arguments\&. \fBParameters:\fP
.RS 4
\fIfmt\fP Printf style format string 
.RE
.PP

.PP
Definition at line 957 of file lspmac\&.c\&.
.PP
.nf
                                         {
  va_list arg_ptr;
  char payload[1400];

  va_start( arg_ptr, fmt);
  vsnprintf( payload, sizeof(payload)-1, fmt, arg_ptr);
  payload[ sizeof(payload)-1] = 0;
  va_end( arg_ptr);

  lslogging_log_message( payload);

  return lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDLINE, 0, 0, strlen( payload), payload, lspmac_GetShortReplyCB, 0);
}
.fi
.SS "void lstimer_add_timer (char *, int, unsigned longint, unsigned longint)"

.PP
Definition at line 44 of file lstimer\&.c\&.
.PP
.nf
                                                                                                 {
  int i;
  struct timespec now;


  // Time we were called\&.  Delay is based on call time, not queued time
  //
  clock_gettime( CLOCK_REALTIME, &now);
  

  pthread_mutex_lock( &lstimer_mutex);

  for( i=0; i<LSTIMER_LIST_LENGTH; i++) {
    if( lstimer_list[i]\&.shots == 0)
      break;
  }

  if( i == LSTIMER_LIST_LENGTH) {
    pthread_mutex_unlock( &lstimer_mutex);
    
    lslogging_log_message( 'lstimer_add_timer: out of timers for event: %s, shots: %d,  secs: %u, nsecs: %u',
                          event, shots, secs, nsecs);
    return;
  }

  strncpy( lstimer_list[i]\&.event, event, LSEVENTS_EVENT_LENGTH - 1);
  lstimer_list[i]\&.event[LSEVENTS_EVENT_LENGTH - 1] = 0;
  lstimer_list[i]\&.shots        = shots;
  lstimer_list[i]\&.delay_secs   = secs;
  lstimer_list[i]\&.delay_nsecs  = nsecs;

  lstimer_list[i]\&.next_secs    = secs + now\&.tv_sec + (now\&.tv_nsec + nsecs) / 1000000000;
  lstimer_list[i]\&.next_nsecs   = (now\&.tv_nsec + nsecs) % 1000000000;
  lstimer_list[i]\&.last_secs    = 0;
  lstimer_list[i]\&.last_nsecs   = 0;
  
  lstimer_list[i]\&.ncalls       = 0;
  lstimer_list[i]\&.init_secs    = now\&.tv_sec;
  lstimer_list[i]\&.init_nsecs   = now\&.tv_nsec;

  if( shots != 0) {
    lstimer_active_timers++;
    new_timer++;
  }

  pthread_cond_signal(  &lstimer_cond);
  pthread_mutex_unlock( &lstimer_mutex);
}
.fi
.SS "void lstimer_init ()"

.PP
Initialize the timer list and pthread stuff\&. 
.PP
Definition at line 256 of file lstimer\&.c\&.
.PP
.nf
                    {
  int i;

  for( i=0; i<LSTIMER_LIST_LENGTH; i++) {
    lstimer_list[i]\&.shots = 0;
  }


  pthread_mutex_init( &lstimer_mutex, NULL);
  pthread_cond_init(  &lstimer_cond, NULL);
}
.fi
.SS "void lstimer_run ()"

.PP
Start up our thread\&. 
.PP
Definition at line 270 of file lstimer\&.c\&.
.PP
.nf
                   {
  pthread_create( &lstimer_thread, NULL, lstimer_worker, NULL);
}
.fi
.SS "void lsupdate_init ()"

.PP
Initialize this module\&. 
.PP
Definition at line 109 of file lsupdate\&.c\&.
.PP
.nf
                     {
}
.fi
.SS "void lsupdate_run ()"

.PP
run the update routines 
.PP
Definition at line 114 of file lsupdate\&.c\&.
.PP
.nf
                    {
  pthread_create( &lsupdate_thread, NULL, lsupdate_worker, NULL);
}
.fi
.SS "void md2cmds_init ()"

.PP
Initialize the md2cmds module\&. 
.PP
Definition at line 771 of file md2cmds\&.c\&.
.PP
.nf
                    {
  memset( md2cmds_cmd, 0, sizeof( md2cmds_cmd));

  pthread_mutex_init( &md2cmds_mutex, NULL);
  pthread_cond_init( &md2cmds_cond, NULL);

  pthread_mutex_init( &md2cmds_moving_mutex, NULL);
  pthread_cond_init(  &md2cmds_moving_cond, NULL);


}
.fi
.SS "void md2cmds_run ()"

.PP
Start up the thread\&. 
.PP
Definition at line 785 of file md2cmds\&.c\&.
.PP
.nf
                   {
  pthread_create( &md2cmds_thread, NULL,            md2cmds_worker, NULL);
  lsevents_add_listener( 'omega crossed zero',      md2cmds_rotate_cb);
  lsevents_add_listener( 'omega In Position',       md2cmds_maybe_rotate_done_cb);
  lsevents_add_listener( 'align\&.x In Position',     md2cmds_maybe_done_moving_cb);
  lsevents_add_listener( 'align\&.y In Position',     md2cmds_maybe_done_moving_cb);
  lsevents_add_listener( 'align\&.z In Position',     md2cmds_maybe_done_moving_cb);
  lsevents_add_listener( 'centering\&.x In Position', md2cmds_maybe_done_moving_cb);
  lsevents_add_listener( 'centering\&.y In Position', md2cmds_maybe_done_moving_cb);
  lsevents_add_listener( 'align\&.x Moving',          md2cmds_maybe_done_moving_cb);
  lsevents_add_listener( 'align\&.y Moving',          md2cmds_maybe_done_moving_cb);
  lsevents_add_listener( 'align\&.z Moving',          md2cmds_maybe_done_moving_cb);
  lsevents_add_listener( 'centering\&.x Moving',      md2cmds_maybe_done_moving_cb);
  lsevents_add_listener( 'centering\&.y Moving',      md2cmds_maybe_done_moving_cb);
  lsevents_add_listener( 'cam\&.zoom In Position',    md2cmds_set_scale_cb);
}
.fi
.SS "void pgpmac_printf (char *fmt, \&.\&.\&.)"

.PP
Terminal output routine ala printf\&. \fBParameters:\fP
.RS 4
\fIfmt\fP Printf style formating string 
.RE
.PP

.PP
Definition at line 326 of file pgpmac\&.c\&.
.PP
.nf
                     {
  va_list arg_ptr;

  pthread_mutex_lock( &ncurses_mutex);

  va_start( arg_ptr, fmt);
  vwprintw( term_output, fmt, arg_ptr);
  va_end( arg_ptr);

  wnoutrefresh( term_output);
  wnoutrefresh( term_input);
  doupdate();

  pthread_mutex_unlock( &ncurses_mutex);

}
.fi
.SS "void PmacSockSendline (char *s)"

.SH "Variable Documentation"
.PP 
.SS "\fBlspmac_motor_t\fP* alignx"

.PP
Alignment stage X\&. 
.PP
Definition at line 81 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* aligny"

.PP
Alignment stage Y\&. 
.PP
Definition at line 82 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* alignz"

.PP
Alignment stage X\&. 
.PP
Definition at line 83 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* anal"

.PP
Polaroid analyzer motor\&. 
.PP
Definition at line 84 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* apery"

.PP
Aperture Y\&. 
.PP
Definition at line 86 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* aperz"

.PP
Aperture Z\&. 
.PP
Definition at line 87 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* blight"

.PP
Back Light DAC\&. 
.PP
Definition at line 98 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* blight_f"

.PP
Back light scale factor\&. 
.PP
Definition at line 103 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* blight_ud"

.PP
Back light Up/Down actuator\&. 
.PP
Definition at line 101 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* capy"

.PP
Capillary Y\&. 
.PP
Definition at line 88 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* capz"

.PP
Capillary Z\&. 
.PP
Definition at line 89 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* cenx"

.PP
Centering Table X\&. 
.PP
Definition at line 91 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* ceny"

.PP
Centering Table Y\&. 
.PP
Definition at line 92 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* cryo"

.PP
Move the cryostream towards or away from the crystal\&. 
.PP
Definition at line 105 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* dryer"

.PP
blow air on the scintilator to dry it off 
.PP
Definition at line 106 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* flight"

.PP
Front Light DAC\&. 
.PP
Definition at line 97 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* flight_f"

.PP
Front light scale factor\&. 
.PP
Definition at line 104 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* flight_oo"

.PP
Turn front light on/off\&. 
.PP
Definition at line 102 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* fluo"

.PP
Move the fluorescence detector in/out\&. 
.PP
Definition at line 107 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* fscint"

.PP
Scintillator Piezo DAC\&. 
.PP
Definition at line 99 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* fshut"

.PP
Fast shutter\&. 
.PP
Definition at line 96 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* kappa"

.PP
Kappa\&. 
.PP
Definition at line 93 of file lspmac\&.c\&.
.SS "\fBlskvs_kvs_t\fP* lskvs_kvs"

.PP
our list (or at least the start of it 
.PP
Definition at line 11 of file lskvs\&.c\&.
.SS "pthread_rwlock_t lskvs_rwlock"

.PP
needed to protect the list 
.PP
Definition at line 12 of file lskvs\&.c\&.
.SS "\fBlspg_getcenter_t\fP lspg_getcenter"

.PP
the getcenter object 
.PP
Definition at line 73 of file lspg\&.c\&.
.SS "\fBlspg_nextshot_t\fP lspg_nextshot"

.PP
the nextshot object 
.PP
Definition at line 72 of file lspg\&.c\&.
.SS "\fBlspmac_motor_t\fP lspmac_motors[]"

.PP
All our motors\&. 
.PP
Definition at line 78 of file lspmac\&.c\&.
.SS "pthread_cond_t lspmac_moving_cond"

.PP
Wait for motor(s) to finish moving condition\&. 
.PP
Definition at line 58 of file lspmac\&.c\&.
.SS "int lspmac_moving_flags"

.PP
Flag used to implement motor moving condition\&. 
.PP
Definition at line 59 of file lspmac\&.c\&.
.SS "pthread_mutex_t lspmac_moving_mutex"

.PP
Coordinate moving motors between threads\&. 
.PP
Definition at line 57 of file lspmac\&.c\&.
.SS "int lspmac_nmotors"

.PP
The number of motors we manage\&. 
.PP
Definition at line 79 of file lspmac\&.c\&.
.SS "pthread_cond_t lspmac_shutter_cond"

.PP
Allows waiting for the shutter status to change\&. 
.PP
Definition at line 56 of file lspmac\&.c\&.
.SS "int lspmac_shutter_has_opened"

.PP
Indicates that the shutter had opened, perhaps briefly even if the state did not change\&. 
.PP
Definition at line 54 of file lspmac\&.c\&.
.SS "pthread_mutex_t lspmac_shutter_mutex"

.PP
Coordinates threads reading shutter status\&. 
.PP
Definition at line 55 of file lspmac\&.c\&.
.SS "int lspmac_shutter_state"

.PP
State of the shutter, used to detect changes\&. 
.PP
Definition at line 53 of file lspmac\&.c\&.
.SS "pthread_mutex_t md2_status_mutex"

.PP
Synchronize reading/writting status buffer\&. 
.PP
Definition at line 296 of file lspmac\&.c\&.
.SS "char md2cmds_cmd[]"

.PP
our command; 
.PP
Definition at line 19 of file md2cmds\&.c\&.
.SS "pthread_cond_t md2cmds_cond"

.PP
condition to signal when it's time to run an md2 command 
.PP
Definition at line 10 of file md2cmds\&.c\&.
.SS "pthread_mutex_t md2cmds_mutex"

.PP
mutex for the condition 
.PP
Definition at line 11 of file md2cmds\&.c\&.
.SS "pthread_cond_t md2cmds_pg_cond"

.SS "pthread_mutex_t md2cmds_pg_mutex"

.SS "pthread_mutex_t ncurses_mutex"

.PP
allow more than one thread access to the screen 
.PP
Definition at line 242 of file pgpmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* omega"

.PP
MD2 omega axis (the air bearing) 
.PP
Definition at line 80 of file lspmac\&.c\&.
.SS "struct timespec omega_zero_time"

.PP
Time we believe that omega crossed zero\&. 
.PP
Definition at line 63 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* phi"

.PP
Phi (not data collection axis) 
.PP
Definition at line 94 of file lspmac\&.c\&.
.SS "pthread_cond_t pmac_queue_cond"

.PP
wait for a command to be sent to PMAC before continuing 
.PP
Definition at line 69 of file lspmac\&.c\&.
.SS "pthread_mutex_t pmac_queue_mutex"

.PP
manage access to the pmac command queue 
.PP
Definition at line 68 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* scint"

.PP
Scintillator Z\&. 
.PP
Definition at line 90 of file lspmac\&.c\&.
.SS "WINDOW* term_input"

.PP
place to put the cursor 
.PP
Definition at line 238 of file pgpmac\&.c\&.
.SS "WINDOW* term_output"

.PP
place to print stuff out 
.PP
Definition at line 237 of file pgpmac\&.c\&.
.SS "WINDOW* term_status"

.PP
shutter, lamp, air, etc status 
.PP
Definition at line 239 of file pgpmac\&.c\&.
.SS "WINDOW* term_status2"

.PP
shutter, lamp, air, etc status 
.PP
Definition at line 240 of file pgpmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* zoom"

.PP
Optical zoom\&. 
.PP
Definition at line 85 of file lspmac\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for LS-CAT PGPMAC from the source code\&.
