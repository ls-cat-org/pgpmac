.TH "lskvs.c" 3 "Wed Nov 14 2012" "LS-CAT PGPMAC" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lskvs.c \- 
.PP
Support for the remote access client key value pairs\&.  

.SH SYNOPSIS
.br
.PP
\fC#include 'pgpmac\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBlskvs_kvs_struct\fP"
.br
.RI "\fIStorage for the key value pairs\&. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBlskvs_kvs_struct\fP \fBlskvs_kvs_t\fP"
.br
.RI "\fIStorage for the key value pairs\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBlskvs_set\fP (char *k, char *v)"
.br
.RI "\fISet the value of a kv pair Create the pair if the key does not exsist\&. \fP"
.ti -1c
.RI "\fBlskvs_kvs_t\fP * \fBlskvs_get\fP (char *k)"
.br
.RI "\fIFind the kv pair object Return with a pointer to the structure or NULL if not found\&. \fP"
.ti -1c
.RI "void \fBlskvs_init\fP ()"
.br
.RI "\fIInitialize lskvs objects\&. \fP"
.ti -1c
.RI "void \fBlskvs_run\fP ()"
.br
.RI "\fIRun things\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static \fBlskvs_kvs_t\fP * \fBlskvs_kvs\fP = NULL"
.br
.RI "\fIour list (or at least the start of it \fP"
.ti -1c
.RI "static pthread_rwlock_t \fBlskvs_rwlock\fP"
.br
.RI "\fIneeded to protect the list \fP"
.in -1c
.SH "Detailed Description"
.PP 
Support for the remote access client key value pairs\&. 

\fBDate:\fP
.RS 4
2012 
.RE
.PP
\fBAuthor:\fP
.RS 4
Keith Brister 
.RE
.PP
\fBCopyright:\fP
.RS 4
All Rights Reserved 
.RE
.PP

.PP
Definition in file \fBlskvs\&.c\fP\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBlskvs_kvs_struct\fP  \fBlskvs_kvs_t\fP"

.PP
Storage for the key value pairs\&. the k's and v's are strings and to keep the memory management less crazy we'll calloc some space for these strings and only free and re-calloc if we need more space later\&. Only the values are ever going to be resized\&. 
.SH "Function Documentation"
.PP 
.SS "\fBlskvs_kvs_t\fP* lskvs_get (char *k)"

.PP
Find the kv pair object Return with a pointer to the structure or NULL if not found\&. \fBParameters:\fP
.RS 4
\fIk\fP key name to search for 
.RE
.PP

.PP
Definition at line 137 of file lskvs\&.c\&.
.PP
.nf
                         {
  lskvs_kvs_t
    *rtn;

  pthread_rwlock_rdlock( &lskvs_rwlock);
  rtn = lskvs_kvs;
  pthread_rwlock_unlock( &lskvs_rwlock);

  while(rtn != NULL) {
    if( strcmp( rtn->k, k) == 0)
      break;
    rtn = rtn->next;
  }
  return rtn;
}
.fi
.SS "void lskvs_init ()"

.PP
Initialize lskvs objects\&. 
.PP
Definition at line 158 of file lskvs\&.c\&.
.PP
.nf
                  {
  pthread_rwlock_init( &lskvs_rwlock, NULL);
}
.fi
.SS "void lskvs_run ()"

.PP
Run things\&. Really, there is nothing to run\&. There is no need for a worker thread here but this has been added so we can add lskvs just like any other module to the pgpmac project\&. Maybe one day we'll need to add a thread and this little routine can be celebrated as being far sighted, ahead of its time\&. 
.PP
Definition at line 168 of file lskvs\&.c\&.
.PP
.nf
                 {
}
.fi
.SS "void lskvs_set (char *k, char *v)"

.PP
Set the value of a kv pair Create the pair if the key does not exsist\&. If more than one thread tries to create the same key at the same time it is possible for the list to contain multiple versions\&. Not good\&. But also not possible if only one thread has the job of create the pairs in the first place\&. Alternatively just grab the write lock at the beginning and hold it until the end\&. The advantage of having only one thread calling lskvs_set is that it wont slow down the other threads that just want to read things\&. In any case, we'll likely never see so much action for any of this to make a differene\&.
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The name of the key 
.br
\fIv\fP The value to assign to the key 
.RE
.PP

.PP
Definition at line 44 of file lskvs\&.c\&.
.PP
.nf
                                  {
  lskvs_kvs_t
    *root,
    *p;

  lslogging_log_message( 'lskvs_set:  k: '%s', v: '%s'', k, v);

  // Don't bother with empty keys
  //
  if( k == NULL || *k == 0)
    return;

  pthread_rwlock_rdlock( &lskvs_rwlock);
  root = lskvs_kvs;
  pthread_rwlock_unlock( &lskvs_rwlock);

  for( p=root; p != NULL; p = p->next) {
    if( strcmp( p->k, k) == 0) {
      break;
    }
  }

  if( p == NULL) {
    //
    // Add a new list item
    //
    p = calloc( 1, sizeof( *p));
    if( p == NULL) {
      lslogging_log_message( 'lskvs_set: out of memory for kv struct (%d bytes', sizeof( *p));
      exit( -1);
    }


    p->k = calloc( strlen(k)+1, sizeof( *k));
    if( p->k == NULL) {
      lslogging_log_message( 'lskvs_set: out of memory for k (%d bytes)', strlen( k)+1);
      exit( -1);
    }
    strcpy( p->k, k);
    p->k[strlen(k)] = 0;

    // leave a little room to grow
    //
    if( v == NULL || *v == 0)
      p->vl = 32;
    else
      p->vl = strlen(v) + 32;

    p->v = calloc( p->vl, sizeof( *v));
    if( p->v == NULL) {
      lslogging_log_message( 'lskvs_set: out of memory for v (%d bytes)', p->vl);
      exit( -1);
    }
    
    if( v == NULL || *v == 0)
      *(p->v) = 0;
    else
      strcpy( p->v, v);

    p->v[p->vl-1] = 0;
    
    pthread_rwlock_init( &p->l, NULL);

    pthread_rwlock_wrlock( &lskvs_rwlock);
    p->next   = lskvs_kvs;
    lskvs_kvs = p;
    pthread_rwlock_unlock( &lskvs_rwlock);
  } else {
    //
    // Just update the value
    // Assume the database only sent us an update because
    // the old and new values are different
    //
    pthread_rwlock_wrlock( &(p->l));
    if( strlen( v) > p->vl-1) {
      free( p->v);
      
      p->vl = strlen(v) + 32;
      p->v = calloc( p->vl, 1);
      if( p->v == NULL) {
        lslogging_log_message( 'lskvs_set: out of memory for re-calloc of v (%d bytes)', p->vl);
        exit( -1);
      }
    }
    strcpy( p->v, v);
    p->v[p->vl-1] = 0;
    pthread_rwlock_unlock( &(p->l));
  }
}
.fi
.SH "Variable Documentation"
.PP 
.SS "\fBlskvs_kvs_t\fP* lskvs_kvs = NULL\fC [static]\fP"

.PP
our list (or at least the start of it 
.PP
Definition at line 25 of file lskvs\&.c\&.
.SS "pthread_rwlock_t lskvs_rwlock\fC [static]\fP"

.PP
needed to protect the list 
.PP
Definition at line 26 of file lskvs\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for LS-CAT PGPMAC from the source code\&.
