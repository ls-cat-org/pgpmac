.TH "md2cmds.c" 3 "14 Nov 2012" "LS-CAT PGPMAC" \" -*- nroff -*-
.ad l
.nh
.SH NAME
md2cmds.c \- 
.PP
Implements commands to run the md2 diffractometer attached to a PMAC controled by postgresql.  

.SH SYNOPSIS
.br
.PP
\fC#include 'pgpmac.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBmd2cmds_transfer\fP ()"
.br
.RI "\fITransfer a sample TODO: Implement. \fP"
.ti -1c
.RI "char * \fBlogtime\fP ()"
.br
.RI "\fIReturn a time string for loggin Time is from the first call to this funciton. \fP"
.ti -1c
.RI "void \fBmd2cmds_moveAbs\fP (char *cmd)"
.br
.RI "\fIMove a motor to the position requested. \fP"
.ti -1c
.RI "void \fBmd2cmds_mvcenter_prep\fP ()"
.br
.RI "\fISets up a centering table and alignment table move Ensures that when we issue the move command that we can detect that the move happened. \fP"
.ti -1c
.RI "void \fBmd2cmds_mvcenter_move\fP (double cx, double cy, double ax, double ay, double az)"
.br
.RI "\fIMove the centering and alignment tables. \fP"
.ti -1c
.RI "void \fBmd2cmds_mvcenter_wait\fP ()"
.br
.RI "\fIWait for the centering and alignment tables to stop moving. \fP"
.ti -1c
.RI "void \fBmd2cmds_collect\fP ()"
.br
.RI "\fICollect some data. \fP"
.ti -1c
.RI "void \fBmd2cmds_rotate\fP ()"
.br
.RI "\fISpin 360 and make a video (recenter first, maybe). \fP"
.ti -1c
.RI "void \fBmd2cmds_center\fP ()"
.br
.RI "\fIMove centering and alignment tables as requested TODO: Implement. \fP"
.ti -1c
.RI "void * \fBmd2cmds_worker\fP (void *dummy)"
.br
.RI "\fIOur worker thread. \fP"
.ti -1c
.RI "void \fBmd2cmds_init\fP ()"
.br
.RI "\fIInitialize the md2cmds module. \fP"
.ti -1c
.RI "void \fBmd2cmds_run\fP ()"
.br
.RI "\fIStart up the thread. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "pthread_cond_t \fBmd2cmds_cond\fP"
.br
.RI "\fIcondition to signal when it's time to run an md2 command \fP"
.ti -1c
.RI "pthread_mutex_t \fBmd2cmds_mutex\fP"
.br
.RI "\fImutex for the condition \fP"
.ti -1c
.RI "pthread_cond_t \fBmd2cmds_pg_cond\fP"
.br
.RI "\fIcoordinate call and response \fP"
.ti -1c
.RI "pthread_mutex_t \fBmd2cmds_pg_mutex\fP"
.br
.RI "\fImessage passing between md2cmds and pg \fP"
.ti -1c
.RI "char \fBmd2cmds_cmd\fP [MD2CMDS_CMD_LENGTH]"
.br
.RI "\fIour command; \fP"
.ti -1c
.RI "static pthread_t \fBmd2cmds_thread\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Implements commands to run the md2 diffractometer attached to a PMAC controled by postgresql. 

\fBDate:\fP
.RS 4
2012 
.RE
.PP
\fBAuthor:\fP
.RS 4
Keith Brister  All Rights Reserved 
.RE
.PP

.PP
Definition in file \fBmd2cmds.c\fP.
.SH "Function Documentation"
.PP 
.SS "char* logtime ()"
.PP
Return a time string for loggin Time is from the first call to this funciton. 
.PP
Definition at line 30 of file md2cmds.c.
.PP
.nf
30                 {
31   static char rtn[128];
32   static char tmp[64];
33   static int first_time = 1;
34   static struct timeval base;
35   struct timeval now;
36   struct tm nows;
37   double diffs;
38 
39   if( first_time) {
40     first_time=0;
41     gettimeofday( &base, NULL);
42     strftime(tmp, sizeof(tmp)-1, '%Y-%m-%d %H:%M:%S', localtime( &(base.tv_sec)));
43     tmp[sizeof(tmp)-1]=0;
44     snprintf( rtn, sizeof(rtn)-1, '%s.%06d', tmp, base.tv_usec);
45     rtn[sizeof(rtn)-1]=0;
46   } else {
47     gettimeofday( &now, NULL);
48     diffs =  (now.tv_sec - base.tv_sec);
49     diffs += (now.tv_usec - base.tv_usec)/1000000.;
50     snprintf( rtn, sizeof( rtn)-1, '%0.6f', diffs);
51     rtn[sizeof(rtn)-1]=0;
52   }
53 
54   return rtn;
55 }
.fi
.SS "void md2cmds_center ()"
.PP
Move centering and alignment tables as requested TODO: Implement. 
.PP
Definition at line 490 of file md2cmds.c.
.PP
.nf
490                       {
491 }
.fi
.SS "void md2cmds_collect ()"
.PP
Collect some data. 
.PP
Definition at line 205 of file md2cmds.c.
.PP
.nf
205                        {
206   long long skey;
207   double p170;  // start cnts
208   double p171;  // end cnts
209   double p173;  // omega velocity cnts/msec
210   double p175;  // acceleration time (msec)
211   double p180;  // exposure time (msec)
212   FILE *zzlog;
213   struct timeval tt_base, tt_now;
214   int center_request;
215 
216   zzlog = fopen( '/tmp/collect_log.txt', 'w');
217   fprintf( zzlog, '%s: Start md2cmds\n', logtime());
218   fflush( zzlog);
219 
220   //
221   // reset shutter has opened flag
222   //
223   lspmac_SockSendline( 'P3001=0 P3002=0');
224 
225 
226   while( 1) {
227     fprintf( zzlog, '%s: call lspg_nextshot_call\n', logtime());
228     fflush( zzlog);
229     lspg_nextshot_call();
230 
231     //
232     // This is where we'd tell the md2 to move the organs into position
233     //
234 
235     fprintf( zzlog, '%s: call lspg_nextshot_wait\n', logtime());
236     fflush( zzlog);
237 
238     lspg_nextshot_wait();
239     fprintf( zzlog, '%s: returned from  lspg_nextshot_wait\n', logtime());
240     fflush( zzlog);
241 
242     if( lspg_nextshot.no_rows_returned) {
243       lspg_nextshot_done();
244       break;
245     }
246 
247     skey = lspg_nextshot.skey;
248     lspg_query_push( NULL, 'SELECT px.shots_set_state(%lld, 'Preparing')', skey);
249 
250     center_request = 0;
251     if( lspg_nextshot.active) {
252       if(
253          (fabs( lspg_nextshot.cx - cenx->position) > 0.1) ||
254          (fabs( lspg_nextshot.cy - ceny->position) > 0.1) ||
255          (fabs( lspg_nextshot.ax - alignx->position) > 0.1) ||
256          (fabs( lspg_nextshot.ay - aligny->position) > 0.1) ||
257          (fabs( lspg_nextshot.az - alignz->position) > 0.1)) {
258 
259         center_request = 1;
260         md2cmds_mvcenter_prep();
261         md2cmds_mvcenter_move( lspg_nextshot.cx, lspg_nextshot.cy, lspg_nextshot.ax, lspg_nextshot.ay, lspg_nextshot.az);
262       }
263     }
264 
265     if( !lspg_nextshot.dsphi_isnull) {
266       lspmac_moveabs_queue( phi, lspg_nextshot.dsphi);
267     }
268   
269     if( !lspg_nextshot.dskappa_isnull) {
270       lspmac_moveabs_queue( kappa, lspg_nextshot.dskappa);
271     }
272 
273   
274     //
275     // Wait for all those motors to stop
276     //
277     if( center_request) {
278       md2cmds_mvcenter_wait();
279     }
280 
281     if( !lspg_nextshot.dsphi_isnull) {
282       lspmac_moveabs_wait( phi);
283     }
284   
285     if( !lspg_nextshot.dskappa_isnull) {
286       lspmac_moveabs_wait( kappa);
287     }
288 
289     //
290     // Calculate the parameters we'll need to run the scan
291     //
292     p180 = lspg_nextshot.dsexp * 1000.0;
293     p170 = omega->u2c * lspg_nextshot.sstart;
294     //    p171 = omega->u2c * ( lspg_nextshot.sstart + lspg_nextshot.dsowidth);
295     p171 = omega->u2c * lspg_nextshot.dsowidth;
296     p173 = fabs(p180) < 1.e-4 ? 0.0 : omega->u2c * lspg_nextshot.dsowidth / p180;
297     p175 = p173/omega->max_accel;
298 
299 
300     //
301     // free up access to nextshot
302     //
303     lspg_nextshot_done();
304 
305     fprintf( zzlog, '%s: finished with lspg_nextshot_done, calling lspg_seq_run_prep_all\n', logtime());
306     fflush( zzlog);
307 
308     //
309     // prepare the database and detector to expose
310     // On exit we own the diffractometer lock and
311     // have checked that all is OK with the detector
312     //
313     lspg_seq_run_prep_all( skey,
314                            kappa->position,
315                            phi->position,
316                            cenx->position,
317                            ceny->position,
318                            alignx->position,
319                            aligny->position,
320                            alignz->position
321                            );
322 
323     
324     fprintf( zzlog, '%s: finished with lspg_seq_run_prep_all\n', logtime());
325     fflush( zzlog);
326     //
327     // make sure our has opened flag is down
328     // wait for the p3001=0 command to be noticed
329     //
330     pthread_mutex_lock( &lspmac_shutter_mutex);
331     if( lspmac_shutter_has_opened == 1)
332       pthread_cond_wait( &lspmac_shutter_cond, &lspmac_shutter_mutex);
333     pthread_mutex_unlock( &lspmac_shutter_mutex);
334 
335     //
336     // Start the exposure
337     //
338     lspmac_SockSendline( 'P170=%.1f P171=%.1f P173=%.1f P174=0 P175=%.1f P176=0 P177=1 P178=0 P180=%.1f M431=1 &1B131R',
339                          p170,      p171,     p173,            p175,                          p180);
340 
341 
342     fprintf( zzlog, '%s: sent command to pmac\n', logtime());
343     fflush( zzlog);
344 
345     //
346     // wait for the shutter to open
347     //
348     pthread_mutex_lock( &lspmac_shutter_mutex);
349     if( lspmac_shutter_has_opened == 0)
350       pthread_cond_wait( &lspmac_shutter_cond, &lspmac_shutter_mutex);
351 
352     fprintf( zzlog, '%s: shutter has opened\n', logtime());
353     fflush( zzlog);
354 
355     //
356     // wait for the shutter to close
357     //
358     if( lspmac_shutter_state == 1)
359       pthread_cond_wait( &lspmac_shutter_cond, &lspmac_shutter_mutex);
360     pthread_mutex_unlock( &lspmac_shutter_mutex);
361 
362     fprintf( zzlog, '%s: shutter now closed, unlocking diffractometer\n', logtime());
363     fflush( zzlog);
364 
365 
366     lspg_query_push( NULL, 'SELECT px.unlock_diffractometer()');
367 
368     fprintf( zzlog, '%s: unlocked diffractometer\n', logtime());
369     fflush( zzlog);
370 
371     lspg_query_push( NULL, 'SELECT px.shots_set_state(%lld, 'Writing')', skey);
372 
373     //
374     // reset shutter has opened flag
375     //
376     lspmac_SockSendline( 'P3001=0');
377     //
378     // TODO:
379     // wait for omega to stop moving then position it for the next frame
380     //
381 
382 
383     if( !lspg_nextshot.active2_isnull && lspg_nextshot.active2) {
384       if(
385          (fabs( lspg_nextshot.cx2 - cenx->position) > 0.1) ||
386          (fabs( lspg_nextshot.cy2 - ceny->position) > 0.1) ||
387          (fabs( lspg_nextshot.ax2 - alignx->position) > 0.1) ||
388          (fabs( lspg_nextshot.ay2 - aligny->position) > 0.1) ||
389          (fabs( lspg_nextshot.az2 - alignz->position) > 0.1)) {
390 
391         center_request = 1;
392         md2cmds_mvcenter_prep();
393         md2cmds_mvcenter_move( lspg_nextshot.cx, lspg_nextshot.cy, lspg_nextshot.ax, lspg_nextshot.ay, lspg_nextshot.az);
394         md2cmds_mvcenter_wait();
395       }
396     }
397 
398   }
399   fprintf( zzlog, '%s: done\n', logtime());
400   fflush( zzlog);
401   fclose( zzlog);
402 }
.fi
.SS "void md2cmds_init ()"
.PP
Initialize the md2cmds module. 
.PP
Definition at line 529 of file md2cmds.c.
.PP
.nf
529                     {
530   memset( md2cmds_cmd, 0, sizeof( md2cmds_cmd));
531 
532   pthread_mutex_init( &md2cmds_mutex, NULL);
533   pthread_cond_init( &md2cmds_cond, NULL);
534 
535   pthread_mutex_init( &md2cmds_pg_mutex, NULL);
536   pthread_cond_init( &md2cmds_pg_cond, NULL);
537 
538 }
.fi
.SS "void md2cmds_moveAbs (char * cmd)"
.PP
Move a motor to the position requested. \fBParameters:\fP
.RS 4
\fIcmd\fP The full command string to parse, ie, 'moveAbs omega 180' 
.RE
.PP

.PP
Definition at line 59 of file md2cmds.c.
.PP
.nf
61                        {
62   char *ignore;
63   char *ptr;
64   char *mtr;
65   char *pos;
66   double fpos;
67   char *endptr;
68   lspmac_motor_t *mp;
69   int i;
70 
71   // Parse the command string
72   //
73   ignore = strtok_r( cmd, ' ', &ptr);
74   if( ignore == NULL) {
75     //
76     // Should generate error message
77     // about blank command
78     //
79     return;
80   }
81 
82   // The first string should be 'moveAbs' cause that's how we got here.
83   // Toss it.
84   
85   mtr = strtok_r( NULL, ' ', &ptr);
86   if( mtr == NULL) {
87     lslogging_log_message( 'md2cmds moveAbs error: missing motor name');
88     return;
89   }
90 
91   pos = strtok_r( NULL, ' ', &ptr);
92   if( pos == NULL) {
93     lslogging_log_message( 'md2cmds moveAbs error: missing position');
94     return;
95   }
96 
97   fpos = strtod( pos, &endptr);
98   if( pos == endptr) {
99     lslogging_log_message( 'md2cmds moveAbs error: Can't decipher '%s' as a number', pos);
100     return;
101   }
102   
103   mp = NULL;
104   for( i=0; i<lspmac_nmotors; i++) {
105     if( strcmp( lspmac_motors[i].name, mtr) == 0) {
106       mp = &(lspmac_motors[i]);
107       break;
108     }
109   }
110 
111 
112   if( mp != NULL && mp->moveAbs != NULL) {
113     wprintw( term_output, 'Moving %s to %f\n', mtr, fpos);
114     wnoutrefresh( term_output);
115     mp->moveAbs( mp, fpos);
116   }
117 
118 }
.fi
.SS "void md2cmds_mvcenter_move (double cx, double cy, double ax, double ay, double az)"
.PP
Move the centering and alignment tables. \fBParameters:\fP
.RS 4
\fIcx\fP Requested Centering Table X 
.br
\fIcy\fP Requested Centering Table Y 
.br
\fIax\fP Requested Alignment Table X 
.br
\fIay\fP Requested Alignment Table Y 
.br
\fIaz\fP Requested Alignment Table Z 
.RE
.PP

.PP
Definition at line 164 of file md2cmds.c.
.PP
.nf
170                              {
171   //
172   // centering stage is coordinate system 2
173   // alignment stage is coordinate system 3
174   //
175   
176   double cx_cts, cy_cts, ax_cts, ay_cts, az_cts;
177 
178   cx_cts = cenx->u2c   * cx;
179   cy_cts = ceny->u2c   * cy;
180   ax_cts = alignx->u2c * ax;
181   ay_cts = aligny->u2c * ay;
182   az_cts = alignz->u2c * az;
183 
184   lspmac_SockSendline( 'M7075=(M7075 | 2) &2 Q100=2 Q20=%.1f Q21=%.1f B150R', cx_cts, cy_cts);
185   lspmac_SockSendline( 'M7075=(M7075 | 4) &3 Q100=4 Q30=%.1f Q31=%.1f Q32=%.1f B160R', ax_cts, ay_cts, az_cts);
186   
187 }
.fi
.SS "void md2cmds_mvcenter_prep ()"
.PP
Sets up a centering table and alignment table move Ensures that when we issue the move command that we can detect that the move happened. 
.PP
Definition at line 125 of file md2cmds.c.
.PP
.nf
125                              {
126   //
127   // Clears the motion flags for coordinate systems 2 and 3
128   // Then sets them.
129   // Each time we wait until we've read back
130   // the changed values
131   //
132   // This guarantees that when we are waiting for motion to stop that it did, in fact, start
133   //
134 
135   //
136   // Clear the centering and alignment stage flags
137   //
138   lspmac_SockSendline( 'M7075=(M7075 | 6) ^ 6');
139 
140   //
141   // Make sure it propagates
142   //
143   pthread_mutex_lock( &lspmac_moving_mutex);
144   while( lspmac_moving_flags & 6)
145     pthread_cond_wait( &lspmac_moving_cond, &lspmac_moving_mutex);
146   pthread_mutex_unlock( &lspmac_moving_mutex);
147 
148   //
149   // Set the centering and alignment stage flags
150   //
151   lspmac_SockSendline( 'M7075=(M7075 | 6)');
152 
153   //
154   // Make sure it propagates
155   //
156   pthread_mutex_lock( &lspmac_moving_mutex);
157   while( (lspmac_moving_flags & 6) == 0)
158     pthread_cond_wait( &lspmac_moving_cond, &lspmac_moving_mutex);
159   pthread_mutex_unlock( &lspmac_moving_mutex);
160 }
.fi
.SS "void md2cmds_mvcenter_wait ()"
.PP
Wait for the centering and alignment tables to stop moving. 
.PP
Definition at line 191 of file md2cmds.c.
.PP
.nf
191                              {
192   //
193   // Just wait until the motion flags are lowered
194   //
195 
196   pthread_mutex_lock( &lspmac_moving_mutex);
197   while( lspmac_moving_flags & 6)
198     pthread_cond_wait( &lspmac_moving_cond, &lspmac_moving_mutex);
199   pthread_mutex_unlock( &lspmac_moving_mutex);
200 }
.fi
.SS "void md2cmds_rotate ()"
.PP
Spin 360 and make a video (recenter first, maybe). 
.PP
Definition at line 407 of file md2cmds.c.
.PP
.nf
407                       {
408   //
409   // BLUMax disables scintilator here.
410   //
411 
412   //
413   // get the new center information
414   //
415   lspg_getcenter_call();
416 
417   lspg_getcenter_wait();
418 
419 
420   // put up the back light
421   blight_ud->moveAbs( blight_ud, 1);
422 
423   if( lspg_getcenter.no_rows_returned) {
424     //
425     // the other case is considered below
426     // Bottom line, zoom is always defined
427     //
428     zoom->moveAbs( zoom, 1);    // default zoom is 1
429   }
430 
431 
432   if( lspg_getcenter.no_rows_returned == 0) {
433     double cx, cy, ax, ay, az;
434 
435     if( lspg_getcenter.zoom_isnull == 0) {
436       zoom->moveAbs( zoom, lspg_getcenter.zoom);
437     } else {
438       zoom->moveAbs( zoom, 1);
439     }
440 
441     //
442     // OK, why not just implement a nice getter that does the locking transparently?  UGLY!
443     //
444     pthread_mutex_lock( &(cenx->mutex));
445     cx = cenx->position;
446     pthread_mutex_unlock( &(cenx->mutex));
447     if( lspg_getcenter.dcx_isnull == 0)
448       cx += lspg_getcenter.dcx;
449 
450     pthread_mutex_lock( &(ceny->mutex));
451     cy = ceny->position;
452     pthread_mutex_unlock( &(ceny->mutex));
453     if( lspg_getcenter.dcy_isnull == 0)
454       cy  += lspg_getcenter.dcy;
455                           
456     pthread_mutex_lock( &(alignx->mutex));
457     ax = alignx->position;
458     pthread_mutex_unlock( &(alignx->mutex));
459     if( lspg_getcenter.dax_isnull == 0)
460       ax  += lspg_getcenter.dax;
461 
462     pthread_mutex_lock( &(aligny->mutex));
463     ay = aligny->position;
464     pthread_mutex_unlock( &(aligny->mutex));
465     if( lspg_getcenter.day_isnull == 0)
466       ay  += lspg_getcenter.day;
467                           
468     pthread_mutex_lock( &(alignz->mutex));
469     az = alignz->position;
470     pthread_mutex_unlock( &(alignz->mutex));
471     if( lspg_getcenter.daz_isnull == 0)
472       az  += lspg_getcenter.daz;
473                           
474     md2cmds_mvcenter_move( cx, cy, ax, ay, az);
475     md2cmds_mvcenter_wait();
476   }
477   lspg_getcenter_done();
478 
479   // Home omega
480   lspmac_SockSendline('M401=1 M1115=1 #1$ &1B1R');
481 
482   
483   
484   
485 }
.fi
.SS "void md2cmds_run ()"
.PP
Start up the thread. 
.PP
Definition at line 542 of file md2cmds.c.
.PP
.nf
542                    {
543   pthread_create( &md2cmds_thread, NULL, md2cmds_worker, NULL);
544 }
.fi
.SS "void md2cmds_transfer ()"
.PP
Transfer a sample TODO: Implement. 
.PP
Definition at line 24 of file md2cmds.c.
.PP
.nf
24                         {
25 }
.fi
.SS "void* md2cmds_worker (void * dummy)"
.PP
Our worker thread. \fBParameters:\fP
.RS 4
\fIdummy\fP > [in] Unused but required by protocol 
.RE
.PP

.PP
Definition at line 497 of file md2cmds.c.
.PP
.nf
499                        {
500 
501   pthread_mutex_lock( &md2cmds_mutex);
502 
503   while( 1) {
504     //
505     // wait for someone to give us a command (and tell us they did so)
506     //
507     while( md2cmds_cmd[0] == 0)
508       pthread_cond_wait( &md2cmds_cond, &md2cmds_mutex);
509 
510     if( strcmp( md2cmds_cmd, 'transfer') == 0) {
511       md2cmds_transfer();
512     } else if( strcmp( md2cmds_cmd, 'collect') == 0) {
513       md2cmds_collect();
514     } else if( strcmp( md2cmds_cmd, 'rotate') == 0) {
515       md2cmds_rotate();
516     } else if( strcmp( md2cmds_cmd, 'center') == 0) {
517       md2cmds_center();
518     } else if( strncmp( md2cmds_cmd, 'moveAbs', 7) == 0) {
519       md2cmds_moveAbs( md2cmds_cmd);
520     }
521 
522     md2cmds_cmd[0] = 0;
523   }
524 }
.fi
.SH "Variable Documentation"
.PP 
.SS "char \fBmd2cmds_cmd\fP[MD2CMDS_CMD_LENGTH]"
.PP
our command; 
.PP
Definition at line 16 of file md2cmds.c.
.SS "pthread_cond_t \fBmd2cmds_cond\fP"
.PP
condition to signal when it's time to run an md2 command 
.PP
Definition at line 10 of file md2cmds.c.
.SS "pthread_mutex_t \fBmd2cmds_mutex\fP"
.PP
mutex for the condition 
.PP
Definition at line 11 of file md2cmds.c.
.SS "pthread_cond_t \fBmd2cmds_pg_cond\fP"
.PP
coordinate call and response 
.PP
Definition at line 13 of file md2cmds.c.
.SS "pthread_mutex_t \fBmd2cmds_pg_mutex\fP"
.PP
message passing between md2cmds and pg 
.PP
Definition at line 14 of file md2cmds.c.
.SS "pthread_t \fBmd2cmds_thread\fP\fC [static]\fP"
.PP
Definition at line 18 of file md2cmds.c.
.SH "Author"
.PP 
Generated automatically by Doxygen for LS-CAT PGPMAC from the source code.
