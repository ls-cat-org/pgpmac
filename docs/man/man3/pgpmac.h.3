.TH "pgpmac.h" 3 "Tue Dec 18 2012" "LS-CAT PGPMAC" \" -*- nroff -*-
.ad l
.nh
.SH NAME
pgpmac.h \- 
.PP
Headers for the entire pgpmac project\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <stdio\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include <sys/socket\&.h>\fP
.br
\fC#include <netdb\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <netinet/in\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br
\fC#include <poll\&.h>\fP
.br
\fC#include <libpq-fe\&.h>\fP
.br
\fC#include <ncurses\&.h>\fP
.br
\fC#include <math\&.h>\fP
.br
\fC#include <pthread\&.h>\fP
.br
\fC#include <signal\&.h>\fP
.br
\fC#include <sys/signalfd\&.h>\fP
.br
\fC#include <sys/time\&.h>\fP
.br
\fC#include <time\&.h>\fP
.br
\fC#include <getopt\&.h>\fP
.br
\fC#include <regex\&.h>\fP
.br
\fC#include <hiredis/hiredis\&.h>\fP
.br
\fC#include <hiredis/async\&.h>\fP
.br
\fC#include <search\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBlsredis_obj_struct\fP"
.br
.RI "\fIRedis Object Basic object whose value is sychronized with our redis db\&. \fP"
.ti -1c
.RI "struct \fBtagEthernetCmd\fP"
.br
.RI "\fIPMAC ethernet packet definition\&. \fP"
.ti -1c
.RI "struct \fBlspmac_cmd_queue_struct\fP"
.br
.RI "\fIPMAC command queue item\&. \fP"
.ti -1c
.RI "struct \fBlspmac_motor_struct\fP"
.br
.RI "\fIMotor information\&. \fP"
.ti -1c
.RI "struct \fBlspmac_bi_struct\fP"
.br
.RI "\fIStorage for binary inputs\&. \fP"
.ti -1c
.RI "struct \fBlspg_getcenter_struct\fP"
.br
.RI "\fIStorage for getcenter query Used for the md2 ROTATE command that generates the centering movies\&. \fP"
.ti -1c
.RI "struct \fBlspg_nextshot_struct\fP"
.br
.RI "\fIStorage definition for nextshot query\&. \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fB_GNU_SOURCE\fP"
.br
.ti -1c
.RI "#define \fBLS_DISPLAY_WINDOW_HEIGHT\fP   8"
.br
.RI "\fINumber of status box rows\&. \fP"
.ti -1c
.RI "#define \fBLS_DISPLAY_WINDOW_WIDTH\fP   24"
.br
.RI "\fINumber of status box columns\&. \fP"
.ti -1c
.RI "#define \fBLS_PG_QUERY_STRING_LENGTH\fP   1024"
.br
.RI "\fIFixed length postgresql query strings\&. Queries should all be function calls so this is not as weird as one might think\&. \fP"
.ti -1c
.RI "#define \fBLSEVENTS_EVENT_LENGTH\fP   256"
.br
.RI "\fIFixed length for event names: simplifies string handling\&. \fP"
.ti -1c
.RI "#define \fBMD2CMDS_CMD_LENGTH\fP   32"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBlsredis_obj_struct\fP \fBlsredis_obj_t\fP"
.br
.RI "\fIRedis Object Basic object whose value is sychronized with our redis db\&. \fP"
.ti -1c
.RI "typedef struct \fBtagEthernetCmd\fP \fBpmac_cmd_t\fP"
.br
.RI "\fIPMAC ethernet packet definition\&. \fP"
.ti -1c
.RI "typedef struct 
.br
\fBlspmac_cmd_queue_struct\fP \fBpmac_cmd_queue_t\fP"
.br
.RI "\fIPMAC command queue item\&. \fP"
.ti -1c
.RI "typedef struct \fBlspmac_motor_struct\fP \fBlspmac_motor_t\fP"
.br
.RI "\fIMotor information\&. \fP"
.ti -1c
.RI "typedef struct \fBlspmac_bi_struct\fP \fBlspmac_bi_t\fP"
.br
.RI "\fIStorage for binary inputs\&. \fP"
.ti -1c
.RI "typedef struct 
.br
\fBlspg_getcenter_struct\fP \fBlspg_getcenter_t\fP"
.br
.RI "\fIStorage for getcenter query Used for the md2 ROTATE command that generates the centering movies\&. \fP"
.ti -1c
.RI "typedef struct \fBlspg_nextshot_struct\fP \fBlspg_nextshot_t\fP"
.br
.RI "\fIStorage definition for nextshot query\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "double \fBlspmac_getPosition\fP (\fBlspmac_motor_t\fP *)"
.br
.RI "\fIget the motor position (with locking) \fP"
.ti -1c
.RI "void \fBPmacSockSendline\fP (char *s)"
.br
.ti -1c
.RI "void \fBpgpmac_printf\fP (char *fmt,\&.\&.\&.)"
.br
.RI "\fITerminal output routine ala printf\&. \fP"
.ti -1c
.RI "char ** \fBlspg_array2ptrs\fP (char *)"
.br
.RI "\fIreturns a null terminated list of strings parsed from postgresql array \fP"
.ti -1c
.RI "void \fBlspg_init\fP ()"
.br
.RI "\fIInitiallize the lspg module\&. \fP"
.ti -1c
.RI "void \fBlspg_run\fP ()"
.br
.RI "\fIStart 'er runnin'\&. \fP"
.ti -1c
.RI "void \fBlspg_seq_run_prep_all\fP (long long skey, double \fBkappa\fP, double \fBphi\fP, double cx, double cy, double ax, double ay, double az)"
.br
.RI "\fIConvinence function to call seq run prep\&. \fP"
.ti -1c
.RI "void \fBlspg_zoom_lut_call\fP ()"
.br
.ti -1c
.RI "void \fBlspmac_init\fP (int, int)"
.br
.RI "\fIInitialize this module\&. \fP"
.ti -1c
.RI "void \fBlspmac_run\fP ()"
.br
.RI "\fIStart up the lspmac thread\&. \fP"
.ti -1c
.RI "void \fBlspmac_move_or_jog_queue\fP (\fBlspmac_motor_t\fP *, double, int)"
.br
.ti -1c
.RI "void \fBlspmac_move_or_jog_preset_queue\fP (\fBlspmac_motor_t\fP *, char *, int)"
.br
.RI "\fImove using a preset value \fP"
.ti -1c
.RI "void \fBlspmac_moveabs_queue\fP (\fBlspmac_motor_t\fP *, double)"
.br
.RI "\fIUse coordinate system motion program, if available, to move motor to requested position\&. \fP"
.ti -1c
.RI "void \fBlspmac_jogabs_queue\fP (\fBlspmac_motor_t\fP *, double)"
.br
.RI "\fIUse jog to move motor to requested position\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_SockSendline\fP (char *,\&.\&.\&.)"
.br
.RI "\fISend a one line command\&. \fP"
.ti -1c
.RI "void \fBlsupdate_init\fP ()"
.br
.ti -1c
.RI "void \fBmd2cmds_init\fP ()"
.br
.RI "\fIInitialize the md2cmds module\&. \fP"
.ti -1c
.RI "void \fBmd2cmds_run\fP ()"
.br
.RI "\fIStart up the thread\&. \fP"
.ti -1c
.RI "void \fBlsupdate_run\fP ()"
.br
.ti -1c
.RI "void \fBlsevents_init\fP ()"
.br
.RI "\fIInitialize this module\&. \fP"
.ti -1c
.RI "void \fBlsevents_run\fP ()"
.br
.RI "\fIStart up the thread and get out of the way\&. \fP"
.ti -1c
.RI "void \fBlsevents_send_event\fP (char *,\&.\&.\&.)"
.br
.RI "\fICall the callback routines for the given event\&. \fP"
.ti -1c
.RI "void \fBlsevents_add_listener\fP (char *, void(*cb)(char *))"
.br
.RI "\fIAdd a callback routine to listen for a specific event\&. \fP"
.ti -1c
.RI "void \fBlsevents_remove_listener\fP (char *, void(*cb)(char *))"
.br
.RI "\fIRemove a listener previously added with lsevents_add_listener\&. \fP"
.ti -1c
.RI "void \fBlstimer_init\fP ()"
.br
.RI "\fIInitialize the timer list and pthread stuff\&. \fP"
.ti -1c
.RI "void \fBlstimer_run\fP ()"
.br
.RI "\fIStart up our thread\&. \fP"
.ti -1c
.RI "void \fBlstimer_add_timer\fP (char *, int, unsigned long int, unsigned long int)"
.br
.RI "\fICreate a timer\&. \fP"
.ti -1c
.RI "void \fBlsredis_init\fP (char *pub, char *re, char *head)"
.br
.RI "\fIInitialize this module, that is, set up the connections\&. \fP"
.ti -1c
.RI "void \fBlsredis_run\fP ()"
.br
.ti -1c
.RI "\fBlsredis_obj_t\fP * \fBlsredis_get_obj\fP (char *,\&.\&.\&.)"
.br
.ti -1c
.RI "char * \fBlsredis_getstr\fP (\fBlsredis_obj_t\fP *p)"
.br
.RI "\fIreturn a copy of the key's string value \fP"
.ti -1c
.RI "double \fBlsredis_getd\fP (\fBlsredis_obj_t\fP *p)"
.br
.ti -1c
.RI "long int \fBlsredis_getl\fP (\fBlsredis_obj_t\fP *p)"
.br
.ti -1c
.RI "char ** \fBlsredis_get_string_array\fP (\fBlsredis_obj_t\fP *p)"
.br
.ti -1c
.RI "int \fBlsredis_getb\fP (\fBlsredis_obj_t\fP *p)"
.br
.ti -1c
.RI "int \fBlsredis_cmpstr\fP (\fBlsredis_obj_t\fP *p, char *s)"
.br
.ti -1c
.RI "int \fBlsredis_regexec\fP (const regex_t *preg, \fBlsredis_obj_t\fP *p, size_t nmatch, regmatch_t *pmatch, int eflags)"
.br
.ti -1c
.RI "int \fBlsredis_cmpnstr\fP (\fBlsredis_obj_t\fP *p, char *s, int n)"
.br
.ti -1c
.RI "int \fBlsredis_find_preset\fP (char *base, char *preset_name, double *dval)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBlspg_getcenter_t\fP \fBlspg_getcenter\fP"
.br
.RI "\fIthe getcenter object \fP"
.ti -1c
.RI "\fBlspg_nextshot_t\fP \fBlspg_nextshot\fP"
.br
.RI "\fIthe nextshot object \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP \fBlspmac_motors\fP []"
.br
.RI "\fIAll our motors\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBomega\fP"
.br
.RI "\fIMD2 omega axis (the air bearing) \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBalignx\fP"
.br
.RI "\fIAlignment stage X\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBaligny\fP"
.br
.RI "\fIAlignment stage Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBalignz\fP"
.br
.RI "\fIAlignment stage X\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBanal\fP"
.br
.RI "\fIPolaroid analyzer motor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBzoom\fP"
.br
.RI "\fIOptical zoom\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBapery\fP"
.br
.RI "\fIAperture Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBaperz\fP"
.br
.RI "\fIAperture Z\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcapy\fP"
.br
.RI "\fICapillary Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcapz\fP"
.br
.RI "\fICapillary Z\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBscint\fP"
.br
.RI "\fIScintillator Z\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcenx\fP"
.br
.RI "\fICentering Table X\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBceny\fP"
.br
.RI "\fICentering Table Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBkappa\fP"
.br
.RI "\fIKappa\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBphi\fP"
.br
.RI "\fIPhi (not data collection axis) \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBfshut\fP"
.br
.RI "\fIFast shutter\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBflight\fP"
.br
.RI "\fIFront Light DAC\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBblight\fP"
.br
.RI "\fIBack Light DAC\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBfscint\fP"
.br
.RI "\fIScintillator Piezo DAC\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBblight_ud\fP"
.br
.RI "\fIBack light Up/Down actuator\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBflight_oo\fP"
.br
.RI "\fITurn front light on/off\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBblight_f\fP"
.br
.RI "\fIBack light scale factor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBflight_f\fP"
.br
.RI "\fIFront light scale factor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcryo\fP"
.br
.RI "\fIMove the cryostream towards or away from the crystal\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBdryer\fP"
.br
.RI "\fIblow air on the scintilator to dry it off \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBfluo\fP"
.br
.RI "\fIMove the fluorescence detector in/out\&. \fP"
.ti -1c
.RI "int \fBlspmac_nmotors\fP"
.br
.RI "\fIThe number of motors we manage\&. \fP"
.ti -1c
.RI "struct timespec \fBomega_zero_time\fP"
.br
.RI "\fITime we believe that omega crossed zero\&. \fP"
.ti -1c
.RI "WINDOW * \fBterm_output\fP"
.br
.RI "\fIplace to print stuff out \fP"
.ti -1c
.RI "WINDOW * \fBterm_input\fP"
.br
.RI "\fIplace to put the cursor \fP"
.ti -1c
.RI "WINDOW * \fBterm_status\fP"
.br
.RI "\fIshutter, lamp, air, etc status \fP"
.ti -1c
.RI "WINDOW * \fBterm_status2\fP"
.br
.RI "\fIshutter, lamp, air, etc status \fP"
.ti -1c
.RI "pthread_mutex_t \fBncurses_mutex\fP"
.br
.RI "\fIallow more than one thread access to the screen \fP"
.ti -1c
.RI "pthread_cond_t \fBmd2cmds_cond\fP"
.br
.RI "\fIcondition to signal when it's time to run an md2 command \fP"
.ti -1c
.RI "pthread_mutex_t \fBmd2cmds_mutex\fP"
.br
.RI "\fImutex for the condition \fP"
.ti -1c
.RI "pthread_cond_t \fBmd2cmds_pg_cond\fP"
.br
.ti -1c
.RI "pthread_mutex_t \fBmd2cmds_pg_mutex\fP"
.br
.ti -1c
.RI "pthread_mutex_t \fBpmac_queue_mutex\fP"
.br
.RI "\fImanage access to the pmac command queue \fP"
.ti -1c
.RI "pthread_cond_t \fBpmac_queue_cond\fP"
.br
.RI "\fIwait for a command to be sent to PMAC before continuing \fP"
.ti -1c
.RI "pthread_mutex_t \fBlspmac_shutter_mutex\fP"
.br
.RI "\fICoordinates threads reading shutter status\&. \fP"
.ti -1c
.RI "pthread_cond_t \fBlspmac_shutter_cond\fP"
.br
.RI "\fIAllows waiting for the shutter status to change\&. \fP"
.ti -1c
.RI "int \fBlspmac_shutter_state\fP"
.br
.RI "\fIState of the shutter, used to detect changes\&. \fP"
.ti -1c
.RI "int \fBlspmac_shutter_has_opened\fP"
.br
.RI "\fIIndicates that the shutter had opened, perhaps briefly even if the state did not change\&. \fP"
.ti -1c
.RI "pthread_mutex_t \fBlspmac_moving_mutex\fP"
.br
.RI "\fICoordinate moving motors between threads\&. \fP"
.ti -1c
.RI "pthread_cond_t \fBlspmac_moving_cond\fP"
.br
.RI "\fIWait for motor(s) to finish moving condition\&. \fP"
.ti -1c
.RI "int \fBlspmac_moving_flags\fP"
.br
.RI "\fIFlag used to implement motor moving condition\&. \fP"
.ti -1c
.RI "pthread_mutex_t \fBmd2_status_mutex\fP"
.br
.RI "\fISynchronize reading/writting status buffer\&. \fP"
.ti -1c
.RI "char \fBmd2cmds_cmd\fP []"
.br
.RI "\fIour command; \fP"
.in -1c
.SH "Detailed Description"
.PP 
Headers for the entire pgpmac project\&. 

\fBDate:\fP
.RS 4
2012 
.RE
.PP
\fBAuthor:\fP
.RS 4
Keith Brister 
.RE
.PP
\fBCopyright:\fP
.RS 4
All Rights Reserved 
.RE
.PP

.PP
Definition in file \fBpgpmac\&.h\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define _GNU_SOURCE"

.PP
Definition at line 7 of file pgpmac\&.h\&.
.SS "#define LS_DISPLAY_WINDOW_HEIGHT   8"

.PP
Number of status box rows\&. 
.PP
Definition at line 56 of file pgpmac\&.h\&.
.SS "#define LS_DISPLAY_WINDOW_WIDTH   24"

.PP
Number of status box columns\&. 
.PP
Definition at line 60 of file pgpmac\&.h\&.
.SS "#define LS_PG_QUERY_STRING_LENGTH   1024"

.PP
Fixed length postgresql query strings\&. Queries should all be function calls so this is not as weird as one might think\&. 
.PP
Definition at line 63 of file pgpmac\&.h\&.
.SS "#define LSEVENTS_EVENT_LENGTH   256"

.PP
Fixed length for event names: simplifies string handling\&. 
.PP
Definition at line 66 of file pgpmac\&.h\&.
.SS "#define MD2CMDS_CMD_LENGTH   32"

.PP
Definition at line 389 of file pgpmac\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBlspg_getcenter_struct\fP  \fBlspg_getcenter_t\fP"

.PP
Storage for getcenter query Used for the md2 ROTATE command that generates the centering movies\&. 
.SS "typedef struct \fBlspg_nextshot_struct\fP  \fBlspg_nextshot_t\fP"

.PP
Storage definition for nextshot query\&. The next shot query returns all the information needed to collect the next data frame\&. Since SQL allows for null fields independently from blank strings a separate integer is used as a flag for this case\&. This adds to the program complexity but allows for some important cases\&. Suck it up\&.definition of the next image to be taken (and the one after that, too!) 
.SS "typedef struct \fBlspmac_bi_struct\fP  \fBlspmac_bi_t\fP"

.PP
Storage for binary inputs\&. 
.SS "typedef struct \fBlspmac_motor_struct\fP  \fBlspmac_motor_t\fP"

.PP
Motor information\&. A catchall for motors and motor like objects\&. Not all members are used by all objects\&. 
.SS "typedef struct \fBlsredis_obj_struct\fP  \fBlsredis_obj_t\fP"

.PP
Redis Object Basic object whose value is sychronized with our redis db\&. 
.SS "typedef struct \fBlspmac_cmd_queue_struct\fP  \fBpmac_cmd_queue_t\fP"

.PP
PMAC command queue item\&. Command queue items are fixed length to simplify memory management\&. 
.SS "typedef struct \fBtagEthernetCmd\fP  \fBpmac_cmd_t\fP"

.PP
PMAC ethernet packet definition\&. Taken directly from the Delta Tau documentation\&. 
.SH "Function Documentation"
.PP 
.SS "void lsevents_add_listener (char *event, void(*)(char *)cb)"

.PP
Add a callback routine to listen for a specific event\&. \fBParameters:\fP
.RS 4
\fIevent\fP the name of the event to listen for 
.br
\fIcb\fP the routine to call 
.RE
.PP

.PP
Definition at line 78 of file lsevents\&.c\&.
.PP
.nf
                                                             {
  lsevents_listener_t *new;
  int err;
  char *errbuf;
  int nerrbuf;



  new = calloc( 1, sizeof( lsevents_listener_t));
  if( new == NULL) {
    lslogging_log_message( 'lsevents_add_listener: out of memory');
    exit( -1);
  }

  err = regcomp( &new->re, event, REG_EXTENDED | REG_NOSUB);
  if( err != 0) {
    nerrbuf = regerror( err, &new->re, NULL, 0);
    errbuf = calloc( nerrbuf, sizeof( char));
    if( errbuf == NULL) {
      lslogging_log_message( 'lsevents_add_listener: out of memory (re)');
      exit( -1);
    }
    regerror( err, &new->re, errbuf, nerrbuf);
    lslogging_log_message( 'lsevents_add_listener: %s', errbuf);
    free( errbuf);
    free( new);
    return;
  }

  new->raw_regexp = strdup( event);
  new->cb   = cb;

  pthread_mutex_lock( &lsevents_listener_mutex);
  new->next = lsevents_listeners_p;
  lsevents_listeners_p = new;
  pthread_mutex_unlock( &lsevents_listener_mutex);

  lslogging_log_message( 'lsevents_add_listener: added listener for event %s', event);

}
.fi
.SS "void lsevents_init ()"

.PP
Initialize this module\&. 
.PP
Definition at line 207 of file lsevents\&.c\&.
.PP
.nf
                     {
  pthread_mutex_init( &lsevents_queue_mutex, NULL);
  pthread_cond_init(  &lsevents_queue_cond, NULL);
  pthread_mutex_init( &lsevents_listener_mutex, NULL);
}
.fi
.SS "void lsevents_remove_listener (char *event, void(*)(char *)cb)"

.PP
Remove a listener previously added with lsevents_add_listener\&. \fBParameters:\fP
.RS 4
\fIevent\fP The name of the event 
.br
\fIcb\fP The callback routine to remove 
.RE
.PP

.PP
Definition at line 123 of file lsevents\&.c\&.
.PP
.nf
                                                                {
  
  lsevents_listener_t *last, *current;

  //
  // Find the listener to remove
  // and unlink it from the list
  //
  pthread_mutex_lock( &lsevents_listener_mutex);
  last = NULL;
  for( current = lsevents_listeners_p; current != NULL; current = current->next) {
    if( strcmp( last->raw_regexp, event) == 0 && last->cb == cb) {
      if( last == NULL) {
        lsevents_listeners_p = current->next;
      } else {
        last->next = current->next;
      }
      break;
    }
  }
  pthread_mutex_unlock( &lsevents_listener_mutex);

  //
  // Now remove it
  //
  if( current != NULL) {
    if( current->raw_regexp != NULL)
      free( current->raw_regexp);
    free(current);
  }
}
.fi
.SS "void lsevents_run ()"

.PP
Start up the thread and get out of the way\&. 
.PP
Definition at line 215 of file lsevents\&.c\&.
.PP
.nf
                    {
  pthread_create( &lsevents_thread, NULL, lsevents_worker, NULL);
}
.fi
.SS "void lsevents_send_event (char *fmt, \&.\&.\&.)"

.PP
Call the callback routines for the given event\&. \fBParameters:\fP
.RS 4
\fIfmt\fP a printf style formating string 
.br
\fI\&.\&.\&.\fP list of arguments specified by the format string 
.RE
.PP

.PP
Definition at line 45 of file lsevents\&.c\&.
.PP
.nf
                                          {
  char event[LSEVENTS_EVENT_LENGTH];
  char *sp;
  va_list arg_ptr;

  va_start( arg_ptr, fmt);
  vsnprintf( event, sizeof(event)-1, fmt, arg_ptr);
  event[sizeof(event)-1]=0;
  va_end( arg_ptr);

  pthread_mutex_lock( &lsevents_queue_mutex);

  lslogging_log_message( 'lsevents_send_event: %s', event);


  // maybe wait for room on the queue
  while( lsevents_queue_on + 1 == lsevents_queue_off)
    pthread_cond_wait( &lsevents_queue_cond, &lsevents_queue_mutex);
  
  sp = lsevents_queue[(lsevents_queue_on++) % LSEVENTS_QUEUE_LENGTH]\&.event;
  strncpy( sp, event, LSEVENTS_EVENT_LENGTH);
  sp[LSEVENTS_EVENT_LENGTH - 1] = 0;

  pthread_cond_signal(  &lsevents_queue_cond);
  pthread_mutex_unlock( &lsevents_queue_mutex);

}
.fi
.SS "char** lspg_array2ptrs (char *)"

.PP
returns a null terminated list of strings parsed from postgresql array 
.PP
Definition at line 165 of file lspg\&.c\&.
.PP
.nf
                                 {
  char **rtn, *sp, *acums;
  int i, n, inquote, havebackslash, rtni;;
  int mxsz;
  
  inquote       = 0;
  havebackslash = 0;

  // Despense with the null input condition before we complicate the code below
  if( a == NULL || a[0] != '{' || a[strlen(a)-1] != '}')
    return NULL;

  // Count the maximum number of strings
  // Actual number will be less if there are quoted commas
  //
  n = 1;
  for( i=0; a[i]; i++) {
    if( a[i] == ',')
      n++;
  }
  //
  // The maximum size of any string is the length of a (+1)
  //
  mxsz = strlen(a) + 1;

  // This is the accumulation string to make up the array elements
  acums = (char *)calloc( mxsz, sizeof( char));
  if( acums == NULL) {
    lslogging_log_message( 'lspg_array2ptrs: out of memory (acums)');
    exit( 1);
  }
  
  //
  // allocate storage for the pointer array and the null terminator
  //
  rtn = (char **)calloc( n+1, sizeof( char *));
  if( rtn == NULL) {
    lslogging_log_message( 'lspg_array2ptrs: out of memory (rtn)');
    exit( 1);
  }
  rtni = 0;
  
  // Go through and create the individual strings
  sp = acums;
  *sp = 0;

  inquote = 0;
  havebackslash = 0;
  for( i=1; a[i] != 0; i++) {
    switch( a[i]) {
    case ''':
      if( havebackslash) {
        // a quoted quote\&.  Cool
        //
        *(sp++) = a[i];
        *sp = 0;
        havebackslash = 0;
      } else {
        // Toggle the flag
        inquote = 1 - inquote;
      }
      break;

    case '\\':
      if( havebackslash) {
        *(sp++) = a[i];
        *sp = 0;
        havebackslash = 0;
      } else {
        havebackslash = 1;
      }
      break;

    case ',':
      if( inquote || havebackslash) {
        *(sp++) = a[i];
        *sp = 0;
        havebackslash = 0;
      } else {
        rtn[rtni++] = strdup( acums);
        sp = acums;
      }
      break;
      
    case '}':
      if( inquote || havebackslash) {
        *(sp++) = a[i];
        *sp = 0;
        havebackslash = 0;
      } else {
        rtn[rtni++] = strdup( acums);
        rtn[rtni]   = NULL;
        free( acums);
        return( rtn);
      }
      break;

    default:
      *(sp++) = a[i];
      *sp = 0;
      havebackslash = 0;
    }
  }
  //
  // Getting here means the final '}' was missing
  // Probably we should throw an error or log it or something\&.
  // Through out the last entry since this there is not resonable expectation that
  // we should be parsing it anyway\&.
  //
  rtn[rtni]   = NULL;
  free( acums);
  return( rtn);
}
.fi
.SS "void lspg_init ()"

.PP
Initiallize the lspg module\&. 
.PP
Definition at line 1464 of file lspg\&.c\&.
.PP
.nf
                 {
  pthread_mutex_init( &lspg_queue_mutex, NULL);
  pthread_cond_init( &lspg_queue_cond, NULL);
  lspg_nextshot_init();
  lspg_getcenter_init();
  lspg_wait_for_detector_init();
  lspg_lock_diffractometer_init();
  lspg_lock_detector_init();
}
.fi
.SS "void lspg_run ()"

.PP
Start 'er runnin'\&. 
.PP
Definition at line 1476 of file lspg\&.c\&.
.PP
.nf
                {
  pthread_create( &lspg_thread, NULL, lspg_worker, NULL);
}
.fi
.SS "void lspg_seq_run_prep_all (long longskey, doublekappa, doublephi, doublecx, doublecy, doubleax, doubleay, doubleaz)"

.PP
Convinence function to call seq run prep\&. \fBParameters:\fP
.RS 4
\fIskey\fP px\&.shots key for this image 
.br
\fIkappa\fP current kappa postion 
.br
\fIphi\fP current phi postition 
.br
\fIcx\fP current center table x 
.br
\fIcy\fP current center table y 
.br
\fIax\fP current alignment table x 
.br
\fIay\fP current alignment table y 
.br
\fIaz\fP current alignment table z 
.RE
.PP

.PP
Definition at line 812 of file lspg\&.c\&.
.PP
.nf
                             {
  lspg_seq_run_prep_call( skey, kappa, phi, cx, cy, ax, ay, az);
  lspg_seq_run_prep_wait();
  lspg_seq_run_prep_done();
}
.fi
.SS "void lspg_zoom_lut_call ()"

.SS "double lspmac_getPosition (\fBlspmac_motor_t\fP *mp)"

.PP
get the motor position (with locking) \fBParameters:\fP
.RS 4
\fImp\fP the motor object 
.RE
.PP

.PP
Definition at line 1228 of file lspmac\&.c\&.
.PP
.nf
                                               {
  double rtn;
  pthread_mutex_lock( &(mp->mutex));
  rtn = mp->position;
  pthread_mutex_unlock( &(mp->mutex));
  return rtn;
}
.fi
.SS "void lspmac_init (int, int)"

.PP
Initialize this module\&. 
.PP
Definition at line 2541 of file lspmac\&.c\&.
.PP
.nf
                   {
  md2_status_t *p;

  // Set our global harvest flags
  getivars = ivarsflag;
  getmvars = mvarsflag;

  // All important status mutex
  pthread_mutex_init( &md2_status_mutex, NULL);

  //
  // Get the MD2 initialization strings
  //
  lspmac_md2_init = lsredis_get_obj( 'md2_pmac\&.init');

  //
  // Initialize the motor objects
  //

  p = &md2_status;

  omega  = lspmac_motor_init( &(lspmac_motors[ 0]), 0, 0, &p->omega_act_pos,     &p->omega_status_1,     &p->omega_status_2,     'Omega   #1 &1 A', 'omega',       lspmac_moveabs_queue);
  alignx = lspmac_motor_init( &(lspmac_motors[ 1]), 0, 1, &p->alignx_act_pos,    &p->alignx_status_1,    &p->alignx_status_2,    'Align X #2 &3 X', 'align\&.x',     lspmac_moveabs_queue);
  aligny = lspmac_motor_init( &(lspmac_motors[ 2]), 0, 2, &p->aligny_act_pos,    &p->aligny_status_1,    &p->aligny_status_2,    'Align Y #3 &3 Y', 'align\&.y',     lspmac_moveabs_queue);
  alignz = lspmac_motor_init( &(lspmac_motors[ 3]), 0, 3, &p->alignz_act_pos,    &p->alignz_status_1,    &p->alignz_status_2,    'Align Z #4 &3 Z', 'align\&.z',     lspmac_moveabs_queue);
  anal   = lspmac_motor_init( &(lspmac_motors[ 4]), 0, 4, &p->analyzer_act_pos,  &p->analyzer_status_1,  &p->analyzer_status_2,  'Anal    #5',      'lightPolar',  lspmac_moveabs_queue);
  zoom   = lspmac_motor_init( &(lspmac_motors[ 5]), 1, 0, &p->zoom_act_pos,      &p->zoom_status_1,      &p->zoom_status_2,      'Zoom    #6 &4 Z', 'cam\&.zoom',    lspmac_movezoom_queue);
  apery  = lspmac_motor_init( &(lspmac_motors[ 6]), 1, 1, &p->aperturey_act_pos, &p->aperturey_status_1, &p->aperturey_status_2, 'Aper Y  #7 &5 Y', 'appy',        lspmac_moveabs_queue);
  aperz  = lspmac_motor_init( &(lspmac_motors[ 7]), 1, 2, &p->aperturez_act_pos, &p->aperturez_status_1, &p->aperturez_status_2, 'Aper Z  #8 &5 Z', 'appz',        lspmac_moveabs_queue);
  capy   = lspmac_motor_init( &(lspmac_motors[ 8]), 1, 3, &p->capy_act_pos,      &p->capy_status_1,      &p->capy_status_2,      'Cap Y   #9 &5 U', 'capy',        lspmac_moveabs_queue);
  capz   = lspmac_motor_init( &(lspmac_motors[ 9]), 1, 4, &p->capz_act_pos,      &p->capz_status_1,      &p->capz_status_2,      'Cap Z  #10 &5 V', 'capz',        lspmac_moveabs_queue);
  scint  = lspmac_motor_init( &(lspmac_motors[10]), 2, 0, &p->scint_act_pos,     &p->scint_status_1,     &p->scint_status_2,     'Scin Z #11 &5 W', 'scint',       lspmac_moveabs_queue);
  cenx   = lspmac_motor_init( &(lspmac_motors[11]), 2, 1, &p->centerx_act_pos,   &p->centerx_status_1,   &p->centerx_status_2,   'Cen X  #17 &2 X', 'centering\&.x', lspmac_moveabs_queue);
  ceny   = lspmac_motor_init( &(lspmac_motors[12]), 2, 2, &p->centery_act_pos,   &p->centery_status_1,   &p->centery_status_2,   'Cen Y  #18 &2 Y', 'centering\&.y', lspmac_moveabs_queue);
  kappa  = lspmac_motor_init( &(lspmac_motors[13]), 2, 3, &p->kappa_act_pos,     &p->kappa_status_1,     &p->kappa_status_2,     'Kappa  #19 &7 X', 'kappa',       lspmac_moveabs_queue);
  phi    = lspmac_motor_init( &(lspmac_motors[14]), 2, 4, &p->phi_act_pos,       &p->phi_status_1,       &p->phi_status_2,       'Phi    #20 &7 Y', 'phi',         lspmac_moveabs_queue);

  fshut  = lspmac_fshut_init( &(lspmac_motors[15]));
  flight = lspmac_dac_init( &(lspmac_motors[16]), &p->front_dac,   'M1200', 'frontLight\&.intensity', lspmac_movedac_queue);
  blight = lspmac_dac_init( &(lspmac_motors[17]), &p->back_dac,    'M1201', 'backLight\&.intensity',  lspmac_movedac_queue);
  fscint = lspmac_dac_init( &(lspmac_motors[18]), &p->scint_piezo, 'M1203', 'scint\&.focus',          lspmac_movedac_queue);

  blight_ud = lspmac_bo_init( &(lspmac_motors[19]), 'backLight',  'M1101=%d', &(md2_status\&.acc11c_5), 0x02);
  cryo      = lspmac_bo_init( &(lspmac_motors[20]), 'cryo',       'M1102=%d', &(md2_status\&.acc11c_5), 0x04);
  dryer     = lspmac_bo_init( &(lspmac_motors[21]), 'dryer',      'M1103=%d', &(md2_status\&.acc11c_5), 0x08);
  fluo      = lspmac_bo_init( &(lspmac_motors[22]), 'fluo',       'M1008=%d', &(md2_status\&.acc11c_2), 0x01);
  flight_oo = lspmac_soft_motor_init( &(lspmac_motors[23]), 'frontLight',        lspmac_moveabs_frontlight_oo_queue);
  blight_f  = lspmac_soft_motor_init( &(lspmac_motors[24]), 'backLight\&.factor',  lspmac_moveabs_blight_factor_queue);
  flight_f  = lspmac_soft_motor_init( &(lspmac_motors[25]), 'frontLight\&.factor', lspmac_moveabs_flight_factor_queue);

  cryo_switch = lspmac_bi_init( &(lspmac_bis[0]), &(md2_status\&.acc11c_1), 0x04, 'CryoSwitchChanged', 'CryoSwitchChanged');

  //
  // Initialize several commands that get called, perhaps, alot
  //
  rr_cmd\&.RequestType = VR_UPLOAD;
  rr_cmd\&.Request     = VR_PMAC_READREADY;
  rr_cmd\&.wValue      = 0;
  rr_cmd\&.wIndex      = 0;
  rr_cmd\&.wLength     = htons(2);
  memset( rr_cmd\&.bData, 0, sizeof(rr_cmd\&.bData));

  gb_cmd\&.RequestType = VR_UPLOAD;
  gb_cmd\&.Request     = VR_PMAC_GETBUFFER;
  gb_cmd\&.wValue      = 0;
  gb_cmd\&.wIndex      = 0;
  gb_cmd\&.wLength     = htons(1400);
  memset( gb_cmd\&.bData, 0, sizeof(gb_cmd\&.bData));

  cr_cmd\&.RequestType = VR_UPLOAD;
  cr_cmd\&.Request     = VR_CTRL_RESPONSE;
  cr_cmd\&.wValue      = 0;
  cr_cmd\&.wIndex      = 0;
  cr_cmd\&.wLength     = htons(1400);
  memset( cr_cmd\&.bData, 0, sizeof(cr_cmd\&.bData));

  //
  // Initialize some mutexs and conditions
  //

  pthread_mutex_init( &pmac_queue_mutex, NULL);
  pthread_cond_init(  &pmac_queue_cond, NULL);

  lspmac_shutter_state = 0;                             // assume the shutter is now closed: not a big deal if we are wrong
  pthread_mutex_init( &lspmac_shutter_mutex, NULL);
  pthread_cond_init(  &lspmac_shutter_cond, NULL);
  pmacfd\&.fd = -1;

  pthread_mutex_init( &lspmac_moving_mutex, NULL);
  pthread_cond_init(  &lspmac_moving_cond, NULL);
}
.fi
.SS "void lspmac_jogabs_queue (\fBlspmac_motor_t\fP *, double)"

.PP
Use jog to move motor to requested position\&. 
.PP
Definition at line 2302 of file lspmac\&.c\&.
.PP
.nf
                            {
  
  lspmac_move_or_jog_abs_queue( mp, requested_position, 1);
}
.fi
.SS "void lspmac_move_or_jog_preset_queue (\fBlspmac_motor_t\fP *, char *, int)"

.PP
move using a preset value 
.PP
Definition at line 2272 of file lspmac\&.c\&.
.PP
.nf
                                       {
  double pos;
  int err;

  if( preset == NULL || *preset == 0)
    return;

  err = lsredis_find_preset( mp->name, preset, &pos);

  if( err != 0)
    lspmac_move_or_jog_abs_queue( mp, pos, use_jog);
}
.fi
.SS "void lspmac_move_or_jog_queue (\fBlspmac_motor_t\fP *, double, int)"

.SS "void lspmac_moveabs_queue (\fBlspmac_motor_t\fP *, double)"

.PP
Use coordinate system motion program, if available, to move motor to requested position\&. 
.PP
Definition at line 2292 of file lspmac\&.c\&.
.PP
.nf
                            {
  
  lspmac_move_or_jog_abs_queue( mp, requested_position, 0);
}
.fi
.SS "void lspmac_run ()"

.PP
Start up the lspmac thread\&. 
.PP
Definition at line 2839 of file lspmac\&.c\&.
.PP
.nf
                  {
  char **inits;
  lspmac_motor_t *mp;
  int i;
  int active;

  pthread_create( &pmac_thread, NULL, lspmac_worker, NULL);

  lsevents_add_listener( 'CryoSwitchChanged',    lspmac_cryoSwitchChanged_cb);
  lsevents_add_listener( 'scint In Position',    lspmac_scint_inPosition_cb);
  lsevents_add_listener( 'scintDried',           lspmac_scint_dried_cb);
  lsevents_add_listener( 'backLight 1',          lspmac_backLight_up_cb);
  lsevents_add_listener( 'backLight 0',          lspmac_backLight_down_cb);
  lsevents_add_listener( 'cam\&.zoom In Position', lspmac_light_zoom_cb);

  lspmac_zoom_lut_setup();
  lspmac_flight_lut_setup();
  lspmac_blight_lut_setup();
  lspmac_fscint_lut_setup();

  //
  // Initialize the MD2 pmac (ie, turn on the right plcc's etc)
  //
  for( inits = lsredis_get_string_array(lspmac_md2_init); *inits != NULL; inits++) {
    lspmac_SockSendline( *inits);
  }
  
  //
  // Initialize the pmac's support for each motor
  // (ie, set the various flag for when a motor is active or not)
  //
  for( i=0; i<lspmac_nmotors; i++) {
    mp = &(lspmac_motors[i]);
    active = lsredis_getb( mp->active);

    // if there is a problem with 'active' then don't do anything
    // On the other hand, various combinations of yes/no true/fals 1/0 should work
    //
    switch( active) {
    case 1:
      inits = lsredis_get_string_array( mp->active_init);
      break;

    case 0:
      inits = lsredis_get_string_array( mp->active_init);
      break;

    default:
      inits = NULL;
    }

    if( inits != NULL) {
      while( *inits != NULL) {
        lspmac_SockSendline( *inits);
        inits++;
      }
    }
  }
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_SockSendline (char *fmt, \&.\&.\&.)"

.PP
Send a one line command\&. Uses printf style arguments\&. \fBParameters:\fP
.RS 4
\fIfmt\fP Printf style format string 
.RE
.PP

.PP
Definition at line 962 of file lspmac\&.c\&.
.PP
.nf
                                         {
  va_list arg_ptr;
  char payload[1400];

  va_start( arg_ptr, fmt);
  vsnprintf( payload, sizeof(payload)-1, fmt, arg_ptr);
  payload[ sizeof(payload)-1] = 0;
  va_end( arg_ptr);

  lslogging_log_message( payload);

  return lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDLINE, 0, 0, strlen( payload), payload, lspmac_GetShortReplyCB, 0);
}
.fi
.SS "int lsredis_cmpnstr (\fBlsredis_obj_t\fP *p, char *s, intn)"

.PP
Definition at line 235 of file lsredis\&.c\&.
.PP
.nf
                                                       {
  int rtn;
  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0)
    pthread_cond_wait( &p->cond, &p->mutex);
  
  rtn = strncmp( p->value, s, n);
  pthread_mutex_unlock( &p->mutex);
  return rtn;
}
.fi
.SS "int lsredis_cmpstr (\fBlsredis_obj_t\fP *p, char *s)"

.PP
Definition at line 224 of file lsredis\&.c\&.
.PP
.nf
                                               {
  int rtn;
  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0)
    pthread_cond_wait( &p->cond, &p->mutex);
  
  rtn = strcmp( p->value, s);
  pthread_mutex_unlock( &p->mutex);
  return rtn;
}
.fi
.SS "int lsredis_find_preset (char *base, char *preset_name, double *dval)"

.PP
Definition at line 777 of file lsredis\&.c\&.
.PP
.nf
                                                                      {
  char s[512];
  int i;
  int err;
  ENTRY htab_input, *htab_output;
  lsredis_obj_t *p;

  i = 0;
  for( i=0; i<1024; i++) {
    snprintf( s, sizeof( s)-1, '%s\&.%s\&.presets\&.%d\&.name', lsredis_head, base, i);
    s[sizeof(s)-1] = 0;
    htab_input\&.key  = s;
    htab_input\&.data = NULL;
    err = hsearch_r( htab_input, FIND, &htab_output, &lsredis_htab);
    if( err == 0) {
      // We've run out of names to look for: done
      lslogging_log_message( 'lsredis_find_preset: no preset for motor %s named '%s'', base, preset_name);
      *dval = 0\&.0;
      return 0;
    }

    // Check if we have a match
    p = htab_output->data;
    if( lsredis_cmpstr( p, preset_name)==0) {
      // got a match, now look for the position
      snprintf( s, sizeof( s)-1, '%s\&.%s\&.presets\&.%d\&.position', lsredis_head, base, i);
      s[sizeof(s)-1] = 0;
      htab_input\&.key = s;
      htab_input\&.data = NULL;
      err = hsearch_r( htab_input, FIND, &htab_output, &lsredis_htab);
      if( err == 0) {
        // Name but not position? odd\&.
        lslogging_log_message( 'lsredis_find_preset: Error, motor %s preset '%s' has no position defined', base, preset_name);
        *dval = 0\&.0;
        return 0;
      }
      p = htab_output->data;
      *dval = lsredis_getd( p);
      return 1;
    }
  }
  // How'd we get here?
  // did someone really define that many presets?  And then looked for one that's not there?
  *dval = 0;
  return 0;
}
.fi
.SS "\fBlsredis_obj_t\fP* lsredis_get_obj (char *, \&.\&.\&.)"

.PP
Definition at line 520 of file lsredis\&.c\&.
.PP
.nf
                                                {
  lsredis_obj_t *rtn;
  va_list arg_ptr;
  char k[512];
  char *kp;
  int nkp;

  va_start( arg_ptr, fmt);
  vsnprintf( k, sizeof(k)-1, fmt, arg_ptr);
  k[sizeof(k)-1] = 0;
  va_end( arg_ptr);

  nkp = strlen(k) + strlen( lsredis_head) + 16;         // 16 is overkill\&. I know\&. Get over it\&.
  kp = calloc( nkp, sizeof( char));
  if( kp == NULL) {
    lslogging_log_message( 'lsredis_get_obj: Out of memory');
    exit( -1);
  }
  
  snprintf( kp, nkp-1, '%s\&.%s', lsredis_head, k);
  kp[nkp-1] = 0;

  pthread_mutex_lock( &lsredis_mutex);
  while( lsredis_running == 0)
    pthread_cond_wait( &lsredis_cond, &lsredis_mutex);

  rtn = _lsredis_get_obj( kp);
  pthread_mutex_unlock( &lsredis_mutex);

  free( kp);
  return rtn;
}
.fi
.SS "char** lsredis_get_string_array (\fBlsredis_obj_t\fP *p)"

.PP
Definition at line 358 of file lsredis\&.c\&.
.PP
.nf
                                                   {
  char **rtn;

  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0)
    pthread_cond_wait( &p->cond, &p->mutex);

  rtn = p->avalue;
  pthread_mutex_unlock( &p->mutex);
  
  return rtn;
}
.fi
.SS "int lsredis_getb (\fBlsredis_obj_t\fP *p)"

.PP
Definition at line 371 of file lsredis\&.c\&.
.PP
.nf
                                    {
  int rtn;

  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0)
    pthread_cond_wait( &p->cond, &p->mutex);

  rtn = p->bvalue;
  pthread_mutex_unlock( &p->mutex);
  
  return rtn;
}  
.fi
.SS "double lsredis_getd (\fBlsredis_obj_t\fP *p)"

.PP
Definition at line 332 of file lsredis\&.c\&.
.PP
.nf
                                       {
  double rtn;

  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0)
    pthread_cond_wait( &p->cond, &p->mutex);

  rtn = p->dvalue;
  pthread_mutex_unlock( &p->mutex);
  
  return rtn;
}
.fi
.SS "long int lsredis_getl (\fBlsredis_obj_t\fP *p)"

.PP
Definition at line 345 of file lsredis\&.c\&.
.PP
.nf
                                         {
  long int rtn;

  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0)
    pthread_cond_wait( &p->cond, &p->mutex);

  rtn = p->lvalue;
  pthread_mutex_unlock( &p->mutex);
  
  return rtn;
}  
.fi
.SS "char* lsredis_getstr (\fBlsredis_obj_t\fP *p)"

.PP
return a copy of the key's string value 
.PP
Definition at line 259 of file lsredis\&.c\&.
.PP
.nf
                                        {
  char *rtn;

  //
  // Have to use strdup since we cannot guarantee that p->value won't be freed while the caller is still using it
  //
  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0)
    pthread_cond_wait( &p->cond, &p->mutex);

  rtn = strdup(p->value);
  pthread_mutex_unlock( &p->mutex);
  return rtn;
}
.fi
.SS "void lsredis_init (char *pub, char *re, char *head)"

.PP
Initialize this module, that is, set up the connections\&. \fBParameters:\fP
.RS 4
\fIpub\fP Publish under this (unique) name 
.br
\fIre\fP Regular expression to select keys we want to mirror 
.br
\fIhead\fP Prepend this (+ a dot) to the beginning of requested objects 
.RE
.PP

.PP
Definition at line 831 of file lsredis\&.c\&.
.PP
.nf
                                                    {
  int err;
  int nerrmsg;
  char *errmsg;

  //
  // set up hash map to store redis objects
  //
  err = hcreate_r( 8192, &lsredis_htab);
  if( err == 0) {
    lslogging_log_message( 'lsredis_init: Cannot create hash table\&.  Really bad things are going to happen\&.  hcreate_r returnd %d', err);
  }

  lsredis_head      = strdup( head);
  lsredis_publisher = strdup( pub);

  pthread_mutex_init( &lsredis_mutex, NULL);
  pthread_cond_init( &lsredis_cond, NULL);

  subac = redisAsyncConnect('127\&.0\&.0\&.1', 6379);
  if( subac->err) {
    lslogging_log_message( 'Error: %s', subac->errstr);
  }

  subfd\&.fd           = subac->c\&.fd;
  subfd\&.events       = 0;
  subac->ev\&.data     = &subfd;
  subac->ev\&.addRead  = lsredis_addRead;
  subac->ev\&.delRead  = lsredis_delRead;
  subac->ev\&.addWrite = lsredis_addWrite;
  subac->ev\&.delWrite = lsredis_delWrite;
  subac->ev\&.cleanup  = lsredis_cleanup;

  roac = redisAsyncConnect('127\&.0\&.0\&.1', 6379);
  if( roac->err) {
    lslogging_log_message( 'Error: %s', roac->errstr);
  }

  rofd\&.fd           = roac->c\&.fd;
  rofd\&.events       = 0;
  roac->ev\&.data     = &rofd;
  roac->ev\&.addRead  = lsredis_addRead;
  roac->ev\&.delRead  = lsredis_delRead;
  roac->ev\&.addWrite = lsredis_addWrite;
  roac->ev\&.delWrite = lsredis_delWrite;
  roac->ev\&.cleanup  = lsredis_cleanup;

  wrac = redisAsyncConnect('10\&.1\&.0\&.3', 6379);
  if( wrac->err) {
    lslogging_log_message( 'Error: %s', wrac->errstr);
  }

  wrfd\&.fd           = wrac->c\&.fd;
  wrfd\&.events       = 0;
  wrac->ev\&.data     = &wrfd;
  wrac->ev\&.addRead  = lsredis_addRead;
  wrac->ev\&.delRead  = lsredis_delRead;
  wrac->ev\&.addWrite = lsredis_addWrite;
  wrac->ev\&.delWrite = lsredis_delWrite;
  wrac->ev\&.cleanup  = lsredis_cleanup;

  err = regcomp( &lsredis_key_select_regex, re, REG_EXTENDED);
  if( err != 0) {
    nerrmsg = regerror( err, &lsredis_key_select_regex, NULL, 0);
    if( nerrmsg > 0) {
      errmsg = calloc( nerrmsg, sizeof( char));
      nerrmsg = regerror( err, &lsredis_key_select_regex, errmsg, nerrmsg);
      lslogging_log_message( 'lsredis_select: %s', errmsg);
      free( errmsg);
    }
  }
}
.fi
.SS "int lsredis_regexec (const regex_t *preg, \fBlsredis_obj_t\fP *p, size_tnmatch, regmatch_t *pmatch, inteflags)"

.PP
Definition at line 246 of file lsredis\&.c\&.
.PP
.nf
                                                                                                           {
  int rtn;

  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0) 
    pthread_cond_wait( &p->cond, &p->mutex);

  rtn = regexec( preg, p->value, nmatch, pmatch, eflags);

  pthread_mutex_unlock( &p->mutex);
}
.fi
.SS "void lsredis_run ()"

.PP
Definition at line 1035 of file lsredis\&.c\&.
.PP
.nf
                   {
  pthread_create( &lsredis_thread, NULL, lsredis_worker, NULL);
}
.fi
.SS "void lstimer_add_timer (char *event, intshots, unsigned long intsecs, unsigned long intnsecs)"

.PP
Create a timer\&. \fBParameters:\fP
.RS 4
\fIevent\fP Name of the event to send when the timer goes off 
.br
\fIshots\fP Number of times to run\&. 0 means never, -1 means forever 
.br
\fIsecs\fP Number of seconds to wait 
.br
\fInsecs\fP Number of nano-seconds to run in addition to secs 
.RE
.PP

.PP
Definition at line 50 of file lstimer\&.c\&.
.PP
.nf
                                                                                                 {
  int i;
  struct timespec now;


  // Time we were called\&.  Delay is based on call time, not queued time
  //
  clock_gettime( CLOCK_REALTIME, &now);
  

  pthread_mutex_lock( &lstimer_mutex);

  for( i=0; i<LSTIMER_LIST_LENGTH; i++) {
    if( lstimer_list[i]\&.shots == 0)
      break;
  }

  if( i == LSTIMER_LIST_LENGTH) {
    pthread_mutex_unlock( &lstimer_mutex);
    
    lslogging_log_message( 'lstimer_add_timer: out of timers for event: %s, shots: %d,  secs: %u, nsecs: %u',
                          event, shots, secs, nsecs);
    return;
  }

  strncpy( lstimer_list[i]\&.event, event, LSEVENTS_EVENT_LENGTH - 1);
  lstimer_list[i]\&.event[LSEVENTS_EVENT_LENGTH - 1] = 0;
  lstimer_list[i]\&.shots        = shots;
  lstimer_list[i]\&.delay_secs   = secs;
  lstimer_list[i]\&.delay_nsecs  = nsecs;

  lstimer_list[i]\&.next_secs    = secs + now\&.tv_sec + (now\&.tv_nsec + nsecs) / 1000000000;
  lstimer_list[i]\&.next_nsecs   = (now\&.tv_nsec + nsecs) % 1000000000;
  lstimer_list[i]\&.last_secs    = 0;
  lstimer_list[i]\&.last_nsecs   = 0;
  
  lstimer_list[i]\&.ncalls       = 0;
  lstimer_list[i]\&.init_secs    = now\&.tv_sec;
  lstimer_list[i]\&.init_nsecs   = now\&.tv_nsec;

  if( shots != 0) {
    lstimer_active_timers++;
    new_timer++;
  }

  pthread_cond_signal(  &lstimer_cond);
  pthread_mutex_unlock( &lstimer_mutex);
}
.fi
.SS "void lstimer_init ()"

.PP
Initialize the timer list and pthread stuff\&. 
.PP
Definition at line 262 of file lstimer\&.c\&.
.PP
.nf
                    {
  int i;

  for( i=0; i<LSTIMER_LIST_LENGTH; i++) {
    lstimer_list[i]\&.shots = 0;
  }


  pthread_mutex_init( &lstimer_mutex, NULL);
  pthread_cond_init(  &lstimer_cond, NULL);
}
.fi
.SS "void lstimer_run ()"

.PP
Start up our thread\&. 
.PP
Definition at line 276 of file lstimer\&.c\&.
.PP
.nf
                   {
  pthread_create( &lstimer_thread, NULL, lstimer_worker, NULL);
}
.fi
.SS "void lsupdate_init ()"

.SS "void lsupdate_run ()"

.SS "void md2cmds_init ()"

.PP
Initialize the md2cmds module\&. 
.PP
Definition at line 797 of file md2cmds\&.c\&.
.PP
.nf
                    {
  memset( md2cmds_cmd, 0, sizeof( md2cmds_cmd));

  pthread_mutex_init( &md2cmds_mutex, NULL);
  pthread_cond_init( &md2cmds_cond, NULL);

  pthread_mutex_init( &md2cmds_moving_mutex, NULL);
  pthread_cond_init(  &md2cmds_moving_cond, NULL);


}
.fi
.SS "void md2cmds_run ()"

.PP
Start up the thread\&. 
.PP
Definition at line 811 of file md2cmds\&.c\&.
.PP
.nf
                   {
  pthread_create( &md2cmds_thread, NULL,            md2cmds_worker, NULL);
  lsevents_add_listener( 'omega crossed zero',      md2cmds_rotate_cb);
  lsevents_add_listener( 'omega In Position',       md2cmds_maybe_rotate_done_cb);
  lsevents_add_listener( 'align\&.x In Position',     md2cmds_maybe_done_moving_cb);
  lsevents_add_listener( 'align\&.y In Position',     md2cmds_maybe_done_moving_cb);
  lsevents_add_listener( 'align\&.z In Position',     md2cmds_maybe_done_moving_cb);
  lsevents_add_listener( 'centering\&.x In Position', md2cmds_maybe_done_moving_cb);
  lsevents_add_listener( 'centering\&.y In Position', md2cmds_maybe_done_moving_cb);
  lsevents_add_listener( 'align\&.x Moving',          md2cmds_maybe_done_moving_cb);
  lsevents_add_listener( 'align\&.y Moving',          md2cmds_maybe_done_moving_cb);
  lsevents_add_listener( 'align\&.z Moving',          md2cmds_maybe_done_moving_cb);
  lsevents_add_listener( 'centering\&.x Moving',      md2cmds_maybe_done_moving_cb);
  lsevents_add_listener( 'centering\&.y Moving',      md2cmds_maybe_done_moving_cb);
  lsevents_add_listener( 'cam\&.zoom In Position',    md2cmds_set_scale_cb);
}
.fi
.SS "void pgpmac_printf (char *fmt, \&.\&.\&.)"

.PP
Terminal output routine ala printf\&. \fBParameters:\fP
.RS 4
\fIfmt\fP Printf style formating string 
.RE
.PP

.PP
Definition at line 326 of file pgpmac\&.c\&.
.PP
.nf
                     {
  va_list arg_ptr;

  pthread_mutex_lock( &ncurses_mutex);

  va_start( arg_ptr, fmt);
  vwprintw( term_output, fmt, arg_ptr);
  va_end( arg_ptr);

  wnoutrefresh( term_output);
  wnoutrefresh( term_input);
  doupdate();

  pthread_mutex_unlock( &ncurses_mutex);

}
.fi
.SS "void PmacSockSendline (char *s)"

.SH "Variable Documentation"
.PP 
.SS "\fBlspmac_motor_t\fP* alignx"

.PP
Alignment stage X\&. 
.PP
Definition at line 83 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* aligny"

.PP
Alignment stage Y\&. 
.PP
Definition at line 84 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* alignz"

.PP
Alignment stage X\&. 
.PP
Definition at line 85 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* anal"

.PP
Polaroid analyzer motor\&. 
.PP
Definition at line 86 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* apery"

.PP
Aperture Y\&. 
.PP
Definition at line 88 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* aperz"

.PP
Aperture Z\&. 
.PP
Definition at line 89 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* blight"

.PP
Back Light DAC\&. 
.PP
Definition at line 100 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* blight_f"

.PP
Back light scale factor\&. 
.PP
Definition at line 105 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* blight_ud"

.PP
Back light Up/Down actuator\&. 
.PP
Definition at line 103 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* capy"

.PP
Capillary Y\&. 
.PP
Definition at line 90 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* capz"

.PP
Capillary Z\&. 
.PP
Definition at line 91 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* cenx"

.PP
Centering Table X\&. 
.PP
Definition at line 93 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* ceny"

.PP
Centering Table Y\&. 
.PP
Definition at line 94 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* cryo"

.PP
Move the cryostream towards or away from the crystal\&. 
.PP
Definition at line 107 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* dryer"

.PP
blow air on the scintilator to dry it off 
.PP
Definition at line 108 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* flight"

.PP
Front Light DAC\&. 
.PP
Definition at line 99 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* flight_f"

.PP
Front light scale factor\&. 
.PP
Definition at line 106 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* flight_oo"

.PP
Turn front light on/off\&. 
.PP
Definition at line 104 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* fluo"

.PP
Move the fluorescence detector in/out\&. 
.PP
Definition at line 109 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* fscint"

.PP
Scintillator Piezo DAC\&. 
.PP
Definition at line 101 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* fshut"

.PP
Fast shutter\&. 
.PP
Definition at line 98 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* kappa"

.PP
Kappa\&. 
.PP
Definition at line 95 of file lspmac\&.c\&.
.SS "\fBlspg_getcenter_t\fP lspg_getcenter"

.PP
the getcenter object 
.PP
Definition at line 73 of file lspg\&.c\&.
.SS "\fBlspg_nextshot_t\fP lspg_nextshot"

.PP
the nextshot object 
.PP
Definition at line 72 of file lspg\&.c\&.
.SS "\fBlspmac_motor_t\fP lspmac_motors[]"

.PP
All our motors\&. 
.PP
Definition at line 80 of file lspmac\&.c\&.
.SS "pthread_cond_t lspmac_moving_cond"

.PP
Wait for motor(s) to finish moving condition\&. 
.PP
Definition at line 60 of file lspmac\&.c\&.
.SS "int lspmac_moving_flags"

.PP
Flag used to implement motor moving condition\&. 
.PP
Definition at line 61 of file lspmac\&.c\&.
.SS "pthread_mutex_t lspmac_moving_mutex"

.PP
Coordinate moving motors between threads\&. 
.PP
Definition at line 59 of file lspmac\&.c\&.
.SS "int lspmac_nmotors"

.PP
The number of motors we manage\&. 
.PP
Definition at line 81 of file lspmac\&.c\&.
.SS "pthread_cond_t lspmac_shutter_cond"

.PP
Allows waiting for the shutter status to change\&. 
.PP
Definition at line 58 of file lspmac\&.c\&.
.SS "int lspmac_shutter_has_opened"

.PP
Indicates that the shutter had opened, perhaps briefly even if the state did not change\&. 
.PP
Definition at line 56 of file lspmac\&.c\&.
.SS "pthread_mutex_t lspmac_shutter_mutex"

.PP
Coordinates threads reading shutter status\&. 
.PP
Definition at line 57 of file lspmac\&.c\&.
.SS "int lspmac_shutter_state"

.PP
State of the shutter, used to detect changes\&. 
.PP
Definition at line 55 of file lspmac\&.c\&.
.SS "pthread_mutex_t md2_status_mutex"

.PP
Synchronize reading/writting status buffer\&. 
.PP
Definition at line 298 of file lspmac\&.c\&.
.SS "char md2cmds_cmd[]"

.PP
our command; 
.PP
Definition at line 19 of file md2cmds\&.c\&.
.SS "pthread_cond_t md2cmds_cond"

.PP
condition to signal when it's time to run an md2 command 
.PP
Definition at line 10 of file md2cmds\&.c\&.
.SS "pthread_mutex_t md2cmds_mutex"

.PP
mutex for the condition 
.PP
Definition at line 11 of file md2cmds\&.c\&.
.SS "pthread_cond_t md2cmds_pg_cond"

.SS "pthread_mutex_t md2cmds_pg_mutex"

.SS "pthread_mutex_t ncurses_mutex"

.PP
allow more than one thread access to the screen 
.PP
Definition at line 242 of file pgpmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* omega"

.PP
MD2 omega axis (the air bearing) 
.PP
Definition at line 82 of file lspmac\&.c\&.
.SS "struct timespec omega_zero_time"

.PP
Time we believe that omega crossed zero\&. 
.PP
Definition at line 65 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* phi"

.PP
Phi (not data collection axis) 
.PP
Definition at line 96 of file lspmac\&.c\&.
.SS "pthread_cond_t pmac_queue_cond"

.PP
wait for a command to be sent to PMAC before continuing 
.PP
Definition at line 71 of file lspmac\&.c\&.
.SS "pthread_mutex_t pmac_queue_mutex"

.PP
manage access to the pmac command queue 
.PP
Definition at line 70 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* scint"

.PP
Scintillator Z\&. 
.PP
Definition at line 92 of file lspmac\&.c\&.
.SS "WINDOW* term_input"

.PP
place to put the cursor 
.PP
Definition at line 238 of file pgpmac\&.c\&.
.SS "WINDOW* term_output"

.PP
place to print stuff out 
.PP
Definition at line 237 of file pgpmac\&.c\&.
.SS "WINDOW* term_status"

.PP
shutter, lamp, air, etc status 
.PP
Definition at line 239 of file pgpmac\&.c\&.
.SS "WINDOW* term_status2"

.PP
shutter, lamp, air, etc status 
.PP
Definition at line 240 of file pgpmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* zoom"

.PP
Optical zoom\&. 
.PP
Definition at line 87 of file lspmac\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for LS-CAT PGPMAC from the source code\&.
