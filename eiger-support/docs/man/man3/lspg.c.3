.TH "lspg.c" 3 "Thu Jun 19 2014" "LS-CAT PGPMAC" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lspg.c \- 
.PP
Postgresql support for the LS-CAT pgpmac project\&.  

.SH SYNOPSIS
.br
.PP
\fC#include 'pgpmac\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBlspg_wait_for_detector_struct\fP"
.br
.RI "\fIObject that implements detector / spindle timing We use database locks for exposure control and this implements the md2 portion of this handshake\&. \fP"
.ti -1c
.RI "struct \fBlspg_lock_diffractometer_struct\fP"
.br
.RI "\fIObject used to impliment locking the diffractometer Critical to exposure timing\&. \fP"
.ti -1c
.RI "struct \fBlspg_lock_detector_struct\fP"
.br
.RI "\fIlock detector object Implements detector lock for exposure control \fP"
.ti -1c
.RI "struct \fBlspg_seq_run_prep_struct\fP"
.br
.RI "\fIData collection running object\&. \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBLS_PG_STATE_INIT\fP   -4"
.br
.ti -1c
.RI "#define \fBLS_PG_STATE_INIT_POLL\fP   -3"
.br
.ti -1c
.RI "#define \fBLS_PG_STATE_RESET\fP   -2"
.br
.ti -1c
.RI "#define \fBLS_PG_STATE_RESET_POLL\fP   -1"
.br
.ti -1c
.RI "#define \fBLS_PG_STATE_IDLE\fP   1"
.br
.ti -1c
.RI "#define \fBLS_PG_STATE_SEND\fP   2"
.br
.ti -1c
.RI "#define \fBLS_PG_STATE_SEND_FLUSH\fP   3"
.br
.ti -1c
.RI "#define \fBLS_PG_STATE_RECV\fP   4"
.br
.ti -1c
.RI "#define \fBLS_PG_STATE_QUITTING\fP   5"
.br
.ti -1c
.RI "#define \fBLS_PG_QUERY_QUEUE_LENGTH\fP   16384"
.br
.RI "\fIQueue length should be long enough that we do not ordinarly bump into the end We should be safe as long as the thread the adds stuff to the queue is not the one that removes it\&. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct 
.br
\fBlspg_wait_for_detector_struct\fP \fBlspg_wait_for_detector_t\fP"
.br
.RI "\fIObject that implements detector / spindle timing We use database locks for exposure control and this implements the md2 portion of this handshake\&. \fP"
.ti -1c
.RI "typedef struct 
.br
\fBlspg_lock_diffractometer_struct\fP \fBlspg_lock_diffractometer_t\fP"
.br
.RI "\fIObject used to impliment locking the diffractometer Critical to exposure timing\&. \fP"
.ti -1c
.RI "typedef struct 
.br
\fBlspg_lock_detector_struct\fP \fBlspg_lock_detector_t\fP"
.br
.RI "\fIlock detector object Implements detector lock for exposure control \fP"
.ti -1c
.RI "typedef struct 
.br
\fBlspg_seq_run_prep_struct\fP \fBlspg_seq_run_prep_t\fP"
.br
.RI "\fIData collection running object\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBlspg_query_queue_t\fP * \fBlspg_query_next\fP ()"
.br
.RI "\fIReturn the next item in the postgresql queue\&. \fP"
.ti -1c
.RI "void \fBlspg_query_reply_next\fP ()"
.br
.RI "\fIRemove the oldest item in the queue\&. \fP"
.ti -1c
.RI "\fBlspg_query_queue_t\fP * \fBlspg_query_reply_peek\fP ()"
.br
.RI "\fIReturn the next item in the reply queue but don't pop it since we may need it more than once\&. \fP"
.ti -1c
.RI "void \fBlspg_query_push\fP (void(*cb)(\fBlspg_query_queue_t\fP *, PGresult *), void(*er)(), char *fmt,\&.\&.\&.)"
.br
.RI "\fIPlace a query on the queue\&. \fP"
.ti -1c
.RI "char ** \fBlspg_array2ptrs\fP (char *a)"
.br
.RI "\fIreturns a null terminated list of strings parsed from postgresql array \fP"
.ti -1c
.RI "void \fBlspg_allkvs_cb\fP (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"
.br
.RI "\fIset a redis variable based on an updated kv pair \fP"
.ti -1c
.RI "void \fBlspg_allkvs_error_cb\fP ()"
.br
.ti -1c
.RI "void \fBlspg_update_kvs_cb\fP (char *event)"
.br
.RI "\fIPerhaps update the px\&.kvs table in postgresql Should be triggered by a timer event\&. \fP"
.ti -1c
.RI "void \fBlspg_starttransfer_init\fP ()"
.br
.ti -1c
.RI "void \fBlspg_starttransfer_cb\fP (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"
.br
.ti -1c
.RI "void \fBlspg_starttransfer_error_cb\fP ()"
.br
.ti -1c
.RI "void \fBlspg_starttransfer_call\fP (unsigned int nextsample, int \fBsample_detected\fP, double ax, double ay, double az, double horz, double vert, double esttime)"
.br
.ti -1c
.RI "void \fBlspg_starttransfer_wait\fP ()"
.br
.ti -1c
.RI "void \fBlspg_starttransfer_done\fP ()"
.br
.ti -1c
.RI "int \fBlspg_starttransfer_all\fP (int *err, unsigned int nextsample, int sampledetected, double ax, double ay, double az, double horz, double vert, double esttime)"
.br
.ti -1c
.RI "void \fBlspg_getcurrentsampleid_init\fP ()"
.br
.ti -1c
.RI "void \fBlspg_getcurrentsampleid_cb\fP (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"
.br
.RI "\fIget currentsampleid \fP"
.ti -1c
.RI "void \fBlspg_getcurrentsampleid_error_cb\fP ()"
.br
.RI "\fIget currentsampleid error callback \fP"
.ti -1c
.RI "void \fBlspg_getcurrentsampleid_call\fP ()"
.br
.ti -1c
.RI "unsigned int \fBlspg_getcurrentsampleid_read\fP ()"
.br
.ti -1c
.RI "unsigned int \fBlspg_getcurrentsampleid_all\fP ()"
.br
.RI "\fIreturn the current sampleid \fP"
.ti -1c
.RI "int \fBlspg_getcurrentsampleid_wait_for_id\fP (unsigned int test)"
.br
.ti -1c
.RI "void \fBlspg_nextsample_cb\fP (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"
.br
.RI "\fINext Sample\&. \fP"
.ti -1c
.RI "void \fBlspg_nextsample_error_cb\fP ()"
.br
.RI "\fINext Sample Query Error Callback\&. \fP"
.ti -1c
.RI "void \fBlspg_nextsample_init\fP ()"
.br
.RI "\fIInitialize the nextsample variable, mutex, and condition\&. \fP"
.ti -1c
.RI "void \fBlspg_nextsample_call\fP ()"
.br
.RI "\fIQueue up a nextsample query\&. \fP"
.ti -1c
.RI "void \fBlspg_nextsample_wait\fP ()"
.br
.RI "\fIWait for the nextsample query to get processed\&. \fP"
.ti -1c
.RI "void \fBlspg_nextsample_done\fP ()"
.br
.RI "\fICalled when the next shot query has been processed\&. \fP"
.ti -1c
.RI "unsigned int \fBlspg_nextsample_all\fP (int *err)"
.br
.ti -1c
.RI "void \fBlspg_waitcryo_init\fP ()"
.br
.ti -1c
.RI "void \fBlspg_waitcryo_cb\fP (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"
.br
.ti -1c
.RI "void \fBlspg_waitcryo_error_cb\fP ()"
.br
.ti -1c
.RI "int \fBlspg_waitcryo_all\fP ()"
.br
.RI "\fIno need to get fancy with the wait cryo command It should not return until the robot is almost ready for air rights \fP"
.ti -1c
.RI "void \fBlspg_demandairrights_init\fP ()"
.br
.RI "\fIinitialize the demandairrights structure \fP"
.ti -1c
.RI "void \fBlspg_demandairrights_cb\fP (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"
.br
.RI "\fIhandle the airrights response \fP"
.ti -1c
.RI "void \fBlspg_demandairrights_error_cb\fP ()"
.br
.RI "\fIhandle airrights query error \fP"
.ti -1c
.RI "void \fBlspg_demandairrights_call\fP ()"
.br
.RI "\fIcall for airrights \fP"
.ti -1c
.RI "int \fBlspg_demandairrights_wait\fP ()"
.br
.RI "\fIwait for the air rights request to return \fP"
.ti -1c
.RI "int \fBlspg_demandairrights_all\fP ()"
.br
.RI "\fIdo nothing until we get airrights \fP"
.ti -1c
.RI "void \fBlspg_nextshot_cb\fP (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"
.br
.RI "\fINext Shot Callback\&. \fP"
.ti -1c
.RI "void \fBlspg_nextshot_error_cb\fP ()"
.br
.RI "\fInext shot query error callback \fP"
.ti -1c
.RI "void \fBlspg_nextshot_init\fP ()"
.br
.RI "\fIInitialize the nextshot variable, mutex, and condition\&. \fP"
.ti -1c
.RI "void \fBlspg_nextshot_call\fP ()"
.br
.RI "\fIQueue up a nextshot query\&. \fP"
.ti -1c
.RI "void \fBlspg_nextshot_wait\fP ()"
.br
.RI "\fIWait for the next shot query to get processed\&. \fP"
.ti -1c
.RI "void \fBlspg_nextshot_done\fP ()"
.br
.RI "\fICalled when the next shot query has been processed\&. \fP"
.ti -1c
.RI "void \fBlspg_wait_for_detector_init\fP ()"
.br
.RI "\fIinitialize the detector timing object \fP"
.ti -1c
.RI "void \fBlspg_wait_for_detector_cb\fP (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"
.br
.RI "\fICallback for the wait for detector query\&. \fP"
.ti -1c
.RI "void \fBlspg_wait_for_detector_error_cb\fP ()"
.br
.RI "\fIwait for detector query error callback \fP"
.ti -1c
.RI "void \fBlspg_wait_for_detector_call\fP ()"
.br
.RI "\fIinitiate the wait for detector query \fP"
.ti -1c
.RI "void \fBlspg_wait_for_detector_wait\fP ()"
.br
.RI "\fIPause the calling thread until the detector is ready Called by the MD2 thread\&. \fP"
.ti -1c
.RI "void \fBlspg_wait_for_detector_done\fP ()"
.br
.RI "\fIDone waiting for the detector\&. \fP"
.ti -1c
.RI "void \fBlspg_wait_for_detector_all\fP ()"
.br
.RI "\fICombined call to wait for the detector\&. \fP"
.ti -1c
.RI "void \fBlspg_lock_diffractometer_init\fP ()"
.br
.RI "\fIinitialize the diffractometer locking object \fP"
.ti -1c
.RI "void \fBlspg_lock_diffractometer_cb\fP (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"
.br
.RI "\fICallback routine for a lock diffractometer query\&. \fP"
.ti -1c
.RI "void \fBlspg_lock_diffractometer_error_cb\fP ()"
.br
.RI "\fIlock diffractometer query error callback \fP"
.ti -1c
.RI "void \fBlspg_lock_diffractometer_call\fP ()"
.br
.RI "\fIRequest that the database grab the diffractometer lock\&. \fP"
.ti -1c
.RI "void \fBlspg_lock_diffractometer_wait\fP ()"
.br
.RI "\fIWait for the diffractometer lock\&. \fP"
.ti -1c
.RI "void \fBlspg_lock_diffractometer_done\fP ()"
.br
.RI "\fIFinish up the lock diffractometer call\&. \fP"
.ti -1c
.RI "void \fBlspg_lock_diffractometer_all\fP ()"
.br
.RI "\fIConvience function that combines lock diffractometer calls\&. \fP"
.ti -1c
.RI "void \fBlspg_lock_detector_init\fP ()"
.br
.RI "\fIInitialize detector lock object\&. \fP"
.ti -1c
.RI "void \fBlspg_lock_detector_cb\fP (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"
.br
.RI "\fICallback for when the detector lock has be grabbed\&. \fP"
.ti -1c
.RI "void \fBlspg_lock_detector_error_cb\fP ()"
.br
.RI "\fIlock detector query error callback \fP"
.ti -1c
.RI "void \fBlspg_lock_detector_call\fP ()"
.br
.RI "\fIRequest (demand) a detector lock\&. \fP"
.ti -1c
.RI "void \fBlspg_lock_detector_wait\fP ()"
.br
.RI "\fIWait for the detector lock\&. \fP"
.ti -1c
.RI "void \fBlspg_lock_detector_done\fP ()"
.br
.RI "\fIFinish waiting\&. \fP"
.ti -1c
.RI "void \fBlspg_lock_detector_all\fP ()"
.br
.RI "\fIDetector lock convinence function\&. \fP"
.ti -1c
.RI "void \fBlspg_seq_run_prep_init\fP ()"
.br
.RI "\fIInitialize the data collection object\&. \fP"
.ti -1c
.RI "void \fBlspg_seq_run_prep_cb\fP (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"
.br
.RI "\fICallback for the seq_run_prep query\&. \fP"
.ti -1c
.RI "void \fBlspg_seq_run_prep_error_cb\fP ()"
.br
.RI "\fICallback for seq_run error\&. \fP"
.ti -1c
.RI "void \fBlspg_seq_run_prep_call\fP (long long skey, double \fBkappa\fP, double \fBphi\fP, double cx, double cy, double ax, double ay, double az)"
.br
.RI "\fIqueue up the seq_run_prep query \fP"
.ti -1c
.RI "void \fBlspg_seq_run_prep_wait\fP ()"
.br
.RI "\fIWait for seq run prep query to return\&. \fP"
.ti -1c
.RI "void \fBlspg_seq_run_prep_done\fP ()"
.br
.RI "\fIIndicate we are done waiting\&. \fP"
.ti -1c
.RI "int \fBlspg_seq_run_prep_all\fP (long long skey, double \fBkappa\fP, double \fBphi\fP, double cx, double cy, double ax, double ay, double az)"
.br
.RI "\fIConvinence function to call seq run prep\&. \fP"
.ti -1c
.RI "void \fBlspg_getcenter_cb\fP (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"
.br
.RI "\fIRetrieve the data to center the crystal\&. \fP"
.ti -1c
.RI "void \fBlspg_getcenter_error_cb\fP ()"
.br
.RI "\fIgetcenter query error callback \fP"
.ti -1c
.RI "void \fBlspg_getcenter_init\fP ()"
.br
.RI "\fIInitialize getcenter object\&. \fP"
.ti -1c
.RI "void \fBlspg_getcenter_call\fP ()"
.br
.RI "\fIRequest a getcenter query\&. \fP"
.ti -1c
.RI "void \fBlspg_getcenter_wait\fP ()"
.br
.RI "\fIWait for a getcenter query to return\&. \fP"
.ti -1c
.RI "void \fBlspg_getcenter_done\fP ()"
.br
.RI "\fIDone with getcenter query\&. \fP"
.ti -1c
.RI "void \fBlspg_getcenter_all\fP ()"
.br
.RI "\fIConvenience function to complete synchronous getcenter query\&. \fP"
.ti -1c
.RI "void \fBlspg_nextaction_cb\fP (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"
.br
.RI "\fIQueue the next MD2 instruction\&. \fP"
.ti -1c
.RI "void \fBlspg_nextaction_error_cb\fP ()"
.br
.ti -1c
.RI "void \fBlspg_nexterrors_cb\fP (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"
.br
.ti -1c
.RI "void \fBlspg_nexterrors_error_cb\fP ()"
.br
.ti -1c
.RI "void \fBlspg_cmd_error_cb\fP ()"
.br
.ti -1c
.RI "void \fBlspg_cmd_cb\fP (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"
.br
.RI "\fISend strings directly to PMAC queue\&. \fP"
.ti -1c
.RI "void \fBlspg_flush\fP ()"
.br
.RI "\fIFlush psql output buffer (ie, send the query) \fP"
.ti -1c
.RI "void \fBlspg_send_next_query\fP ()"
.br
.RI "\fIsend the next queued query to the DB server \fP"
.ti -1c
.RI "void \fBlspg_receive\fP ()"
.br
.RI "\fIReceive a result of a query\&. \fP"
.ti -1c
.RI "void \fBlspg_sig_service\fP (struct pollfd *evt)"
.br
.RI "\fIService a signal Signals here are treated as file descriptors and fits into our poll scheme\&. \fP"
.ti -1c
.RI "void \fBlspg_pg_service\fP (struct pollfd *evt)"
.br
.RI "\fII/O control to/from the postgresql server\&. \fP"
.ti -1c
.RI "PQnoticeProcessor \fBlspg_notice_processor\fP (void *arg, const char *msg)"
.br
.ti -1c
.RI "void \fBlspg_pg_connect\fP ()"
.br
.RI "\fIConnect to the pg server\&. \fP"
.ti -1c
.RI "void \fBlspg_next_state\fP ()"
.br
.RI "\fIImplements our state machine Does not strictly only set the next state as it also calls some functions that, perhaps, alters the state mid-function\&. \fP"
.ti -1c
.RI "void * \fBlspg_worker\fP (void *dummy)"
.br
.RI "\fIThe main loop for the lspg thread\&. \fP"
.ti -1c
.RI "void \fBlspg_preset_changed_cb\fP (char *event)"
.br
.ti -1c
.RI "void \fBlspg_check_preset_in_position_cb\fP (char *event)"
.br
.ti -1c
.RI "void \fBlspg_unset_current_preset_moving_cb\fP (char *event)"
.br
.ti -1c
.RI "void \fBlspg_set_scale_cb\fP (char *event)"
.br
.RI "\fIFix up xscale and yscale when zoom changes\&. \fP"
.ti -1c
.RI "void \fBlspg_sample_detector_cb\fP (char *event)"
.br
.RI "\fIlog magnet state \fP"
.ti -1c
.RI "void \fBlspg_quit_query_cb\fP (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"
.br
.RI "\fIcall back to handle signing out of the database \fP"
.ti -1c
.RI "void \fBlspg_quitting_cb\fP (char *event)"
.br
.RI "\fIPrepare to exit the program in a couple of seconds\&. \fP"
.ti -1c
.RI "void \fBlspg_init\fP ()"
.br
.RI "\fIInitiallize the lspg module\&. \fP"
.ti -1c
.RI "pthread_t * \fBlspg_run\fP ()"
.br
.RI "\fIStart 'er runnin'\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static int \fBls_pg_state\fP = \fBLS_PG_STATE_INIT\fP"
.br
.RI "\fIState of the lspg state machine\&. \fP"
.ti -1c
.RI "static struct timeval 
.br
lspg_time_sent \fBnow\fP"
.br
.RI "\fIused to ensure we do not inundate the db server with connection requests \fP"
.ti -1c
.RI "static pthread_t \fBlspg_thread\fP"
.br
.RI "\fIour worker thread \fP"
.ti -1c
.RI "static pthread_mutex_t \fBlspg_queue_mutex\fP"
.br
.RI "\fIkeep the queue from getting tangled \fP"
.ti -1c
.RI "static pthread_cond_t \fBlspg_queue_cond\fP"
.br
.RI "\fIkeeps the queue from overflowing \fP"
.ti -1c
.RI "static struct pollfd \fBlspgfd\fP"
.br
.RI "\fIour poll info \fP"
.ti -1c
.RI "static \fBlspg_query_queue_t\fP \fBlspg_query_queue\fP [\fBLS_PG_QUERY_QUEUE_LENGTH\fP]"
.br
.RI "\fIOur query queue\&. \fP"
.ti -1c
.RI "static unsigned int \fBlspg_query_queue_on\fP = 0"
.br
.RI "\fINext position to add something to the queue\&. \fP"
.ti -1c
.RI "static unsigned int \fBlspg_query_queue_off\fP = 0"
.br
.RI "\fIThe last item still being used (on == off means nothing in queue) \fP"
.ti -1c
.RI "static unsigned int \fBlspg_query_queue_reply\fP = 0"
.br
.RI "\fIThe current item being digested\&. \fP"
.ti -1c
.RI "static PGconn * \fBq\fP = NULL"
.br
.RI "\fIDatabase connector\&. \fP"
.ti -1c
.RI "static int \fBlspg_running\fP = 1"
.br
.RI "\fIflag to tell worker it's time to go home \fP"
.ti -1c
.RI "static PostgresPollingStatusType \fBlspg_connectPoll_response\fP"
.br
.RI "\fIUsed to determine state while connecting\&. \fP"
.ti -1c
.RI "static PostgresPollingStatusType \fBlspg_resetPoll_response\fP"
.br
.RI "\fIUsed to determine state while reconnecting\&. \fP"
.ti -1c
.RI "\fBlspg_nextsample_t\fP \fBlspg_nextsample\fP"
.br
.RI "\fIthe very next sample \fP"
.ti -1c
.RI "\fBlspg_nextshot_t\fP \fBlspg_nextshot\fP"
.br
.RI "\fIthe nextshot object \fP"
.ti -1c
.RI "\fBlspg_getcenter_t\fP \fBlspg_getcenter\fP"
.br
.RI "\fIthe getcenter object \fP"
.ti -1c
.RI "\fBlspg_demandairrights_t\fP \fBlspg_demandairrights\fP"
.br
.RI "\fIour demandairrights object \fP"
.ti -1c
.RI "\fBlspg_getcurrentsampleid_t\fP \fBlspg_getcurrentsampleid\fP"
.br
.RI "\fIour currentsample id \fP"
.ti -1c
.RI "\fBlspg_starttransfer_t\fP \fBlspg_starttransfer\fP"
.br
.RI "\fIstart a sample transfer \fP"
.ti -1c
.RI "\fBlspg_waitcryo_t\fP \fBlspg_waitcryo\fP"
.br
.RI "\fIsignal the robot \fP"
.ti -1c
.RI "static \fBlspg_wait_for_detector_t\fP \fBlspg_wait_for_detector\fP"
.br
.RI "\fIInstance of the detector timing object\&. \fP"
.ti -1c
.RI "static \fBlspg_lock_diffractometer_t\fP \fBlspg_lock_diffractometer\fP"
.br
.ti -1c
.RI "static \fBlspg_lock_detector_t\fP \fBlspg_lock_detector\fP"
.br
.ti -1c
.RI "static \fBlspg_seq_run_prep_t\fP \fBlspg_seq_run_prep\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Postgresql support for the LS-CAT pgpmac project\&. 

.PP
.nf
\date 2012
\author Keith Brister
\copyright All Rights Reserved
.fi
.PP
.PP
.PP
.nf

  Database state machine
.fi
.PP
.PP
.PP
.nf
State           Description
.fi
.PP
.PP
.PP
.nf
 -4             Initiate connection
 -3             Poll until connection initialization is complete
 -2             Initiate reset
 -1             Poll until connection reset is complete
  1             Idle (wait for a notify from the server)
  2             Send a query to the server
  3             Continue flushing a command to the server
  4             Waiting for a reply
  5             Quitting: ignore new queries
.fi
.PP
 
.PP
Definition in file \fBlspg\&.c\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define LS_PG_QUERY_QUEUE_LENGTH   16384"

.PP
Queue length should be long enough that we do not ordinarly bump into the end We should be safe as long as the thread the adds stuff to the queue is not the one that removes it\&. (And we can tolerate the adding thread being paused\&.) 
.PP
Definition at line 52 of file lspg\&.c\&.
.SS "#define LS_PG_STATE_IDLE   1"

.PP
Definition at line 34 of file lspg\&.c\&.
.SS "#define LS_PG_STATE_INIT   -4"

.PP
Definition at line 30 of file lspg\&.c\&.
.SS "#define LS_PG_STATE_INIT_POLL   -3"

.PP
Definition at line 31 of file lspg\&.c\&.
.SS "#define LS_PG_STATE_QUITTING   5"

.PP
Definition at line 38 of file lspg\&.c\&.
.SS "#define LS_PG_STATE_RECV   4"

.PP
Definition at line 37 of file lspg\&.c\&.
.SS "#define LS_PG_STATE_RESET   -2"

.PP
Definition at line 32 of file lspg\&.c\&.
.SS "#define LS_PG_STATE_RESET_POLL   -1"

.PP
Definition at line 33 of file lspg\&.c\&.
.SS "#define LS_PG_STATE_SEND   2"

.PP
Definition at line 35 of file lspg\&.c\&.
.SS "#define LS_PG_STATE_SEND_FLUSH   3"

.PP
Definition at line 36 of file lspg\&.c\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBlspg_lock_detector_struct\fP  \fBlspg_lock_detector_t\fP"

.PP
lock detector object Implements detector lock for exposure control 
.SS "typedef struct \fBlspg_lock_diffractometer_struct\fP  \fBlspg_lock_diffractometer_t\fP"

.PP
Object used to impliment locking the diffractometer Critical to exposure timing\&. 
.SS "typedef struct \fBlspg_seq_run_prep_struct\fP  \fBlspg_seq_run_prep_t\fP"

.PP
Data collection running object\&. 
.SS "typedef struct \fBlspg_wait_for_detector_struct\fP  \fBlspg_wait_for_detector_t\fP"

.PP
Object that implements detector / spindle timing We use database locks for exposure control and this implements the md2 portion of this handshake\&. 
.SH "Function Documentation"
.PP 
.SS "void lspg_allkvs_cb (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"

.PP
set a redis variable based on an updated kv pair \fBParameters:\fP
.RS 4
\fIqqp\fP The query that elicited this response 
.br
\fIpgr\fP The resonse from postgresql 
.RE
.PP

.PP
Definition at line 284 of file lspg\&.c\&.
.PP
.nf
                                                             {
  int i;
  lsredis_obj_t *robj;
  
  for( i=0; i<PQntuples( pgr); i += 2) {
    pthread_mutex_lock( &lsredis_mutex);
    while( lsredis_running == 0)
      pthread_cond_wait( &lsredis_cond, &lsredis_mutex);
    pthread_mutex_unlock( &lsredis_mutex);

    robj = _lsredis_get_obj( PQgetvalue( pgr, i, 0));

    if( robj == NULL) {
      lslogging_log_message( 'lspg_allkvs_cb: could not find redis object named '%s'', PQgetvalue( pgr, i, 0));
      continue;
    }

    lsredis_setstr( robj, '%s', PQgetvalue( pgr, i+1, 0));
  }
}
.fi
.SS "void lspg_allkvs_error_cb ()"

.PP
Definition at line 305 of file lspg\&.c\&.
.PP
.nf
                            {
  lslogging_log_message( 'query error getting kvs');
}
.fi
.SS "char** lspg_array2ptrs (char *a)"

.PP
returns a null terminated list of strings parsed from postgresql array 
.PP
Definition at line 165 of file lspg\&.c\&.
.PP
.nf
                                 {
  char **rtn, *sp, *acums;
  int i, n, inquote, havebackslash, rtni;;
  int mxsz;
  
  inquote       = 0;
  havebackslash = 0;

  // Despense with the null input condition before we complicate the code below
  if( a == NULL || a[0] != '{' || a[strlen(a)-1] != '}')
    return NULL;

  // Count the maximum number of strings
  // Actual number will be less if there are quoted commas
  //
  n = 1;
  for( i=0; a[i]; i++) {
    if( a[i] == ',')
      n++;
  }
  //
  // The maximum size of any string is the length of a (+1)
  //
  mxsz = strlen(a) + 1;

  // This is the accumulation string to make up the array elements
  acums = (char *)calloc( mxsz, sizeof( char));
  if( acums == NULL) {
    lslogging_log_message( 'lspg_array2ptrs: out of memory (acums)');
    exit( 1);
  }
  
  //
  // allocate storage for the pointer array and the null terminator
  //
  rtn = (char **)calloc( n+1, sizeof( char *));
  if( rtn == NULL) {
    lslogging_log_message( 'lspg_array2ptrs: out of memory (rtn)');
    exit( 1);
  }
  rtni = 0;
  
  // Go through and create the individual strings
  sp = acums;
  *sp = 0;

  inquote = 0;
  havebackslash = 0;
  for( i=1; a[i] != 0; i++) {
    switch( a[i]) {
    case ''':
      if( havebackslash) {
        // a quoted quote\&.  Cool
        //
        *(sp++) = a[i];
        *sp = 0;
        havebackslash = 0;
      } else {
        // Toggle the flag
        inquote = 1 - inquote;
      }
      break;

    case '\\':
      if( havebackslash) {
        *(sp++) = a[i];
        *sp = 0;
        havebackslash = 0;
      } else {
        havebackslash = 1;
      }
      break;

    case ',':
      if( inquote || havebackslash) {
        *(sp++) = a[i];
        *sp = 0;
        havebackslash = 0;
      } else {
        rtn[rtni++] = strdup( acums);
        sp = acums;
      }
      break;
      
    case '}':
      if( inquote || havebackslash) {
        *(sp++) = a[i];
        *sp = 0;
        havebackslash = 0;
      } else {
        rtn[rtni++] = strdup( acums);
        rtn[rtni]   = NULL;
        free( acums);
        return( rtn);
      }
      break;

    default:
      *(sp++) = a[i];
      *sp = 0;
      havebackslash = 0;
    }
  }
  //
  // Getting here means the final '}' was missing
  // Probably we should throw an error or log it or something\&.
  // Through out the last entry since this there is not resonable expectation that
  // we should be parsing it anyway\&.
  //
  rtn[rtni]   = NULL;
  free( acums);
  return( rtn);
}
.fi
.SS "void lspg_check_preset_in_position_cb (char *event)"

.PP
Definition at line 2065 of file lspg\&.c\&.
.PP
.nf
                                                    {
  lspmac_motor_t *mp;
  char cp[64];
  int i;

  for( i=0; i<strlen( event); i++) {
    cp[i] = 0;
    if( event[i] == ' ')
      break;
    cp[i] = event[i];
  }

  mp = lspmac_find_motor_by_name( cp);
  if( mp == NULL) {
    return;
  }
  i = lsredis_find_preset_index_by_position( mp);
  lspg_query_push( NULL, NULL, 'EXECUTE kvupdate( '{%s\&.currentPreset,%d}')', cp, i);

}
.fi
.SS "void lspg_cmd_cb (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"

.PP
Send strings directly to PMAC queue\&. \fBParameters:\fP
.RS 4
\fIqqp\fP Our query 
.br
\fIpgr\fP Our result 
.RE
.PP

.PP
Definition at line 1524 of file lspg\&.c\&.
.PP
.nf
                   {
  //
  // Call back funciton assumes query results in zero or more commands to send to the PMAC
  //
  int i;
  char *sp;
  
  for( i=0; i<PQntuples( pgr); i++) {
    sp = PQgetvalue( pgr, i, 0);
    if( sp != NULL && *sp != 0) {
      lspmac_SockSendDPline( NULL, sp);
      //      lspmac_SockSendline( sp);
      //
      // Keep asking for more until
      // there are no commands left
      // 
      // This should solve a potential problem where
      // more than one command is put on the queue for a given notify\&.
      //
      lspg_query_push( lspg_cmd_cb, lspg_cmd_error_cb, 'select pmac\&.md2_queue_next()');
    }
  }
}
.fi
.SS "void lspg_cmd_error_cb ()"

.PP
Definition at line 1518 of file lspg\&.c\&.
.PP
.nf
                         {
  lslogging_log_message( 'query error getting next md2 command');
}
.fi
.SS "int lspg_demandairrights_all ()"

.PP
do nothing until we get airrights 
.PP
Definition at line 726 of file lspg\&.c\&.
.PP
.nf
                               {
  lspg_demandairrights_call();
  return lspg_demandairrights_wait();
  // there is no 'done' version
}
.fi
.SS "void lspg_demandairrights_call ()"

.PP
call for airrights 
.PP
Definition at line 702 of file lspg\&.c\&.
.PP
.nf
                                 {
  lslogging_log_message( 'Demanding Air Rights');
  pthread_mutex_lock( &lspg_demandairrights\&.mutex);
  lspg_demandairrights\&.new_value_ready = 0;
  lspg_demandairrights\&.query_error     = 0;
  pthread_mutex_unlock( &lspg_demandairrights\&.mutex);
  lspg_query_push( lspg_demandairrights_cb, lspg_demandairrights_error_cb, 'SELECT px\&.demandairrights()');
}
.fi
.SS "void lspg_demandairrights_cb (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"

.PP
handle the airrights response 
.PP
Definition at line 683 of file lspg\&.c\&.
.PP
.nf
                                                                      {
  pthread_mutex_lock( &lspg_demandairrights\&.mutex);
  lspg_demandairrights\&.new_value_ready = 1;
  pthread_cond_signal( &lspg_demandairrights\&.cond);
  pthread_mutex_unlock( &lspg_demandairrights\&.mutex);
}
.fi
.SS "void lspg_demandairrights_error_cb ()"

.PP
handle airrights query error 
.PP
Definition at line 692 of file lspg\&.c\&.
.PP
.nf
                                     {
  pthread_mutex_lock( &lspg_demandairrights\&.mutex);
  lspg_demandairrights\&.query_error = 1;
  pthread_cond_signal( &lspg_demandairrights\&.cond);
  pthread_mutex_unlock( &lspg_demandairrights\&.mutex);
  lslogging_log_message( 'Received Air Rights');
}
.fi
.SS "void lspg_demandairrights_init ()"

.PP
initialize the demandairrights structure 
.PP
Definition at line 674 of file lspg\&.c\&.
.PP
.nf
                                 {
  lspg_demandairrights\&.new_value_ready = 0;
  lspg_demandairrights\&.query_error     = 0;
  pthread_mutex_init( &lspg_demandairrights\&.mutex, NULL);
  pthread_cond_init( &lspg_demandairrights\&.cond, NULL);
}
.fi
.SS "int lspg_demandairrights_wait ()"

.PP
wait for the air rights request to return 
.PP
Definition at line 713 of file lspg\&.c\&.
.PP
.nf
                                {
  int rtn;
  pthread_mutex_lock( &lspg_demandairrights\&.mutex);
  while( lspg_demandairrights\&.new_value_ready == 0 && lspg_demandairrights\&.query_error == 0)
    pthread_cond_wait( &lspg_demandairrights\&.cond, &lspg_demandairrights\&.mutex);
  rtn = lspg_demandairrights\&.query_error;
  pthread_mutex_unlock( &lspg_demandairrights\&.mutex);

  return rtn;
}
.fi
.SS "void lspg_flush ()"

.PP
Flush psql output buffer (ie, send the query) 
.PP
Definition at line 1554 of file lspg\&.c\&.
.PP
.nf
                  {
  int err;

  err = PQflush( q);
  switch( err) {
  case -1:
    // an error occured

    lslogging_log_message( 'flush failed: %s', PQerrorMessage( q));

    ls_pg_state = LS_PG_STATE_IDLE;
    //
    // We should probably reset the connection and start from scratch\&.  Probably the connection died\&.
    //
    break;
          
  case 0:
    // goodness and joy\&.
    ls_pg_state = LS_PG_STATE_RECV;
    break;

  case 1:
    // more sending to do
    ls_pg_state = LS_PG_STATE_SEND_FLUSH;
    break;
  }
}
.fi
.SS "void lspg_getcenter_all ()"

.PP
Convenience function to complete synchronous getcenter query\&. 
.PP
Definition at line 1451 of file lspg\&.c\&.
.PP
.nf
                          {
  lspg_getcenter_call();
  lspg_getcenter_wait();
  lspg_getcenter_done();
}
.fi
.SS "void lspg_getcenter_call ()"

.PP
Request a getcenter query\&. 
.PP
Definition at line 1426 of file lspg\&.c\&.
.PP
.nf
                           {
  pthread_mutex_lock( &lspg_getcenter\&.mutex);
  lspg_getcenter\&.new_value_ready = 0;
  lspg_getcenter\&.query_error     = 0;
  pthread_mutex_unlock( &lspg_getcenter\&.mutex);

  lspg_query_push( lspg_getcenter_cb, lspg_getcenter_error_cb, 'SELECT * FROM px\&.getcenter2()');
}
.fi
.SS "void lspg_getcenter_cb (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"

.PP
Retrieve the data to center the crystal\&. 
.PP
Definition at line 1346 of file lspg\&.c\&.
.PP
.nf
                                                                {
  static int
    zoom_c, dcx_c, dcy_c, dax_c, day_c, daz_c, hash_c;

  pthread_mutex_lock( &(lspg_getcenter\&.mutex));
  
  lspg_getcenter\&.no_rows_returned = PQntuples( pgr) <= 0;
  if( lspg_getcenter\&.no_rows_returned) {
    //
    // No particular reason this path should ever be taken
    // but if we don't get rows then we had better not move anything\&.
    //
    lspg_getcenter\&.new_value_ready = 1;
    pthread_cond_signal( &(lspg_getcenter\&.cond));
    pthread_mutex_unlock( &(lspg_getcenter\&.mutex));
    return;
  }

  zoom_c = PQfnumber( pgr, 'zoom');
  dcx_c  = PQfnumber( pgr, 'dcx');
  dcy_c  = PQfnumber( pgr, 'dcy');
  dax_c  = PQfnumber( pgr, 'dax');
  day_c  = PQfnumber( pgr, 'day');
  daz_c  = PQfnumber( pgr, 'daz');
  hash_c = PQfnumber( pgr, 'hash');

  lspg_getcenter\&.zoom_isnull = PQgetisnull( pgr, 0, zoom_c);
  if( lspg_getcenter\&.zoom_isnull == 0)
    lspg_getcenter\&.zoom = atoi( PQgetvalue( pgr, 0, zoom_c));

  lspg_getcenter\&.dcx_isnull = PQgetisnull( pgr, 0, dcx_c);
  if( lspg_getcenter\&.dcx_isnull == 0)
    lspg_getcenter\&.dcx = atof( PQgetvalue( pgr, 0, dcx_c));

  lspg_getcenter\&.dcy_isnull = PQgetisnull( pgr, 0, dcy_c);
  if( lspg_getcenter\&.dcy_isnull == 0)
    lspg_getcenter\&.dcy = atof( PQgetvalue( pgr, 0, dcy_c));

  lspg_getcenter\&.dax_isnull = PQgetisnull( pgr, 0, dax_c);
  if( lspg_getcenter\&.dax_isnull == 0)
    lspg_getcenter\&.dax = atof( PQgetvalue( pgr, 0, dax_c));

  lspg_getcenter\&.day_isnull = PQgetisnull( pgr, 0, day_c);
  if( lspg_getcenter\&.day_isnull == 0)
    lspg_getcenter\&.day = atof( PQgetvalue( pgr, 0, day_c));

  lspg_getcenter\&.daz_isnull = PQgetisnull( pgr, 0, daz_c);
  if( lspg_getcenter\&.daz_isnull == 0)
    lspg_getcenter\&.daz = atof( PQgetvalue( pgr, 0, daz_c));

  lspg_getcenter\&.hash_isnull = PQgetisnull( pgr, 0, hash_c);
  if( lspg_getcenter\&.hash != NULL)
    free( lspg_getcenter\&.hash);
  lspg_getcenter\&.hash = strdup( PQgetvalue( pgr, 0, hash_c));

  lspg_getcenter\&.new_value_ready = 1;

  pthread_cond_signal( &(lspg_getcenter\&.cond));
  pthread_mutex_unlock( &(lspg_getcenter\&.mutex));
}
.fi
.SS "void lspg_getcenter_done ()"

.PP
Done with getcenter query\&. 
.PP
Definition at line 1445 of file lspg\&.c\&.
.PP
.nf
                           {
  pthread_mutex_unlock( &(lspg_getcenter\&.mutex));
}
.fi
.SS "void lspg_getcenter_error_cb ()"

.PP
getcenter query error callback 
.PP
Definition at line 1409 of file lspg\&.c\&.
.PP
.nf
                               {
  pthread_mutex_lock( &lspg_getcenter\&.mutex);
  lspg_getcenter\&.query_error = 1;
  pthread_cond_signal( &lspg_getcenter\&.cond);
  pthread_mutex_unlock( &lspg_getcenter\&.mutex);
}
.fi
.SS "void lspg_getcenter_init ()"

.PP
Initialize getcenter object\&. 
.PP
Definition at line 1418 of file lspg\&.c\&.
.PP
.nf
                           {
  memset( &lspg_getcenter, 0, sizeof( lspg_getcenter));
  pthread_mutex_init( &(lspg_getcenter\&.mutex), NULL);
  pthread_cond_init( &(lspg_getcenter\&.cond), NULL);
}
.fi
.SS "void lspg_getcenter_wait ()"

.PP
Wait for a getcenter query to return\&. 
.PP
Definition at line 1437 of file lspg\&.c\&.
.PP
.nf
                           {
  pthread_mutex_lock( &(lspg_getcenter\&.mutex));
  while( lspg_getcenter\&.new_value_ready == 0 && lspg_getcenter\&.query_error == 0)
    pthread_cond_wait( &(lspg_getcenter\&.cond), &(lspg_getcenter\&.mutex));
}
.fi
.SS "unsigned int lspg_getcurrentsampleid_all ()"

.PP
return the current sampleid 
.PP
Definition at line 510 of file lspg\&.c\&.
.PP
.nf
                                           {
  lspg_getcurrentsampleid_call();
  return lspg_getcurrentsampleid_read();
}
.fi
.SS "void lspg_getcurrentsampleid_call ()"

.PP
Definition at line 482 of file lspg\&.c\&.
.PP
.nf
                                    {
  pthread_mutex_lock( &lspg_getcurrentsampleid\&.mutex);
  lspg_getcurrentsampleid\&.new_value_ready = 0;
  lspg_getcurrentsampleid\&.query_error     = 0;
  pthread_mutex_unlock( &lspg_getcurrentsampleid\&.mutex);

  lspg_query_push( lspg_getcurrentsampleid_cb, lspg_getcurrentsampleid_error_cb, 'SELECT px\&.getcurrentsampleid()');
}
.fi
.SS "void lspg_getcurrentsampleid_cb (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"

.PP
get currentsampleid 
.PP
Definition at line 452 of file lspg\&.c\&.
.PP
.nf
                                                                         {
  pthread_mutex_lock( &lspg_getcurrentsampleid\&.mutex);

  lspg_getcurrentsampleid\&.new_value_ready = 1;
  lspg_getcurrentsampleid\&.no_rows_returned = PQntuples( pgr) <= 0;
  if( lspg_getcurrentsampleid\&.no_rows_returned) {
    pthread_cond_signal( &lspg_getcurrentsampleid\&.cond);
    pthread_mutex_unlock( &lspg_getcurrentsampleid\&.mutex);
    return;
  }

  lspg_getcurrentsampleid\&.getcurrentsampleid_isnull = PQgetisnull( pgr, 0, 0);
  if( lspg_getcurrentsampleid\&.getcurrentsampleid_isnull == 0)
    lspg_getcurrentsampleid\&.getcurrentsampleid = strtol( PQgetvalue( pgr, 0, 0), NULL, 0);

  pthread_cond_signal( &lspg_getcurrentsampleid\&.cond);
  pthread_mutex_unlock( &lspg_getcurrentsampleid\&.mutex);
}
.fi
.SS "void lspg_getcurrentsampleid_error_cb ()"

.PP
get currentsampleid error callback 
.PP
Definition at line 473 of file lspg\&.c\&.
.PP
.nf
                                        {
  pthread_mutex_lock( &lspg_getcurrentsampleid\&.mutex);
  lspg_getcurrentsampleid\&.query_error = 1;
  pthread_cond_signal( &lspg_getcurrentsampleid\&.cond);
  pthread_mutex_unlock( &lspg_getcurrentsampleid\&.mutex);
}
.fi
.SS "void lspg_getcurrentsampleid_init ()"

.PP
Definition at line 443 of file lspg\&.c\&.
.PP
.nf
                                    {
  lspg_getcurrentsampleid\&.new_value_ready = 0;
  lspg_getcurrentsampleid\&.query_error     = 0;
  pthread_mutex_init( &lspg_getcurrentsampleid\&.mutex, NULL);
  pthread_cond_init( &lspg_getcurrentsampleid\&.cond, NULL);
}
.fi
.SS "unsigned int lspg_getcurrentsampleid_read ()"

.PP
Definition at line 493 of file lspg\&.c\&.
.PP
.nf
                                            {
  unsigned int rtn;
  pthread_mutex_lock( &lspg_getcurrentsampleid\&.mutex);
  while( lspg_getcurrentsampleid\&.new_value_ready == 0 && lspg_getcurrentsampleid\&.query_error == 0)
    pthread_cond_wait( &lspg_getcurrentsampleid\&.cond, &lspg_getcurrentsampleid\&.mutex);
  
  if( lspg_getcurrentsampleid\&.getcurrentsampleid_isnull || lspg_getcurrentsampleid\&.query_error != 0)
    rtn = -1;
  else
    rtn = lspg_getcurrentsampleid\&.getcurrentsampleid;

  pthread_mutex_unlock( &lspg_getcurrentsampleid\&.mutex);
  return rtn;
}
.fi
.SS "int lspg_getcurrentsampleid_wait_for_id (unsigned inttest)"

.PP
Definition at line 517 of file lspg\&.c\&.
.PP
.nf
                                                            {
  int rtn;

  pthread_mutex_lock( &lspg_getcurrentsampleid\&.mutex);
  while( lspg_getcurrentsampleid\&.getcurrentsampleid != test && lspg_getcurrentsampleid\&.query_error == 0)
    pthread_cond_wait( &lspg_getcurrentsampleid\&.cond, &lspg_getcurrentsampleid\&.mutex);
  
  rtn = lspg_getcurrentsampleid\&.query_error;
  pthread_mutex_unlock( &lspg_getcurrentsampleid\&.mutex);

  return rtn;
}
.fi
.SS "void lspg_init ()"

.PP
Initiallize the lspg module\&. 
.PP
Definition at line 2163 of file lspg\&.c\&.
.PP
.nf
                 {
  pthread_mutex_init( &lspg_queue_mutex, NULL);
  pthread_cond_init( &lspg_queue_cond, NULL);

  lspg_demandairrights_init();
  lspg_getcenter_init();
  lspg_getcurrentsampleid_init();
  lspg_lock_detector_init();
  lspg_lock_diffractometer_init();
  lspg_nextsample_init();
  lspg_nextshot_init();
  lspg_seq_run_prep_init();
  lspg_starttransfer_init();
  lspg_wait_for_detector_init();
  lspg_waitcryo_init();
}
.fi
.SS "void lspg_lock_detector_all ()"

.PP
Detector lock convinence function\&. 
.PP
Definition at line 1240 of file lspg\&.c\&.
.PP
.nf
                              {
  lspg_lock_detector_call();
  lspg_lock_detector_wait();
  lspg_lock_detector_done();
}
.fi
.SS "void lspg_lock_detector_call ()"

.PP
Request (demand) a detector lock\&. 
.PP
Definition at line 1215 of file lspg\&.c\&.
.PP
.nf
                               {
  pthread_mutex_lock( &(lspg_lock_detector\&.mutex));
  lspg_lock_detector\&.new_value_ready = 0;
  lspg_lock_detector\&.query_error     = 0;
  pthread_mutex_unlock( &(lspg_lock_detector\&.mutex));

  lspg_query_push( lspg_lock_detector_cb, lspg_lock_detector_error_cb, 'SELECT px\&.lock_detector()');
}
.fi
.SS "void lspg_lock_detector_cb (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"

.PP
Callback for when the detector lock has be grabbed\&. 
.PP
Definition at line 1197 of file lspg\&.c\&.
.PP
.nf
                                                                    {
  pthread_mutex_lock( &(lspg_lock_detector\&.mutex));
  lspg_lock_detector\&.new_value_ready = 1;
  pthread_cond_signal( &(lspg_lock_detector\&.cond));
  pthread_mutex_unlock( &(lspg_lock_detector\&.mutex));
}
.fi
.SS "void lspg_lock_detector_done ()"

.PP
Finish waiting\&. 
.PP
Definition at line 1234 of file lspg\&.c\&.
.PP
.nf
                               {
  pthread_mutex_unlock( &(lspg_lock_detector\&.mutex));
}
.fi
.SS "void lspg_lock_detector_error_cb ()"

.PP
lock detector query error callback 
.PP
Definition at line 1206 of file lspg\&.c\&.
.PP
.nf
                                   {
  pthread_mutex_lock( &lspg_lock_detector\&.mutex);
  lspg_lock_detector\&.query_error = 1;
  pthread_cond_signal( &lspg_lock_detector\&.cond);
  pthread_mutex_unlock( &lspg_lock_detector\&.mutex);
}
.fi
.SS "void lspg_lock_detector_init ()"

.PP
Initialize detector lock object\&. 
.PP
Definition at line 1188 of file lspg\&.c\&.
.PP
.nf
                               {
  lspg_lock_detector\&.new_value_ready = 0;
  lspg_lock_detector\&.query_error     = 0;
  pthread_mutex_init( &(lspg_lock_detector\&.mutex), NULL);
  pthread_cond_init(  &(lspg_lock_detector\&.cond),  NULL);
}
.fi
.SS "void lspg_lock_detector_wait ()"

.PP
Wait for the detector lock\&. 
.PP
Definition at line 1226 of file lspg\&.c\&.
.PP
.nf
                               {
  pthread_mutex_lock( &(lspg_lock_detector\&.mutex));
  while( lspg_lock_detector\&.new_value_ready == 0 && lspg_lock_detector\&.query_error == 0)
    pthread_cond_wait( &(lspg_lock_detector\&.cond), &(lspg_lock_detector\&.mutex));
}
.fi
.SS "void lspg_lock_diffractometer_all ()"

.PP
Convience function that combines lock diffractometer calls\&. 
.PP
Definition at line 1169 of file lspg\&.c\&.
.PP
.nf
                                    {
  lspg_lock_diffractometer_call();
  lspg_lock_diffractometer_wait();
  lspg_lock_diffractometer_all();
}
.fi
.SS "void lspg_lock_diffractometer_call ()"

.PP
Request that the database grab the diffractometer lock\&. 
.PP
Definition at line 1144 of file lspg\&.c\&.
.PP
.nf
                                     {
  pthread_mutex_lock( &(lspg_lock_diffractometer\&.mutex));
  lspg_lock_diffractometer\&.new_value_ready = 0;
  lspg_lock_diffractometer\&.query_error     = 0;
  pthread_mutex_unlock( &(lspg_lock_diffractometer\&.mutex));

  lspg_query_push( lspg_lock_diffractometer_cb, lspg_lock_diffractometer_error_cb, 'SELECT px\&.lock_diffractomter()');
}
.fi
.SS "void lspg_lock_diffractometer_cb (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"

.PP
Callback routine for a lock diffractometer query\&. 
.PP
Definition at line 1126 of file lspg\&.c\&.
.PP
.nf
                                                                          {
  pthread_mutex_lock( &(lspg_lock_diffractometer\&.mutex));
  lspg_lock_diffractometer\&.new_value_ready = 1;
  pthread_cond_signal( &(lspg_lock_diffractometer\&.cond));
  pthread_mutex_unlock( &(lspg_lock_diffractometer\&.mutex));
}
.fi
.SS "void lspg_lock_diffractometer_done ()"

.PP
Finish up the lock diffractometer call\&. 
.PP
Definition at line 1163 of file lspg\&.c\&.
.PP
.nf
                                     {
  pthread_mutex_unlock( &(lspg_lock_diffractometer\&.mutex));
}
.fi
.SS "void lspg_lock_diffractometer_error_cb ()"

.PP
lock diffractometer query error callback 
.PP
Definition at line 1135 of file lspg\&.c\&.
.PP
.nf
                                         {
  pthread_mutex_lock( &lspg_lock_diffractometer\&.mutex);
  lspg_lock_diffractometer\&.query_error = 1;
  pthread_cond_signal( &lspg_lock_diffractometer\&.cond);
  pthread_mutex_unlock( &lspg_lock_diffractometer\&.mutex);
}
.fi
.SS "void lspg_lock_diffractometer_init ()"

.PP
initialize the diffractometer locking object 
.PP
Definition at line 1117 of file lspg\&.c\&.
.PP
.nf
                                     {
  lspg_lock_diffractometer\&.new_value_ready = 0;
  lspg_lock_diffractometer\&.query_error     = 0;
  pthread_mutex_init( &(lspg_lock_diffractometer\&.mutex), NULL);
  pthread_cond_init(  &(lspg_lock_diffractometer\&.cond), NULL);
}
.fi
.SS "void lspg_lock_diffractometer_wait ()"

.PP
Wait for the diffractometer lock\&. 
.PP
Definition at line 1155 of file lspg\&.c\&.
.PP
.nf
                                     {
  pthread_mutex_lock( &(lspg_lock_diffractometer\&.mutex));
  while( lspg_lock_diffractometer\&.new_value_ready == 0 && lspg_lock_diffractometer\&.query_error == 0)
    pthread_cond_wait( &(lspg_lock_diffractometer\&.cond), &(lspg_lock_diffractometer\&.mutex));
}
.fi
.SS "void lspg_next_state ()"

.PP
Implements our state machine Does not strictly only set the next state as it also calls some functions that, perhaps, alters the state mid-function\&. 
.PP
Definition at line 1917 of file lspg\&.c\&.
.PP
.nf
                       {
  //
  // connect to the database
  //
  if( q == NULL ||
      ls_pg_state == LS_PG_STATE_INIT ||
      ls_pg_state == LS_PG_STATE_RESET ||
      ls_pg_state == LS_PG_STATE_INIT_POLL ||
      ls_pg_state == LS_PG_STATE_RESET_POLL)
    lspg_pg_connect( lspgfd);


  if( ls_pg_state == LS_PG_STATE_IDLE && lspg_query_queue_on != lspg_query_queue_off)
    ls_pg_state = LS_PG_STATE_SEND;

  switch( ls_pg_state) {
  case LS_PG_STATE_INIT_POLL:
    if( lspg_connectPoll_response == PGRES_POLLING_WRITING)
      lspgfd\&.events = POLLOUT;
    else if( lspg_connectPoll_response == PGRES_POLLING_READING)
      lspgfd\&.events = POLLIN;
    else
      lspgfd\&.events = 0;
    break;
      
  case LS_PG_STATE_RESET_POLL:
    if( lspg_resetPoll_response == PGRES_POLLING_WRITING)
      lspgfd\&.events = POLLOUT;
    else if( lspg_resetPoll_response == PGRES_POLLING_READING)
      lspgfd\&.events = POLLIN;
    else
      lspgfd\&.events = 0;
    break;

  case LS_PG_STATE_IDLE:
  case LS_PG_STATE_RECV:
    lspgfd\&.events = POLLIN;
    break;

  case LS_PG_STATE_SEND:
  case LS_PG_STATE_SEND_FLUSH:
    lspgfd\&.events = POLLOUT;
    break;

  default:
    lspgfd\&.events = 0;
  }
}
.fi
.SS "void lspg_nextaction_cb (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"

.PP
Queue the next MD2 instruction\&. \fBParameters:\fP
.RS 4
\fIqqp\fP The query that generated this result 
.br
\fIpgr\fP The result 
.RE
.PP

.PP
Definition at line 1460 of file lspg\&.c\&.
.PP
.nf
                          {
  char *action;


  if( PQntuples( pgr) <= 0)
    return;             // Note: nextaction should always return at least 'noAction', so this branch should never be taken

  action = PQgetvalue( pgr, 0, 0);      // next action only returns one row

  if( strcmp( action, 'noAction') == 0)
    return;
  
  md2cmds_push_queue( action);

}
.fi
.SS "void lspg_nextaction_error_cb ()"

.PP
Definition at line 1479 of file lspg\&.c\&.
.PP
.nf
                                {
  lslogging_log_message( 'query error getting next md2 action');
}
.fi
.SS "void lspg_nexterrors_cb (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"

.PP
Definition at line 1483 of file lspg\&.c\&.
.PP
.nf
                                                                 {
  static int etid_col, etseverity_col, etterse_col, etverbose_col, etdetails_col;
  static int first_time=1;
  int i;
  char *terse, *verbose, *details, *severity, *id;
  
  if( first_time) {
    etid_col       = PQfnumber( pgr, 'etid');
    etseverity_col = PQfnumber( pgr, 'etseverity');
    etterse_col    = PQfnumber( pgr, 'etterse');
    etverbose_col  = PQfnumber( pgr, 'etverbose');
    etdetails_col  = PQfnumber( pgr, 'etdetails');
    first_time     = 0;
  }

  for( i=0; i<PQntuples( pgr); i++) {
    id       = PQgetvalue( pgr, i, etid_col);
    terse    = PQgetvalue( pgr, i, etterse_col);
    verbose  = PQgetvalue( pgr, i, etverbose_col);
    details  = PQgetvalue( pgr, i, etdetails_col);
    severity = PQgetvalue( pgr, i, etseverity_col);
    
    lspg_query_push( NULL, NULL, 'EXECUTE acknowledgeerror(%s)', id);

    lslogging_log_message( 'lspg_nexterrors_cb: %s %s\n', severity, strlen(verbose)>0 ? verbose : terse);
    if( strlen( details) > 0)
      lslogging_log_message( 'lspg_nexterrors_cb: %s\n', details);
  }
}
.fi
.SS "void lspg_nexterrors_error_cb ()"

.PP
Definition at line 1513 of file lspg\&.c\&.
.PP
.nf
                                {
  lslogging_log_message( 'query error retrieving next error message');
}
.fi
.SS "unsigned int lspg_nextsample_all (int *err)"

.PP
Definition at line 608 of file lspg\&.c\&.
.PP
.nf
                                            {
  unsigned int rtn;

  lspg_nextsample_call();
  lspg_nextsample_wait();

  if( lspg_nextsample\&.no_rows_returned || lspg_nextsample\&.query_error) {
    rtn = 0;
    *err = lspg_nextsample\&.query_error ? 2 : 1;
  } else {
    if( lspg_nextsample\&.nextsample_isnull) {
      rtn = 0;
      *err = 1;
    } else {
      rtn = lspg_nextsample\&.nextsample;
      *err = 0;
    }
  }
  lspg_nextsample_done();

  return rtn;
}
.fi
.SS "void lspg_nextsample_call ()"

.PP
Queue up a nextsample query\&. 
.PP
Definition at line 584 of file lspg\&.c\&.
.PP
.nf
                            {
  pthread_mutex_lock( &(lspg_nextsample\&.mutex));
  lspg_nextsample\&.new_value_ready = 0;
  lspg_nextsample\&.query_error     = 0;
  pthread_mutex_unlock( &(lspg_nextsample\&.mutex));
  
  lspg_query_push( lspg_nextsample_cb, lspg_nextsample_error_cb, 'SELECT nextsample FROM px\&.nextsample()');
}
.fi
.SS "void lspg_nextsample_cb (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"

.PP
Next Sample\&. \fBParameters:\fP
.RS 4
\fIqqp\fP Our nextsample query 
.br
\fIpgr\fP result of the query 
.RE
.PP

.PP
Definition at line 533 of file lspg\&.c\&.
.PP
.nf
                        {
  static int got_columns = 0;
  static int nextsample_col;
  pthread_mutex_lock( &(lspg_nextsample\&.mutex));

  lspg_nextsample\&.no_rows_returned = PQntuples( pgr) <= 0;
  if( lspg_nextsample\&.no_rows_returned) {
    lslogging_log_message( 'lspg_nextsample_cb: no rows returned\&.  This should never happen\&.');
    lspg_nextsample\&.new_value_ready = 1;
    pthread_cond_signal( &(lspg_nextsample\&.cond));
    pthread_mutex_unlock( &(lspg_nextsample\&.mutex));
    return;
  }

  if( got_columns == 0) {
    nextsample_col = PQfnumber( pgr, 'nextsample');
    got_columns = 1;
  }

  lspg_nextsample\&.nextsample_isnull = PQgetisnull( pgr, 0, nextsample_col);
  if( lspg_nextsample\&.nextsample_isnull == 0)
    lspg_nextsample\&.nextsample = strtol( PQgetvalue( pgr, 0, nextsample_col), NULL, 0);

  lspg_nextsample\&.new_value_ready = 1;
  pthread_cond_signal( &(lspg_nextsample\&.cond));
  pthread_mutex_unlock( &(lspg_nextsample\&.mutex));
}
.fi
.SS "void lspg_nextsample_done ()"

.PP
Called when the next shot query has been processed\&. 
.PP
Definition at line 603 of file lspg\&.c\&.
.PP
.nf
                            {
  pthread_mutex_unlock( &(lspg_nextsample\&.mutex));
}
.fi
.SS "void lspg_nextsample_error_cb ()"

.PP
Next Sample Query Error Callback\&. 
.PP
Definition at line 566 of file lspg\&.c\&.
.PP
.nf
                                {
  pthread_mutex_lock( &(lspg_nextsample\&.mutex));
  lspg_nextsample\&.query_error = 1;
  pthread_cond_signal( &(lspg_nextsample\&.cond));
  pthread_mutex_unlock( &(lspg_nextsample\&.mutex));
}
.fi
.SS "void lspg_nextsample_init ()"

.PP
Initialize the nextsample variable, mutex, and condition\&. 
.PP
Definition at line 576 of file lspg\&.c\&.
.PP
.nf
                            {
  memset( &lspg_nextsample, 0, sizeof( lspg_nextsample));
  pthread_mutex_init( &(lspg_nextsample\&.mutex), NULL);
  pthread_cond_init( &(lspg_nextsample\&.cond), NULL);
}
.fi
.SS "void lspg_nextsample_wait ()"

.PP
Wait for the nextsample query to get processed\&. 
.PP
Definition at line 595 of file lspg\&.c\&.
.PP
.nf
                            {
  pthread_mutex_lock( &(lspg_nextsample\&.mutex));
  while( lspg_nextsample\&.new_value_ready == 0 && lspg_nextsample\&.query_error == 0)
    pthread_cond_wait( &(lspg_nextsample\&.cond), &(lspg_nextsample\&.mutex));
}
.fi
.SS "void lspg_nextshot_call ()"

.PP
Queue up a nextshot query\&. 
.PP
Definition at line 1003 of file lspg\&.c\&.
.PP
.nf
                          {
  pthread_mutex_lock( &(lspg_nextshot\&.mutex));
  lspg_nextshot\&.new_value_ready = 0;
  lspg_nextshot\&.query_error     = 0;
  pthread_mutex_unlock( &(lspg_nextshot\&.mutex));
  
  lspg_query_push( lspg_nextshot_cb, lspg_nextshot_error_cb, 'SELECT * FROM px\&.nextshot2()');
}
.fi
.SS "void lspg_nextshot_cb (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"

.PP
Next Shot Callback\&. This is a long and tedious routine as there are a large number of variables returned\&. Suck it up\&. Return with the global object lspg_nextshot set\&. \fBParameters:\fP
.RS 4
\fIqqp\fP Our nextshot query 
.br
\fIpgr\fP result of the query 
.RE
.PP

.PP
Definition at line 739 of file lspg\&.c\&.
.PP
.nf
                        {
  static int got_col_nums=0;
  static int
    dsdir_c, dspid_c, dsowidth_c, dsoscaxis_c, dsexp_c, skey_c, sstart_c, sfn_c, dsphi_c,
    dsomega_c, dskappa_c, dsdist_c, dsnrg_c, dshpid_c, cx_c, cy_c, ax_c, ay_c, az_c,
    active_c, sindex_c, stype_c,
    dsowidth2_c, dsoscaxis2_c, dsexp2_c, sstart2_c, dsphi2_c, dsomega2_c, dskappa2_c, dsdist2_c, dsnrg2_c,
    cx2_c, cy2_c, ax2_c, ay2_c, az2_c, active2_c, sindex2_c, stype2_c;
  
  pthread_mutex_lock( &(lspg_nextshot\&.mutex));

  lspg_nextshot\&.no_rows_returned = PQntuples( pgr) <= 0;
  if( lspg_nextshot\&.no_rows_returned) {
    lspg_nextshot\&.new_value_ready = 1;
    pthread_cond_signal( &(lspg_nextshot\&.cond));
    pthread_mutex_unlock( &(lspg_nextshot\&.mutex));
    return;                     // I guess there was no shot after all
  }

  if( got_col_nums == 0) {
    dsdir_c      = PQfnumber( pgr, 'dsdir');
    dspid_c      = PQfnumber( pgr, 'dspid');
    dsowidth_c   = PQfnumber( pgr, 'dsowidth');
    dsoscaxis_c  = PQfnumber( pgr, 'dsoscaxis');
    dsexp_c      = PQfnumber( pgr, 'dsexp');
    skey_c       = PQfnumber( pgr, 'skey');
    sstart_c     = PQfnumber( pgr, 'sstart');
    sfn_c        = PQfnumber( pgr, 'sfn');
    dsphi_c      = PQfnumber( pgr, 'dsphi');
    dsomega_c    = PQfnumber( pgr, 'dsomega');
    dskappa_c    = PQfnumber( pgr, 'dskappa');
    dsdist_c     = PQfnumber( pgr, 'dsdist');
    dsnrg_c      = PQfnumber( pgr, 'dsnrg');
    dshpid_c     = PQfnumber( pgr, 'dshpid');
    cx_c         = PQfnumber( pgr, 'cx');
    cy_c         = PQfnumber( pgr, 'cy');
    ax_c         = PQfnumber( pgr, 'ax');
    ay_c         = PQfnumber( pgr, 'ay');
    az_c         = PQfnumber( pgr, 'az');
    active_c     = PQfnumber( pgr, 'active');
    sindex_c     = PQfnumber( pgr, 'sindex');
    stype_c      = PQfnumber( pgr, 'stype');
    dsowidth2_c  = PQfnumber( pgr, 'dsowidth2');
    dsoscaxis2_c = PQfnumber( pgr, 'dsoscaxis2');
    dsexp2_c     = PQfnumber( pgr, 'dsexp2');
    sstart2_c    = PQfnumber( pgr, 'sstart2');
    dsphi2_c     = PQfnumber( pgr, 'dsphi2');
    dsomega2_c   = PQfnumber( pgr, 'dsomega2');
    dskappa2_c   = PQfnumber( pgr, 'dskappa2');
    dsdist2_c    = PQfnumber( pgr, 'dsdist2');
    dsnrg2_c     = PQfnumber( pgr, 'dsnrg2');
    cx2_c        = PQfnumber( pgr, 'cx2');
    cy2_c        = PQfnumber( pgr, 'cy2');
    ax2_c        = PQfnumber( pgr, 'ax2');
    ay2_c        = PQfnumber( pgr, 'ay2');
    az2_c        = PQfnumber( pgr, 'az2');
    active2_c    = PQfnumber( pgr, 'active2');
    sindex2_c    = PQfnumber( pgr, 'sindex2');
    stype2_c     = PQfnumber( pgr, 'stype2');
    
    got_col_nums = 1;
  }


  //
  // NULL string values come back as empty strings
  // Mark the null flag but allocate the empty string anyway
  //

  lspg_nextshot\&.dsdir_isnull = PQgetisnull( pgr, 0, dsdir_c);
  if( lspg_nextshot\&.dsdir != NULL)
    free( lspg_nextshot\&.dsdir);
  lspg_nextshot\&.dsdir = strdup( PQgetvalue( pgr, 0, dsdir_c));

  lspg_nextshot\&.dspid_isnull = PQgetisnull( pgr, 0, dspid_c);
  if( lspg_nextshot\&.dspid != NULL)
    free( lspg_nextshot\&.dspid);
  lspg_nextshot\&.dspid = strdup( PQgetvalue( pgr, 0, dspid_c));

  lspg_nextshot\&.dsoscaxis_isnull = PQgetisnull( pgr, 0, dsoscaxis_c);
  if( lspg_nextshot\&.dsoscaxis != NULL)
    free( lspg_nextshot\&.dsoscaxis);
  lspg_nextshot\&.dsoscaxis = strdup( PQgetvalue( pgr, 0, dsoscaxis_c));

  lspg_nextshot\&.dsoscaxis2_isnull = PQgetisnull( pgr, 0, dsoscaxis2_c);
  if( lspg_nextshot\&.dsoscaxis2 != NULL)
    free( lspg_nextshot\&.dsoscaxis2);
  lspg_nextshot\&.dsoscaxis2 = strdup( PQgetvalue( pgr, 0, dsoscaxis2_c));

  lspg_nextshot\&.sfn_isnull = PQgetisnull(pgr, 0, sfn_c);
  if( lspg_nextshot\&.sfn != NULL)
    free( lspg_nextshot\&.sfn);
  lspg_nextshot\&.sfn = strdup( PQgetvalue( pgr, 0, sfn_c));

  lspg_nextshot\&.stype_isnull = PQgetisnull( pgr, 0, stype_c);
  if( lspg_nextshot\&.stype != NULL)
    free( lspg_nextshot\&.stype);
  lspg_nextshot\&.stype = strdup( PQgetvalue( pgr, 0, stype_c));

  lspg_nextshot\&.stype2_isnull = PQgetisnull( pgr, 0, stype2_c);
  if( lspg_nextshot\&.stype2 != NULL)
    free( lspg_nextshot\&.stype2);
  lspg_nextshot\&.stype2 = strdup( PQgetvalue( pgr, 0, stype2_c));

  //
  // Probably shouldn't try to convert null number values
  //
  lspg_nextshot\&.dsowidth_isnull = PQgetisnull( pgr, 0, dsowidth_c);
  if( lspg_nextshot\&.dsowidth_isnull == 0)
    lspg_nextshot\&.dsowidth = atof( PQgetvalue( pgr,0, dsowidth_c));

  lspg_nextshot\&.dsexp_isnull = PQgetisnull( pgr, 0, dsexp_c);
  if( lspg_nextshot\&.dsexp_isnull == 0)
    lspg_nextshot\&.dsexp    = atof( PQgetvalue( pgr,0, dsexp_c));

  lspg_nextshot\&.sstart_isnull = PQgetisnull( pgr, 0, sstart_c);
  if( lspg_nextshot\&.sstart_isnull == 0)
    lspg_nextshot\&.sstart   = atof( PQgetvalue( pgr,0, sstart_c));

  lspg_nextshot\&.dsphi_isnull = PQgetisnull( pgr, 0, dsphi_c);
  if( lspg_nextshot\&.dsphi_isnull == 0)
    lspg_nextshot\&.dsphi    = atof( PQgetvalue( pgr,0, dsphi_c));

  lspg_nextshot\&.dsomega_isnull = PQgetisnull( pgr, 0, dsomega_c);
  if( lspg_nextshot\&.dsomega_isnull == 0)
    lspg_nextshot\&.dsomega  = atof( PQgetvalue( pgr,0, dsomega_c));

  lspg_nextshot\&.dskappa_isnull = PQgetisnull( pgr, 0, dskappa_c);
  if( lspg_nextshot\&.dskappa_isnull == 0)
    lspg_nextshot\&.dskappa  = atof( PQgetvalue( pgr,0, dskappa_c));

  lspg_nextshot\&.dsdist_isnull = PQgetisnull( pgr, 0, dsdist_c);
  if( lspg_nextshot\&.dsdist_isnull == 0)
    lspg_nextshot\&.dsdist   = atof( PQgetvalue( pgr,0, dsdist_c));

  lspg_nextshot\&.dsnrg_isnull = PQgetisnull( pgr, 0, dsnrg_c);
  if( lspg_nextshot\&.dsnrg_isnull == 0)
    lspg_nextshot\&.dsnrg    = atof( PQgetvalue( pgr,0, dsnrg_c));

  lspg_nextshot\&.cx_isnull = PQgetisnull( pgr, 0, cx_c);
  if( lspg_nextshot\&.cx_isnull == 0)
    lspg_nextshot\&.cx       = atof( PQgetvalue( pgr,0, cx_c));

  lspg_nextshot\&.cy_isnull = PQgetisnull( pgr, 0, cy_c);
  if( lspg_nextshot\&.cy_isnull == 0)
    lspg_nextshot\&.cy       = atof( PQgetvalue( pgr,0, cy_c));

  lspg_nextshot\&.ax_isnull = PQgetisnull( pgr, 0, ax_c);
  if( lspg_nextshot\&.ax_isnull == 0)
    lspg_nextshot\&.ax       = atof( PQgetvalue( pgr,0, ax_c));

  lspg_nextshot\&.ay_isnull = PQgetisnull( pgr, 0, ay_c);
  if( lspg_nextshot\&.ay_isnull == 0)
    lspg_nextshot\&.ay       = atof( PQgetvalue( pgr,0, ay_c));

  lspg_nextshot\&.az_isnull = PQgetisnull( pgr, 0, az_c);
  if( lspg_nextshot\&.az_isnull == 0)
    lspg_nextshot\&.az       = atof( PQgetvalue( pgr,0, az_c));
  
  lspg_nextshot\&.active_isnull = PQgetisnull( pgr, 0, active_c);
  if( lspg_nextshot\&.active_isnull == 0)
    lspg_nextshot\&.active = atoi( PQgetvalue( pgr, 0, active_c));

  lspg_nextshot\&.sindex_isnull = PQgetisnull( pgr, 0, sindex_c);
  if( lspg_nextshot\&.sindex_isnull == 0)
    lspg_nextshot\&.sindex = atoi( PQgetvalue( pgr, 0, sindex_c));

  lspg_nextshot\&.dshpid_isnull = PQgetisnull( pgr, 0, dshpid_c);
  if( lspg_nextshot\&.dshpid_isnull == 0)
    lspg_nextshot\&.dshpid = atoi( PQgetvalue( pgr, 0, dshpid_c));
  
  lspg_nextshot\&.skey_isnull = PQgetisnull( pgr, 0, skey_c);
  if( lspg_nextshot\&.skey_isnull == 0)
    lspg_nextshot\&.skey   = atoll( PQgetvalue( pgr, 0, skey_c));

  lspg_nextshot\&.dsowidth2_isnull = PQgetisnull( pgr, 0, dsowidth2_c);
  if( lspg_nextshot\&.dsowidth2_isnull == 0)
    lspg_nextshot\&.dsowidth2 = atof( PQgetvalue( pgr,0, dsowidth2_c));

  lspg_nextshot\&.dsexp2_isnull = PQgetisnull( pgr, 0, dsexp2_c);
  if( lspg_nextshot\&.dsexp2_isnull == 0)
    lspg_nextshot\&.dsexp2    = atof( PQgetvalue( pgr,0, dsexp2_c));

  lspg_nextshot\&.sstart2_isnull = PQgetisnull( pgr, 0, sstart2_c);
  if( lspg_nextshot\&.sstart2_isnull == 0)
    lspg_nextshot\&.sstart2   = atof( PQgetvalue( pgr,0, sstart2_c));

  lspg_nextshot\&.dsphi2_isnull = PQgetisnull( pgr, 0, dsphi2_c);
  if( lspg_nextshot\&.dsphi2_isnull == 0)
    lspg_nextshot\&.dsphi2    = atof( PQgetvalue( pgr,0, dsphi2_c));

  lspg_nextshot\&.dsomega2_isnull = PQgetisnull( pgr, 0, dsomega2_c);
  if( lspg_nextshot\&.dsomega2_isnull == 0)
    lspg_nextshot\&.dsomega2  = atof( PQgetvalue( pgr,0, dsomega2_c));

  lspg_nextshot\&.dskappa2_isnull = PQgetisnull( pgr, 0, dskappa2_c);
  if( lspg_nextshot\&.dskappa2_isnull == 0)
    lspg_nextshot\&.dskappa2  = atof( PQgetvalue( pgr,0, dskappa2_c));

  lspg_nextshot\&.dsdist2_isnull = PQgetisnull( pgr, 0, dsdist2_c);
  if( lspg_nextshot\&.dsdist2_isnull == 0)
    lspg_nextshot\&.dsdist2   = atof( PQgetvalue( pgr,0, dsdist2_c));

  lspg_nextshot\&.dsnrg2_isnull = PQgetisnull( pgr, 0, dsnrg2_c);
  if( lspg_nextshot\&.dsnrg2_isnull == 0)
    lspg_nextshot\&.dsnrg2    = atof( PQgetvalue( pgr,0, dsnrg2_c));

  lspg_nextshot\&.cx2_isnull = PQgetisnull( pgr, 0, cx2_c);
  if( lspg_nextshot\&.cx2_isnull == 0)
    lspg_nextshot\&.cx2       = atof( PQgetvalue( pgr,0, cx2_c));

  lspg_nextshot\&.cy2_isnull = PQgetisnull( pgr, 0, cy2_c);
  if( lspg_nextshot\&.cy2_isnull == 0)
    lspg_nextshot\&.cy2       = atof( PQgetvalue( pgr,0, cy2_c));

  lspg_nextshot\&.ax2_isnull = PQgetisnull( pgr, 0, ax2_c);
  if( lspg_nextshot\&.ax2_isnull == 0)
    lspg_nextshot\&.ax2       = atof( PQgetvalue( pgr,0, ax2_c));

  lspg_nextshot\&.ay2_isnull = PQgetisnull( pgr, 0, ay2_c);
  if( lspg_nextshot\&.ay2_isnull == 0)
    lspg_nextshot\&.ay2       = atof( PQgetvalue( pgr,0, ay2_c));

  lspg_nextshot\&.az2_isnull = PQgetisnull( pgr, 0, az2_c);
  if( lspg_nextshot\&.az2_isnull == 0)
    lspg_nextshot\&.az2       = atof( PQgetvalue( pgr,0, az2_c));
  
  lspg_nextshot\&.active2_isnull = PQgetisnull( pgr, 0, active2_c);
  if( lspg_nextshot\&.active2_isnull == 0)
    lspg_nextshot\&.active2 = atoi( PQgetvalue( pgr, 0, active2_c));

  lspg_nextshot\&.sindex2_isnull = PQgetisnull( pgr, 0, sindex2_c);
  if( lspg_nextshot\&.sindex2_isnull == 0)
    lspg_nextshot\&.sindex2 = atoi( PQgetvalue( pgr, 0, sindex2_c));

  lspg_nextshot\&.new_value_ready = 1;

  pthread_cond_signal( &(lspg_nextshot\&.cond));
  pthread_mutex_unlock( &(lspg_nextshot\&.mutex));

}
.fi
.SS "void lspg_nextshot_done ()"

.PP
Called when the next shot query has been processed\&. 
.PP
Definition at line 1022 of file lspg\&.c\&.
.PP
.nf
                          {
  pthread_mutex_unlock( &(lspg_nextshot\&.mutex));
}
.fi
.SS "void lspg_nextshot_error_cb ()"

.PP
next shot query error callback 
.PP
Definition at line 986 of file lspg\&.c\&.
.PP
.nf
                              {
  pthread_mutex_lock( &lspg_nextshot\&.mutex);
  lspg_nextshot\&.query_error = 1;
  pthread_cond_signal( &lspg_nextshot\&.cond);
  pthread_mutex_unlock( &lspg_nextshot\&.mutex);
}
.fi
.SS "void lspg_nextshot_init ()"

.PP
Initialize the nextshot variable, mutex, and condition\&. 
.PP
Definition at line 995 of file lspg\&.c\&.
.PP
.nf
                          {
  memset( &lspg_nextshot, 0, sizeof( lspg_nextshot));
  pthread_mutex_init( &(lspg_nextshot\&.mutex), NULL);
  pthread_cond_init( &(lspg_nextshot\&.cond), NULL);
}
.fi
.SS "void lspg_nextshot_wait ()"

.PP
Wait for the next shot query to get processed\&. 
.PP
Definition at line 1014 of file lspg\&.c\&.
.PP
.nf
                          {
  pthread_mutex_lock( &(lspg_nextshot\&.mutex));
  while( lspg_nextshot\&.new_value_ready == 0 && lspg_nextshot\&.query_error == 0)
    pthread_cond_wait( &(lspg_nextshot\&.cond), &(lspg_nextshot\&.mutex));
}
.fi
.SS "PQnoticeProcessor lspg_notice_processor (void *arg, const char *msg)"

.PP
Definition at line 1821 of file lspg\&.c\&.
.PP
.nf
                                                                     {
  lslogging_log_message( 'lspg: %s', msg);
  return NULL;
}
.fi
.SS "void lspg_pg_connect ()"

.PP
Connect to the pg server\&. 
.PP
Definition at line 1828 of file lspg\&.c\&.
.PP
.nf
                       {
  int err;

  if( q == NULL)
    ls_pg_state = LS_PG_STATE_INIT;

  switch( ls_pg_state) {
  case LS_PG_STATE_INIT:

    if( lspg_time_sent\&.tv_sec != 0) {
      //
      // Reality check: if it's less the about 10 seconds since the last failed attempt
      // the just chill\&.
      //
      gettimeofday( &now, NULL);
      if( now\&.tv_sec - lspg_time_sent\&.tv_sec < 10) {
        return;
      }
    }

    q = PQconnectStart( 'dbname=ls user=lsuser hostaddr=10\&.1\&.0\&.3');
    if( q == NULL) {
      lslogging_log_message( 'Out of memory (lspg_pg_connect)');
      exit( -1);
    }

    err = PQstatus( q);
    if( err == CONNECTION_BAD) {
      lslogging_log_message( 'Trouble connecting to database');

      gettimeofday( &lspg_time_sent, NULL);
      return;
    }
    err = PQsetnonblocking( q, 1);
    if( err != 0) {
      lslogging_log_message( 'Odd, could not set database connection to nonblocking');
    }

    ls_pg_state = LS_PG_STATE_INIT_POLL;
    lspg_connectPoll_response = PGRES_POLLING_WRITING;
    //
    // set up the connection for poll
    //
    lspgfd\&.fd = PQsocket( q);
    break;

  case LS_PG_STATE_INIT_POLL:
    if( lspg_connectPoll_response == PGRES_POLLING_FAILED) {
      PQfinish( q);
      q = NULL;
      ls_pg_state = LS_PG_STATE_INIT;
    } else if( lspg_connectPoll_response == PGRES_POLLING_OK) {
      PQsetNoticeProcessor( q, (PQnoticeProcessor)lspg_notice_processor, NULL);
      lspg_query_push( NULL, NULL, 'select pmac\&.md2_init()');
      ls_pg_state = LS_PG_STATE_IDLE;
    }
    break;

  case LS_PG_STATE_RESET:
    err = PQresetStart( q);
    if( err == 0) {
      PQfinish( q);
      q = NULL;
      ls_pg_state = LS_PG_STATE_INIT;
    } else {
      ls_pg_state = LS_PG_STATE_RESET_POLL;
      lspg_resetPoll_response = PGRES_POLLING_WRITING;
    }
    break;

  case LS_PG_STATE_RESET_POLL:
    if( lspg_resetPoll_response == PGRES_POLLING_FAILED) {
      PQfinish( q);
      q = NULL;
      ls_pg_state = LS_PG_STATE_INIT;
    } else if( lspg_resetPoll_response == PGRES_POLLING_OK) {
      lspg_query_push( NULL, NULL, 'select pmac\&.md2_init()');
      ls_pg_state = LS_PG_STATE_IDLE;
    }
    break;
  }
}
.fi
.SS "void lspg_pg_service (struct pollfd *evt)"

.PP
I/O control to/from the postgresql server\&. \fBParameters:\fP
.RS 4
\fIevt\fP The pollfd object that we are responding to 
.RE
.PP

.PP
Definition at line 1716 of file lspg\&.c\&.
.PP
.nf
                       {
  //
  // Currently just used to check for notifies
  // Other socket communication is done syncronously
  //

  if( evt->revents & POLLIN) {
    int err;

    if( ls_pg_state == LS_PG_STATE_INIT_POLL) {
      lspg_connectPoll_response = PQconnectPoll( q);
      if( lspg_connectPoll_response == PGRES_POLLING_FAILED) {
        ls_pg_state = LS_PG_STATE_RESET;
      }
      return;
    }

    if( ls_pg_state == LS_PG_STATE_RESET_POLL) {
      lspg_resetPoll_response = PQresetPoll( q);
      if( lspg_resetPoll_response == PGRES_POLLING_FAILED) {
        ls_pg_state = LS_PG_STATE_RESET;
      }
      return;
    }


    //
    // if in IDLE or RECV we need to call consumeInput first
    //
    if( ls_pg_state == LS_PG_STATE_IDLE) {
      err = PQconsumeInput( q);
      if( err != 1) {
        lslogging_log_message( 'consume input failed: %s', PQerrorMessage( q));
        ls_pg_state = LS_PG_STATE_RESET;
        return;
      }
    }      

    if( ls_pg_state == LS_PG_STATE_RECV) {
      lspg_receive();
    }

    //
    // Check for notifies regardless of our state
    // Push as many requests as we have notifies\&.
    //
    {
      PGnotify *pgn;

      while( 1) {
        pgn = PQnotifies( q);
        if( pgn == NULL)
          break;

        lslogging_log_message( 'lspg_pg_service: notify recieved %s', pgn->relname);
        
        if( strstr( pgn->relname, '_pmac') != NULL) {
          lspg_query_push( lspg_cmd_cb, lspg_cmd_error_cb, 'EXECUTE md2_queue_next');
        } else if( strstr( pgn->relname, '_diff') != NULL || strstr( pgn->relname, '_run') != NULL) {
          lspg_query_push( lspg_nextaction_cb, lspg_nextaction_error_cb, 'EXECUTE nextaction');
        } else if( strstr( pgn->relname, '_sample') != NULL) {
          lspg_getcurrentsampleid_call();
        } else if( strstr( pgn->relname, '_kvs') != NULL) {
          lspg_query_push( lspg_allkvs_cb, lspg_allkvs_error_cb, 'EXECUTE getkvs');
        } else if( strstr( pgn->relname, '_mess') != NULL) {
          lspg_query_push( lspg_nexterrors_cb, lspg_nexterrors_error_cb, 'EXECUTE nexterrors');
        } else if( strstr( pgn->relname, '_pause') != NULL) {
          
        }
        PQfreemem( pgn);
      }
    }
  }

  if( evt->revents & POLLOUT) {

    if( ls_pg_state == LS_PG_STATE_INIT_POLL) {
      lspg_connectPoll_response = PQconnectPoll( q);
      if( lspg_connectPoll_response == PGRES_POLLING_FAILED) {
        ls_pg_state = LS_PG_STATE_RESET;
      }
      return;
    }

    if( ls_pg_state == LS_PG_STATE_RESET_POLL) {
      lspg_resetPoll_response = PQresetPoll( q);
      if( lspg_resetPoll_response == PGRES_POLLING_FAILED) {
        ls_pg_state = LS_PG_STATE_RESET;
      }
      return;
    }


    if( ls_pg_state == LS_PG_STATE_SEND) {
      lspg_send_next_query();
    }

    if( ls_pg_state == LS_PG_STATE_SEND_FLUSH) {
      lspg_flush();
    }
  }
}
.fi
.SS "void lspg_preset_changed_cb (char *event)"

.PP
Definition at line 2039 of file lspg\&.c\&.
.PP
.nf
                                          {
  static char base[] = 'Preset Changed ';
  char *pn;
  lsredis_obj_t *p;
  char *v;

  pn = strstr( event, base);
  if( pn == NULL) {
    lslogging_log_message( 'lspg_preset_changed_cb: Could not parse '%s'', event);
    return;
  }
  pn += strlen( base);
  
  p = lsredis_get_obj( '%s', pn);
  if( p == NULL) {
    lslogging_log_message( 'lspg_preset_changed_cb: Could not find variable '%s'', pn);
    return;
  }
  v = lsredis_getstr( p);
  if( v == NULL || v[0] == 0) {
    lslogging_log_message( 'lspg_preset_chanted_cb: Value for preset %s is %s', pn, v==NULL ? 'NULL' : 'Empty');
    return;
  }
  lspg_query_push( NULL, NULL, 'EXECUTE kvupdate('{%s,%s}'::text[])', pn, v);
}
.fi
.SS "\fBlspg_query_queue_t\fP* lspg_query_next ()"

.PP
Return the next item in the postgresql queue\&. If there is an item left in the queue then it is returned\&. Otherwise, NULL is returned\&. 
.PP
Definition at line 77 of file lspg\&.c\&.
.PP
.nf
                                      {
  lspg_query_queue_t *rtn;
  
  pthread_mutex_lock( &lspg_queue_mutex);

  if( lspg_query_queue_off == lspg_query_queue_on)
    // Queue is empty
    rtn = NULL;
  else {
    rtn = &(lspg_query_queue[(lspg_query_queue_off++) % LS_PG_QUERY_QUEUE_LENGTH]); 
    pthread_cond_signal( &lspg_queue_cond);
  }
  pthread_mutex_unlock( &lspg_queue_mutex);

  return rtn;
}
.fi
.SS "void lspg_query_push (void(*)(\fBlspg_query_queue_t\fP *, PGresult *)cb, void(*)()er, char *fmt, \&.\&.\&.)"

.PP
Place a query on the queue\&. \fBParameters:\fP
.RS 4
\fIcb\fP Our callback function that deals with the response 
.br
\fIer\fP error response 
.br
\fIfmt\fP Printf style function to generate the query 
.RE
.PP

.PP
Definition at line 130 of file lspg\&.c\&.
.PP
.nf
                       {
  int idx;
  va_list arg_ptr;

  pthread_mutex_lock( &lspg_queue_mutex);

  //
  // Pause the thread while we service the queue
  //
  while( (lspg_query_queue_on + 1) % LS_PG_QUERY_QUEUE_LENGTH == lspg_query_queue_off % LS_PG_QUERY_QUEUE_LENGTH) {
    pthread_cond_wait( &lspg_queue_cond, &lspg_queue_mutex);
  }

  idx = lspg_query_queue_on % LS_PG_QUERY_QUEUE_LENGTH;

  va_start( arg_ptr, fmt);
  vsnprintf( lspg_query_queue[idx]\&.qs, LS_PG_QUERY_STRING_LENGTH-1, fmt, arg_ptr);
  va_end( arg_ptr);

  lspg_query_queue[idx]\&.qs[LS_PG_QUERY_STRING_LENGTH - 1] = 0;
  lspg_query_queue[idx]\&.onResponse = cb;
  lspg_query_queue[idx]\&.onError    = er;
  lspg_query_queue_on++;

  pthread_kill( lspg_thread, SIGUSR1);
  pthread_mutex_unlock( &lspg_queue_mutex);
};
.fi
.SS "void lspg_query_reply_next ()"

.PP
Remove the oldest item in the queue\&. this is called only when there is nothing else to service the reply: this pop does not return anything\&. We use the \&.\&.\&.reply_peek function to return the next item in the reply queue 
.PP
Definition at line 101 of file lspg\&.c\&.
.PP
.nf
                             {

  pthread_mutex_lock( &lspg_queue_mutex);

  if( lspg_query_queue_reply != lspg_query_queue_on)
    lspg_query_queue_reply++;

  pthread_mutex_unlock( &lspg_queue_mutex);
}
.fi
.SS "\fBlspg_query_queue_t\fP* lspg_query_reply_peek ()"

.PP
Return the next item in the reply queue but don't pop it since we may need it more than once\&. Call \fBlspg_query_reply_next()\fP when done\&. 
.PP
Definition at line 114 of file lspg\&.c\&.
.PP
.nf
                                            {
  lspg_query_queue_t *rtn;

  pthread_mutex_lock( &lspg_queue_mutex);

  if( lspg_query_queue_reply == lspg_query_queue_on)
    rtn = NULL;
  else
    rtn = &(lspg_query_queue[(lspg_query_queue_reply) % LS_PG_QUERY_QUEUE_LENGTH]);

  pthread_mutex_unlock( &lspg_queue_mutex);
  return rtn;
}
.fi
.SS "void lspg_quit_query_cb (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"

.PP
call back to handle signing out of the database 
.PP
Definition at line 2148 of file lspg\&.c\&.
.PP
.nf
                                                                 {
  ls_pg_state = LS_PG_STATE_QUITTING;
  PQfinish( q);
  lspg_running = 0;
}
.fi
.SS "void lspg_quitting_cb (char *event)"

.PP
Prepare to exit the program in a couple of seconds\&. 
.PP
Definition at line 2156 of file lspg\&.c\&.
.PP
.nf
                                    {
  lspg_query_push( lspg_quit_query_cb, lspg_quit_query_cb, 'SELECT px\&.dropairrights()');

}
.fi
.SS "void lspg_receive ()"

.PP
Receive a result of a query\&. 
.PP
Definition at line 1631 of file lspg\&.c\&.
.PP
.nf
                    {
  PGresult *pgr;
  lspg_query_queue_t *qqp;
  int err;

  err = PQconsumeInput( q);
  if( err != 1) {
    lslogging_log_message( 'consume input failed: %s', PQerrorMessage( q));
    ls_pg_state = LS_PG_STATE_RESET;
    return;
  }

  //
  // We must call PQgetResult until it returns NULL before sending the next query
  // This implies that only one query can ever be active at a time and our queue
  // management should be simple
  //
  // We should be in the LS_PG_STATE_RECV here
  //

  while( !PQisBusy( q)) {
    pgr = PQgetResult( q);
    if( pgr == NULL) {
      lspg_query_reply_next();
      //
      // we are now done reading the response from the database
      //
      ls_pg_state = LS_PG_STATE_IDLE;
      break;
    } else {
      ExecStatusType es;

      qqp = lspg_query_reply_peek();
      es = PQresultStatus( pgr);

      if( es != PGRES_COMMAND_OK && es != PGRES_TUPLES_OK) {
        char *emess;
        emess = PQresultErrorMessage( pgr);
        if( emess != NULL && emess[0] != 0) {
          lslogging_log_message( 'Error from query '%s':\n%s', qqp->qs, emess);
        }
        if( qqp != NULL && qqp->onError != NULL)
          qqp->onError();
      } else {
        //
        // Deal with the response
        //
        // If the response is likely to take awhile we should probably
        // add a new state and put something in the main look to run the onResponse
        // routine in the main loop\&.  For now, though, we only expect very brief onResponse routines
        //
        if( qqp != NULL && qqp->onResponse != NULL)
          qqp->onResponse( qqp, pgr);
      }
      PQclear( pgr);
    }
  }
}
.fi
.SS "pthread_t* lspg_run ()"

.PP
Start 'er runnin'\&. 
.PP
Definition at line 2182 of file lspg\&.c\&.
.PP
.nf
                      {

  pthread_create( &lspg_thread, NULL, lspg_worker, NULL);
  lsevents_add_listener( '^(appy|appz|capy|capz|scint) In Position$', lspg_check_preset_in_position_cb);
  lsevents_add_listener( '^(appy|appz|capy|capz|scint) Moving$',      lspg_unset_current_preset_moving_cb);
  lsevents_add_listener( '^Preset Changed (\&.+)',                      lspg_preset_changed_cb);
  lsevents_add_listener( '^Sample(Detected|Absent)$',                 lspg_sample_detector_cb);
  lsevents_add_listener( '^Timer Update KVs$',                        lspg_update_kvs_cb);
  lsevents_add_listener( '^cam\&.zoom In Position$',                    lspg_set_scale_cb);
  lsevents_add_listener( '^Quitting Program$',                        lspg_quitting_cb);
  lstimer_set_timer(     'Timer Update KVs', -1, 0, 500000000);

  //
  // Make sure we own the airrights
  //
  lspg_demandairrights_all();

  return( &lspg_thread);
}
.fi
.SS "void lspg_sample_detector_cb (char *event)"

.PP
log magnet state 
.PP
Definition at line 2136 of file lspg\&.c\&.
.PP
.nf
                                           {
  int present;
  if( strcmp( event, 'SampleDetected') == 0)
    present = 1;
  else
    present = 0;

  lspg_query_push( NULL, NULL, 'SELECT px\&.logmagnetstate(%s)', present ? 'TRUE' : 'FALSE');
}
.fi
.SS "void lspg_send_next_query ()"

.PP
send the next queued query to the DB server 
.PP
Definition at line 1584 of file lspg\&.c\&.
.PP
.nf
                            {
  //
  // Normally we should be in the 'send' state
  // but we can also send if we are servicing
  // a reply
  //

  lspg_query_queue_t *qqp;
  int err;

  qqp = lspg_query_next();
  if( qqp == NULL) {
    //
    // A send without a query?  Should never happen\&.
    // But at least we shouldn't segfault if it does\&.
    //
    return;
  }

  if( qqp->qs[0] == 0) {
    //
    // Do we really have to check this case?
    // It would only come up if we stupidly pushed an empty query string
    // or ran off the end of the queue
    //
    lslogging_log_message( 'Popped empty query string\&.  Probably bad things are going on\&.');

    lspg_query_reply_next();
    ls_pg_state = LS_PG_STATE_IDLE;
  } else {
    err = PQsendQuery( q, qqp->qs);
    if( err == 0) {
      lslogging_log_message( 'query failed: %s\n', PQerrorMessage( q));

      //
      // Don't wait for a reply, just reset the connection
      //
      lspg_query_reply_next();
      ls_pg_state = LS_PG_STATE_RESET;
    } else {
      ls_pg_state = LS_PG_STATE_SEND_FLUSH;
    }
  }
}
.fi
.SS "int lspg_seq_run_prep_all (long longskey, doublekappa, doublephi, doublecx, doublecy, doubleax, doubleay, doubleaz)"

.PP
Convinence function to call seq run prep\&. \fBParameters:\fP
.RS 4
\fIskey\fP px\&.shots key for this image 
.br
\fIkappa\fP current kappa postion 
.br
\fIphi\fP current phi postition 
.br
\fIcx\fP current center table x 
.br
\fIcy\fP current center table y 
.br
\fIax\fP current alignment table x 
.br
\fIay\fP current alignment table y 
.br
\fIaz\fP current alignment table z 
.RE
.PP

.PP
Definition at line 1326 of file lspg\&.c\&.
.PP
.nf
                             {
  int rtn;
  lspg_seq_run_prep_call( skey, kappa, phi, cx, cy, ax, ay, az);
  lspg_seq_run_prep_wait();
  rtn = lspg_seq_run_prep\&.query_error;
  lspg_seq_run_prep_done();
  return rtn;
}
.fi
.SS "void lspg_seq_run_prep_call (long longskey, doublekappa, doublephi, doublecx, doublecy, doubleax, doubleay, doubleaz)"

.PP
queue up the seq_run_prep query \fBParameters:\fP
.RS 4
\fIskey\fP px\&.shots key for this image 
.br
\fIkappa\fP current kappa postion 
.br
\fIphi\fP current phi postition 
.br
\fIcx\fP current center table x 
.br
\fIcy\fP current center table y 
.br
\fIax\fP current alignment table x 
.br
\fIay\fP current alignment table y 
.br
\fIaz\fP current alignment table z 
.RE
.PP

.PP
Definition at line 1290 of file lspg\&.c\&.
.PP
.nf
                              {
  pthread_mutex_lock( &(lspg_seq_run_prep\&.mutex));
  lspg_seq_run_prep\&.new_value_ready = 0;
  lspg_seq_run_prep\&.query_error     = 0;
  pthread_mutex_unlock( &(lspg_seq_run_prep\&.mutex));

  lspg_query_push( lspg_seq_run_prep_cb, lspg_seq_run_prep_error_cb, 
                   'SELECT px\&.seq_run_prep( %lld, %\&.3f, %\&.3f, %\&.3f, %\&.3f, %\&.3f, %\&.3f, %\&.3f)',
                   skey, kappa, phi, cx, cy, ax, ay, az);
}
.fi
.SS "void lspg_seq_run_prep_cb (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"

.PP
Callback for the seq_run_prep query\&. \fBParameters:\fP
.RS 4
\fIqqp\fP The query item that generated this callback 
.br
\fIpgr\fP The result of the query 
.RE
.PP

.PP
Definition at line 1267 of file lspg\&.c\&.
.PP
.nf
                            {
  pthread_mutex_lock( &(lspg_seq_run_prep\&.mutex));
  lspg_seq_run_prep\&.new_value_ready = 1;
  pthread_cond_signal( &(lspg_seq_run_prep\&.cond));
  pthread_mutex_unlock( &(lspg_seq_run_prep\&.mutex));
}
.fi
.SS "void lspg_seq_run_prep_done ()"

.PP
Indicate we are done waiting\&. 
.PP
Definition at line 1320 of file lspg\&.c\&.
.PP
.nf
                              {
  pthread_mutex_unlock( &(lspg_seq_run_prep\&.mutex));
}
.fi
.SS "void lspg_seq_run_prep_error_cb ()"

.PP
Callback for seq_run error\&. 
.PP
Definition at line 1280 of file lspg\&.c\&.
.PP
.nf
                                  {
  pthread_mutex_lock( & (lspg_seq_run_prep\&.mutex));
  lspg_seq_run_prep\&.query_error = 1;
  pthread_cond_signal( &(lspg_seq_run_prep\&.cond));
  pthread_mutex_unlock( &(lspg_seq_run_prep\&.mutex));
}
.fi
.SS "void lspg_seq_run_prep_init ()"

.PP
Initialize the data collection object\&. 
.PP
Definition at line 1258 of file lspg\&.c\&.
.PP
.nf
                              {
  lspg_seq_run_prep\&.new_value_ready = 0;
  lspg_seq_run_prep\&.query_error     = 0;
  pthread_mutex_init( &(lspg_seq_run_prep\&.mutex), NULL);
  pthread_cond_init(  &(lspg_seq_run_prep\&.cond),  NULL);
}
.fi
.SS "void lspg_seq_run_prep_wait ()"

.PP
Wait for seq run prep query to return\&. 
.PP
Definition at line 1312 of file lspg\&.c\&.
.PP
.nf
                              {
  pthread_mutex_lock( &(lspg_seq_run_prep\&.mutex));
  while( lspg_seq_run_prep\&.new_value_ready == 0 && lspg_seq_run_prep\&.query_error == 0)
    pthread_cond_wait( &(lspg_seq_run_prep\&.cond), &(lspg_seq_run_prep\&.mutex));
}
.fi
.SS "void lspg_set_scale_cb (char *event)"

.PP
Fix up xscale and yscale when zoom changes\&. 
.PP
Definition at line 2109 of file lspg\&.c\&.
.PP
.nf
                                     {
  int mag;
  lsredis_obj_t *px, *py;
  char *sx, *sy;

  //
  // There is already a call back to set the redis variables xScale and yScale
  // we just need to set the KV's
  //

  mag = floor(( lspmac_getPosition( zoom) + 0\&.5));
  
  px  = lsredis_get_obj( 'cam\&.zoom\&.%d\&.ScaleX', mag);
  sx = lsredis_getstr( px);

  py  = lsredis_get_obj( 'cam\&.zoom\&.%d\&.ScaleY', mag);
  sy = lsredis_getstr( py);

  lspg_query_push( NULL, NULL, 'EXECUTE kvupdate( '{cam\&.xScale,%s,cam\&.yScale,%s}')', sx, sy);
  free( sx);
  free( sy);
}
.fi
.SS "void lspg_sig_service (struct pollfd *evt)"

.PP
Service a signal Signals here are treated as file descriptors and fits into our poll scheme\&. \fBParameters:\fP
.RS 4
\fIevt\fP The pollfd object that triggered this call 
.RE
.PP

.PP
Definition at line 1694 of file lspg\&.c\&.
.PP
.nf
                        {
  struct signalfd_siginfo fdsi;

  //
  // Really, we don't care about the signal,
  // it's just used to drop out of the poll
  // function when there is something for us
  // to do that didn't invovle something coming
  // from our postgresql server\&.
  //
  // This is accompished by the query_push function
  // to notify us that a new query is ready\&.
  //

  read( evt->fd, &fdsi, sizeof( struct signalfd_siginfo));

}
.fi
.SS "int lspg_starttransfer_all (int *err, unsigned intnextsample, intsampledetected, doubleax, doubleay, doubleaz, doublehorz, doublevert, doubleesttime)"

.PP
Definition at line 427 of file lspg\&.c\&.
.PP
.nf
                                                                                                                                                              {
  int rtn;

  lspg_starttransfer_call( nextsample, sampledetected, ax, ay, az, horz, vert, esttime);
  lspg_starttransfer_wait();
  if( lspg_starttransfer\&.no_rows_returned || lspg_starttransfer\&.starttransfer != 1) {
    *err = 1;
  } else {
    *err = 0;
    rtn = lspg_starttransfer\&.starttransfer;
  }
  lspg_starttransfer_done();

  return rtn;
}
.fi
.SS "void lspg_starttransfer_call (unsigned intnextsample, intsample_detected, doubleax, doubleay, doubleaz, doublehorz, doublevert, doubleesttime)"

.PP
Definition at line 405 of file lspg\&.c\&.
.PP
.nf
                                                                                                                                                       {
  pthread_mutex_lock( &(lspg_starttransfer\&.mutex));
  lspg_starttransfer\&.new_value_ready = 0;
  lspg_starttransfer\&.query_error     = 0;
  pthread_mutex_unlock( &(lspg_starttransfer\&.mutex));

  lspg_query_push( lspg_starttransfer_cb, lspg_starttransfer_error_cb,
                   'SELECT px\&.starttransfer( %d, %s, %\&.3f, %\&.3f, %\&.3f, %\&.3f, %\&.3f, %\&.3f)',
                   nextsample, sample_detected ? 'True' : 'False', ax, ay, az, horz, vert, esttime);
}
.fi
.SS "void lspg_starttransfer_cb (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"
\fBParameters:\fP
.RS 4
\fIqqp\fP Our nextsample query 
.br
\fIpgr\fP result of the query 
.RE
.PP

.PP
Definition at line 377 of file lspg\&.c\&.
.PP
.nf
                        {
  pthread_mutex_lock( &(lspg_starttransfer\&.mutex));

  lspg_starttransfer\&.new_value_ready = 1;
  if( PQntuples( pgr) <=0) {
    lspg_starttransfer\&.no_rows_returned = 1;
    lspg_starttransfer\&.starttransfer = 0;
  } else {
    lspg_starttransfer\&.no_rows_returned = 0;
    if( PQgetisnull( pgr, 0, 0) || strcmp( PQgetvalue( pgr,0,0), '1') != 0)
      lspg_starttransfer\&.starttransfer = 0;
    else
      lspg_starttransfer\&.starttransfer = 1;
  }
  pthread_cond_signal( &(lspg_starttransfer\&.cond));
  pthread_mutex_unlock( &(lspg_starttransfer\&.mutex));
}
.fi
.SS "void lspg_starttransfer_done ()"

.PP
Definition at line 422 of file lspg\&.c\&.
.PP
.nf
                               {
  pthread_mutex_unlock( &(lspg_starttransfer\&.mutex));
}
.fi
.SS "void lspg_starttransfer_error_cb ()"

.PP
Definition at line 398 of file lspg\&.c\&.
.PP
.nf
                                    {
  pthread_mutex_lock( &(lspg_starttransfer\&.mutex));
  lspg_starttransfer\&.query_error = 1;
  pthread_cond_signal( &(lspg_starttransfer\&.cond));
  pthread_mutex_unlock( &(lspg_starttransfer\&.mutex));
}
.fi
.SS "void lspg_starttransfer_init ()"

.PP
Definition at line 370 of file lspg\&.c\&.
.PP
.nf
                               {
  lspg_starttransfer\&.new_value_ready = 0;
  lspg_starttransfer\&.query_error     = 0;
  pthread_mutex_init( &lspg_starttransfer\&.mutex, NULL);
  pthread_cond_init( &lspg_starttransfer\&.cond, NULL);
}
.fi
.SS "void lspg_starttransfer_wait ()"

.PP
Definition at line 416 of file lspg\&.c\&.
.PP
.nf
                               {
  pthread_mutex_lock( &(lspg_starttransfer\&.mutex));
  while( lspg_starttransfer\&.new_value_ready == 0 && lspg_starttransfer\&.query_error == 0)
    pthread_cond_wait( &(lspg_starttransfer\&.cond), &(lspg_starttransfer\&.mutex));
}
.fi
.SS "void lspg_unset_current_preset_moving_cb (char *event)"

.PP
Definition at line 2086 of file lspg\&.c\&.
.PP
.nf
                                                       {
  lspmac_motor_t *mp;
  char cp[64];
  int i;

  for( i=0; i<strlen( event); i++) {
    cp[i] = 0;
    if( event[i] == ' ')
      break;
    cp[i] = event[i];
  }

  mp = lspmac_find_motor_by_name( cp);
  if( mp == NULL) {
    lslogging_log_message( 'lspg_unset_current_reset_moving_cb: Could not find motor '%s'', cp);
    return;
  }
  lspg_query_push( NULL, NULL, 'EXECUTE kvupdate( '{%s\&.currentPreset,-1}')', cp);
}
.fi
.SS "void lspg_update_kvs_cb (char *event)"

.PP
Perhaps update the px\&.kvs table in postgresql Should be triggered by a timer event\&. 
.PP
Definition at line 313 of file lspg\&.c\&.
.PP
.nf
                                      {
  static char s[LS_PG_QUERY_STRING_LENGTH - 64], *fmt;
  int i, need_comma, n;
  lspmac_motor_t *mp;
  int updateme;
  double new_value;

  s[0] = 0;
  need_comma = 0;

  for( i=0; i<lspmac_nmotors; i++ ) {
    mp = &(lspmac_motors[i]);
    pthread_mutex_lock( &mp->mutex);
    if( fabs(mp->reported_pg_position - mp->position) >= lsredis_getd(mp->update_resolution)) {
      new_value = mp->position;
      mp->reported_pg_position = mp->position;
      fmt = lsredis_getstr( mp->redis_fmt);     // borrow the redis format
      updateme = 1;
    } else {
      updateme = 0;
    }
    pthread_mutex_unlock( &mp->mutex);
    if( !updateme)
      continue;
    
    n = strlen( s);
    snprintf( &(s[n]), sizeof(s)-n-1, '%s%s\&.position,', need_comma++ ? ',' : '', mp->name);

    n = strlen( s);
    snprintf( &(s[n]), sizeof(s)-n-1, fmt, new_value);

    //
    // And again for the original remote interface
    // We'll be able to remove this, someday
    //
    n = strlen( s);
    snprintf( &(s[n]), sizeof(s)-n-1, ',%s,',  mp->name);

    n = strlen( s);
    snprintf( &(s[n]), sizeof(s)-n-1, fmt, new_value);
    free( fmt);

    n = strlen( s);
    if( n >= sizeof(s) - 64) {
      lspg_query_push( NULL, NULL, 'EXECUTE kvupdate('{%s}')', s);
      s[0] = 0;
      need_comma = 0;
    }
  }

  if( strlen(s)) {
    lspg_query_push( NULL, NULL, 'EXECUTE kvupdate('{%s}')', s);
  }
}
.fi
.SS "void lspg_wait_for_detector_all ()"

.PP
Combined call to wait for the detector\&. 
.PP
Definition at line 1097 of file lspg\&.c\&.
.PP
.nf
                                  {
  lspg_wait_for_detector_call();
  lspg_wait_for_detector_wait();
  lspg_wait_for_detector_done();
}
.fi
.SS "void lspg_wait_for_detector_call ()"

.PP
initiate the wait for detector query 
.PP
Definition at line 1070 of file lspg\&.c\&.
.PP
.nf
                                   {
  pthread_mutex_lock( &(lspg_wait_for_detector\&.mutex));
  lspg_wait_for_detector\&.new_value_ready = 0;
  lspg_wait_for_detector\&.query_error     = 0;
  pthread_mutex_unlock( &(lspg_wait_for_detector\&.mutex));
  
  lspg_query_push( lspg_wait_for_detector_cb, lspg_wait_for_detector_error_cb, 'SELECT px\&.lock_detector_test_block()');
}
.fi
.SS "void lspg_wait_for_detector_cb (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"

.PP
Callback for the wait for detector query\&. 
.PP
Definition at line 1052 of file lspg\&.c\&.
.PP
.nf
                                                                        {
  pthread_mutex_lock( &(lspg_wait_for_detector\&.mutex));
  lspg_wait_for_detector\&.new_value_ready = 1;
  pthread_cond_signal(  &(lspg_wait_for_detector\&.cond));
  pthread_mutex_unlock( &(lspg_wait_for_detector\&.mutex));
}
.fi
.SS "void lspg_wait_for_detector_done ()"

.PP
Done waiting for the detector\&. 
.PP
Definition at line 1090 of file lspg\&.c\&.
.PP
.nf
                                   {
  pthread_mutex_unlock( &(lspg_wait_for_detector\&.mutex));
}
.fi
.SS "void lspg_wait_for_detector_error_cb ()"

.PP
wait for detector query error callback 
.PP
Definition at line 1061 of file lspg\&.c\&.
.PP
.nf
                                       {
  pthread_mutex_lock( &lspg_wait_for_detector\&.mutex);
  lspg_wait_for_detector\&.query_error = 1;
  pthread_cond_signal( &lspg_wait_for_detector\&.cond);
  pthread_mutex_unlock( &lspg_wait_for_detector\&.mutex);
}
.fi
.SS "void lspg_wait_for_detector_init ()"

.PP
initialize the detector timing object 
.PP
Definition at line 1043 of file lspg\&.c\&.
.PP
.nf
                                   {
  lspg_wait_for_detector\&.new_value_ready = 0;
  lspg_wait_for_detector\&.query_error     = 0;
  pthread_mutex_init( &(lspg_wait_for_detector\&.mutex), NULL);
  pthread_cond_init(  &(lspg_wait_for_detector\&.cond), NULL);
}
.fi
.SS "void lspg_wait_for_detector_wait ()"

.PP
Pause the calling thread until the detector is ready Called by the MD2 thread\&. 
.PP
Definition at line 1082 of file lspg\&.c\&.
.PP
.nf
                                   {
  pthread_mutex_lock( &(lspg_wait_for_detector\&.mutex));
  while( lspg_wait_for_detector\&.new_value_ready == 0 && lspg_wait_for_detector\&.query_error == 0)
    pthread_cond_wait( &(lspg_wait_for_detector\&.cond), &(lspg_wait_for_detector\&.mutex));
}
.fi
.SS "int lspg_waitcryo_all ()"

.PP
no need to get fancy with the wait cryo command It should not return until the robot is almost ready for air rights 
.PP
Definition at line 655 of file lspg\&.c\&.
.PP
.nf
                        {
  int rtn;
  pthread_mutex_lock( &lspg_waitcryo\&.mutex);
  lspg_waitcryo\&.new_value_ready = 0;
  lspg_waitcryo\&.query_error     = 0;

  lspg_query_push( lspg_waitcryo_cb, lspg_waitcryo_error_cb, 'SELECT px\&.waitcryo()');

  while( lspg_waitcryo\&.new_value_ready == 0 && lspg_waitcryo\&.query_error == 0)
    pthread_cond_wait( &lspg_waitcryo\&.cond, &lspg_waitcryo\&.mutex);

  rtn = lspg_waitcryo\&.query_error;
  pthread_mutex_unlock( &lspg_waitcryo\&.mutex);

  return rtn;
}
.fi
.SS "void lspg_waitcryo_cb (\fBlspg_query_queue_t\fP *qqp, PGresult *pgr)"

.PP
Definition at line 638 of file lspg\&.c\&.
.PP
.nf
                                                               {
  pthread_mutex_lock( &lspg_waitcryo\&.mutex);
  lspg_waitcryo\&.new_value_ready = 1;
  pthread_cond_signal( &lspg_waitcryo\&.cond);
  pthread_mutex_unlock( &lspg_waitcryo\&.mutex);
}
.fi
.SS "void lspg_waitcryo_error_cb ()"

.PP
Definition at line 645 of file lspg\&.c\&.
.PP
.nf
                              {
  pthread_mutex_lock( &lspg_waitcryo\&.mutex);
  lspg_waitcryo\&.query_error = 1;
  pthread_cond_signal( &lspg_waitcryo\&.cond);
  pthread_mutex_unlock( &lspg_waitcryo\&.mutex);
}
.fi
.SS "void lspg_waitcryo_init ()"

.PP
Definition at line 631 of file lspg\&.c\&.
.PP
.nf
                          {
  lspg_waitcryo\&.new_value_ready = 0;
  lspg_waitcryo\&.query_error     = 0;
  pthread_mutex_init( &lspg_waitcryo\&.mutex, NULL);
  pthread_cond_init( &lspg_waitcryo\&.cond, NULL);
}
.fi
.SS "void* lspg_worker (void *dummy)"

.PP
The main loop for the lspg thread\&. \fBParameters:\fP
.RS 4
\fIdummy\fP Required by pthreads but unused 
.RE
.PP

.PP
Definition at line 1968 of file lspg\&.c\&.
.PP
.nf
                    {
  static struct pollfd fda[2];  // 0=signal handler, 1=pg socket
  static int nfda = 0;
  static sigset_t our_sigset;

  //
  // block ordinary signal mechanism
  //
  sigemptyset( &our_sigset);
  sigaddset( &our_sigset, SIGUSR1);
  pthread_sigmask(SIG_BLOCK, &our_sigset, NULL);

    
  fda[0]\&.fd = signalfd( -1, &our_sigset, SFD_NONBLOCK);
  if( fda[0]\&.fd == -1) {
    char *es;

    es = strerror( errno);
    lslogging_log_message( 'Signalfd trouble: %s', es);
  }
  fda[0]\&.events = POLLIN;

  //
  //  make sure file descriptor is not legal until it's been conneceted
  //
  lspgfd\&.fd   = -1;


  while( lspg_running) {
    int pollrtn;
    int poll_timeout_ms;

   lspg_next_state();

    if( lspgfd\&.fd == -1) {
      //
      // Here a connection to the database is not established\&.
      // Periodicaly try again\&.  Should possibly arrange to reconnect
      // to signalfd but that's unlikely to be nessesary\&.
      //
      nfda = 1;
      poll_timeout_ms = 10000;
      fda[1]\&.revents = 0;
    } else {
      //
      // Arrange to peacfully do nothing until either the pg server sends us something
      // or someone pushs something onto our queue
      //
      nfda = 2;
      fda[1]\&.fd      = lspgfd\&.fd;
      fda[1]\&.events  = lspgfd\&.events;
      fda[1]\&.revents = 0;
      poll_timeout_ms = -1;
    }

    pollrtn = poll( fda, nfda, poll_timeout_ms);

    if( pollrtn && fda[0]\&.revents) {
      lspg_sig_service( &(fda[0]));
      pollrtn--;
    } 
    if( pollrtn && fda[1]\&.revents) {
      lspg_pg_service( &(fda[1]));
      pollrtn--;
    } 
  }
  return NULL;
}
.fi
.SH "Variable Documentation"
.PP 
.SS "int ls_pg_state = \fBLS_PG_STATE_INIT\fP\fC [static]\fP"

.PP
State of the lspg state machine\&. 
.PP
Definition at line 40 of file lspg\&.c\&.
.SS "PostgresPollingStatusType lspg_connectPoll_response\fC [static]\fP"

.PP
Used to determine state while connecting\&. 
.PP
Definition at line 62 of file lspg\&.c\&.
.SS "\fBlspg_demandairrights_t\fP lspg_demandairrights"

.PP
our demandairrights object 
.PP
Definition at line 68 of file lspg\&.c\&.
.SS "\fBlspg_getcenter_t\fP lspg_getcenter"

.PP
the getcenter object 
.PP
Definition at line 67 of file lspg\&.c\&.
.SS "\fBlspg_getcurrentsampleid_t\fP lspg_getcurrentsampleid"

.PP
our currentsample id 
.PP
Definition at line 69 of file lspg\&.c\&.
.SS "\fBlspg_lock_detector_t\fP lspg_lock_detector\fC [static]\fP"

.PP
Definition at line 1184 of file lspg\&.c\&.
.SS "\fBlspg_lock_diffractometer_t\fP lspg_lock_diffractometer\fC [static]\fP"

.PP
Definition at line 1113 of file lspg\&.c\&.
.SS "\fBlspg_nextsample_t\fP lspg_nextsample"

.PP
the very next sample 
.PP
Definition at line 65 of file lspg\&.c\&.
.SS "\fBlspg_nextshot_t\fP lspg_nextshot"

.PP
the nextshot object 
.PP
Definition at line 66 of file lspg\&.c\&.
.SS "\fBlspg_query_queue_t\fP lspg_query_queue[\fBLS_PG_QUERY_QUEUE_LENGTH\fP]\fC [static]\fP"

.PP
Our query queue\&. 
.PP
Definition at line 53 of file lspg\&.c\&.
.SS "unsigned int lspg_query_queue_off = 0\fC [static]\fP"

.PP
The last item still being used (on == off means nothing in queue) 
.PP
Definition at line 55 of file lspg\&.c\&.
.SS "unsigned int lspg_query_queue_on = 0\fC [static]\fP"

.PP
Next position to add something to the queue\&. 
.PP
Definition at line 54 of file lspg\&.c\&.
.SS "unsigned int lspg_query_queue_reply = 0\fC [static]\fP"

.PP
The current item being digested\&. Normally off <= reply <= on\&. Corner case of queue wrap arround works because we only increment and compare for equality\&. 
.PP
Definition at line 56 of file lspg\&.c\&.
.SS "pthread_cond_t lspg_queue_cond\fC [static]\fP"

.PP
keeps the queue from overflowing 
.PP
Definition at line 45 of file lspg\&.c\&.
.SS "pthread_mutex_t lspg_queue_mutex\fC [static]\fP"

.PP
keep the queue from getting tangled 
.PP
Definition at line 44 of file lspg\&.c\&.
.SS "PostgresPollingStatusType lspg_resetPoll_response\fC [static]\fP"

.PP
Used to determine state while reconnecting\&. 
.PP
Definition at line 63 of file lspg\&.c\&.
.SS "int lspg_running = 1\fC [static]\fP"

.PP
flag to tell worker it's time to go home 
.PP
Definition at line 61 of file lspg\&.c\&.
.SS "\fBlspg_seq_run_prep_t\fP lspg_seq_run_prep\fC [static]\fP"

.PP
Definition at line 1254 of file lspg\&.c\&.
.SS "\fBlspg_starttransfer_t\fP lspg_starttransfer"

.PP
start a sample transfer 
.PP
Definition at line 70 of file lspg\&.c\&.
.SS "pthread_t lspg_thread\fC [static]\fP"

.PP
our worker thread 
.PP
Definition at line 43 of file lspg\&.c\&.
.SS "\fBlspg_wait_for_detector_t\fP lspg_wait_for_detector\fC [static]\fP"

.PP
Instance of the detector timing object\&. 
.PP
Definition at line 1039 of file lspg\&.c\&.
.SS "\fBlspg_waitcryo_t\fP lspg_waitcryo"

.PP
signal the robot 
.PP
Definition at line 71 of file lspg\&.c\&.
.SS "struct pollfd lspgfd\fC [static]\fP"

.PP
our poll info 
.PP
Definition at line 46 of file lspg\&.c\&.
.SS "struct timeval lspg_time_sent now\fC [static]\fP"

.PP
used to ensure we do not inundate the db server with connection requests 
.PP
Definition at line 41 of file lspg\&.c\&.
.SS "PGconn* q = NULL\fC [static]\fP"

.PP
Database connector\&. 
.PP
Definition at line 60 of file lspg\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for LS-CAT PGPMAC from the source code\&.
