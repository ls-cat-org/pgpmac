.TH "lsredis.c" 3 "Wed Jan 23 2013" "LS-CAT PGPMAC" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lsredis.c \- 
.PP
Support redis hash synchronization\&.  

.SH SYNOPSIS
.br
.PP
\fC#include 'pgpmac\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBlsredis_debugCB\fP (redisAsyncContext *ac, void *reply, void *privdata)"
.br
.RI "\fILog the reply\&. \fP"
.ti -1c
.RI "void \fB_lsredis_set_value\fP (\fBlsredis_obj_t\fP *p, char *v)"
.br
.RI "\fIset_value and setstr helper funciton p->mutex must be locked before calling \fP"
.ti -1c
.RI "void \fBlsredis_set_value\fP (\fBlsredis_obj_t\fP *p, char *fmt,\&.\&.\&.)"
.br
.RI "\fISet the value of a redis object and make it valid\&. \fP"
.ti -1c
.RI "int \fBlsredis_cmpstr\fP (\fBlsredis_obj_t\fP *p, char *s)"
.br
.ti -1c
.RI "int \fBlsredis_cmpnstr\fP (\fBlsredis_obj_t\fP *p, char *s, int n)"
.br
.ti -1c
.RI "int \fBlsredis_regexec\fP (const regex_t *preg, \fBlsredis_obj_t\fP *p, size_t nmatch, regmatch_t *pmatch, int eflags)"
.br
.ti -1c
.RI "char * \fBlsredis_getstr\fP (\fBlsredis_obj_t\fP *p)"
.br
.RI "\fIreturn a copy of the key's string value \fP"
.ti -1c
.RI "void \fBlsredis_setstr\fP (\fBlsredis_obj_t\fP *p, char *fmt,\&.\&.\&.)"
.br
.RI "\fISet the value and update redis\&. \fP"
.ti -1c
.RI "double \fBlsredis_getd\fP (\fBlsredis_obj_t\fP *p)"
.br
.ti -1c
.RI "long int \fBlsredis_getl\fP (\fBlsredis_obj_t\fP *p)"
.br
.ti -1c
.RI "char ** \fBlsredis_get_string_array\fP (\fBlsredis_obj_t\fP *p)"
.br
.ti -1c
.RI "int \fBlsredis_getb\fP (\fBlsredis_obj_t\fP *p)"
.br
.ti -1c
.RI "char \fBlsredis_getc\fP (\fBlsredis_obj_t\fP *p)"
.br
.ti -1c
.RI "void \fBlsredis_hgetCB\fP (redisAsyncContext *ac, void *reply, void *privdata)"
.br
.ti -1c
.RI "\fBlsredis_obj_t\fP * \fB_lsredis_get_obj\fP (char *key)"
.br
.RI "\fIMaybe add a new object Used internally for this module Must be called with lsredis_mutex locked\&. \fP"
.ti -1c
.RI "\fBlsredis_obj_t\fP * \fBlsredis_get_obj\fP (char *fmt,\&.\&.\&.)"
.br
.ti -1c
.RI "void \fBredisDisconnectCB\fP (const redisAsyncContext *ac, int status)"
.br
.RI "\fIcall back in case a redis server becomes disconnected TODO: reconnect \fP"
.ti -1c
.RI "void \fBlsredis_addRead\fP (void *data)"
.br
.RI "\fIhook to mange read events \fP"
.ti -1c
.RI "void \fBlsredis_delRead\fP (void *data)"
.br
.RI "\fIhook to manage 'don't need to read' events \fP"
.ti -1c
.RI "void \fBlsredis_addWrite\fP (void *data)"
.br
.RI "\fIhook to manage write events \fP"
.ti -1c
.RI "void \fBlsredis_delWrite\fP (void *data)"
.br
.RI "\fIhook to manage 'don't need to write anymore' events \fP"
.ti -1c
.RI "void \fBlsredis_cleanup\fP (void *data)"
.br
.RI "\fIhook to clean up TODO: figure out what we are supposed to do here and do it \fP"
.ti -1c
.RI "void \fBlsredis_subCB\fP (redisAsyncContext *ac, void *reply, void *privdata)"
.br
.RI "\fIUse the publication to request the new value\&. \fP"
.ti -1c
.RI "void \fBlsredis_maybe_add_key\fP (char *k)"
.br
.ti -1c
.RI "void \fBlsredis_keysCB\fP (redisAsyncContext *ac, void *reply, void *privdata)"
.br
.RI "\fISift through the keys to find ones we like\&. \fP"
.ti -1c
.RI "int \fBlsredis_find_preset\fP (char *base, char *preset_name, double *dval)"
.br
.ti -1c
.RI "void \fBlsredis_init\fP (char *pub, char *re, char *head)"
.br
.RI "\fIInitialize this module, that is, set up the connections\&. \fP"
.ti -1c
.RI "void \fBlsredis_fd_service\fP (struct pollfd *evt)"
.br
.RI "\fIservice the socket requests \fP"
.ti -1c
.RI "void \fBlsredis_sig_service\fP (struct pollfd *evt)"
.br
.ti -1c
.RI "void * \fBlsredis_worker\fP (void *dummy)"
.br
.RI "\fIsubscribe to changes and service sockets \fP"
.ti -1c
.RI "void \fBlsredis_run\fP ()"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static pthread_t \fBlsredis_thread\fP"
.br
.ti -1c
.RI "static pthread_mutex_t \fBlsredis_mutex\fP = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP"
.br
.ti -1c
.RI "static pthread_cond_t \fBlsredis_cond\fP"
.br
.ti -1c
.RI "static int \fBlsredis_running\fP = 0"
.br
.ti -1c
.RI "static \fBlsredis_obj_t\fP * \fBlsredis_objs\fP = NULL"
.br
.ti -1c
.RI "static struct hsearch_data \fBlsredis_htab\fP"
.br
.ti -1c
.RI "static redisAsyncContext * \fBsubac\fP"
.br
.ti -1c
.RI "static redisAsyncContext * \fBroac\fP"
.br
.ti -1c
.RI "static redisAsyncContext * \fBwrac\fP"
.br
.ti -1c
.RI "static char * \fBlsredis_publisher\fP = NULL"
.br
.ti -1c
.RI "static regex_t \fBlsredis_key_select_regex\fP"
.br
.ti -1c
.RI "static char * \fBlsredis_head\fP = NULL"
.br
.ti -1c
.RI "static struct pollfd \fBsubfd\fP"
.br
.ti -1c
.RI "static struct pollfd \fBrofd\fP"
.br
.ti -1c
.RI "static struct pollfd \fBwrfd\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Support redis hash synchronization\&. 

.PP
.nf
\date 2012
\author Keith Brister
\copyright All Rights Reserved
.fi
.PP
.PP
Redis support for redis in pgpmac\&.
.PP
Values in redis are assumed to be hashs with at list one field 'VALUE'\&. At startup the initialization routine is passed a regular expression to select which keys we'd like to duplicate locally as a lsredis_obj_t\&. It is assumed that the following construct in redis is used to change a value:
.PP
.PP
.nf

    MULTI
    HSET key VALUE value
    PUBLISH publisher key
    EXEC
.fi
.PP
.PP
Where 'publisher' is a unique name in the following format: 
.PP
.nf

         MD2-*
   or    UI-*
   or    REDIS_KV_CONNECTOR
.fi
.PP
 (this last value is used to support the now depreciated px\&.kvs table in the LS-CAT postgresql server)\&. We assume that all publisher that we are listening to ONLY publish key names that have changed\&.
.PP
When someone else changes a value we invalidate our internal copy and issue a 'HGET key VALUE' command\&. Other threads that request the value of our lsredis_obj_t will pause until the new value has been received and processed\&.
.PP
When a value changes locally this module changes it in redis as shown above\&. At this point we refuse other publishers attempt to change the value until we've seen all of our PUBLISH messages\&. That is, we ignore changes that in redis happened before our change\&.
.PP
You'll need an lsredis_obj_t to do anything with redis in the pgpmac project: 
.PP
.nf

   lsredis_obj_t *lsredis_get_obj( char *fmt, \&.\&.\&.)  where fmt is a printf style formatting string to interpret the rest of the arguments (if any)
                                                    During initialization a 'head' string is passed that is prepended to form the redis key\&.
                                                    For example, 'omega\&.position' might refer to the key 'stns\&.2\&.omega\&.position' at LS-CAT\&.
   
.fi
.PP
.PP
To set a redis value use 
.PP
.nf

    void lsredis_setstr( lsredis_obj_t *p, char *fmt, \&.\&.\&.)  where fmt is a printf style formatting string to interpret the rest of the arguments (if any)
   
.fi
.PP
.PP
When a new value is seen we immediately parse it and make it available through the following functions: 
.PP
.nf

.fi
.PP
.PP
.PP
.nf
     char    *lsredis_getstr( lsredis_obj_t *p)            Returns a copy of the VALUE field\&.  Use 'free' on the retured value when done using it\&.
.fi
.PP
.PP
.PP
.nf
     double   \fBlsredis_getd( lsredis_obj_t *p)\fP              Returns a double\&.  If the value was not a number it returns 0\&.
.fi
.PP
.PP
.PP
.nf
     long int \fBlsredis_getl( lsredis_obj_t *p)\fP              Returns a long int\&.  If the value was not a number it returns 0\&.
.fi
.PP
.PP
.PP
.nf
     char   **lsredis_get_string_array( lsredis_obj_t *p)  Returns an array of string pointers\&.  Value is assumed formated as a postgresql array, ie, {here,'I am','for example'}\&.
                                                  or NULL if the value could not be parsed
.fi
.PP
.PP
.PP
.nf
     int      \fBlsredis_getb( lsredis_obj_t *p)\fP              Returns 1, 0, or -1 based on the fist character of the string\&. 1 for T,t,Y,y, or 1, 0 for F,f,N,n or 0, -1 for anything else\&.
.fi
.PP
.PP
.PP
.nf
     char     \fBlsredis_getc( lsredis_obj_t *p)\fP              Returns the first character of VALUE
.fi
.PP
.PP
.PP
.nf
   
.fi
.PP
 
.PP
Definition in file \fBlsredis\&.c\fP\&.
.SH "Function Documentation"
.PP 
.SS "\fBlsredis_obj_t\fP* _lsredis_get_obj (char *key)"

.PP
Maybe add a new object Used internally for this module Must be called with lsredis_mutex locked\&. 
.PP
Definition at line 438 of file lsredis\&.c\&.
.PP
.nf
                                            {
  lsredis_obj_t *p;
  regmatch_t pmatch[2];
  int err;
  ENTRY htab_input, *htab_output;

  // Dispense with obviously bad keys straight away
  // unless p->valid == 0 in which case we call HGET first
  //
  // TODO: review logic: is there ever a time when valid is zero for a preexisting p and HGET has not been called?
  //       If not then we should just return p without checking for validity\&.
  //
  if( key == NULL || *key == 0 || strchr( key, ' ') != NULL) {
    lslogging_log_message( '_lsredis_get_obj: bad key '%s'', key == NULL ? '<NULL>' : key);
    return NULL;
  }

  // If the key is already there then just return it
  //

  htab_input\&.key  = key;
  htab_input\&.data = NULL;
  errno = 0;
  err = hsearch_r( htab_input, FIND, &htab_output, &lsredis_htab);

  if( err == 0)
    p = NULL;
  else
    p = htab_output->data;


  if( p != NULL) {
    return p;
  } else {
    // make a new one\&.
    p = calloc( 1, sizeof( lsredis_obj_t));
    if( p == NULL) {
      lslogging_log_message( '_lsredis_get_obj: Out of memory');
      exit( -1);
    }
    
    err = regexec( &lsredis_key_select_regex, key, 2, pmatch, 0);
    if( err == 0 && pmatch[1]\&.rm_so != -1) {
      p->events_name = strndup( key+pmatch[1]\&.rm_so, pmatch[1]\&.rm_eo - pmatch[1]\&.rm_so);
    } else {
      p->events_name = strdup( key);
    }
    if( p->events_name == NULL) {
      lslogging_log_message( '_lsredis_get_obj: Out of memory (events_name)');
      exit( -1);
    }

    pthread_mutex_init( &p->mutex, NULL);
    pthread_cond_init(  &p->cond, NULL);
    p->value = NULL;
    p->valid = 0;
    lsevents_send_event( '%s Invalid', p->events_name);
    p->wait_for_me = 0;
    p->key = strdup( key);
    p->hits = 0;
  
    htab_input\&.key  = p->key;
    htab_input\&.data = p;

    errno = 0;
    err = hsearch_r( htab_input, ENTER, &htab_output, &lsredis_htab);
    if( err == 0) {
      lslogging_log_message( '_lsredis_get_obj: hseach error on enter\&.  errno=%d', errno);
    }

    //
    // Shouldn't need the linked list unless we need to rebuild the hash table when, for example, we run out of room\&.
    // TODO: resize hash table when needed\&.
    //
    p->next = lsredis_objs;
    lsredis_objs = p;
  }
  //
  // We arrive here with the valid flag lowered\&.  Go ahead and request the latest value\&.
  //
  redisAsyncCommand( roac, lsredis_hgetCB, p, 'HGET %s VALUE', key);

  return p;
}
.fi
.SS "void _lsredis_set_value (\fBlsredis_obj_t\fP *p, char *v)"

.PP
set_value and setstr helper funciton p->mutex must be locked before calling 
.PP
Definition at line 146 of file lsredis\&.c\&.
.PP
.nf
                                                    {

  if( strlen(v) >= (unsigned int) p->value_length) {
    if( p->value != NULL)
      free( p->value);
    p->value_length = strlen(v) + 256;
    p->value = calloc( p->value_length, sizeof( char));
    if( p->value == NULL) {
      lslogging_log_message( '_lsredis_set_value: out of memory');
      exit( -1);
    }
  }
  strncpy( p->value, v, p->value_length - 1);
  p->value[p->value_length-1] = 0;
  p->dvalue = strtod( p->value, NULL);
  p->lvalue = p->dvalue;

  if( p->avalue != NULL) {
    int i;
    for( i=0; (p->avalue)[i] != NULL; i++)
      free( (p->avalue)[i]);
    free( p->avalue);
    p->avalue = NULL;
  }

  p->avalue = lspg_array2ptrs( p->value);

  switch( *(p->value)) {
      case 'T':
      case 't':
      case 'Y':
      case 'y':
      case '1':
        p->bvalue = 1;
      break;

      case 'F':
      case 'f':
      case 'N':
      case 'n':
      case '0':
        p->bvalue = 0;
      break;

      default:
        p->bvalue = -1;         // nil is -1 here in our world
    }

  p->cvalue = *(p->value);

  if( !(p->valid)) {
    p->valid = 1;
    lsevents_send_event( '%s Valid', p->events_name);
  }
}
.fi
.SS "void lsredis_addRead (void *data)"

.PP
hook to mange read events 
.PP
Definition at line 568 of file lsredis\&.c\&.
.PP
.nf
                                  {
  struct pollfd *pfd;
  pfd = (struct pollfd *)data;

  if( (pfd->events & POLLIN) == 0) {
    pfd->events |= POLLIN;
    pthread_kill( lsredis_thread, SIGUSR1);
  }
}
.fi
.SS "void lsredis_addWrite (void *data)"

.PP
hook to manage write events 
.PP
Definition at line 592 of file lsredis\&.c\&.
.PP
.nf
                                   {
  struct pollfd *pfd;
  pfd = (struct pollfd *)data;

  if( (pfd->events & POLLOUT) == 0) {
    pfd->events |= POLLOUT;
    pthread_kill( lsredis_thread, SIGUSR1);
  }
}
.fi
.SS "void lsredis_cleanup (void *data)"

.PP
hook to clean up TODO: figure out what we are supposed to do here and do it 
.PP
Definition at line 617 of file lsredis\&.c\&.
.PP
.nf
                                  {
  struct pollfd *pfd;
  pfd = (struct pollfd *)data;

  pfd->fd = -1;

  if( (pfd->events & (POLLOUT | POLLIN)) != 0) {
    pfd->events &= ~(POLLOUT | POLLIN);
    pthread_kill( lsredis_thread, SIGUSR1);
  }
}
.fi
.SS "int lsredis_cmpnstr (\fBlsredis_obj_t\fP *p, char *s, intn)"

.PP
Definition at line 236 of file lsredis\&.c\&.
.PP
.nf
                                                       {
  int rtn;
  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0)
    pthread_cond_wait( &p->cond, &p->mutex);
  
  rtn = strncmp( p->value, s, n);
  pthread_mutex_unlock( &p->mutex);
  return rtn;
}
.fi
.SS "int lsredis_cmpstr (\fBlsredis_obj_t\fP *p, char *s)"

.PP
Definition at line 225 of file lsredis\&.c\&.
.PP
.nf
                                               {
  int rtn;
  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0)
    pthread_cond_wait( &p->cond, &p->mutex);
  
  rtn = strcmp( p->value, s);
  pthread_mutex_unlock( &p->mutex);
  return rtn;
}
.fi
.SS "void lsredis_debugCB (redisAsyncContext *ac, void *reply, void *privdata)"

.PP
Log the reply\&. 
.PP
Definition at line 96 of file lsredis\&.c\&.
.PP
.nf
                                                                          {
  static int indentlevel = 0;
  redisReply *r;
  int i;

  r = (redisReply *)reply;

  if( r == NULL) {
    lslogging_log_message( 'Null reply\&.  Odd');
    return;
  }

  switch( r->type) {
  case REDIS_REPLY_STATUS:
    lslogging_log_message( '%*sSTATUS: %s', indentlevel*4,'', r->str);
    break;

  case REDIS_REPLY_ERROR:
    lslogging_log_message( '%*sERROR: %s', indentlevel*4, '', r->str);
    break;

  case REDIS_REPLY_INTEGER:
    lslogging_log_message( '%*sInteger: %lld', indentlevel*4, '', r->integer);
    break;

  case REDIS_REPLY_NIL:
    lslogging_log_message( '%*s(nil)', indentlevel*4, '');
    break;

  case REDIS_REPLY_STRING:
    lslogging_log_message( '%*sSTRING: %s', indentlevel*4, '', r->str);
    break;

  case REDIS_REPLY_ARRAY:
    lslogging_log_message( '%*sARRAY of %d elements', indentlevel*4, '', (int)r->elements);
    indentlevel++;
    for( i=0; i<(int)r->elements; i++)
      lsredis_debugCB( ac, r->element[i], NULL);
    indentlevel--;
    break;

  default:
    lslogging_log_message( '%*sUnknown type %d', indentlevel*4,'', r->type);

  }
}
.fi
.SS "void lsredis_delRead (void *data)"

.PP
hook to manage 'don't need to read' events 
.PP
Definition at line 580 of file lsredis\&.c\&.
.PP
.nf
                                  {
  struct pollfd *pfd;
  pfd = (struct pollfd *)data;

  if( (pfd->events & POLLIN) != 0) {
    pfd->events &= ~POLLIN;
    pthread_kill( lsredis_thread, SIGUSR1);
  }
}
.fi
.SS "void lsredis_delWrite (void *data)"

.PP
hook to manage 'don't need to write anymore' events 
.PP
Definition at line 604 of file lsredis\&.c\&.
.PP
.nf
                                   {
  struct pollfd *pfd;
  pfd = (struct pollfd *)data;

  if( (pfd->events & POLLOUT) != 0) {
    pfd->events &= ~POLLOUT;
    pthread_kill( lsredis_thread, SIGUSR1);
  }
}
.fi
.SS "void lsredis_fd_service (struct pollfd *evt)"

.PP
service the socket requests 
.PP
Definition at line 889 of file lsredis\&.c\&.
.PP
.nf
                                             {
  pthread_mutex_lock( &lsredis_mutex);
  if( evt->fd == subac->c\&.fd) {
    if( evt->revents & POLLIN)
      redisAsyncHandleRead( subac);
    if( evt->revents & POLLOUT)
      redisAsyncHandleWrite( subac);
  }
  if( evt->fd == roac->c\&.fd) {
    if( evt->revents & POLLIN)
      redisAsyncHandleRead( roac);
    if( evt->revents & POLLOUT)
      redisAsyncHandleWrite( roac);
  }
  if( evt->fd == wrac->c\&.fd) {
    if( evt->revents & POLLIN)
      redisAsyncHandleRead( wrac);
    if( evt->revents & POLLOUT)
      redisAsyncHandleWrite( wrac);
  }
  pthread_mutex_unlock( &lsredis_mutex);
}
.fi
.SS "int lsredis_find_preset (char *base, char *preset_name, double *dval)"

.PP
Definition at line 756 of file lsredis\&.c\&.
.PP
.nf
                                                                      {
  char s[512];
  int i;
  int err;
  ENTRY htab_input, *htab_output;
  lsredis_obj_t *p;

  i = 0;
  for( i=0; i<1024; i++) {
    snprintf( s, sizeof( s)-1, '%s\&.%s\&.presets\&.%d\&.name', lsredis_head, base, i);
    s[sizeof(s)-1] = 0;
    htab_input\&.key  = s;
    htab_input\&.data = NULL;
    err = hsearch_r( htab_input, FIND, &htab_output, &lsredis_htab);
    if( err == 0) {
      // We've run out of names to look for: done
      lslogging_log_message( 'lsredis_find_preset: no preset for motor %s named '%s'', base, preset_name);
      *dval = 0\&.0;
      return 0;
    }

    // Check if we have a match
    p = htab_output->data;
    if( lsredis_cmpstr( p, preset_name)==0) {
      // got a match, now look for the position
      snprintf( s, sizeof( s)-1, '%s\&.%s\&.presets\&.%d\&.position', lsredis_head, base, i);
      s[sizeof(s)-1] = 0;
      htab_input\&.key = s;
      htab_input\&.data = NULL;
      err = hsearch_r( htab_input, FIND, &htab_output, &lsredis_htab);
      if( err == 0) {
        // Name but not position? odd\&.
        lslogging_log_message( 'lsredis_find_preset: Error, motor %s preset '%s' has no position defined', base, preset_name);
        *dval = 0\&.0;
        return 0;
      }
      p = htab_output->data;
      *dval = lsredis_getd( p);
      return 1;
    }
  }
  // How'd we get here?
  // did someone really define that many presets?  And then looked for one that's not there?
  *dval = 0;
  return 0;
}
.fi
.SS "\fBlsredis_obj_t\fP* lsredis_get_obj (char *fmt, \&.\&.\&.)"

.PP
Definition at line 524 of file lsredis\&.c\&.
.PP
.nf
                                                {
  lsredis_obj_t *rtn;
  va_list arg_ptr;
  char k[512];
  char *kp;
  int nkp;

  va_start( arg_ptr, fmt);
  vsnprintf( k, sizeof(k)-1, fmt, arg_ptr);
  k[sizeof(k)-1] = 0;
  va_end( arg_ptr);

  nkp = strlen(k) + strlen( lsredis_head) + 16;         // 16 is overkill\&. I know\&. Get over it\&.
  kp = calloc( nkp, sizeof( char));
  if( kp == NULL) {
    lslogging_log_message( 'lsredis_get_obj: Out of memory');
    exit( -1);
  }
  
  snprintf( kp, nkp-1, '%s\&.%s', lsredis_head, k);
  kp[nkp-1] = 0;

  pthread_mutex_lock( &lsredis_mutex);
  while( lsredis_running == 0)
    pthread_cond_wait( &lsredis_cond, &lsredis_mutex);

  rtn = _lsredis_get_obj( kp);
  pthread_mutex_unlock( &lsredis_mutex);

  free( kp);
  return rtn;
}
.fi
.SS "char** lsredis_get_string_array (\fBlsredis_obj_t\fP *p)"

.PP
Definition at line 365 of file lsredis\&.c\&.
.PP
.nf
                                                   {
  char **rtn;

  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0)
    pthread_cond_wait( &p->cond, &p->mutex);

  rtn = p->avalue;
  pthread_mutex_unlock( &p->mutex);
  
  return rtn;
}
.fi
.SS "int lsredis_getb (\fBlsredis_obj_t\fP *p)"

.PP
Definition at line 378 of file lsredis\&.c\&.
.PP
.nf
                                    {
  int rtn;

  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0)
    pthread_cond_wait( &p->cond, &p->mutex);

  rtn = p->bvalue;
  pthread_mutex_unlock( &p->mutex);
  
  return rtn;
}  
.fi
.SS "char lsredis_getc (\fBlsredis_obj_t\fP *p)"

.PP
Definition at line 391 of file lsredis\&.c\&.
.PP
.nf
                                     {
  int rtn;

  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0)
    pthread_cond_wait( &p->cond, &p->mutex);

  rtn = p->cvalue;
  pthread_mutex_unlock( &p->mutex);
  
  return rtn;
}  
.fi
.SS "double lsredis_getd (\fBlsredis_obj_t\fP *p)"

.PP
Definition at line 339 of file lsredis\&.c\&.
.PP
.nf
                                       {
  double rtn;

  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0)
    pthread_cond_wait( &p->cond, &p->mutex);

  rtn = p->dvalue;
  pthread_mutex_unlock( &p->mutex);
  
  return rtn;
}
.fi
.SS "long int lsredis_getl (\fBlsredis_obj_t\fP *p)"

.PP
Definition at line 352 of file lsredis\&.c\&.
.PP
.nf
                                         {
  long int rtn;

  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0)
    pthread_cond_wait( &p->cond, &p->mutex);

  rtn = p->lvalue;
  pthread_mutex_unlock( &p->mutex);
  
  return rtn;
}  
.fi
.SS "char* lsredis_getstr (\fBlsredis_obj_t\fP *p)"

.PP
return a copy of the key's string value 
.PP
Definition at line 263 of file lsredis\&.c\&.
.PP
.nf
                                        {
  char *rtn;

  //
  // Have to use strdup since we cannot guarantee that p->value won't be freed while the caller is still using it
  //
  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0)
    pthread_cond_wait( &p->cond, &p->mutex);

  rtn = strdup(p->value);
  pthread_mutex_unlock( &p->mutex);
  return rtn;
}
.fi
.SS "void lsredis_hgetCB (redisAsyncContext *ac, void *reply, void *privdata)"

.PP
Definition at line 404 of file lsredis\&.c\&.
.PP
.nf
                                                                         {
  redisReply *r;
  lsredis_obj_t *p;

  r = reply;
  p =  privdata;

  //  lslogging_log_message( 'hgetCB: %s %s', p == NULL ? '<NULL>' : p->key, r->type == REDIS_REPLY_STRING ? r->str : 'Non-string value\&.  Why?');

  //
  // Apparently this item does not exist
  // Just set it to an empty string so at least other apps will have the same behaviour as us
  // TODO: figure out a better way to deal with missing key/values
  //
  if( p != NULL && r->type == REDIS_REPLY_NIL) {
    lsredis_setstr( p, '');
    return;
  }

  if( p != NULL && r->type == REDIS_REPLY_STRING && r->str != NULL) {
    pthread_mutex_lock( &p->mutex);

    _lsredis_set_value( p, r->str);

    pthread_cond_signal( &p->cond);
    pthread_mutex_unlock( &p->mutex);
  }
}
.fi
.SS "void lsredis_init (char *pub, char *re, char *head)"

.PP
Initialize this module, that is, set up the connections\&. \fBParameters:\fP
.RS 4
\fIpub\fP Publish under this (unique) name 
.br
\fIre\fP Regular expression to select keys we want to mirror 
.br
\fIhead\fP Prepend this (+ a dot) to the beginning of requested objects 
.RE
.PP

.PP
Definition at line 810 of file lsredis\&.c\&.
.PP
.nf
                                                    {
  int err;
  int nerrmsg;
  char *errmsg;

  //
  // set up hash map to store redis objects
  //
  err = hcreate_r( 8192, &lsredis_htab);
  if( err == 0) {
    lslogging_log_message( 'lsredis_init: Cannot create hash table\&.  Really bad things are going to happen\&.  hcreate_r returned %d', err);
  }

  lsredis_head      = strdup( head);
  lsredis_publisher = strdup( pub);

  
  pthread_cond_init( &lsredis_cond, NULL);

  subac = redisAsyncConnect('127\&.0\&.0\&.1', 6379);
  if( subac->err) {
    lslogging_log_message( 'Error: %s', subac->errstr);
  }

  subfd\&.fd           = subac->c\&.fd;
  subfd\&.events       = 0;
  subac->ev\&.data     = &subfd;
  subac->ev\&.addRead  = lsredis_addRead;
  subac->ev\&.delRead  = lsredis_delRead;
  subac->ev\&.addWrite = lsredis_addWrite;
  subac->ev\&.delWrite = lsredis_delWrite;
  subac->ev\&.cleanup  = lsredis_cleanup;

  roac = redisAsyncConnect('127\&.0\&.0\&.1', 6379);
  if( roac->err) {
    lslogging_log_message( 'Error: %s', roac->errstr);
  }

  rofd\&.fd           = roac->c\&.fd;
  rofd\&.events       = 0;
  roac->ev\&.data     = &rofd;
  roac->ev\&.addRead  = lsredis_addRead;
  roac->ev\&.delRead  = lsredis_delRead;
  roac->ev\&.addWrite = lsredis_addWrite;
  roac->ev\&.delWrite = lsredis_delWrite;
  roac->ev\&.cleanup  = lsredis_cleanup;

  //wrac = redisAsyncConnect('10\&.1\&.0\&.3', 6379);
  wrac = redisAsyncConnect('127\&.0\&.0\&.1', 6379);
  if( wrac->err) {
    lslogging_log_message( 'Error: %s', wrac->errstr);
  }

  wrfd\&.fd           = wrac->c\&.fd;
  wrfd\&.events       = 0;
  wrac->ev\&.data     = &wrfd;
  wrac->ev\&.addRead  = lsredis_addRead;
  wrac->ev\&.delRead  = lsredis_delRead;
  wrac->ev\&.addWrite = lsredis_addWrite;
  wrac->ev\&.delWrite = lsredis_delWrite;
  wrac->ev\&.cleanup  = lsredis_cleanup;

  err = regcomp( &lsredis_key_select_regex, re, REG_EXTENDED);
  if( err != 0) {
    nerrmsg = regerror( err, &lsredis_key_select_regex, NULL, 0);
    if( nerrmsg > 0) {
      errmsg = calloc( nerrmsg, sizeof( char));
      nerrmsg = regerror( err, &lsredis_key_select_regex, errmsg, nerrmsg);
      lslogging_log_message( 'lsredis_select: %s', errmsg);
      free( errmsg);
    }
  }
}
.fi
.SS "void lsredis_keysCB (redisAsyncContext *ac, void *reply, void *privdata)"

.PP
Sift through the keys to find ones we like\&. Add them to our list of followed objects 
.PP
Definition at line 735 of file lsredis\&.c\&.
.PP
.nf
                                                                         {
  redisReply *r;
  int i;
  
  r = reply;
  if( r->type != REDIS_REPLY_ARRAY) {
    lslogging_log_message( 'lsredis_keysCB: exepected array\&.\&.\&.');
    lsredis_debugCB( ac, reply, privdata);
    return;
  }
  
  for( i=0; i< (int)r->elements; i++) {
    if( r->element[i]->type != REDIS_REPLY_STRING) {
      lslogging_log_message( 'lsredis_keysCB: exected string\&.\&.\&.');
      lsredis_debugCB( ac, r->element[i], privdata);
    } else {
      lsredis_maybe_add_key( r->element[i]->str);
    }
  }
}
.fi
.SS "void lsredis_maybe_add_key (char *k)"

.PP
Definition at line 727 of file lsredis\&.c\&.
.PP
.nf
                                     {
  if( regexec( &lsredis_key_select_regex, k, 0, NULL, 0) == 0) {
    _lsredis_get_obj( k);
  }
}
.fi
.SS "int lsredis_regexec (const regex_t *preg, \fBlsredis_obj_t\fP *p, size_tnmatch, regmatch_t *pmatch, inteflags)"

.PP
Definition at line 247 of file lsredis\&.c\&.
.PP
.nf
                                                                                                           {
  int rtn;

  pthread_mutex_lock( &p->mutex);
  while( p->valid == 0) 
    pthread_cond_wait( &p->cond, &p->mutex);

  rtn = regexec( preg, p->value, nmatch, pmatch, eflags);

  pthread_mutex_unlock( &p->mutex);

  return rtn;
}
.fi
.SS "void lsredis_run ()"

.PP
Definition at line 1014 of file lsredis\&.c\&.
.PP
.nf
                   {
  pthread_create( &lsredis_thread, NULL, lsredis_worker, NULL);
}
.fi
.SS "void lsredis_set_value (\fBlsredis_obj_t\fP *p, char *fmt, \&.\&.\&.)"

.PP
Set the value of a redis object and make it valid\&. Called by mgetCB to set the value as it is in redis Maybe TODO: we've arbitrarily set the maximum size of a value here\&. Although I cannot imagine needed bigger values it would not be a big deal to enable it\&. 
.PP
Definition at line 207 of file lsredis\&.c\&.
.PP
.nf
                                                          {
  va_list arg_ptr;
  char v[512];
  
  va_start( arg_ptr, fmt);
  vsnprintf( v, sizeof(v)-1, fmt, arg_ptr);
  va_end( arg_ptr);

  v[sizeof(v)-1] = 0;

  pthread_mutex_lock( &p->mutex);

  _lsredis_set_value( p, v);

  pthread_cond_signal( &p->cond);
  pthread_mutex_unlock( &p->mutex);
}
.fi
.SS "void lsredis_setstr (\fBlsredis_obj_t\fP *p, char *fmt, \&.\&.\&.)"

.PP
Set the value and update redis\&. Note that lsredis_set_value sets the value based on redis while here we set redis based on the value Arbitray maximum string length set here\&. TODO: Probably this limit should be removed at some point\&.
.PP
redisAsyncCommandArgv used instead of redisAsyncCommand 'cause it's easier (and possible) to deal with strings that would otherwise cause hiredis to emit a bad command, like those containing spaces\&. < up the count of times we need to see ourselves published before we start listening to others again
.PP
< Unlock to prevent deadlock in case the service routine needs to set our value
.PP
< redisAsyncCommandArgv shouldn't need to access this after it's made up it's packet (before it returns) so we should be OK with this location disappearing soon\&. 
.PP
Definition at line 288 of file lsredis\&.c\&.
.PP
.nf
                                                       {
  va_list arg_ptr;
  char v[512];
  char *argv[4];

  va_start( arg_ptr, fmt);
  vsnprintf( v, sizeof(v)-1, fmt, arg_ptr);
  v[sizeof(v)-1] = 0;
  va_end( arg_ptr);
  
  pthread_mutex_lock( &p->mutex);

  //
  // Don't send an update if a good value has not changed
  //
  if( p->valid && strcmp( v, p->value) == 0) {
    // nothing to do
    pthread_mutex_unlock( &p->mutex);
    return;
  }

  p->wait_for_me++;                     
  pthread_mutex_unlock( &p->mutex);     


  argv[0] = 'HSET';
  argv[1] = p->key;
  argv[2] = 'VALUE';
  argv[3] = v;          


  pthread_mutex_lock( &lsredis_mutex);
  while( lsredis_running == 0)
    pthread_cond_wait( &lsredis_cond, &lsredis_mutex);

  redisAsyncCommand( wrac, NULL, NULL, 'MULTI');
  redisAsyncCommandArgv( wrac, NULL, NULL, 4, (const char **)argv, NULL);

  redisAsyncCommand( wrac, NULL, NULL, 'PUBLISH %s %s', lsredis_publisher, p->key);
  redisAsyncCommand( wrac, NULL, NULL, 'EXEC');
  pthread_mutex_unlock( &lsredis_mutex);

  // Assume redis will take exactly the value we sent it
  //
  pthread_mutex_lock( &p->mutex);
  _lsredis_set_value( p, v);
  pthread_cond_signal( &p->cond);
  pthread_mutex_unlock( &p->mutex);
}
.fi
.SS "void lsredis_sig_service (struct pollfd *evt)"
\fBParameters:\fP
.RS 4
\fIevt\fP The pollfd object that triggered this call 
.RE
.PP

.PP
Definition at line 913 of file lsredis\&.c\&.
.PP
.nf
                        {
  struct signalfd_siginfo fdsi;

  //
  // Really, we don't care about the signal,
  // it's just used to drop out of the poll
  // function when there is something for us
  // to do\&.
  //


  read( evt->fd, &fdsi, sizeof( struct signalfd_siginfo));

}
.fi
.SS "void lsredis_subCB (redisAsyncContext *ac, void *reply, void *privdata)"

.PP
Use the publication to request the new value\&. 
.PP
Definition at line 635 of file lsredis\&.c\&.
.PP
.nf
                                                                        {
  redisReply *r;
  lsredis_obj_t *p;
  char *k;
  char *publisher;
  ENTRY htab_input, *htab_output;
  int err;

  r = (redisReply *)reply;

  // Ignore our psubscribe reply
  //
  if( r->type == REDIS_REPLY_ARRAY && r->elements == 3 && r->element[0]->type == REDIS_REPLY_STRING && strcmp( r->element[0]->str, 'psubscribe')==0)
    return;

  // But log other stuff we don't understand
  //
  if( r->type != REDIS_REPLY_ARRAY ||
      r->elements != 4 ||
      r->element[3]->type != REDIS_REPLY_STRING ||
      r->element[2]->type != REDIS_REPLY_STRING) {

    lslogging_log_message( 'lsredis_subCB: unexpected reply');
    lsredis_debugCB( ac, reply, privdata);
    return;
  }

  //
  // Ignore obvious junk
  //
  k = r->element[3]->str;

  if( k == NULL || *k == 0)
    return;
  
  //
  // see if we care
  //
  if( regexec( &lsredis_key_select_regex, k, 0, NULL, 0) == 0) {
    //
    // We should know about this one
    //
    
    htab_input\&.key  = k;
    htab_input\&.data = NULL;

    errno = 0;
    err = hsearch_r( htab_input, FIND, &htab_output, &lsredis_htab);
    if( err == 0 && errno == ESRCH)
      p = NULL;
    else
      p = htab_output->data;
      

    if( p == NULL) {
      _lsredis_get_obj( k);
    } else {
      // Look who's talk'n
      publisher = r->element[2]->str;

      pthread_mutex_lock( &p->mutex);
      if( p->wait_for_me) {
        //
        // see if we are done waiting
        //
        if( strcmp( publisher, lsredis_publisher)==0)
          p->wait_for_me--;

        pthread_mutex_unlock( &p->mutex);
        //
        // Don't get a new value, either we set it last or we are still waiting for redis to report
        // our publication
        //
        return;
      }

      // Here we know our value is out of date
      //
      p->valid = 0;
      lsevents_send_event( '%s Invalid', p->events_name);
      pthread_mutex_unlock( &p->mutex);

      //
      // We shouldn't get here if wait_for_me is zero and we are the publisher\&.
      // If somehow we did (ie we did an hset with out incrementing wait_for_me or if we published too many times), it shouldn't hurt to get the value again\&.
      //
      redisAsyncCommand( roac, lsredis_hgetCB, p, 'HGET %s VALUE', k);
    }
  }
}
.fi
.SS "void* lsredis_worker (void *dummy)"

.PP
subscribe to changes and service sockets < poll timeout, in millisecs (of course)
.PP
< array of pollfd's for the poll function, one entry per connection
.PP
< number of active elements in fda 
.PP
Definition at line 932 of file lsredis\&.c\&.
.PP
.nf
                                    {
  static int poll_timeout_ms = -1;      
  static struct pollfd fda[4];          
  static int nfda = 0;                  
  static sigset_t our_sigset;
  int pollrtn;
  int i;


  pthread_mutex_lock( &lsredis_mutex);
  //
  // block ordinary signal mechanism
  //
  sigemptyset( &our_sigset);
  sigaddset( &our_sigset, SIGUSR1);
  pthread_sigmask( SIG_BLOCK, &our_sigset, NULL);

  // Set up fd mechanism
  //
  fda[0]\&.fd = signalfd( -1, &our_sigset, SFD_NONBLOCK);
  if( fda[0]\&.fd == -1) {
    char *es;

    es = strerror( errno);
    lslogging_log_message( 'lsredis_worker: Signalfd trouble '%s'', es);
  }
  fda[0]\&.events = POLLIN;
  nfda = 1;

  lsredis_running = 1;

  if( redisAsyncCommand( subac, lsredis_subCB, NULL, 'PSUBSCRIBE REDIS_KV_CONNECTOR UI* MD2-*') == REDIS_ERR) {
    lslogging_log_message( 'Error sending PSUBSCRIBE command');
  }

  redisAsyncCommand( roac, lsredis_keysCB, NULL, 'KEYS *');
  pthread_cond_signal( &lsredis_cond);
  pthread_mutex_unlock( &lsredis_mutex);


  while(1) {
    nfda = 1;

    pthread_mutex_lock( &lsredis_mutex);
    if( subfd\&.fd != -1) {
      fda[nfda]\&.fd      = subfd\&.fd;
      fda[nfda]\&.events  = subfd\&.events;
      fda[nfda]\&.revents = 0;
      nfda++;
    }

    if( rofd\&.fd != -1) {
      fda[nfda]\&.fd      = rofd\&.fd;
      fda[nfda]\&.events  = rofd\&.events;
      fda[nfda]\&.revents = 0; 
     nfda++;
    }

    if( wrfd\&.fd != -1) {
      fda[nfda]\&.fd      = wrfd\&.fd;
      fda[nfda]\&.events  = wrfd\&.events;
      fda[nfda]\&.revents = 0;
      nfda++;
    }
    pthread_mutex_unlock( &lsredis_mutex);

    pollrtn = poll( fda, nfda, poll_timeout_ms);

    if( pollrtn && fda[0]\&.revents) {
      lsredis_sig_service( &(fda[0]));
      pollrtn--;
    } 

    for( i=1; i<nfda; i++) {
      if( fda[i]\&.revents) {
        lsredis_fd_service( &(fda[i]));
      }
    }
  }
}
.fi
.SS "void redisDisconnectCB (const redisAsyncContext *ac, intstatus)"

.PP
call back in case a redis server becomes disconnected TODO: reconnect 
.PP
Definition at line 560 of file lsredis\&.c\&.
.PP
.nf
                                                                {
  if( status != REDIS_OK) {
    lslogging_log_message( 'lsredis: Disconnected with status %d', status);
  }
}
.fi
.SH "Variable Documentation"
.PP 
.SS "pthread_cond_t lsredis_cond\fC [static]\fP"

.PP
Definition at line 75 of file lsredis\&.c\&.
.SS "char* lsredis_head = NULL\fC [static]\fP"

.PP
Definition at line 88 of file lsredis\&.c\&.
.SS "struct hsearch_data lsredis_htab\fC [static]\fP"

.PP
Definition at line 80 of file lsredis\&.c\&.
.SS "regex_t lsredis_key_select_regex\fC [static]\fP"

.PP
Definition at line 87 of file lsredis\&.c\&.
.SS "pthread_mutex_t lsredis_mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP\fC [static]\fP"

.PP
Definition at line 73 of file lsredis\&.c\&.
.SS "\fBlsredis_obj_t\fP* lsredis_objs = NULL\fC [static]\fP"

.PP
Definition at line 79 of file lsredis\&.c\&.
.SS "char* lsredis_publisher = NULL\fC [static]\fP"

.PP
Definition at line 86 of file lsredis\&.c\&.
.SS "int lsredis_running = 0\fC [static]\fP"

.PP
Definition at line 76 of file lsredis\&.c\&.
.SS "pthread_t lsredis_thread\fC [static]\fP"

.PP
Definition at line 71 of file lsredis\&.c\&.
.SS "redisAsyncContext* roac\fC [static]\fP"

.PP
Definition at line 83 of file lsredis\&.c\&.
.SS "struct pollfd rofd\fC [static]\fP"

.PP
Definition at line 91 of file lsredis\&.c\&.
.SS "redisAsyncContext* subac\fC [static]\fP"

.PP
Definition at line 82 of file lsredis\&.c\&.
.SS "struct pollfd subfd\fC [static]\fP"

.PP
Definition at line 90 of file lsredis\&.c\&.
.SS "redisAsyncContext* wrac\fC [static]\fP"

.PP
Definition at line 84 of file lsredis\&.c\&.
.SS "struct pollfd wrfd\fC [static]\fP"

.PP
Definition at line 92 of file lsredis\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for LS-CAT PGPMAC from the source code\&.
