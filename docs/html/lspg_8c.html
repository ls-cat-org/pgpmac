<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LS-CAT PGPMAC: lspg.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lspg.c File Reference</h1>
<p>Postgresql support for the LS-CAT pgpmac project.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="pgpmac_8h_source.html">pgpmac.h</a>&quot;</code><br/>

<p><a href="lspg_8c_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlspgQueryQueueStruct.html">lspgQueryQueueStruct</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store each query along with it's callback function.  <a href="structlspgQueryQueueStruct.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlspg__wait__for__detector__struct.html">lspg_wait_for_detector_struct</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object that implements detector / spindle timing We use database locks for exposure control and this implements the md2 portion of this handshake.  <a href="structlspg__wait__for__detector__struct.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlspg__lock__diffractometer__struct.html">lspg_lock_diffractometer_struct</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object used to impliment locking the diffractometer Critical to exposure timing.  <a href="structlspg__lock__diffractometer__struct.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlspg__lock__detector__struct.html">lspg_lock_detector_struct</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">lock detector object Implements detector lock for exposure control  <a href="structlspg__lock__detector__struct.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlspg__seq__run__prep__struct.html">lspg_seq_run_prep_struct</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data collection running object.  <a href="structlspg__seq__run__prep__struct.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#af443092447378c73bf93aa143576aba4">LS_PG_STATE_INIT</a>&nbsp;&nbsp;&nbsp;-4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ae7ea5876846b5f04c419aee22d3c0aa1">LS_PG_STATE_INIT_POLL</a>&nbsp;&nbsp;&nbsp;-3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#accda8c3a598dc7f5b107b04986d8ab50">LS_PG_STATE_RESET</a>&nbsp;&nbsp;&nbsp;-2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ac70a1141f3b138055ea7143bd493187c">LS_PG_STATE_RESET_POLL</a>&nbsp;&nbsp;&nbsp;-1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#aaf1dd8ba4dafb91c296554c4cbf312e3">LS_PG_STATE_IDLE</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a3c6eb19f262a990e1f9ba630d9edc309">LS_PG_STATE_SEND</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a88a7e80c12fb0449c4b0857a0c7deb21">LS_PG_STATE_SEND_FLUSH</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a373e668840b4795ff9a71bc3f744d209">LS_PG_STATE_RECV</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a08fe83fe8226002ee8b80ce0a914fd11">LS_PG_QUERY_QUEUE_LENGTH</a>&nbsp;&nbsp;&nbsp;16318</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Why such a long queue? you might ask.  <a href="#a08fe83fe8226002ee8b80ce0a914fd11"></a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structlspgQueryQueueStruct.html">lspgQueryQueueStruct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ae57432c0a6ac48a50457815dab2c5b4c">lspg_query_queue_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store each query along with it's callback function.  <a href="#ae57432c0a6ac48a50457815dab2c5b4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="structlspg__wait__for__detector__struct.html">lspg_wait_for_detector_struct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a6f273a499bf316de95df3816a9b1bc06">lspg_wait_for_detector_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object that implements detector / spindle timing We use database locks for exposure control and this implements the md2 portion of this handshake.  <a href="#a6f273a499bf316de95df3816a9b1bc06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="structlspg__lock__diffractometer__struct.html">lspg_lock_diffractometer_struct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a7232a0d630558f0c4c081d087150973d">lspg_lock_diffractometer_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object used to impliment locking the diffractometer Critical to exposure timing.  <a href="#a7232a0d630558f0c4c081d087150973d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="structlspg__lock__detector__struct.html">lspg_lock_detector_struct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a3442e66a1f05457eb22a0d4a5d295f3a">lspg_lock_detector_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">lock detector object Implements detector lock for exposure control  <a href="#a3442e66a1f05457eb22a0d4a5d295f3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="structlspg__seq__run__prep__struct.html">lspg_seq_run_prep_struct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ab2da550aea6388c835abe0ee0b226eb0">lspg_seq_run_prep_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data collection running object.  <a href="#ab2da550aea6388c835abe0ee0b226eb0"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ad5f3ec8f197cc330c83dba70f310533c">lspg_query_next</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next item in the postgresql queue.  <a href="#ad5f3ec8f197cc330c83dba70f310533c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a3847589e641f7e16a0cd68ef30e37cca">lspg_query_reply_next</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the oldest item in the queue.  <a href="#a3847589e641f7e16a0cd68ef30e37cca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ae6bf4f54117bedf903360883bb32699f">lspg_query_reply_peek</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next item in the reply queue but don't pop it since we may need it more than once.  <a href="#ae6bf4f54117bedf903360883bb32699f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4">lspg_query_push</a> (void(*cb)(<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *, PGresult *), char *fmt,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Place a query on the queue.  <a href="#a0bb9ef42da8fa21c4df48ec384ab69f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a329a7fdfa5025a403ea2779e178fd3ed">lspg_init_motors_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Motor initialization callback.  <a href="#a329a7fdfa5025a403ea2779e178fd3ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#af34559ab5624e1e68085dbcd9410c692">lspg_zoom_lut_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Zoom motor look up table callback.  <a href="#af34559ab5624e1e68085dbcd9410c692"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ac5d5d512350a9ba346635e2415d7c3d5">lspg_flight_lut_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Front Light Lookup table query callback Install the lookup table for the Front Light.  <a href="#ac5d5d512350a9ba346635e2415d7c3d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a6f5fa5727f2876f8b9370110a92afa50">lspg_blight_lut_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Back Light Lookup Table Callback Install the lookup table for the Back Light.  <a href="#a6f5fa5727f2876f8b9370110a92afa50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a9e92a204f606761d368ac7e06ef0f09c">lspg_nextshot_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Next Shot Callback.  <a href="#a9e92a204f606761d368ac7e06ef0f09c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#aff91db7d60e6c832684c023813e36dbf">lspg_nextshot_init</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the nextshot variable, mutex, and condition.  <a href="#aff91db7d60e6c832684c023813e36dbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#af17ef79544ca5d78fd477010fe90d538">lspg_nextshot_call</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queue up a nextshot query.  <a href="#af17ef79544ca5d78fd477010fe90d538"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a784a6de32a86fec9efb3ef3ae4b6e3ac">lspg_nextshot_wait</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the next shot query to get processed.  <a href="#a784a6de32a86fec9efb3ef3ae4b6e3ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a50458a014041a4118452802dfb303960">lspg_nextshot_done</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called when the next shot query has been processed.  <a href="#a50458a014041a4118452802dfb303960"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a3517f8fbed91c998f6036284f9bd0c48">lspg_wait_for_detector_init</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">initialize the detector timing object  <a href="#a3517f8fbed91c998f6036284f9bd0c48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a5747c519d1aa4c310010a862cae8a823">lspg_wait_for_detector_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback for the wait for detector query.  <a href="#a5747c519d1aa4c310010a862cae8a823"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a4b5222b859a44eae616804a1e990b86d">lspg_wait_for_detector_call</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">initiate the wait for detector query  <a href="#a4b5222b859a44eae616804a1e990b86d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#af094e01be121ce8e14abb679abd17e19">lspg_wait_for_detector_wait</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pause the calling thread until the detector is ready Called by the MD2 thread.  <a href="#af094e01be121ce8e14abb679abd17e19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#abb3645dee7c4514b650ab02f27570a69">lspg_wait_for_detector_done</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Done waiting for the detector.  <a href="#abb3645dee7c4514b650ab02f27570a69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ab9780e15924a50b2a5545e10806000b3">lspg_wait_for_detector_all</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combined call to wait for the detector.  <a href="#ab9780e15924a50b2a5545e10806000b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a39bb94f8e0d47702b2b920a3dee61ebc">lspg_lock_diffractometer_init</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">initialize the diffractometer locking object  <a href="#a39bb94f8e0d47702b2b920a3dee61ebc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#aad4f378f37c0030634dafa0d9445d916">lspg_lock_diffractometer_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback routine for a lock diffractometer query.  <a href="#aad4f378f37c0030634dafa0d9445d916"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ac5ebeb38e8e9926a52f024fe76201175">lspg_lock_diffractometer_call</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request that the database grab the diffractometer lock.  <a href="#ac5ebeb38e8e9926a52f024fe76201175"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a8445e1dec753f2c517b87fcb9c5b5943">lspg_lock_diffractometer_wait</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the diffractometer lock.  <a href="#a8445e1dec753f2c517b87fcb9c5b5943"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a75aaf0b3fe33530062226c69a33ce821">lspg_lock_diffractometer_done</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finish up the lock diffractometer call.  <a href="#a75aaf0b3fe33530062226c69a33ce821"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a88b33e75c42197740b157a51ea726f21">lspg_lock_diffractometer_all</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convience function that combines lock diffractometer calls.  <a href="#a88b33e75c42197740b157a51ea726f21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a0e9bbf847dadfe0d10830d67824d9be8">lspg_lock_detector_init</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize detector lock object.  <a href="#a0e9bbf847dadfe0d10830d67824d9be8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#aa760191c2b443170cebbcbf5ea5345f3">lspg_lock_detector_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback for when the detector lock has be grabbed.  <a href="#aa760191c2b443170cebbcbf5ea5345f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a5f71a20cc297684b2afe28e7bd8e8383">lspg_lock_detector_call</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request (demand) a detector lock.  <a href="#a5f71a20cc297684b2afe28e7bd8e8383"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ad3d9c56bd3ca6bcc43db30872cc441cc">lspg_lock_detector_wait</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the detector lock.  <a href="#ad3d9c56bd3ca6bcc43db30872cc441cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a1b567040693ff6e2932a2477045d75fa">lspg_lock_detector_done</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finish waiting.  <a href="#a1b567040693ff6e2932a2477045d75fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#aff93d2f5ac31aa249a0bef40a3837c84">lspg_lock_detector_all</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detector lock convinence function.  <a href="#aff93d2f5ac31aa249a0bef40a3837c84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a31823ecb2b44d4a6674f804059a27bce">lspg_seq_run_prep_init</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the data collection object.  <a href="#a31823ecb2b44d4a6674f804059a27bce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a11cda12050dc9a86188e15e2155a6013">lspg_seq_run_prep_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback for the seq_run_prep query.  <a href="#a11cda12050dc9a86188e15e2155a6013"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#af7d6efd861b152a371442791deb42bd3">lspg_seq_run_prep_call</a> (long long skey, double <a class="el" href="pgpmac_8h.html#a0be79ccb7ebf3a665248fd856112b9fd">kappa</a>, double <a class="el" href="pgpmac_8h.html#ac8070dc568ad974a3db42b51eca828cc">phi</a>, double cx, double cy, double ax, double ay, double az)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">queue up the seq_run_prep query  <a href="#af7d6efd861b152a371442791deb42bd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ac0b01f501322432a8fa37f31898c3499">lspg_seq_run_prep_wait</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for seq run prep query to return.  <a href="#ac0b01f501322432a8fa37f31898c3499"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a472b09ddf716c80207f97e2bb5d37d66">lspg_seq_run_prep_done</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicate we are done waiting.  <a href="#a472b09ddf716c80207f97e2bb5d37d66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a4253474d4dd305aec0afdd5552b3ddd5">lspg_seq_run_prep_all</a> (long long skey, double <a class="el" href="pgpmac_8h.html#a0be79ccb7ebf3a665248fd856112b9fd">kappa</a>, double <a class="el" href="pgpmac_8h.html#ac8070dc568ad974a3db42b51eca828cc">phi</a>, double cx, double cy, double ax, double ay, double az)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convinence function to call seq run prep.  <a href="#a4253474d4dd305aec0afdd5552b3ddd5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a8184824f2b71b1d35141d7922ca69cd7">lspg_getcenter_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TODO: implement getcenter code.  <a href="#a8184824f2b71b1d35141d7922ca69cd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#aeda8dad89b03d7d61cc994dd63ee5db6">lspg_nextaction_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queue the next MD2 instruction.  <a href="#aeda8dad89b03d7d61cc994dd63ee5db6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a1e11f525ca0f9ac9ab71f9fbe983c42b">lspg_cmd_cb</a> (<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *qqp, PGresult *pgr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send strings directly to PMAC queue.  <a href="#a1e11f525ca0f9ac9ab71f9fbe983c42b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#af6485ac1749c5de3008dd0e0badaa09c">lspg_flush</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush psql output buffer (ie, send the query).  <a href="#af6485ac1749c5de3008dd0e0badaa09c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a714b15e117ffe7bfce4f2f2ce4725b0a">lspg_send_next_query</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">send the next queued query to the DB server  <a href="#a714b15e117ffe7bfce4f2f2ce4725b0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a038c5af23469b789fc1c55d21cb43029">lspg_receive</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a result of a query.  <a href="#a038c5af23469b789fc1c55d21cb43029"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a049f4422994aa2eb2b841ffb2937f895">lspg_sig_service</a> (struct pollfd *evt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Service a signal Signals here are treated as file descriptors and fits into our poll scheme.  <a href="#a049f4422994aa2eb2b841ffb2937f895"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#aa8d1fed4b461c2139a21826d524777d5">lspg_pg_service</a> (struct pollfd *evt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">I/O control to/from the postgresql server.  <a href="#aa8d1fed4b461c2139a21826d524777d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a581c18be0368425665a40b4b7f7d9714">lspg_pg_connect</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect to the pg server.  <a href="#a581c18be0368425665a40b4b7f7d9714"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ab52a8c8245bf6561f40c0f224fc07ff4">lspg_next_state</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implements our state machine Does not strictly only set the next state as it also calls some functions that, perhaps, alters the state mid-function.  <a href="#ab52a8c8245bf6561f40c0f224fc07ff4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#aaf4fadd2943fa3a2ecb5d840e84d68fa">lspg_worker</a> (void *dummy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The main loop for the lspg thread.  <a href="#aaf4fadd2943fa3a2ecb5d840e84d68fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a8a77972df14166e05c94ed0792baa09b">lspg_init</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initiallize the lspg module.  <a href="#a8a77972df14166e05c94ed0792baa09b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a1adfdb5ca9fdb5060849d726bf540117">lspg_run</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start 'er runnin'.  <a href="#a1adfdb5ca9fdb5060849d726bf540117"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1">ls_pg_state</a> = LS_PG_STATE_INIT</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">State of the lspg state machine.  <a href="#a4937baac0cc78ea306d58b5f027867f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static pthread_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a04eb0cda0d5e5afeae7c393b51689765">lspg_thread</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">our worker thread  <a href="#a04eb0cda0d5e5afeae7c393b51689765"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static pthread_mutex_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a3d49c5147ca0e5634c382ef71c4ae24e">pg_queue_mutex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">keep the queue from getting tangled  <a href="#a3d49c5147ca0e5634c382ef71c4ae24e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct pollfd&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d">lspgfd</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">our poll info  <a href="#af3f897b8ffa020ca54289bc5b28cb64d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a357d9d98f0b8c9625ccebcebfcdce955">lspg_query_queue</a> [LS_PG_QUERY_QUEUE_LENGTH]</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Our query queue.  <a href="#a357d9d98f0b8c9625ccebcebfcdce955"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a3cbe7f3161b3c1838ebc56a3bbcfd8a6">lspg_query_queue_on</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Next position to add something to the queue.  <a href="#a3cbe7f3161b3c1838ebc56a3bbcfd8a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#aca86bb77d6cecfae9251743f4171bafb">lspg_query_queue_off</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The last item still being used (on == off means nothing in queue).  <a href="#aca86bb77d6cecfae9251743f4171bafb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a2603b071afdbff7c0924b13de2454264">lspg_query_queue_reply</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The current item being digested.  <a href="#a2603b071afdbff7c0924b13de2454264"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PGconn *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3">q</a> = NULL</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Database connector.  <a href="#a9012783dbbadf652a81649a289697cf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PostgresPollingStatusType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a69ae04978986e6413ca7cefcb692b645">lspg_connectPoll_response</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to determine state while connecting.  <a href="#a69ae04978986e6413ca7cefcb692b645"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PostgresPollingStatusType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a06c5a937e41a6c706a247777642ec1fb">lspg_resetPoll_response</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to determine state while reconnecting.  <a href="#a06c5a937e41a6c706a247777642ec1fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlspg__nextshot__struct.html">lspg_nextshot_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd">lspg_nextshot</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the nextshot object  <a href="#ad8d8e2f578ca79189a80c1fd5b60cefd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlspg__wait__for__detector__struct.html">lspg_wait_for_detector_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58">lspg_wait_for_detector</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instance of the detector timing object.  <a href="#a0dfc8d0410cd2d7f7da7a70d3ef88e58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlspg__lock__diffractometer__struct.html">lspg_lock_diffractometer_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlspg__lock__detector__struct.html">lspg_lock_detector_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlspg__seq__run__prep__struct.html">lspg_seq_run_prep_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Postgresql support for the LS-CAT pgpmac project. </p>
<dl class="date"><dt><b>Date:</b></dt><dd>2012 </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Keith Brister  All Rights Reserved</dd></dl>
<pre>
  Database state machine</pre><pre>State		Description</pre><pre> -4		Initiate connection
 -3		Poll until connection initialization is complete
 -2		Initiate reset
 -1		Poll until connection reset is complete
  1		Idle (wait for a notify from the server)
  2		Send a query to the server
  3		Continue flushing a command to the server
  4		Waiting for a reply
</pre> 
<p>Definition in file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a08fe83fe8226002ee8b80ce0a914fd11"></a><!-- doxytag: member="lspg.c::LS_PG_QUERY_QUEUE_LENGTH" ref="a08fe83fe8226002ee8b80ce0a914fd11" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LS_PG_QUERY_QUEUE_LENGTH&nbsp;&nbsp;&nbsp;16318</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Why such a long queue? you might ask. </p>
<p>A huge queue is used here to insure that we don't have to worry too much about over running it. Typically we'll be adding a few queries at a time (for example, to initialize the motors) but not much more than that. When we over run the queue we'll need to look deeply into the root cause as something has gone terribly wrong. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00061">61</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="aaf1dd8ba4dafb91c296554c4cbf312e3"></a><!-- doxytag: member="lspg.c::LS_PG_STATE_IDLE" ref="aaf1dd8ba4dafb91c296554c4cbf312e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LS_PG_STATE_IDLE&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00034">34</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="af443092447378c73bf93aa143576aba4"></a><!-- doxytag: member="lspg.c::LS_PG_STATE_INIT" ref="af443092447378c73bf93aa143576aba4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LS_PG_STATE_INIT&nbsp;&nbsp;&nbsp;-4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00030">30</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="ae7ea5876846b5f04c419aee22d3c0aa1"></a><!-- doxytag: member="lspg.c::LS_PG_STATE_INIT_POLL" ref="ae7ea5876846b5f04c419aee22d3c0aa1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LS_PG_STATE_INIT_POLL&nbsp;&nbsp;&nbsp;-3</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00031">31</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a373e668840b4795ff9a71bc3f744d209"></a><!-- doxytag: member="lspg.c::LS_PG_STATE_RECV" ref="a373e668840b4795ff9a71bc3f744d209" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LS_PG_STATE_RECV&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00037">37</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="accda8c3a598dc7f5b107b04986d8ab50"></a><!-- doxytag: member="lspg.c::LS_PG_STATE_RESET" ref="accda8c3a598dc7f5b107b04986d8ab50" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LS_PG_STATE_RESET&nbsp;&nbsp;&nbsp;-2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00032">32</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="ac70a1141f3b138055ea7143bd493187c"></a><!-- doxytag: member="lspg.c::LS_PG_STATE_RESET_POLL" ref="ac70a1141f3b138055ea7143bd493187c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LS_PG_STATE_RESET_POLL&nbsp;&nbsp;&nbsp;-1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00033">33</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3c6eb19f262a990e1f9ba630d9edc309"></a><!-- doxytag: member="lspg.c::LS_PG_STATE_SEND" ref="a3c6eb19f262a990e1f9ba630d9edc309" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LS_PG_STATE_SEND&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00035">35</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a88a7e80c12fb0449c4b0857a0c7deb21"></a><!-- doxytag: member="lspg.c::LS_PG_STATE_SEND_FLUSH" ref="a88a7e80c12fb0449c4b0857a0c7deb21" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LS_PG_STATE_SEND_FLUSH&nbsp;&nbsp;&nbsp;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00036">36</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a3442e66a1f05457eb22a0d4a5d295f3a"></a><!-- doxytag: member="lspg.c::lspg_lock_detector_t" ref="a3442e66a1f05457eb22a0d4a5d295f3a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlspg__lock__detector__struct.html">lspg_lock_detector_struct</a>  <a class="el" href="structlspg__lock__detector__struct.html">lspg_lock_detector_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>lock detector object Implements detector lock for exposure control </p>

</div>
</div>
<a class="anchor" id="a7232a0d630558f0c4c081d087150973d"></a><!-- doxytag: member="lspg.c::lspg_lock_diffractometer_t" ref="a7232a0d630558f0c4c081d087150973d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlspg__lock__diffractometer__struct.html">lspg_lock_diffractometer_struct</a>  <a class="el" href="structlspg__lock__diffractometer__struct.html">lspg_lock_diffractometer_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Object used to impliment locking the diffractometer Critical to exposure timing. </p>

</div>
</div>
<a class="anchor" id="ae57432c0a6ac48a50457815dab2c5b4c"></a><!-- doxytag: member="lspg.c::lspg_query_queue_t" ref="ae57432c0a6ac48a50457815dab2c5b4c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlspgQueryQueueStruct.html">lspgQueryQueueStruct</a>  <a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Store each query along with it's callback function. </p>
<p>All calls are asynchronous </p>

</div>
</div>
<a class="anchor" id="ab2da550aea6388c835abe0ee0b226eb0"></a><!-- doxytag: member="lspg.c::lspg_seq_run_prep_t" ref="ab2da550aea6388c835abe0ee0b226eb0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlspg__seq__run__prep__struct.html">lspg_seq_run_prep_struct</a>  <a class="el" href="structlspg__seq__run__prep__struct.html">lspg_seq_run_prep_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Data collection running object. </p>

</div>
</div>
<a class="anchor" id="a6f273a499bf316de95df3816a9b1bc06"></a><!-- doxytag: member="lspg.c::lspg_wait_for_detector_t" ref="a6f273a499bf316de95df3816a9b1bc06" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlspg__wait__for__detector__struct.html">lspg_wait_for_detector_struct</a>  <a class="el" href="structlspg__wait__for__detector__struct.html">lspg_wait_for_detector_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Object that implements detector / spindle timing We use database locks for exposure control and this implements the md2 portion of this handshake. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a6f5fa5727f2876f8b9370110a92afa50"></a><!-- doxytag: member="lspg.c::lspg_blight_lut_cb" ref="a6f5fa5727f2876f8b9370110a92afa50" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_blight_lut_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Back Light Lookup Table Callback Install the lookup table for the Back Light. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>qqp</em>&nbsp;</td><td>Our query </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pgr</em>&nbsp;</td><td>The query's result </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00278">278</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00281"></a>00281                           {
<a name="l00282"></a>00282   <span class="keywordtype">int</span> i;
<a name="l00283"></a>00283   
<a name="l00284"></a>00284   pthread_mutex_lock( &amp;(<a class="code" href="lspmac_8c.html#a85d6eaa4b4a82bb3112574f458d1dc50" title="Back Light DAC.">blight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a188c5b1e991750ce2ffd53e0192e0907" title="coordinate waiting for motor to be done">mutex</a>));
<a name="l00285"></a>00285 
<a name="l00286"></a>00286   <a class="code" href="lspmac_8c.html#a85d6eaa4b4a82bb3112574f458d1dc50" title="Back Light DAC.">blight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a11cbc6f50c150ed446e9a901cf7cc12b" title="length of lut">nlut</a> = PQntuples( pgr)/2;
<a name="l00287"></a>00287   <a class="code" href="lspmac_8c.html#a85d6eaa4b4a82bb3112574f458d1dc50" title="Back Light DAC.">blight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a7b43671f7f3e06521f6cf91fb9ac707d" title="lookup table (instead of u2c)">lut</a>  = calloc( 2*<a class="code" href="lspmac_8c.html#a85d6eaa4b4a82bb3112574f458d1dc50" title="Back Light DAC.">blight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a11cbc6f50c150ed446e9a901cf7cc12b" title="length of lut">nlut</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00288"></a>00288   <span class="keywordflow">if</span>( <a class="code" href="lspmac_8c.html#a85d6eaa4b4a82bb3112574f458d1dc50" title="Back Light DAC.">blight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a7b43671f7f3e06521f6cf91fb9ac707d" title="lookup table (instead of u2c)">lut</a> == NULL) {
<a name="l00289"></a>00289     wprintw( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>, <span class="stringliteral">&quot;\nOut of memmory (lspg_blight_lut_cb)&quot;</span>);
<a name="l00290"></a>00290     wnoutrefresh( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>);
<a name="l00291"></a>00291     wnoutrefresh( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>);
<a name="l00292"></a>00292     doupdate();
<a name="l00293"></a>00293     pthread_mutex_unlock( &amp;(<a class="code" href="lspmac_8c.html#a85d6eaa4b4a82bb3112574f458d1dc50" title="Back Light DAC.">blight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a188c5b1e991750ce2ffd53e0192e0907" title="coordinate waiting for motor to be done">mutex</a>));
<a name="l00294"></a>00294     <span class="keywordflow">return</span>;
<a name="l00295"></a>00295   }
<a name="l00296"></a>00296   
<a name="l00297"></a>00297   <span class="keywordflow">for</span>( i=0; i&lt;PQntuples( pgr); i++) {
<a name="l00298"></a>00298     <a class="code" href="lspmac_8c.html#a85d6eaa4b4a82bb3112574f458d1dc50" title="Back Light DAC.">blight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a7b43671f7f3e06521f6cf91fb9ac707d" title="lookup table (instead of u2c)">lut</a>[i] = strtod( PQgetvalue( pgr, i, 0), NULL);
<a name="l00299"></a>00299   }
<a name="l00300"></a>00300 
<a name="l00301"></a>00301   pthread_mutex_unlock( &amp;(<a class="code" href="lspmac_8c.html#a85d6eaa4b4a82bb3112574f458d1dc50" title="Back Light DAC.">blight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a188c5b1e991750ce2ffd53e0192e0907" title="coordinate waiting for motor to be done">mutex</a>));
<a name="l00302"></a>00302 
<a name="l00303"></a>00303 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1e11f525ca0f9ac9ab71f9fbe983c42b"></a><!-- doxytag: member="lspg.c::lspg_cmd_cb" ref="a1e11f525ca0f9ac9ab71f9fbe983c42b" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_cmd_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send strings directly to PMAC queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>qqp</em>&nbsp;</td><td>Our query </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pgr</em>&nbsp;</td><td>Our result </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00895">895</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00898"></a>00898                    {
<a name="l00899"></a>00899   <span class="comment">//</span>
<a name="l00900"></a>00900   <span class="comment">// Call back funciton assumes query results in zero or more commands to send to the PMAC</span>
<a name="l00901"></a>00901   <span class="comment">//</span>
<a name="l00902"></a>00902   <span class="keywordtype">int</span> i;
<a name="l00903"></a>00903   <span class="keywordtype">char</span> *sp;
<a name="l00904"></a>00904   
<a name="l00905"></a>00905   <span class="keywordflow">for</span>( i=0; i&lt;PQntuples( pgr); i++) {
<a name="l00906"></a>00906     sp = PQgetvalue( pgr, i, 0);
<a name="l00907"></a>00907     <span class="keywordflow">if</span>( sp != NULL &amp;&amp; *sp != 0) {
<a name="l00908"></a>00908       <a class="code" href="lspmac_8c.html#aaa442d9bc7a3cdee39adea0724f0e18c" title="Send a one line command.">lspmac_SockSendline</a>( sp);
<a name="l00909"></a>00909       <span class="comment">//</span>
<a name="l00910"></a>00910       <span class="comment">// Keep asking for more until</span>
<a name="l00911"></a>00911       <span class="comment">// there are no commands left</span>
<a name="l00912"></a>00912       <span class="comment">// </span>
<a name="l00913"></a>00913       <span class="comment">// This should solve a potential problem where</span>
<a name="l00914"></a>00914       <span class="comment">// more than one command is put on the queue for a given notify.</span>
<a name="l00915"></a>00915       <span class="comment">//</span>
<a name="l00916"></a>00916       <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#a1e11f525ca0f9ac9ab71f9fbe983c42b" title="Send strings directly to PMAC queue.">lspg_cmd_cb</a>, <span class="stringliteral">&quot;select pmac.md2_queue_next()&quot;</span>);
<a name="l00917"></a>00917     }
<a name="l00918"></a>00918   }
<a name="l00919"></a>00919 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac5d5d512350a9ba346635e2415d7c3d5"></a><!-- doxytag: member="lspg.c::lspg_flight_lut_cb" ref="ac5d5d512350a9ba346635e2415d7c3d5" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_flight_lut_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Front Light Lookup table query callback Install the lookup table for the Front Light. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>qqp</em>&nbsp;</td><td>Our query </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pgr</em>&nbsp;</td><td>Our result object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00247">247</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00250"></a>00250                           {
<a name="l00251"></a>00251   <span class="keywordtype">int</span> i;
<a name="l00252"></a>00252   
<a name="l00253"></a>00253   pthread_mutex_lock( &amp;(<a class="code" href="lspmac_8c.html#aeb09895663eff333b7a75acb319a9fc1" title="Front Light DAC.">flight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a188c5b1e991750ce2ffd53e0192e0907" title="coordinate waiting for motor to be done">mutex</a>));
<a name="l00254"></a>00254 
<a name="l00255"></a>00255   <a class="code" href="lspmac_8c.html#aeb09895663eff333b7a75acb319a9fc1" title="Front Light DAC.">flight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a11cbc6f50c150ed446e9a901cf7cc12b" title="length of lut">nlut</a> = PQntuples( pgr)/2;
<a name="l00256"></a>00256   <a class="code" href="lspmac_8c.html#aeb09895663eff333b7a75acb319a9fc1" title="Front Light DAC.">flight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a7b43671f7f3e06521f6cf91fb9ac707d" title="lookup table (instead of u2c)">lut</a>  = calloc( 2*<a class="code" href="lspmac_8c.html#aeb09895663eff333b7a75acb319a9fc1" title="Front Light DAC.">flight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a11cbc6f50c150ed446e9a901cf7cc12b" title="length of lut">nlut</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00257"></a>00257   <span class="keywordflow">if</span>( <a class="code" href="lspmac_8c.html#aeb09895663eff333b7a75acb319a9fc1" title="Front Light DAC.">flight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a7b43671f7f3e06521f6cf91fb9ac707d" title="lookup table (instead of u2c)">lut</a> == NULL) {
<a name="l00258"></a>00258     wprintw( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>, <span class="stringliteral">&quot;\nOut of memmory (lspg_flight_lut_cb)&quot;</span>);
<a name="l00259"></a>00259     wnoutrefresh( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>);
<a name="l00260"></a>00260     wnoutrefresh( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>);
<a name="l00261"></a>00261     doupdate();
<a name="l00262"></a>00262     pthread_mutex_unlock( &amp;(<a class="code" href="lspmac_8c.html#aeb09895663eff333b7a75acb319a9fc1" title="Front Light DAC.">flight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a188c5b1e991750ce2ffd53e0192e0907" title="coordinate waiting for motor to be done">mutex</a>));
<a name="l00263"></a>00263     <span class="keywordflow">return</span>;
<a name="l00264"></a>00264   }
<a name="l00265"></a>00265   
<a name="l00266"></a>00266   <span class="keywordflow">for</span>( i=0; i&lt;PQntuples( pgr); i++) {
<a name="l00267"></a>00267     <a class="code" href="lspmac_8c.html#aeb09895663eff333b7a75acb319a9fc1" title="Front Light DAC.">flight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a7b43671f7f3e06521f6cf91fb9ac707d" title="lookup table (instead of u2c)">lut</a>[i] = strtod( PQgetvalue( pgr, i, 0), NULL);
<a name="l00268"></a>00268   }
<a name="l00269"></a>00269 
<a name="l00270"></a>00270   pthread_mutex_unlock( &amp;(<a class="code" href="lspmac_8c.html#aeb09895663eff333b7a75acb319a9fc1" title="Front Light DAC.">flight</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a188c5b1e991750ce2ffd53e0192e0907" title="coordinate waiting for motor to be done">mutex</a>));
<a name="l00271"></a>00271 
<a name="l00272"></a>00272 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af6485ac1749c5de3008dd0e0badaa09c"></a><!-- doxytag: member="lspg.c::lspg_flush" ref="af6485ac1749c5de3008dd0e0badaa09c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_flush </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flush psql output buffer (ie, send the query). </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00924">924</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00924"></a>00924                   {
<a name="l00925"></a>00925   <span class="keywordtype">int</span> err;
<a name="l00926"></a>00926 
<a name="l00927"></a>00927   err = PQflush( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l00928"></a>00928   <span class="keywordflow">switch</span>( err) {
<a name="l00929"></a>00929   <span class="keywordflow">case</span> -1:
<a name="l00930"></a>00930     <span class="comment">// an error occured</span>
<a name="l00931"></a>00931 
<a name="l00932"></a>00932     pthread_mutex_lock( &amp;<a class="code" href="pgpmac_8c.html#ad128c64890c7c0d4f836d9ec6e99216a" title="allow more than one thread access to the screen">ncurses_mutex</a>);
<a name="l00933"></a>00933     wprintw( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>, <span class="stringliteral">&quot;\nflush failed: %s\n&quot;</span>, PQerrorMessage( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>));
<a name="l00934"></a>00934     wnoutrefresh( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>);
<a name="l00935"></a>00935     wnoutrefresh( <a class="code" href="pgpmac_8c.html#ab0487111dbe3c05d0bd835eb2fb9a3f7" title="place to put the cursor">term_input</a>);
<a name="l00936"></a>00936     doupdate();
<a name="l00937"></a>00937     pthread_mutex_unlock( &amp;<a class="code" href="pgpmac_8c.html#ad128c64890c7c0d4f836d9ec6e99216a" title="allow more than one thread access to the screen">ncurses_mutex</a>);
<a name="l00938"></a>00938 
<a name="l00939"></a>00939     <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#aaf1dd8ba4dafb91c296554c4cbf312e3">LS_PG_STATE_IDLE</a>;
<a name="l00940"></a>00940     <span class="comment">//</span>
<a name="l00941"></a>00941     <span class="comment">// We should probably reset the connection and start from scratch.  Probably the connection died.</span>
<a name="l00942"></a>00942     <span class="comment">//</span>
<a name="l00943"></a>00943     <span class="keywordflow">break</span>;
<a name="l00944"></a>00944           
<a name="l00945"></a>00945   <span class="keywordflow">case</span> 0:
<a name="l00946"></a>00946     <span class="comment">// goodness and joy.</span>
<a name="l00947"></a>00947     <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#a373e668840b4795ff9a71bc3f744d209">LS_PG_STATE_RECV</a>;
<a name="l00948"></a>00948     <span class="keywordflow">break</span>;
<a name="l00949"></a>00949 
<a name="l00950"></a>00950   <span class="keywordflow">case</span> 1:
<a name="l00951"></a>00951     <span class="comment">// more sending to do</span>
<a name="l00952"></a>00952     <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#a88a7e80c12fb0449c4b0857a0c7deb21">LS_PG_STATE_SEND_FLUSH</a>;
<a name="l00953"></a>00953     <span class="keywordflow">break</span>;
<a name="l00954"></a>00954   }
<a name="l00955"></a>00955 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8184824f2b71b1d35141d7922ca69cd7"></a><!-- doxytag: member="lspg.c::lspg_getcenter_cb" ref="a8184824f2b71b1d35141d7922ca69cd7" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_getcenter_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: implement getcenter code. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00856">856</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00856"></a>00856                                                                 {
<a name="l00857"></a>00857   <span class="keywordtype">int</span> theZoom;
<a name="l00858"></a>00858   <span class="keywordtype">double</span> dxp, dyp, z, b;
<a name="l00859"></a>00859   <span class="comment">// Need camera pixel height and pixel width!</span>
<a name="l00860"></a>00860 
<a name="l00861"></a>00861 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8a77972df14166e05c94ed0792baa09b"></a><!-- doxytag: member="lspg.c::lspg_init" ref="a8a77972df14166e05c94ed0792baa09b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initiallize the lspg module. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01451">1451</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01451"></a>01451                  {
<a name="l01452"></a>01452   pthread_mutex_init( &amp;<a class="code" href="lspg_8c.html#a3d49c5147ca0e5634c382ef71c4ae24e" title="keep the queue from getting tangled">pg_queue_mutex</a>, NULL);
<a name="l01453"></a>01453   <a class="code" href="lspg_8c.html#aff91db7d60e6c832684c023813e36dbf" title="Initialize the nextshot variable, mutex, and condition.">lspg_nextshot_init</a>();
<a name="l01454"></a>01454   <a class="code" href="lspg_8c.html#a3517f8fbed91c998f6036284f9bd0c48" title="initialize the detector timing object">lspg_wait_for_detector_init</a>();
<a name="l01455"></a>01455   <a class="code" href="lspg_8c.html#a39bb94f8e0d47702b2b920a3dee61ebc" title="initialize the diffractometer locking object">lspg_lock_diffractometer_init</a>();
<a name="l01456"></a>01456   <a class="code" href="lspg_8c.html#a0e9bbf847dadfe0d10830d67824d9be8" title="Initialize detector lock object.">lspg_lock_detector_init</a>();
<a name="l01457"></a>01457 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a329a7fdfa5025a403ea2779e178fd3ed"></a><!-- doxytag: member="lspg.c::lspg_init_motors_cb" ref="a329a7fdfa5025a403ea2779e178fd3ed" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_init_motors_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Motor initialization callback. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>qqp</em>&nbsp;</td><td>The query queue item used to call us </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pgr</em>&nbsp;</td><td>The postgresql result object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00167">167</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00170"></a>00170                            {
<a name="l00171"></a>00171   <span class="keywordtype">int</span> i, j;
<a name="l00172"></a>00172   uint32_t  motor_number, motor_number_column, max_speed_column, max_accel_column;
<a name="l00173"></a>00173   uint32_t units_column;
<a name="l00174"></a>00174   uint32_t u2c_column;
<a name="l00175"></a>00175   uint32_t format_column;
<a name="l00176"></a>00176   <span class="keywordtype">char</span> *sp;
<a name="l00177"></a>00177   <a class="code" href="structlspmac__motor__struct.html" title="Motor information.">lspmac_motor_t</a> *lsdp;
<a name="l00178"></a>00178   
<a name="l00179"></a>00179   motor_number_column    = PQfnumber( pgr, <span class="stringliteral">&quot;mm_motor&quot;</span>);
<a name="l00180"></a>00180   units_column           = PQfnumber( pgr, <span class="stringliteral">&quot;mm_unit&quot;</span>);
<a name="l00181"></a>00181   u2c_column             = PQfnumber( pgr, <span class="stringliteral">&quot;mm_u2c&quot;</span>);
<a name="l00182"></a>00182   format_column          = PQfnumber( pgr, <span class="stringliteral">&quot;mm_printf&quot;</span>);
<a name="l00183"></a>00183   max_speed_column = PQfnumber( pgr, <span class="stringliteral">&quot;mm_max_speed&quot;</span>);
<a name="l00184"></a>00184   max_accel_column = PQfnumber( pgr, <span class="stringliteral">&quot;mm_max_speed&quot;</span>);
<a name="l00185"></a>00185 
<a name="l00186"></a>00186   <span class="keywordflow">if</span>( motor_number_column == -1 || units_column == -1 || u2c_column == -1 || format_column == -1)
<a name="l00187"></a>00187     <span class="keywordflow">return</span>;
<a name="l00188"></a>00188 
<a name="l00189"></a>00189   <span class="keywordflow">for</span>( i=0; i&lt;PQntuples( pgr); i++) {
<a name="l00190"></a>00190 
<a name="l00191"></a>00191     motor_number = atoi(PQgetvalue( pgr, i, motor_number_column));
<a name="l00192"></a>00192 
<a name="l00193"></a>00193     lsdp = NULL;
<a name="l00194"></a>00194     <span class="keywordflow">for</span>( j=0; j&lt;<a class="code" href="lspmac_8c.html#a56260f012c50a591ee7f97e500f16994" title="The number of motors we manage.">lspmac_nmotors</a>; j++) {
<a name="l00195"></a>00195       <span class="keywordflow">if</span>( <a class="code" href="lspmac_8c.html#a9bffbf72495499b505543cd942f665da" title="All our motors.">lspmac_motors</a>[j].motor_num == motor_number) {
<a name="l00196"></a>00196         lsdp = &amp;(<a class="code" href="lspmac_8c.html#a9bffbf72495499b505543cd942f665da" title="All our motors.">lspmac_motors</a>[j]);
<a name="l00197"></a>00197         lsdp-&gt;<a class="code" href="structlspmac__motor__struct.html#a82bceff2ae698b4b9618360b446aec08" title="string to use as the units">units</a> = strdup( PQgetvalue( pgr, i, units_column));
<a name="l00198"></a>00198         lsdp-&gt;<a class="code" href="structlspmac__motor__struct.html#aba3d9d00271187128506bbbb1d77da19" title="printf format">format</a>= strdup( PQgetvalue( pgr, i, format_column));
<a name="l00199"></a>00199         lsdp-&gt;<a class="code" href="structlspmac__motor__struct.html#a61415627ab2dc0f438b190d117e532db" title="conversion from counts to units: 0.0 means not loaded yet">u2c</a>   = atof(PQgetvalue( pgr, i, u2c_column));
<a name="l00200"></a>00200         lsdp-&gt;<a class="code" href="structlspmac__motor__struct.html#af27159eeef80e4438446e01f24fae9d5" title="our maximum speed (cts/msec)">max_speed</a> = atof(PQgetvalue( pgr, i, max_speed_column));
<a name="l00201"></a>00201         lsdp-&gt;<a class="code" href="structlspmac__motor__struct.html#afec8dc1d4b97ba9c1d6e4f7a088342e4" title="our maximum acceleration (cts/msec^2)">max_accel</a> = atof(PQgetvalue( pgr, i, max_accel_column));
<a name="l00202"></a>00202         <span class="keywordflow">break</span>;
<a name="l00203"></a>00203       }
<a name="l00204"></a>00204     }
<a name="l00205"></a>00205     <span class="keywordflow">if</span>( lsdp == NULL)
<a name="l00206"></a>00206       <span class="keywordflow">continue</span>;
<a name="l00207"></a>00207       
<a name="l00208"></a>00208 
<a name="l00209"></a>00209     <span class="keywordflow">if</span>( fabs(lsdp-&gt;<a class="code" href="structlspmac__motor__struct.html#a61415627ab2dc0f438b190d117e532db" title="conversion from counts to units: 0.0 means not loaded yet">u2c</a>) &lt;= 1.0e-9)
<a name="l00210"></a>00210       lsdp-&gt;<a class="code" href="structlspmac__motor__struct.html#a61415627ab2dc0f438b190d117e532db" title="conversion from counts to units: 0.0 means not loaded yet">u2c</a> = 1.0;
<a name="l00211"></a>00211       
<a name="l00212"></a>00212   }
<a name="l00213"></a>00213 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aff93d2f5ac31aa249a0bef40a3837c84"></a><!-- doxytag: member="lspg.c::lspg_lock_detector_all" ref="aff93d2f5ac31aa249a0bef40a3837c84" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_detector_all </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detector lock convinence function. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00768">768</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00768"></a>00768                               {
<a name="l00769"></a>00769   <a class="code" href="lspg_8c.html#a5f71a20cc297684b2afe28e7bd8e8383" title="Request (demand) a detector lock.">lspg_lock_detector_call</a>();
<a name="l00770"></a>00770   <a class="code" href="lspg_8c.html#ad3d9c56bd3ca6bcc43db30872cc441cc" title="Wait for the detector lock.">lspg_lock_detector_wait</a>();
<a name="l00771"></a>00771   <a class="code" href="lspg_8c.html#a1b567040693ff6e2932a2477045d75fa" title="Finish waiting.">lspg_lock_detector_done</a>();
<a name="l00772"></a>00772 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5f71a20cc297684b2afe28e7bd8e8383"></a><!-- doxytag: member="lspg.c::lspg_lock_detector_call" ref="a5f71a20cc297684b2afe28e7bd8e8383" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_detector_call </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request (demand) a detector lock. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00744">744</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00744"></a>00744                                {
<a name="l00745"></a>00745   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#ab5ab5534b376a8fbafdd0b54cec4483c">mutex</a>));
<a name="l00746"></a>00746   <a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#a62373414b815fe178edd8522b3bd4d78">new_value_ready</a> = 0;
<a name="l00747"></a>00747   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#ab5ab5534b376a8fbafdd0b54cec4483c">mutex</a>));
<a name="l00748"></a>00748 
<a name="l00749"></a>00749   <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#aa760191c2b443170cebbcbf5ea5345f3" title="Callback for when the detector lock has be grabbed.">lspg_lock_detector_cb</a>, <span class="stringliteral">&quot;SELECT px.lock_detector()&quot;</span>);
<a name="l00750"></a>00750 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa760191c2b443170cebbcbf5ea5345f3"></a><!-- doxytag: member="lspg.c::lspg_lock_detector_cb" ref="aa760191c2b443170cebbcbf5ea5345f3" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_detector_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback for when the detector lock has be grabbed. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00735">735</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00735"></a>00735                                                                     {
<a name="l00736"></a>00736   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#ab5ab5534b376a8fbafdd0b54cec4483c">mutex</a>));
<a name="l00737"></a>00737   <a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#a62373414b815fe178edd8522b3bd4d78">new_value_ready</a> = 1;
<a name="l00738"></a>00738   pthread_cond_signal( &amp;(<a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#adc90c859665dccc8717219e824cba0b8">cond</a>));
<a name="l00739"></a>00739   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#ab5ab5534b376a8fbafdd0b54cec4483c">mutex</a>));
<a name="l00740"></a>00740 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1b567040693ff6e2932a2477045d75fa"></a><!-- doxytag: member="lspg.c::lspg_lock_detector_done" ref="a1b567040693ff6e2932a2477045d75fa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_detector_done </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finish waiting. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00762">762</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00762"></a>00762                                {
<a name="l00763"></a>00763   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#ab5ab5534b376a8fbafdd0b54cec4483c">mutex</a>));
<a name="l00764"></a>00764 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0e9bbf847dadfe0d10830d67824d9be8"></a><!-- doxytag: member="lspg.c::lspg_lock_detector_init" ref="a0e9bbf847dadfe0d10830d67824d9be8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_detector_init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize detector lock object. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00727">727</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00727"></a>00727                                {
<a name="l00728"></a>00728   <a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#a62373414b815fe178edd8522b3bd4d78">new_value_ready</a> = 0;
<a name="l00729"></a>00729   pthread_mutex_init( &amp;(<a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#ab5ab5534b376a8fbafdd0b54cec4483c">mutex</a>), NULL);
<a name="l00730"></a>00730   pthread_cond_init(  &amp;(<a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#adc90c859665dccc8717219e824cba0b8">cond</a>),  NULL);
<a name="l00731"></a>00731 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad3d9c56bd3ca6bcc43db30872cc441cc"></a><!-- doxytag: member="lspg.c::lspg_lock_detector_wait" ref="ad3d9c56bd3ca6bcc43db30872cc441cc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_detector_wait </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for the detector lock. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00754">754</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00754"></a>00754                                {
<a name="l00755"></a>00755   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#ab5ab5534b376a8fbafdd0b54cec4483c">mutex</a>));
<a name="l00756"></a>00756   <span class="keywordflow">while</span>( <a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#a62373414b815fe178edd8522b3bd4d78">new_value_ready</a> == 0)
<a name="l00757"></a>00757     pthread_cond_wait( &amp;(<a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#adc90c859665dccc8717219e824cba0b8">cond</a>), &amp;(<a class="code" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a>.<a class="code" href="structlspg__lock__detector__struct.html#ab5ab5534b376a8fbafdd0b54cec4483c">mutex</a>));
<a name="l00758"></a>00758 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a88b33e75c42197740b157a51ea726f21"></a><!-- doxytag: member="lspg.c::lspg_lock_diffractometer_all" ref="a88b33e75c42197740b157a51ea726f21" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_diffractometer_all </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convience function that combines lock diffractometer calls. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00709">709</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00709"></a>00709                                     {
<a name="l00710"></a>00710   <a class="code" href="lspg_8c.html#ac5ebeb38e8e9926a52f024fe76201175" title="Request that the database grab the diffractometer lock.">lspg_lock_diffractometer_call</a>();
<a name="l00711"></a>00711   <a class="code" href="lspg_8c.html#a8445e1dec753f2c517b87fcb9c5b5943" title="Wait for the diffractometer lock.">lspg_lock_diffractometer_wait</a>();
<a name="l00712"></a>00712   <a class="code" href="lspg_8c.html#a88b33e75c42197740b157a51ea726f21" title="Convience function that combines lock diffractometer calls.">lspg_lock_diffractometer_all</a>();
<a name="l00713"></a>00713 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac5ebeb38e8e9926a52f024fe76201175"></a><!-- doxytag: member="lspg.c::lspg_lock_diffractometer_call" ref="ac5ebeb38e8e9926a52f024fe76201175" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_diffractometer_call </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request that the database grab the diffractometer lock. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00685">685</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00685"></a>00685                                      {
<a name="l00686"></a>00686   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#a362e848dfd1551428b8d12d8776fd2ed">mutex</a>));
<a name="l00687"></a>00687   <a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#ae94acdf44008ce48930e3083f08f5b6c">new_value_ready</a> = 0;
<a name="l00688"></a>00688   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#a362e848dfd1551428b8d12d8776fd2ed">mutex</a>));
<a name="l00689"></a>00689 
<a name="l00690"></a>00690   <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#aad4f378f37c0030634dafa0d9445d916" title="Callback routine for a lock diffractometer query.">lspg_lock_diffractometer_cb</a>, <span class="stringliteral">&quot;SELECT px.lock_diffractomter()&quot;</span>);
<a name="l00691"></a>00691 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aad4f378f37c0030634dafa0d9445d916"></a><!-- doxytag: member="lspg.c::lspg_lock_diffractometer_cb" ref="aad4f378f37c0030634dafa0d9445d916" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_diffractometer_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback routine for a lock diffractometer query. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00676">676</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00676"></a>00676                                                                           {
<a name="l00677"></a>00677   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#a362e848dfd1551428b8d12d8776fd2ed">mutex</a>));
<a name="l00678"></a>00678   <a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#ae94acdf44008ce48930e3083f08f5b6c">new_value_ready</a> = 1;
<a name="l00679"></a>00679   pthread_cond_signal( &amp;(<a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#a7614c802af37c1d3358479a2c13ac898">cond</a>));
<a name="l00680"></a>00680   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#a362e848dfd1551428b8d12d8776fd2ed">mutex</a>));
<a name="l00681"></a>00681 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a75aaf0b3fe33530062226c69a33ce821"></a><!-- doxytag: member="lspg.c::lspg_lock_diffractometer_done" ref="a75aaf0b3fe33530062226c69a33ce821" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_diffractometer_done </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finish up the lock diffractometer call. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00703">703</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00703"></a>00703                                      {
<a name="l00704"></a>00704   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#a362e848dfd1551428b8d12d8776fd2ed">mutex</a>));
<a name="l00705"></a>00705 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a39bb94f8e0d47702b2b920a3dee61ebc"></a><!-- doxytag: member="lspg.c::lspg_lock_diffractometer_init" ref="a39bb94f8e0d47702b2b920a3dee61ebc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_diffractometer_init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>initialize the diffractometer locking object </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00668">668</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00668"></a>00668                                      {
<a name="l00669"></a>00669   <a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#ae94acdf44008ce48930e3083f08f5b6c">new_value_ready</a> = 0;
<a name="l00670"></a>00670   pthread_mutex_init( &amp;(<a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#a362e848dfd1551428b8d12d8776fd2ed">mutex</a>), NULL);
<a name="l00671"></a>00671   pthread_cond_init(  &amp;(<a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#a7614c802af37c1d3358479a2c13ac898">cond</a>), NULL);
<a name="l00672"></a>00672 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8445e1dec753f2c517b87fcb9c5b5943"></a><!-- doxytag: member="lspg.c::lspg_lock_diffractometer_wait" ref="a8445e1dec753f2c517b87fcb9c5b5943" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_lock_diffractometer_wait </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for the diffractometer lock. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00695">695</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00695"></a>00695                                      {
<a name="l00696"></a>00696   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#a362e848dfd1551428b8d12d8776fd2ed">mutex</a>));
<a name="l00697"></a>00697   <span class="keywordflow">while</span>( <a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#ae94acdf44008ce48930e3083f08f5b6c">new_value_ready</a> == 0)
<a name="l00698"></a>00698     pthread_cond_wait( &amp;(<a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#a7614c802af37c1d3358479a2c13ac898">cond</a>), &amp;(<a class="code" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a>.<a class="code" href="structlspg__lock__diffractometer__struct.html#a362e848dfd1551428b8d12d8776fd2ed">mutex</a>));
<a name="l00699"></a>00699 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab52a8c8245bf6561f40c0f224fc07ff4"></a><!-- doxytag: member="lspg.c::lspg_next_state" ref="ab52a8c8245bf6561f40c0f224fc07ff4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_next_state </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements our state machine Does not strictly only set the next state as it also calls some functions that, perhaps, alters the state mid-function. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01315">1315</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01315"></a>01315                        {
<a name="l01316"></a>01316   <span class="comment">//</span>
<a name="l01317"></a>01317   <span class="comment">// connect to the database</span>
<a name="l01318"></a>01318   <span class="comment">//</span>
<a name="l01319"></a>01319   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a> == NULL ||
<a name="l01320"></a>01320       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#af443092447378c73bf93aa143576aba4">LS_PG_STATE_INIT</a> ||
<a name="l01321"></a>01321       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#accda8c3a598dc7f5b107b04986d8ab50">LS_PG_STATE_RESET</a> ||
<a name="l01322"></a>01322       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#ae7ea5876846b5f04c419aee22d3c0aa1">LS_PG_STATE_INIT_POLL</a> ||
<a name="l01323"></a>01323       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#ac70a1141f3b138055ea7143bd493187c">LS_PG_STATE_RESET_POLL</a>)
<a name="l01324"></a>01324     <a class="code" href="lspg_8c.html#a581c18be0368425665a40b4b7f7d9714" title="Connect to the pg server.">lspg_pg_connect</a>( <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>);
<a name="l01325"></a>01325 
<a name="l01326"></a>01326 
<a name="l01327"></a>01327   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#aaf1dd8ba4dafb91c296554c4cbf312e3">LS_PG_STATE_IDLE</a> &amp;&amp; <a class="code" href="lspg_8c.html#a3cbe7f3161b3c1838ebc56a3bbcfd8a6" title="Next position to add something to the queue.">lspg_query_queue_on</a> != <a class="code" href="lspg_8c.html#aca86bb77d6cecfae9251743f4171bafb" title="The last item still being used (on == off means nothing in queue).">lspg_query_queue_off</a>)
<a name="l01328"></a>01328     <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#a3c6eb19f262a990e1f9ba630d9edc309">LS_PG_STATE_SEND</a>;
<a name="l01329"></a>01329 
<a name="l01330"></a>01330   <span class="keywordflow">switch</span>( <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a>) {
<a name="l01331"></a>01331   <span class="keywordflow">case</span> <a class="code" href="lspg_8c.html#ae7ea5876846b5f04c419aee22d3c0aa1">LS_PG_STATE_INIT_POLL</a>:
<a name="l01332"></a>01332     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a69ae04978986e6413ca7cefcb692b645" title="Used to determine state while connecting.">lspg_connectPoll_response</a> == PGRES_POLLING_WRITING)
<a name="l01333"></a>01333       <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.events = POLLOUT;
<a name="l01334"></a>01334     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a69ae04978986e6413ca7cefcb692b645" title="Used to determine state while connecting.">lspg_connectPoll_response</a> == PGRES_POLLING_READING)
<a name="l01335"></a>01335       <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.events = POLLIN;
<a name="l01336"></a>01336     <span class="keywordflow">else</span>
<a name="l01337"></a>01337       <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.events = 0;
<a name="l01338"></a>01338     <span class="keywordflow">break</span>;
<a name="l01339"></a>01339       
<a name="l01340"></a>01340   <span class="keywordflow">case</span> <a class="code" href="lspg_8c.html#ac70a1141f3b138055ea7143bd493187c">LS_PG_STATE_RESET_POLL</a>:
<a name="l01341"></a>01341     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a06c5a937e41a6c706a247777642ec1fb" title="Used to determine state while reconnecting.">lspg_resetPoll_response</a> == PGRES_POLLING_WRITING)
<a name="l01342"></a>01342       <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.events = POLLOUT;
<a name="l01343"></a>01343     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a06c5a937e41a6c706a247777642ec1fb" title="Used to determine state while reconnecting.">lspg_resetPoll_response</a> == PGRES_POLLING_READING)
<a name="l01344"></a>01344       <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.events = POLLIN;
<a name="l01345"></a>01345     <span class="keywordflow">else</span>
<a name="l01346"></a>01346       <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.events = 0;
<a name="l01347"></a>01347     <span class="keywordflow">break</span>;
<a name="l01348"></a>01348 
<a name="l01349"></a>01349   <span class="keywordflow">case</span> <a class="code" href="lspg_8c.html#aaf1dd8ba4dafb91c296554c4cbf312e3">LS_PG_STATE_IDLE</a>:
<a name="l01350"></a>01350   <span class="keywordflow">case</span> <a class="code" href="lspg_8c.html#a373e668840b4795ff9a71bc3f744d209">LS_PG_STATE_RECV</a>:
<a name="l01351"></a>01351     <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.events = POLLIN;
<a name="l01352"></a>01352     <span class="keywordflow">break</span>;
<a name="l01353"></a>01353 
<a name="l01354"></a>01354   <span class="keywordflow">case</span> <a class="code" href="lspg_8c.html#a3c6eb19f262a990e1f9ba630d9edc309">LS_PG_STATE_SEND</a>:
<a name="l01355"></a>01355   <span class="keywordflow">case</span> <a class="code" href="lspg_8c.html#a88a7e80c12fb0449c4b0857a0c7deb21">LS_PG_STATE_SEND_FLUSH</a>:
<a name="l01356"></a>01356     <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.events = POLLOUT;
<a name="l01357"></a>01357     <span class="keywordflow">break</span>;
<a name="l01358"></a>01358 
<a name="l01359"></a>01359   <span class="keywordflow">default</span>:
<a name="l01360"></a>01360     <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.events = 0;
<a name="l01361"></a>01361   }
<a name="l01362"></a>01362 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aeda8dad89b03d7d61cc994dd63ee5db6"></a><!-- doxytag: member="lspg.c::lspg_nextaction_cb" ref="aeda8dad89b03d7d61cc994dd63ee5db6" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_nextaction_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Queue the next MD2 instruction. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>qqp</em>&nbsp;</td><td>The query that generated this result </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pgr</em>&nbsp;</td><td>The result </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00865">865</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00868"></a>00868                           {
<a name="l00869"></a>00869   <span class="keywordtype">char</span> *action;
<a name="l00870"></a>00870 
<a name="l00871"></a>00871   <span class="keywordflow">if</span>( PQntuples( pgr) &lt;= 0)
<a name="l00872"></a>00872     <span class="keywordflow">return</span>;             <span class="comment">// Note: nextaction should always return at least &quot;noAction&quot;, so this branch should never be taken</span>
<a name="l00873"></a>00873 
<a name="l00874"></a>00874   action = PQgetvalue( pgr, 0, 0);      <span class="comment">// next action only returns one row</span>
<a name="l00875"></a>00875 
<a name="l00876"></a>00876   <span class="keywordflow">if</span>( strcmp( action, <span class="stringliteral">&quot;noAction&quot;</span>) == 0)
<a name="l00877"></a>00877     <span class="keywordflow">return</span>;
<a name="l00878"></a>00878   
<a name="l00879"></a>00879   <span class="keywordflow">if</span>( pthread_mutex_trylock( &amp;<a class="code" href="md2cmds_8c.html#ad67304bb851dc6268b0cda2f40fc5aa8" title="mutex for the condition">md2cmds_mutex</a>) == 0) {
<a name="l00880"></a>00880     strncpy( <a class="code" href="md2cmds_8c.html#a5f0fe1e2dfa92cf345b8c29134ab1ede" title="our command;">md2cmds_cmd</a>, action, <a class="code" href="pgpmac_8h.html#a30f0f377b0f0695284145d420ea51846">MD2CMDS_CMD_LENGTH</a>-1);
<a name="l00881"></a>00881     <a class="code" href="md2cmds_8c.html#a5f0fe1e2dfa92cf345b8c29134ab1ede" title="our command;">md2cmds_cmd</a>[<a class="code" href="pgpmac_8h.html#a30f0f377b0f0695284145d420ea51846">MD2CMDS_CMD_LENGTH</a>-1] = 0;
<a name="l00882"></a>00882     pthread_cond_signal( &amp;<a class="code" href="md2cmds_8c.html#a08d5b18ec9478d753c46a3e28d1f2126" title="condition to signal when it&amp;#39;s time to run an md2 command">md2cmds_cond</a>);
<a name="l00883"></a>00883     pthread_mutex_unlock( &amp;<a class="code" href="md2cmds_8c.html#ad67304bb851dc6268b0cda2f40fc5aa8" title="mutex for the condition">md2cmds_mutex</a>);
<a name="l00884"></a>00884   } <span class="keywordflow">else</span> {
<a name="l00885"></a>00885     <span class="comment">//</span>
<a name="l00886"></a>00886     <span class="comment">// TODO:</span>
<a name="l00887"></a>00887     <span class="comment">// We should probably report that we aren&apos;t going to act</span>
<a name="l00888"></a>00888     <span class="comment">// on the requested action.  That code would go here.</span>
<a name="l00889"></a>00889     <span class="comment">//</span>
<a name="l00890"></a>00890   }
<a name="l00891"></a>00891 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af17ef79544ca5d78fd477010fe90d538"></a><!-- doxytag: member="lspg.c::lspg_nextshot_call" ref="af17ef79544ca5d78fd477010fe90d538" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_nextshot_call </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Queue up a nextshot query. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00568">568</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00568"></a>00568                           {
<a name="l00569"></a>00569   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a38b657155fbee9b73278f76912cf2333" title="Our mutex for sanity in the multi-threaded program.">mutex</a>));
<a name="l00570"></a>00570   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#adb8da14444b98f556dba9420dd4666dc" title="Our flag for the condition to wait for.">new_value_ready</a> = 0;
<a name="l00571"></a>00571   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a38b657155fbee9b73278f76912cf2333" title="Our mutex for sanity in the multi-threaded program.">mutex</a>));
<a name="l00572"></a>00572   
<a name="l00573"></a>00573   <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#a9e92a204f606761d368ac7e06ef0f09c" title="Next Shot Callback.">lspg_nextshot_cb</a>, <span class="stringliteral">&quot;SELECT * FROM px.nextshot()&quot;</span>);
<a name="l00574"></a>00574 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a9e92a204f606761d368ac7e06ef0f09c"></a><!-- doxytag: member="lspg.c::lspg_nextshot_cb" ref="a9e92a204f606761d368ac7e06ef0f09c" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_nextshot_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Next Shot Callback. </p>
<p>This is a long and tedious routine as there are a large number of variables returned. Suck it up. Return with the global variable lspg_nextshot set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>qqp</em>&nbsp;</td><td>Our nextshot query </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pgr</em>&nbsp;</td><td>result of the query </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00313">313</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00316"></a>00316                         {
<a name="l00317"></a>00317   <span class="keyword">static</span> <span class="keywordtype">int</span> got_col_nums=0;
<a name="l00318"></a>00318   <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00319"></a>00319     dsdir_c, dspid_c, dsowidth_c, dsoscaxis_c, dsexp_c, skey_c, sstart_c, sfn_c, dsphi_c,
<a name="l00320"></a>00320     dsomega_c, dskappa_c, dsdist_c, dsnrg_c, dshpid_c, cx_c, cy_c, ax_c, ay_c, az_c,
<a name="l00321"></a>00321     active_c, sindex_c, stype_c,
<a name="l00322"></a>00322     dsowidth2_c, dsoscaxis2_c, dsexp2_c, sstart2_c, dsphi2_c, dsomega2_c, dskappa2_c, dsdist2_c, dsnrg2_c,
<a name="l00323"></a>00323     cx2_c, cy2_c, ax2_c, ay2_c, az2_c, active2_c, sindex2_c, stype2_c;
<a name="l00324"></a>00324   
<a name="l00325"></a>00325   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a38b657155fbee9b73278f76912cf2333" title="Our mutex for sanity in the multi-threaded program.">mutex</a>));
<a name="l00326"></a>00326 
<a name="l00327"></a>00327   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#abc9242805729f70b83df79706c394c71" title="flag indicating that no rows were returned.">no_rows_returned</a> = PQntuples( pgr) &lt;= 0;
<a name="l00328"></a>00328   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#abc9242805729f70b83df79706c394c71" title="flag indicating that no rows were returned.">no_rows_returned</a>) {
<a name="l00329"></a>00329     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#adb8da14444b98f556dba9420dd4666dc" title="Our flag for the condition to wait for.">new_value_ready</a> = 1;
<a name="l00330"></a>00330     pthread_cond_signal( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#afc773a9eefc173aa98d5c2889e1d7669" title="Condition to wait for a response from our postgresql server.">cond</a>));
<a name="l00331"></a>00331     pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a38b657155fbee9b73278f76912cf2333" title="Our mutex for sanity in the multi-threaded program.">mutex</a>));
<a name="l00332"></a>00332     <span class="keywordflow">return</span>;                     <span class="comment">// I guess there was no shot after all</span>
<a name="l00333"></a>00333   }
<a name="l00334"></a>00334 
<a name="l00335"></a>00335   <span class="keywordflow">if</span>( got_col_nums == 0) {
<a name="l00336"></a>00336     dsdir_c      = PQfnumber( pgr, <span class="stringliteral">&quot;dsdir&quot;</span>);
<a name="l00337"></a>00337     dspid_c      = PQfnumber( pgr, <span class="stringliteral">&quot;dspid&quot;</span>);
<a name="l00338"></a>00338     dsowidth_c   = PQfnumber( pgr, <span class="stringliteral">&quot;dsowidth&quot;</span>);
<a name="l00339"></a>00339     dsoscaxis_c  = PQfnumber( pgr, <span class="stringliteral">&quot;dsoscaxis&quot;</span>);
<a name="l00340"></a>00340     dsexp_c      = PQfnumber( pgr, <span class="stringliteral">&quot;dsexp&quot;</span>);
<a name="l00341"></a>00341     skey_c       = PQfnumber( pgr, <span class="stringliteral">&quot;skey&quot;</span>);
<a name="l00342"></a>00342     sstart_c     = PQfnumber( pgr, <span class="stringliteral">&quot;sstart&quot;</span>);
<a name="l00343"></a>00343     sfn_c        = PQfnumber( pgr, <span class="stringliteral">&quot;sfn&quot;</span>);
<a name="l00344"></a>00344     dsphi_c      = PQfnumber( pgr, <span class="stringliteral">&quot;dsphi&quot;</span>);
<a name="l00345"></a>00345     dsomega_c    = PQfnumber( pgr, <span class="stringliteral">&quot;dsomega&quot;</span>);
<a name="l00346"></a>00346     dskappa_c    = PQfnumber( pgr, <span class="stringliteral">&quot;dskappa&quot;</span>);
<a name="l00347"></a>00347     dsdist_c     = PQfnumber( pgr, <span class="stringliteral">&quot;dsdist&quot;</span>);
<a name="l00348"></a>00348     dsnrg_c      = PQfnumber( pgr, <span class="stringliteral">&quot;dsnrg&quot;</span>);
<a name="l00349"></a>00349     dshpid_c     = PQfnumber( pgr, <span class="stringliteral">&quot;dshpid&quot;</span>);
<a name="l00350"></a>00350     cx_c         = PQfnumber( pgr, <span class="stringliteral">&quot;cx&quot;</span>);
<a name="l00351"></a>00351     cy_c         = PQfnumber( pgr, <span class="stringliteral">&quot;cy&quot;</span>);
<a name="l00352"></a>00352     ax_c         = PQfnumber( pgr, <span class="stringliteral">&quot;ax&quot;</span>);
<a name="l00353"></a>00353     ay_c         = PQfnumber( pgr, <span class="stringliteral">&quot;ay&quot;</span>);
<a name="l00354"></a>00354     az_c         = PQfnumber( pgr, <span class="stringliteral">&quot;az&quot;</span>);
<a name="l00355"></a>00355     active_c     = PQfnumber( pgr, <span class="stringliteral">&quot;active&quot;</span>);
<a name="l00356"></a>00356     sindex_c     = PQfnumber( pgr, <span class="stringliteral">&quot;sindex&quot;</span>);
<a name="l00357"></a>00357     stype_c      = PQfnumber( pgr, <span class="stringliteral">&quot;stype&quot;</span>);
<a name="l00358"></a>00358     dsowidth2_c  = PQfnumber( pgr, <span class="stringliteral">&quot;dsowidth2&quot;</span>);
<a name="l00359"></a>00359     dsoscaxis2_c = PQfnumber( pgr, <span class="stringliteral">&quot;dsoscaxis2&quot;</span>);
<a name="l00360"></a>00360     dsexp2_c     = PQfnumber( pgr, <span class="stringliteral">&quot;dsexp2&quot;</span>);
<a name="l00361"></a>00361     sstart2_c    = PQfnumber( pgr, <span class="stringliteral">&quot;sstart2&quot;</span>);
<a name="l00362"></a>00362     dsphi2_c     = PQfnumber( pgr, <span class="stringliteral">&quot;dsphi2&quot;</span>);
<a name="l00363"></a>00363     dsomega2_c   = PQfnumber( pgr, <span class="stringliteral">&quot;dsomega2&quot;</span>);
<a name="l00364"></a>00364     dskappa2_c   = PQfnumber( pgr, <span class="stringliteral">&quot;dskappa2&quot;</span>);
<a name="l00365"></a>00365     dsdist2_c    = PQfnumber( pgr, <span class="stringliteral">&quot;dsdist2&quot;</span>);
<a name="l00366"></a>00366     dsnrg2_c     = PQfnumber( pgr, <span class="stringliteral">&quot;dsnrg2&quot;</span>);
<a name="l00367"></a>00367     cx2_c        = PQfnumber( pgr, <span class="stringliteral">&quot;cx2&quot;</span>);
<a name="l00368"></a>00368     cy2_c        = PQfnumber( pgr, <span class="stringliteral">&quot;cy2&quot;</span>);
<a name="l00369"></a>00369     ax2_c        = PQfnumber( pgr, <span class="stringliteral">&quot;ax2&quot;</span>);
<a name="l00370"></a>00370     ay2_c        = PQfnumber( pgr, <span class="stringliteral">&quot;ay2&quot;</span>);
<a name="l00371"></a>00371     az2_c        = PQfnumber( pgr, <span class="stringliteral">&quot;az2&quot;</span>);
<a name="l00372"></a>00372     active2_c    = PQfnumber( pgr, <span class="stringliteral">&quot;active2&quot;</span>);
<a name="l00373"></a>00373     sindex2_c    = PQfnumber( pgr, <span class="stringliteral">&quot;sindex2&quot;</span>);
<a name="l00374"></a>00374     stype2_c     = PQfnumber( pgr, <span class="stringliteral">&quot;stype2&quot;</span>);
<a name="l00375"></a>00375     
<a name="l00376"></a>00376     got_col_nums = 1;
<a name="l00377"></a>00377   }
<a name="l00378"></a>00378 
<a name="l00379"></a>00379 
<a name="l00380"></a>00380   <span class="comment">//</span>
<a name="l00381"></a>00381   <span class="comment">// NULL string values come back as empty strings</span>
<a name="l00382"></a>00382   <span class="comment">// Mark the null flag but allocate the empty string anyway</span>
<a name="l00383"></a>00383   <span class="comment">//</span>
<a name="l00384"></a>00384 
<a name="l00385"></a>00385   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a8dea57b78b92d67d83ccbb6ed6da13ca">dsdir_isnull</a> = PQgetisnull( pgr, 0, dsdir_c);
<a name="l00386"></a>00386   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ac372e1774a25b3d4bfbb9169762eb39e" title="Directory for data relative to the ESAF home directory.">dsdir</a> != NULL)
<a name="l00387"></a>00387     free( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ac372e1774a25b3d4bfbb9169762eb39e" title="Directory for data relative to the ESAF home directory.">dsdir</a>);
<a name="l00388"></a>00388   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ac372e1774a25b3d4bfbb9169762eb39e" title="Directory for data relative to the ESAF home directory.">dsdir</a> = strdup( PQgetvalue( pgr, 0, dsdir_c));
<a name="l00389"></a>00389 
<a name="l00390"></a>00390   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a7665485395487756ab448d0c81c84d10">dspid_isnull</a> = PQgetisnull( pgr, 0, dspid_c);
<a name="l00391"></a>00391   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a4487e718c2b55a8ab9ebb18329574ae1" title="ID string identifying this dataset.">dspid</a> != NULL)
<a name="l00392"></a>00392     free( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a4487e718c2b55a8ab9ebb18329574ae1" title="ID string identifying this dataset.">dspid</a>);
<a name="l00393"></a>00393   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a4487e718c2b55a8ab9ebb18329574ae1" title="ID string identifying this dataset.">dspid</a> = strdup( PQgetvalue( pgr, 0, dspid_c));
<a name="l00394"></a>00394 
<a name="l00395"></a>00395   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a51a26391afcacfb4c946fb9e8e9ab6b0">dsoscaxis_isnull</a> = PQgetisnull( pgr, 0, dsoscaxis_c);
<a name="l00396"></a>00396   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a9a62c304e66013e8e5e5618a44f0b6d4" title="dataset defined oscillation axis (always omega)">dsoscaxis</a> != NULL)
<a name="l00397"></a>00397     free( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a9a62c304e66013e8e5e5618a44f0b6d4" title="dataset defined oscillation axis (always omega)">dsoscaxis</a>);
<a name="l00398"></a>00398   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a9a62c304e66013e8e5e5618a44f0b6d4" title="dataset defined oscillation axis (always omega)">dsoscaxis</a> = strdup( PQgetvalue( pgr, 0, dsoscaxis_c));
<a name="l00399"></a>00399 
<a name="l00400"></a>00400   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a98e280e99ae847559bb82836df3c32d1">dsoscaxis2_isnull</a> = PQgetisnull( pgr, 0, dsoscaxis2_c);
<a name="l00401"></a>00401   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ac86005a6e90ff502da9e95b59d0b7a5f" title="next image ascillation axis (always &amp;quot;omega&amp;quot;)">dsoscaxis2</a> != NULL)
<a name="l00402"></a>00402     free( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ac86005a6e90ff502da9e95b59d0b7a5f" title="next image ascillation axis (always &amp;quot;omega&amp;quot;)">dsoscaxis2</a>);
<a name="l00403"></a>00403   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ac86005a6e90ff502da9e95b59d0b7a5f" title="next image ascillation axis (always &amp;quot;omega&amp;quot;)">dsoscaxis2</a> = strdup( PQgetvalue( pgr, 0, dsoscaxis2_c));
<a name="l00404"></a>00404 
<a name="l00405"></a>00405   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a56f32eb413b1fca9f085874eb86294de">sfn_isnull</a> = PQgetisnull(pgr, 0, sfn_c);
<a name="l00406"></a>00406   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a03252bba597b081edc9d08b20b558cc7" title="file name">sfn</a> != NULL)
<a name="l00407"></a>00407     free( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a03252bba597b081edc9d08b20b558cc7" title="file name">sfn</a>);
<a name="l00408"></a>00408   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a03252bba597b081edc9d08b20b558cc7" title="file name">sfn</a> = strdup( PQgetvalue( pgr, 0, sfn_c));
<a name="l00409"></a>00409 
<a name="l00410"></a>00410   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a79f48c452a4aca8506bae22f897c7441">stype_isnull</a> = PQgetisnull( pgr, 0, stype_c);
<a name="l00411"></a>00411   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ab5a70b189c2fe516ca0c84bd06f3e564" title="&amp;quot;Normal&amp;quot; or &amp;quot;Gridsearch&amp;quot;">stype</a> != NULL)
<a name="l00412"></a>00412     free( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ab5a70b189c2fe516ca0c84bd06f3e564" title="&amp;quot;Normal&amp;quot; or &amp;quot;Gridsearch&amp;quot;">stype</a>);
<a name="l00413"></a>00413   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ab5a70b189c2fe516ca0c84bd06f3e564" title="&amp;quot;Normal&amp;quot; or &amp;quot;Gridsearch&amp;quot;">stype</a> = strdup( PQgetvalue( pgr, 0, stype_c));
<a name="l00414"></a>00414 
<a name="l00415"></a>00415   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a203e29ed0bb403aaab6d7f95f690cc0d">stype2_isnull</a> = PQgetisnull( pgr, 0, stype2_c);
<a name="l00416"></a>00416   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ae08ef74ea76e6e099a3ff6c7f845d337" title="next image type (&amp;quot;Normal&amp;quot; or &amp;quot;Gridsearch&amp;quot;)">stype2</a> != NULL)
<a name="l00417"></a>00417     free( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ae08ef74ea76e6e099a3ff6c7f845d337" title="next image type (&amp;quot;Normal&amp;quot; or &amp;quot;Gridsearch&amp;quot;)">stype2</a>);
<a name="l00418"></a>00418   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ae08ef74ea76e6e099a3ff6c7f845d337" title="next image type (&amp;quot;Normal&amp;quot; or &amp;quot;Gridsearch&amp;quot;)">stype2</a> = strdup( PQgetvalue( pgr, 0, stype2_c));
<a name="l00419"></a>00419 
<a name="l00420"></a>00420   <span class="comment">//</span>
<a name="l00421"></a>00421   <span class="comment">// Probably shouldn&apos;t try to convert null number values</span>
<a name="l00422"></a>00422   <span class="comment">//</span>
<a name="l00423"></a>00423   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a5dd3db64790e09bc03499e521bbaa126">dsowidth_isnull</a> = PQgetisnull( pgr, 0, dsowidth_c);
<a name="l00424"></a>00424   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a5dd3db64790e09bc03499e521bbaa126">dsowidth_isnull</a> == 0)
<a name="l00425"></a>00425     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ad5a8f568a04aa6a13767933062b28f19" title="dataset defined oscillation width">dsowidth</a> = atof( PQgetvalue( pgr,0, dsowidth_c));
<a name="l00426"></a>00426 
<a name="l00427"></a>00427   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ae07498f62ea9c0e2f702b78c87500794">dsexp_isnull</a> = PQgetisnull( pgr, 0, dsexp_c);
<a name="l00428"></a>00428   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ae07498f62ea9c0e2f702b78c87500794">dsexp_isnull</a> == 0)
<a name="l00429"></a>00429     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a063e4c99201a763c2eb048acfc855efa" title="dataset defined exposure time">dsexp</a>    = atof( PQgetvalue( pgr,0, dsexp_c));
<a name="l00430"></a>00430 
<a name="l00431"></a>00431   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#aa53094de91e2f69d7174ab119df1cdac">sstart_isnull</a> = PQgetisnull( pgr, 0, sstart_c);
<a name="l00432"></a>00432   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#aa53094de91e2f69d7174ab119df1cdac">sstart_isnull</a> == 0)
<a name="l00433"></a>00433     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a8dc11eaa094d59f61642c4abc226918f" title="starting angle">sstart</a>   = atof( PQgetvalue( pgr,0, sstart_c));
<a name="l00434"></a>00434 
<a name="l00435"></a>00435   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a2d1f51cb1bb575a214344773136be878">dsphi_isnull</a> = PQgetisnull( pgr, 0, dsphi_c);
<a name="l00436"></a>00436   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a2d1f51cb1bb575a214344773136be878">dsphi_isnull</a> == 0)
<a name="l00437"></a>00437     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a64ebde597ca97a3b98145dc2d580c64f" title="dataset defined starting phi angle">dsphi</a>    = atof( PQgetvalue( pgr,0, dsphi_c));
<a name="l00438"></a>00438 
<a name="l00439"></a>00439   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ad1da3548dc642d415aed53dc165c44fc">dsomega_isnull</a> = PQgetisnull( pgr, 0, dsomega_c);
<a name="l00440"></a>00440   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ad1da3548dc642d415aed53dc165c44fc">dsomega_isnull</a> == 0)
<a name="l00441"></a>00441     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a4be525bb32fb0232c21a91529f1e8c73" title="dataset defined starting omega angle">dsomega</a>  = atof( PQgetvalue( pgr,0, dsomega_c));
<a name="l00442"></a>00442 
<a name="l00443"></a>00443   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a1686a72509cc1c3383ee95a790ddff14">dskappa_isnull</a> = PQgetisnull( pgr, 0, dskappa_c);
<a name="l00444"></a>00444   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a1686a72509cc1c3383ee95a790ddff14">dskappa_isnull</a> == 0)
<a name="l00445"></a>00445     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a59355281e8eb935cd7bfac597fdc5289" title="dataset defined starting kappa angle">dskappa</a>  = atof( PQgetvalue( pgr,0, dskappa_c));
<a name="l00446"></a>00446 
<a name="l00447"></a>00447   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ac6f2bdc7b023d933509bf74af7b169f9">dsdist_isnull</a> = PQgetisnull( pgr, 0, dsdist_c);
<a name="l00448"></a>00448   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ac6f2bdc7b023d933509bf74af7b169f9">dsdist_isnull</a> == 0)
<a name="l00449"></a>00449     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#acab9431a911f5bb11296cbfb271fb83a" title="dataset defined detector distance">dsdist</a>   = atof( PQgetvalue( pgr,0, dsdist_c));
<a name="l00450"></a>00450 
<a name="l00451"></a>00451   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ad14d8bb50290ec12e58f4aaec5cc5aab">dsnrg_isnull</a> = PQgetisnull( pgr, 0, dsnrg_c);
<a name="l00452"></a>00452   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ad14d8bb50290ec12e58f4aaec5cc5aab">dsnrg_isnull</a> == 0)
<a name="l00453"></a>00453     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a371e574055fec7660b8f2e637eaf9f25" title="dataset defined energy">dsnrg</a>    = atof( PQgetvalue( pgr,0, dsnrg_c));
<a name="l00454"></a>00454 
<a name="l00455"></a>00455   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a779b99533f0ed4e659177afb0b791ad2">cx_isnull</a> = PQgetisnull( pgr, 0, cx_c);
<a name="l00456"></a>00456   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a779b99533f0ed4e659177afb0b791ad2">cx_isnull</a> == 0)
<a name="l00457"></a>00457     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ad9eb2013fa6f295f72f0891fe98c863f" title="centering table x position">cx</a>       = atof( PQgetvalue( pgr,0, cx_c));
<a name="l00458"></a>00458 
<a name="l00459"></a>00459   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a3895d645420848aed05b95694ec8c6c7">cy_isnull</a> = PQgetisnull( pgr, 0, cy_c);
<a name="l00460"></a>00460   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a3895d645420848aed05b95694ec8c6c7">cy_isnull</a> == 0)
<a name="l00461"></a>00461     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ab7a7b37a17f06c4e9ebdcdf056946098" title="centering table y position">cy</a>       = atof( PQgetvalue( pgr,0, cy_c));
<a name="l00462"></a>00462 
<a name="l00463"></a>00463   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#aae46c7911b2b218497ad4a68f3dbb7d9">ax_isnull</a> = PQgetisnull( pgr, 0, ax_c);
<a name="l00464"></a>00464   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#aae46c7911b2b218497ad4a68f3dbb7d9">ax_isnull</a> == 0)
<a name="l00465"></a>00465     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a7f57874223897ab7d9c7531a9522904d" title="alignment table x position">ax</a>       = atof( PQgetvalue( pgr,0, ax_c));
<a name="l00466"></a>00466 
<a name="l00467"></a>00467   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a9da91abc8090532ed98ccd47a3bab775">ay_isnull</a> = PQgetisnull( pgr, 0, ay_c);
<a name="l00468"></a>00468   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a9da91abc8090532ed98ccd47a3bab775">ay_isnull</a> == 0)
<a name="l00469"></a>00469     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a9e20b9a0aeb41f7f7d653a1c60335bf1" title="alignment table y position">ay</a>       = atof( PQgetvalue( pgr,0, ay_c));
<a name="l00470"></a>00470 
<a name="l00471"></a>00471   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#aaebd6d432810313294b5fed5f4445cb1">az_isnull</a> = PQgetisnull( pgr, 0, az_c);
<a name="l00472"></a>00472   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#aaebd6d432810313294b5fed5f4445cb1">az_isnull</a> == 0)
<a name="l00473"></a>00473     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a66e678866ce79f6398b66d033ae45a17" title="alignment table z position">az</a>       = atof( PQgetvalue( pgr,0, az_c));
<a name="l00474"></a>00474   
<a name="l00475"></a>00475   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a9f777671ec617a0f533b3c51f28babb3">active_isnull</a> = PQgetisnull( pgr, 0, active_c);
<a name="l00476"></a>00476   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a9f777671ec617a0f533b3c51f28babb3">active_isnull</a> == 0)
<a name="l00477"></a>00477     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a1a94eefbad713976a3d9213695a6ca28" title="flag: 1=move to indicated center position, 0=don&amp;#39;t move center or alignment tables...">active</a> = atoi( PQgetvalue( pgr, 0, active_c));
<a name="l00478"></a>00478 
<a name="l00479"></a>00479   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a7ca4fbc86974d1b75a681ba5ecaaf5af">sindex_isnull</a> = PQgetisnull( pgr, 0, sindex_c);
<a name="l00480"></a>00480   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a7ca4fbc86974d1b75a681ba5ecaaf5af">sindex_isnull</a> == 0)
<a name="l00481"></a>00481     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a5d096f2c2bf9be29c44129b54eaf01da" title="index of frame (used to generate the file extension)">sindex</a> = atoi( PQgetvalue( pgr, 0, sindex_c));
<a name="l00482"></a>00482 
<a name="l00483"></a>00483   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#afe16be0382423aa3f25cb3d6cf99430b">dshpid_isnull</a> = PQgetisnull( pgr, 0, dshpid_c);
<a name="l00484"></a>00484   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#afe16be0382423aa3f25cb3d6cf99430b">dshpid_isnull</a> == 0)
<a name="l00485"></a>00485     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a5e260a420176f2973cdb100d0a5c4c09" title="sample holder ID">dshpid</a> = atoi( PQgetvalue( pgr, 0, dshpid_c));
<a name="l00486"></a>00486   
<a name="l00487"></a>00487   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#abd3c69357470052eb79ddd8eddd57b2c">skey_isnull</a> = PQgetisnull( pgr, 0, skey_c);
<a name="l00488"></a>00488   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#abd3c69357470052eb79ddd8eddd57b2c">skey_isnull</a> == 0)
<a name="l00489"></a>00489     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#af64a4e3f17752b5f1f05fb15d6f48382" title="key identifying a particulary image">skey</a>   = atoll( PQgetvalue( pgr, 0, skey_c));
<a name="l00490"></a>00490 
<a name="l00491"></a>00491   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a5ffd27b8063506fd54162658e5c2ce8a">dsowidth2_isnull</a> = PQgetisnull( pgr, 0, dsowidth2_c);
<a name="l00492"></a>00492   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a5ffd27b8063506fd54162658e5c2ce8a">dsowidth2_isnull</a> == 0)
<a name="l00493"></a>00493     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a5378e13735a5392a9fcd853ce8c9e929" title="next image oscillation width">dsowidth2</a> = atof( PQgetvalue( pgr,0, dsowidth2_c));
<a name="l00494"></a>00494 
<a name="l00495"></a>00495   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a45091283dc073e5b7da2cfbe5a75fade">dsexp2_isnull</a> = PQgetisnull( pgr, 0, dsexp2_c);
<a name="l00496"></a>00496   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a45091283dc073e5b7da2cfbe5a75fade">dsexp2_isnull</a> == 0)
<a name="l00497"></a>00497     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a4d8c34309572875352ddabe9cc9001ee" title="next image exposure time">dsexp2</a>    = atof( PQgetvalue( pgr,0, dsexp2_c));
<a name="l00498"></a>00498 
<a name="l00499"></a>00499   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a240c8532d5ce48dbc872d5123a4e721c">sstart2_isnull</a> = PQgetisnull( pgr, 0, sstart2_c);
<a name="l00500"></a>00500   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a240c8532d5ce48dbc872d5123a4e721c">sstart2_isnull</a> == 0)
<a name="l00501"></a>00501     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a8445cbd2206dc6d62b6bd433f5218c98" title="next image start angle">sstart2</a>   = atof( PQgetvalue( pgr,0, sstart2_c));
<a name="l00502"></a>00502 
<a name="l00503"></a>00503   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a57a9c43be86188f65b96d59c2adec674">dsphi2_isnull</a> = PQgetisnull( pgr, 0, dsphi2_c);
<a name="l00504"></a>00504   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a57a9c43be86188f65b96d59c2adec674">dsphi2_isnull</a> == 0)
<a name="l00505"></a>00505     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a98857616b6bbb6ba861e96b6b7551756" title="next image phi position">dsphi2</a>    = atof( PQgetvalue( pgr,0, dsphi2_c));
<a name="l00506"></a>00506 
<a name="l00507"></a>00507   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#afaf9bdf89a68e7f479969072643e55eb">dsomega2_isnull</a> = PQgetisnull( pgr, 0, dsomega2_c);
<a name="l00508"></a>00508   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#afaf9bdf89a68e7f479969072643e55eb">dsomega2_isnull</a> == 0)
<a name="l00509"></a>00509     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a84ae35abfa725d1bdbff5403f6384ee4" title="next image omega position">dsomega2</a>  = atof( PQgetvalue( pgr,0, dsomega2_c));
<a name="l00510"></a>00510 
<a name="l00511"></a>00511   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a9a7e47372f4f6e0e48a0cb3c78fa8437">dskappa2_isnull</a> = PQgetisnull( pgr, 0, dskappa2_c);
<a name="l00512"></a>00512   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a9a7e47372f4f6e0e48a0cb3c78fa8437">dskappa2_isnull</a> == 0)
<a name="l00513"></a>00513     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a8571a0b95fb6ea6356fd7204b9c9e371" title="next image kappa position">dskappa2</a>  = atof( PQgetvalue( pgr,0, dskappa2_c));
<a name="l00514"></a>00514 
<a name="l00515"></a>00515   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a7fce65f4719a4a8110006f8b72eec3f7">dsdist2_isnull</a> = PQgetisnull( pgr, 0, dsdist2_c);
<a name="l00516"></a>00516   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a7fce65f4719a4a8110006f8b72eec3f7">dsdist2_isnull</a> == 0)
<a name="l00517"></a>00517     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a516827749068577217b27860a01e6041" title="next image distance">dsdist2</a>   = atof( PQgetvalue( pgr,0, dsdist2_c));
<a name="l00518"></a>00518 
<a name="l00519"></a>00519   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#aee9f8196dd9bcea832a60f2f0ea3a999">dsnrg2_isnull</a> = PQgetisnull( pgr, 0, dsnrg2_c);
<a name="l00520"></a>00520   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#aee9f8196dd9bcea832a60f2f0ea3a999">dsnrg2_isnull</a> == 0)
<a name="l00521"></a>00521     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ae461439c2af31255227765c0fb61850f" title="next image energy">dsnrg2</a>    = atof( PQgetvalue( pgr,0, dsnrg2_c));
<a name="l00522"></a>00522 
<a name="l00523"></a>00523   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a3ad947f4efe2cb5c338244b019334749">cx2_isnull</a> = PQgetisnull( pgr, 0, cx2_c);
<a name="l00524"></a>00524   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a3ad947f4efe2cb5c338244b019334749">cx2_isnull</a> == 0)
<a name="l00525"></a>00525     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a10d45763100bc59f9a5f68f1b48db6d3" title="next image centering table x position">cx2</a>       = atof( PQgetvalue( pgr,0, cx2_c));
<a name="l00526"></a>00526 
<a name="l00527"></a>00527   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a57d78a389413827302df6ebe3dcb3c89">cy2_isnull</a> = PQgetisnull( pgr, 0, cy2_c);
<a name="l00528"></a>00528   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a57d78a389413827302df6ebe3dcb3c89">cy2_isnull</a> == 0)
<a name="l00529"></a>00529     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a3644e5c3f12af18a3b426d4d4d7e16a5" title="next image centering table y position">cy2</a>       = atof( PQgetvalue( pgr,0, cy2_c));
<a name="l00530"></a>00530 
<a name="l00531"></a>00531   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a846845b0b9ecf6517ef85554771ec71d">ax2_isnull</a> = PQgetisnull( pgr, 0, ax2_c);
<a name="l00532"></a>00532   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a846845b0b9ecf6517ef85554771ec71d">ax2_isnull</a> == 0)
<a name="l00533"></a>00533     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ab76bd38d2a098bc7eda82aff5dcb9c66" title="next image alignment x position">ax2</a>       = atof( PQgetvalue( pgr,0, ax2_c));
<a name="l00534"></a>00534 
<a name="l00535"></a>00535   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ad0f50ec6339296d3d39c8d95131ab6b5">ay2_isnull</a> = PQgetisnull( pgr, 0, ay2_c);
<a name="l00536"></a>00536   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ad0f50ec6339296d3d39c8d95131ab6b5">ay2_isnull</a> == 0)
<a name="l00537"></a>00537     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ad13759740204b42e379161f98815f3d0" title="next image alignment y position">ay2</a>       = atof( PQgetvalue( pgr,0, ay2_c));
<a name="l00538"></a>00538 
<a name="l00539"></a>00539   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a95d080f13a4e02b9aa883821ee3e721c">az2_isnull</a> = PQgetisnull( pgr, 0, az2_c);
<a name="l00540"></a>00540   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a95d080f13a4e02b9aa883821ee3e721c">az2_isnull</a> == 0)
<a name="l00541"></a>00541     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a94698a030fd5b2abf1f10a2ad33476a4" title="next image alignment z position">az2</a>       = atof( PQgetvalue( pgr,0, az2_c));
<a name="l00542"></a>00542   
<a name="l00543"></a>00543   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a1aa11ff4a4c8d69695786b4349e84e6b">active2_isnull</a> = PQgetisnull( pgr, 0, active2_c);
<a name="l00544"></a>00544   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a1aa11ff4a4c8d69695786b4349e84e6b">active2_isnull</a> == 0)
<a name="l00545"></a>00545     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a2875aa18df587806a3d8c05220fd62b5" title="flag: 1 if next image should use the above centering parameters">active2</a> = atoi( PQgetvalue( pgr, 0, active2_c));
<a name="l00546"></a>00546 
<a name="l00547"></a>00547   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a28e0b5c32a2741ef22edeb9d35b04e4d">sindex2_isnull</a> = PQgetisnull( pgr, 0, sindex2_c);
<a name="l00548"></a>00548   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a28e0b5c32a2741ef22edeb9d35b04e4d">sindex2_isnull</a> == 0)
<a name="l00549"></a>00549     <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#ae9d0cfdff6868e0ba9cd5acafbe133db" title="next image index number">sindex2</a> = atoi( PQgetvalue( pgr, 0, sindex2_c));
<a name="l00550"></a>00550 
<a name="l00551"></a>00551   <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#adb8da14444b98f556dba9420dd4666dc" title="Our flag for the condition to wait for.">new_value_ready</a> = 1;
<a name="l00552"></a>00552 
<a name="l00553"></a>00553   pthread_cond_signal( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#afc773a9eefc173aa98d5c2889e1d7669" title="Condition to wait for a response from our postgresql server.">cond</a>));
<a name="l00554"></a>00554   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a38b657155fbee9b73278f76912cf2333" title="Our mutex for sanity in the multi-threaded program.">mutex</a>));
<a name="l00555"></a>00555 
<a name="l00556"></a>00556 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a50458a014041a4118452802dfb303960"></a><!-- doxytag: member="lspg.c::lspg_nextshot_done" ref="a50458a014041a4118452802dfb303960" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_nextshot_done </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when the next shot query has been processed. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00586">586</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00586"></a>00586                           {
<a name="l00587"></a>00587   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a38b657155fbee9b73278f76912cf2333" title="Our mutex for sanity in the multi-threaded program.">mutex</a>));
<a name="l00588"></a>00588 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aff91db7d60e6c832684c023813e36dbf"></a><!-- doxytag: member="lspg.c::lspg_nextshot_init" ref="aff91db7d60e6c832684c023813e36dbf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_nextshot_init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the nextshot variable, mutex, and condition. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00560">560</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00560"></a>00560                           {
<a name="l00561"></a>00561   memset( &amp;<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>, 0, <span class="keyword">sizeof</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>));
<a name="l00562"></a>00562   pthread_mutex_init( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a38b657155fbee9b73278f76912cf2333" title="Our mutex for sanity in the multi-threaded program.">mutex</a>), NULL);
<a name="l00563"></a>00563   pthread_cond_init( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#afc773a9eefc173aa98d5c2889e1d7669" title="Condition to wait for a response from our postgresql server.">cond</a>), NULL);
<a name="l00564"></a>00564 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a784a6de32a86fec9efb3ef3ae4b6e3ac"></a><!-- doxytag: member="lspg.c::lspg_nextshot_wait" ref="a784a6de32a86fec9efb3ef3ae4b6e3ac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_nextshot_wait </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for the next shot query to get processed. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00578">578</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00578"></a>00578                           {
<a name="l00579"></a>00579   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a38b657155fbee9b73278f76912cf2333" title="Our mutex for sanity in the multi-threaded program.">mutex</a>));
<a name="l00580"></a>00580   <span class="keywordflow">while</span>( <a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#adb8da14444b98f556dba9420dd4666dc" title="Our flag for the condition to wait for.">new_value_ready</a> == 0)
<a name="l00581"></a>00581     pthread_cond_wait( &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#afc773a9eefc173aa98d5c2889e1d7669" title="Condition to wait for a response from our postgresql server.">cond</a>), &amp;(<a class="code" href="lspg_8c.html#ad8d8e2f578ca79189a80c1fd5b60cefd" title="the nextshot object">lspg_nextshot</a>.<a class="code" href="structlspg__nextshot__struct.html#a38b657155fbee9b73278f76912cf2333" title="Our mutex for sanity in the multi-threaded program.">mutex</a>));
<a name="l00582"></a>00582 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a581c18be0368425665a40b4b7f7d9714"></a><!-- doxytag: member="lspg.c::lspg_pg_connect" ref="a581c18be0368425665a40b4b7f7d9714" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_pg_connect </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect to the pg server. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01214">1214</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01214"></a>01214                        {
<a name="l01215"></a>01215   PGresult *pgr;
<a name="l01216"></a>01216   <span class="keywordtype">int</span> wait_interval = 1;
<a name="l01217"></a>01217   <span class="keywordtype">int</span> connection_init = 0;
<a name="l01218"></a>01218   <span class="keywordtype">int</span> i, err;
<a name="l01219"></a>01219 
<a name="l01220"></a>01220   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a> == NULL)
<a name="l01221"></a>01221     <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#af443092447378c73bf93aa143576aba4">LS_PG_STATE_INIT</a>;
<a name="l01222"></a>01222 
<a name="l01223"></a>01223   <span class="keywordflow">switch</span>( <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a>) {
<a name="l01224"></a>01224   <span class="keywordflow">case</span> <a class="code" href="lspg_8c.html#af443092447378c73bf93aa143576aba4">LS_PG_STATE_INIT</a>:
<a name="l01225"></a>01225     <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a> = PQconnectStart( <span class="stringliteral">&quot;dbname=ls user=lsuser hostaddr=10.1.0.3&quot;</span>);
<a name="l01226"></a>01226     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a> == NULL) {
<a name="l01227"></a>01227       pthread_mutex_lock( &amp;<a class="code" href="pgpmac_8c.html#ad128c64890c7c0d4f836d9ec6e99216a" title="allow more than one thread access to the screen">ncurses_mutex</a>);
<a name="l01228"></a>01228       wprintw( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>, <span class="stringliteral">&quot;Out of memory (lspg_pg_connect)\n&quot;</span>);
<a name="l01229"></a>01229       wnoutrefresh( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>);
<a name="l01230"></a>01230       wnoutrefresh( <a class="code" href="pgpmac_8c.html#ab0487111dbe3c05d0bd835eb2fb9a3f7" title="place to put the cursor">term_input</a>);
<a name="l01231"></a>01231       doupdate();
<a name="l01232"></a>01232       pthread_mutex_unlock( &amp;<a class="code" href="pgpmac_8c.html#ad128c64890c7c0d4f836d9ec6e99216a" title="allow more than one thread access to the screen">ncurses_mutex</a>);
<a name="l01233"></a>01233       exit( -1);
<a name="l01234"></a>01234     }
<a name="l01235"></a>01235 
<a name="l01236"></a>01236     err = PQstatus( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01237"></a>01237     <span class="keywordflow">if</span>( err == CONNECTION_BAD) {
<a name="l01238"></a>01238       pthread_mutex_lock( &amp;<a class="code" href="pgpmac_8c.html#ad128c64890c7c0d4f836d9ec6e99216a" title="allow more than one thread access to the screen">ncurses_mutex</a>);
<a name="l01239"></a>01239       wprintw( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>, <span class="stringliteral">&quot;Trouble connecting to database\n&quot;</span>);
<a name="l01240"></a>01240       wnoutrefresh( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>);
<a name="l01241"></a>01241       wnoutrefresh( <a class="code" href="pgpmac_8c.html#ab0487111dbe3c05d0bd835eb2fb9a3f7" title="place to put the cursor">term_input</a>);
<a name="l01242"></a>01242       doupdate();
<a name="l01243"></a>01243       pthread_mutex_unlock( &amp;<a class="code" href="pgpmac_8c.html#ad128c64890c7c0d4f836d9ec6e99216a" title="allow more than one thread access to the screen">ncurses_mutex</a>);
<a name="l01244"></a>01244       <span class="comment">//</span>
<a name="l01245"></a>01245       <span class="comment">// TODO: save time of day so we can check that we are not retrying the connection too often</span>
<a name="l01246"></a>01246       <span class="comment">//</span>
<a name="l01247"></a>01247       <span class="keywordflow">return</span>;
<a name="l01248"></a>01248     }
<a name="l01249"></a>01249     err = PQsetnonblocking( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>, 1);
<a name="l01250"></a>01250     <span class="keywordflow">if</span>( err != 0) {
<a name="l01251"></a>01251       pthread_mutex_lock( &amp;<a class="code" href="pgpmac_8c.html#ad128c64890c7c0d4f836d9ec6e99216a" title="allow more than one thread access to the screen">ncurses_mutex</a>);
<a name="l01252"></a>01252       wprintw( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>, <span class="stringliteral">&quot;Odd, could not set database connection to nonblocking\n&quot;</span>);
<a name="l01253"></a>01253       wnoutrefresh( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>);
<a name="l01254"></a>01254       wnoutrefresh( <a class="code" href="pgpmac_8c.html#ab0487111dbe3c05d0bd835eb2fb9a3f7" title="place to put the cursor">term_input</a>);
<a name="l01255"></a>01255       doupdate();
<a name="l01256"></a>01256       pthread_mutex_unlock( &amp;<a class="code" href="pgpmac_8c.html#ad128c64890c7c0d4f836d9ec6e99216a" title="allow more than one thread access to the screen">ncurses_mutex</a>);
<a name="l01257"></a>01257     }
<a name="l01258"></a>01258 
<a name="l01259"></a>01259     <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#ae7ea5876846b5f04c419aee22d3c0aa1">LS_PG_STATE_INIT_POLL</a>;
<a name="l01260"></a>01260     <a class="code" href="lspg_8c.html#a69ae04978986e6413ca7cefcb692b645" title="Used to determine state while connecting.">lspg_connectPoll_response</a> = PGRES_POLLING_WRITING;
<a name="l01261"></a>01261     <span class="comment">//</span>
<a name="l01262"></a>01262     <span class="comment">// set up the connection for poll</span>
<a name="l01263"></a>01263     <span class="comment">//</span>
<a name="l01264"></a>01264     <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.fd = PQsocket( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01265"></a>01265     <span class="keywordflow">break</span>;
<a name="l01266"></a>01266 
<a name="l01267"></a>01267   <span class="keywordflow">case</span> <a class="code" href="lspg_8c.html#ae7ea5876846b5f04c419aee22d3c0aa1">LS_PG_STATE_INIT_POLL</a>:
<a name="l01268"></a>01268     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a69ae04978986e6413ca7cefcb692b645" title="Used to determine state while connecting.">lspg_connectPoll_response</a> == PGRES_POLLING_FAILED) {
<a name="l01269"></a>01269       PQfinish( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01270"></a>01270       <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a> = NULL;
<a name="l01271"></a>01271       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#af443092447378c73bf93aa143576aba4">LS_PG_STATE_INIT</a>;
<a name="l01272"></a>01272     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a69ae04978986e6413ca7cefcb692b645" title="Used to determine state while connecting.">lspg_connectPoll_response</a> == PGRES_POLLING_OK) {
<a name="l01273"></a>01273       <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#a329a7fdfa5025a403ea2779e178fd3ed" title="Motor initialization callback.">lspg_init_motors_cb</a>, <span class="stringliteral">&quot;select * from pmac.md2_getmotors()&quot;</span>);
<a name="l01274"></a>01274       <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( NULL, <span class="stringliteral">&quot;select pmac.md2_init()&quot;</span>);
<a name="l01275"></a>01275       <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#af34559ab5624e1e68085dbcd9410c692" title="Zoom motor look up table callback.">lspg_zoom_lut_cb</a>, <span class="stringliteral">&quot;SELECT * FROM pmac.md2_zoom_lut()&quot;</span>);
<a name="l01276"></a>01276       <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#ac5d5d512350a9ba346635e2415d7c3d5" title="Front Light Lookup table query callback Install the lookup table for the Front Light...">lspg_flight_lut_cb</a>, <span class="stringliteral">&quot;SELECT * FROM pmac.md2_flight_lut()&quot;</span>);
<a name="l01277"></a>01277       <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#a6f5fa5727f2876f8b9370110a92afa50" title="Back Light Lookup Table Callback Install the lookup table for the Back Light.">lspg_blight_lut_cb</a>, <span class="stringliteral">&quot;SELECT * FROM pmac.md2_blight_lut()&quot;</span>);
<a name="l01278"></a>01278 
<a name="l01279"></a>01279       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#aaf1dd8ba4dafb91c296554c4cbf312e3">LS_PG_STATE_IDLE</a>;
<a name="l01280"></a>01280     }
<a name="l01281"></a>01281     <span class="keywordflow">break</span>;
<a name="l01282"></a>01282 
<a name="l01283"></a>01283   <span class="keywordflow">case</span> <a class="code" href="lspg_8c.html#accda8c3a598dc7f5b107b04986d8ab50">LS_PG_STATE_RESET</a>:
<a name="l01284"></a>01284     err = PQresetStart( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01285"></a>01285     <span class="keywordflow">if</span>( err == 0) {
<a name="l01286"></a>01286       PQfinish( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01287"></a>01287       <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a> = NULL;
<a name="l01288"></a>01288       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#af443092447378c73bf93aa143576aba4">LS_PG_STATE_INIT</a>;
<a name="l01289"></a>01289     } <span class="keywordflow">else</span> {
<a name="l01290"></a>01290       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#ac70a1141f3b138055ea7143bd493187c">LS_PG_STATE_RESET_POLL</a>;
<a name="l01291"></a>01291       <a class="code" href="lspg_8c.html#a06c5a937e41a6c706a247777642ec1fb" title="Used to determine state while reconnecting.">lspg_resetPoll_response</a> = PGRES_POLLING_WRITING;
<a name="l01292"></a>01292     }
<a name="l01293"></a>01293     <span class="keywordflow">break</span>;
<a name="l01294"></a>01294 
<a name="l01295"></a>01295   <span class="keywordflow">case</span> <a class="code" href="lspg_8c.html#ac70a1141f3b138055ea7143bd493187c">LS_PG_STATE_RESET_POLL</a>:
<a name="l01296"></a>01296     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a06c5a937e41a6c706a247777642ec1fb" title="Used to determine state while reconnecting.">lspg_resetPoll_response</a> == PGRES_POLLING_FAILED) {
<a name="l01297"></a>01297       PQfinish( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01298"></a>01298       <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a> = NULL;
<a name="l01299"></a>01299       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#af443092447378c73bf93aa143576aba4">LS_PG_STATE_INIT</a>;
<a name="l01300"></a>01300     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a06c5a937e41a6c706a247777642ec1fb" title="Used to determine state while reconnecting.">lspg_resetPoll_response</a> == PGRES_POLLING_OK) {
<a name="l01301"></a>01301       <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#a329a7fdfa5025a403ea2779e178fd3ed" title="Motor initialization callback.">lspg_init_motors_cb</a>, <span class="stringliteral">&quot;select * from pmac.md2_getmotors()&quot;</span>);
<a name="l01302"></a>01302       <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( NULL, <span class="stringliteral">&quot;select pmac.md2_init()&quot;</span>);
<a name="l01303"></a>01303       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#aaf1dd8ba4dafb91c296554c4cbf312e3">LS_PG_STATE_IDLE</a>;
<a name="l01304"></a>01304     }
<a name="l01305"></a>01305     <span class="keywordflow">break</span>;
<a name="l01306"></a>01306   }
<a name="l01307"></a>01307 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa8d1fed4b461c2139a21826d524777d5"></a><!-- doxytag: member="lspg.c::lspg_pg_service" ref="aa8d1fed4b461c2139a21826d524777d5" args="(struct pollfd *evt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_pg_service </td>
          <td>(</td>
          <td class="paramtype">struct pollfd *&nbsp;</td>
          <td class="paramname"> <em>evt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>I/O control to/from the postgresql server. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>evt</em>&nbsp;</td><td>The pollfd object that we are responding to </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01109">1109</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01111"></a>01111                        {
<a name="l01112"></a>01112   <span class="comment">//</span>
<a name="l01113"></a>01113   <span class="comment">// Currently just used to check for notifies</span>
<a name="l01114"></a>01114   <span class="comment">// Other socket communication is done syncronously</span>
<a name="l01115"></a>01115   <span class="comment">// Reconsider this if we start using the pmac gather functions</span>
<a name="l01116"></a>01116   <span class="comment">// since we&apos;ll want to be servicing those sockets ASAP</span>
<a name="l01117"></a>01117   <span class="comment">//</span>
<a name="l01118"></a>01118 
<a name="l01119"></a>01119   <span class="keywordflow">if</span>( evt-&gt;revents &amp; POLLIN) {
<a name="l01120"></a>01120     <span class="keywordtype">int</span> err;
<a name="l01121"></a>01121 
<a name="l01122"></a>01122     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#ae7ea5876846b5f04c419aee22d3c0aa1">LS_PG_STATE_INIT_POLL</a>) {
<a name="l01123"></a>01123       <a class="code" href="lspg_8c.html#a69ae04978986e6413ca7cefcb692b645" title="Used to determine state while connecting.">lspg_connectPoll_response</a> = PQconnectPoll( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01124"></a>01124       <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a69ae04978986e6413ca7cefcb692b645" title="Used to determine state while connecting.">lspg_connectPoll_response</a> == PGRES_POLLING_FAILED) {
<a name="l01125"></a>01125         <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#accda8c3a598dc7f5b107b04986d8ab50">LS_PG_STATE_RESET</a>;
<a name="l01126"></a>01126       }
<a name="l01127"></a>01127       <span class="keywordflow">return</span>;
<a name="l01128"></a>01128     }
<a name="l01129"></a>01129 
<a name="l01130"></a>01130     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#ac70a1141f3b138055ea7143bd493187c">LS_PG_STATE_RESET_POLL</a>) {
<a name="l01131"></a>01131       <a class="code" href="lspg_8c.html#a06c5a937e41a6c706a247777642ec1fb" title="Used to determine state while reconnecting.">lspg_resetPoll_response</a> = PQresetPoll( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01132"></a>01132       <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a06c5a937e41a6c706a247777642ec1fb" title="Used to determine state while reconnecting.">lspg_resetPoll_response</a> == PGRES_POLLING_FAILED) {
<a name="l01133"></a>01133         <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#accda8c3a598dc7f5b107b04986d8ab50">LS_PG_STATE_RESET</a>;
<a name="l01134"></a>01134       }
<a name="l01135"></a>01135       <span class="keywordflow">return</span>;
<a name="l01136"></a>01136     }
<a name="l01137"></a>01137 
<a name="l01138"></a>01138 
<a name="l01139"></a>01139     <span class="comment">//</span>
<a name="l01140"></a>01140     <span class="comment">// if in IDLE or RECV we need to call consumeInput first</span>
<a name="l01141"></a>01141     <span class="comment">//</span>
<a name="l01142"></a>01142     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#aaf1dd8ba4dafb91c296554c4cbf312e3">LS_PG_STATE_IDLE</a>) {
<a name="l01143"></a>01143       err = PQconsumeInput( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01144"></a>01144       <span class="keywordflow">if</span>( err != 1) {
<a name="l01145"></a>01145         pthread_mutex_lock( &amp;<a class="code" href="pgpmac_8c.html#ad128c64890c7c0d4f836d9ec6e99216a" title="allow more than one thread access to the screen">ncurses_mutex</a>);
<a name="l01146"></a>01146         wprintw( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>, <span class="stringliteral">&quot;\nconsume input failed: %s\n&quot;</span>, PQerrorMessage( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>));
<a name="l01147"></a>01147         wnoutrefresh( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>);
<a name="l01148"></a>01148         wnoutrefresh( <a class="code" href="pgpmac_8c.html#ab0487111dbe3c05d0bd835eb2fb9a3f7" title="place to put the cursor">term_input</a>);
<a name="l01149"></a>01149         doupdate();
<a name="l01150"></a>01150         pthread_mutex_unlock( &amp;<a class="code" href="pgpmac_8c.html#ad128c64890c7c0d4f836d9ec6e99216a" title="allow more than one thread access to the screen">ncurses_mutex</a>);
<a name="l01151"></a>01151         <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#accda8c3a598dc7f5b107b04986d8ab50">LS_PG_STATE_RESET</a>;
<a name="l01152"></a>01152         <span class="keywordflow">return</span>;
<a name="l01153"></a>01153       }
<a name="l01154"></a>01154     }      
<a name="l01155"></a>01155 
<a name="l01156"></a>01156     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#a373e668840b4795ff9a71bc3f744d209">LS_PG_STATE_RECV</a>) {
<a name="l01157"></a>01157       <a class="code" href="lspg_8c.html#a038c5af23469b789fc1c55d21cb43029" title="Receive a result of a query.">lspg_receive</a>();
<a name="l01158"></a>01158     }
<a name="l01159"></a>01159 
<a name="l01160"></a>01160     <span class="comment">//</span>
<a name="l01161"></a>01161     <span class="comment">// Check for notifies regardless of our state</span>
<a name="l01162"></a>01162     <span class="comment">// Push as many requests as we have notifies.</span>
<a name="l01163"></a>01163     <span class="comment">//</span>
<a name="l01164"></a>01164     {
<a name="l01165"></a>01165       PGnotify *pgn;
<a name="l01166"></a>01166 
<a name="l01167"></a>01167       <span class="keywordflow">while</span>( 1) {
<a name="l01168"></a>01168         pgn = PQnotifies( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01169"></a>01169         <span class="keywordflow">if</span>( pgn == NULL)
<a name="l01170"></a>01170           <span class="keywordflow">break</span>;
<a name="l01171"></a>01171         
<a name="l01172"></a>01172         <span class="keywordflow">if</span>( strstr( pgn-&gt;relname, <span class="stringliteral">&quot;_pmac&quot;</span>) != NULL) {
<a name="l01173"></a>01173           <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#a1e11f525ca0f9ac9ab71f9fbe983c42b" title="Send strings directly to PMAC queue.">lspg_cmd_cb</a>, <span class="stringliteral">&quot;SELECT pmac.md2_queue_next()&quot;</span>);
<a name="l01174"></a>01174         } <span class="keywordflow">else</span> {
<a name="l01175"></a>01175           <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#aeda8dad89b03d7d61cc994dd63ee5db6" title="Queue the next MD2 instruction.">lspg_nextaction_cb</a>, <span class="stringliteral">&quot;SELECT action FROM px.nextaction()&quot;</span>);
<a name="l01176"></a>01176         }
<a name="l01177"></a>01177         PQfreemem( pgn);
<a name="l01178"></a>01178       }
<a name="l01179"></a>01179     }
<a name="l01180"></a>01180   }
<a name="l01181"></a>01181 
<a name="l01182"></a>01182   <span class="keywordflow">if</span>( evt-&gt;revents &amp; POLLOUT) {
<a name="l01183"></a>01183 
<a name="l01184"></a>01184     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#ae7ea5876846b5f04c419aee22d3c0aa1">LS_PG_STATE_INIT_POLL</a>) {
<a name="l01185"></a>01185       <a class="code" href="lspg_8c.html#a69ae04978986e6413ca7cefcb692b645" title="Used to determine state while connecting.">lspg_connectPoll_response</a> = PQconnectPoll( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01186"></a>01186       <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a69ae04978986e6413ca7cefcb692b645" title="Used to determine state while connecting.">lspg_connectPoll_response</a> == PGRES_POLLING_FAILED) {
<a name="l01187"></a>01187         <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#accda8c3a598dc7f5b107b04986d8ab50">LS_PG_STATE_RESET</a>;
<a name="l01188"></a>01188       }
<a name="l01189"></a>01189       <span class="keywordflow">return</span>;
<a name="l01190"></a>01190     }
<a name="l01191"></a>01191 
<a name="l01192"></a>01192     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#ac70a1141f3b138055ea7143bd493187c">LS_PG_STATE_RESET_POLL</a>) {
<a name="l01193"></a>01193       <a class="code" href="lspg_8c.html#a06c5a937e41a6c706a247777642ec1fb" title="Used to determine state while reconnecting.">lspg_resetPoll_response</a> = PQresetPoll( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01194"></a>01194       <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a06c5a937e41a6c706a247777642ec1fb" title="Used to determine state while reconnecting.">lspg_resetPoll_response</a> == PGRES_POLLING_FAILED) {
<a name="l01195"></a>01195         <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#accda8c3a598dc7f5b107b04986d8ab50">LS_PG_STATE_RESET</a>;
<a name="l01196"></a>01196       }
<a name="l01197"></a>01197       <span class="keywordflow">return</span>;
<a name="l01198"></a>01198     }
<a name="l01199"></a>01199 
<a name="l01200"></a>01200 
<a name="l01201"></a>01201     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#a3c6eb19f262a990e1f9ba630d9edc309">LS_PG_STATE_SEND</a>) {
<a name="l01202"></a>01202       <a class="code" href="lspg_8c.html#a714b15e117ffe7bfce4f2f2ce4725b0a" title="send the next queued query to the DB server">lspg_send_next_query</a>();
<a name="l01203"></a>01203     }
<a name="l01204"></a>01204 
<a name="l01205"></a>01205     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#a88a7e80c12fb0449c4b0857a0c7deb21">LS_PG_STATE_SEND_FLUSH</a>) {
<a name="l01206"></a>01206       <a class="code" href="lspg_8c.html#af6485ac1749c5de3008dd0e0badaa09c" title="Flush psql output buffer (ie, send the query).">lspg_flush</a>();
<a name="l01207"></a>01207     }
<a name="l01208"></a>01208   }
<a name="l01209"></a>01209 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad5f3ec8f197cc330c83dba70f310533c"></a><!-- doxytag: member="lspg.c::lspg_query_next" ref="ad5f3ec8f197cc330c83dba70f310533c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a>* lspg_query_next </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the next item in the postgresql queue. </p>
<p>If there is an item left in the queue then it is returned. Otherwise, NULL is returned. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00080">80</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00080"></a>00080                                       {
<a name="l00081"></a>00081   <a class="code" href="structlspgQueryQueueStruct.html" title="Store each query along with it&amp;#39;s callback function.">lspg_query_queue_t</a> *rtn;
<a name="l00082"></a>00082   
<a name="l00083"></a>00083   pthread_mutex_lock( &amp;<a class="code" href="lspg_8c.html#a3d49c5147ca0e5634c382ef71c4ae24e" title="keep the queue from getting tangled">pg_queue_mutex</a>);
<a name="l00084"></a>00084 
<a name="l00085"></a>00085   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#aca86bb77d6cecfae9251743f4171bafb" title="The last item still being used (on == off means nothing in queue).">lspg_query_queue_off</a> == <a class="code" href="lspg_8c.html#a3cbe7f3161b3c1838ebc56a3bbcfd8a6" title="Next position to add something to the queue.">lspg_query_queue_on</a>)
<a name="l00086"></a>00086     <span class="comment">// Queue is empty</span>
<a name="l00087"></a>00087     rtn = NULL;
<a name="l00088"></a>00088   <span class="keywordflow">else</span>
<a name="l00089"></a>00089     rtn = &amp;(<a class="code" href="lspg_8c.html#a357d9d98f0b8c9625ccebcebfcdce955" title="Our query queue.">lspg_query_queue</a>[(<a class="code" href="lspg_8c.html#aca86bb77d6cecfae9251743f4171bafb" title="The last item still being used (on == off means nothing in queue).">lspg_query_queue_off</a>++) % <a class="code" href="lspg_8c.html#a08fe83fe8226002ee8b80ce0a914fd11" title="Why such a long queue? you might ask.">LS_PG_QUERY_QUEUE_LENGTH</a>]); 
<a name="l00090"></a>00090   pthread_mutex_unlock( &amp;<a class="code" href="lspg_8c.html#a3d49c5147ca0e5634c382ef71c4ae24e" title="keep the queue from getting tangled">pg_queue_mutex</a>);
<a name="l00091"></a>00091 
<a name="l00092"></a>00092   <span class="keywordflow">return</span> rtn;
<a name="l00093"></a>00093 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a0bb9ef42da8fa21c4df48ec384ab69f4"></a><!-- doxytag: member="lspg.c::lspg_query_push" ref="a0bb9ef42da8fa21c4df48ec384ab69f4" args="(void(*cb)(lspg_query_queue_t *, PGresult *), char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_query_push </td>
          <td>(</td>
          <td class="paramtype">void(*)(<a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *, PGresult *)&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Place a query on the queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cb</em>&nbsp;</td><td>Our callback function that deals with the response </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fmt</em>&nbsp;</td><td>Printf style function to generate the query </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00131">131</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00135"></a>00135                        {
<a name="l00136"></a>00136   <span class="keywordtype">int</span> idx;
<a name="l00137"></a>00137   va_list arg_ptr;
<a name="l00138"></a>00138 
<a name="l00139"></a>00139   pthread_mutex_lock( &amp;<a class="code" href="lspg_8c.html#a3d49c5147ca0e5634c382ef71c4ae24e" title="keep the queue from getting tangled">pg_queue_mutex</a>);
<a name="l00140"></a>00140 
<a name="l00141"></a>00141   <span class="comment">//</span>
<a name="l00142"></a>00142   <span class="comment">// TODO</span>
<a name="l00143"></a>00143   <span class="comment">//</span>
<a name="l00144"></a>00144   <span class="comment">// Should really wait until there is enough room on the queue.</span>
<a name="l00145"></a>00145   <span class="comment">// Although the queue is big it is not infinite, so one day we&apos;ll over run it.</span>
<a name="l00146"></a>00146   <span class="comment">// Should really test to see if (on + 1) == off.  If so, then use pg_queue_cond to</span>
<a name="l00147"></a>00147   <span class="comment">// wait until some room has been cleared.</span>
<a name="l00148"></a>00148   <span class="comment">//</span>
<a name="l00149"></a>00149 
<a name="l00150"></a>00150   idx = <a class="code" href="lspg_8c.html#a3cbe7f3161b3c1838ebc56a3bbcfd8a6" title="Next position to add something to the queue.">lspg_query_queue_on</a> % <a class="code" href="lspg_8c.html#a08fe83fe8226002ee8b80ce0a914fd11" title="Why such a long queue? you might ask.">LS_PG_QUERY_QUEUE_LENGTH</a>;
<a name="l00151"></a>00151 
<a name="l00152"></a>00152   va_start( arg_ptr, fmt);
<a name="l00153"></a>00153   vsnprintf( <a class="code" href="lspg_8c.html#a357d9d98f0b8c9625ccebcebfcdce955" title="Our query queue.">lspg_query_queue</a>[idx].qs, <a class="code" href="pgpmac_8h.html#a3a8ef1b4b5994d6dd12bf74454ea891b" title="Fixed length postgresql query strings. Queries should all be function calls so this...">LS_PG_QUERY_STRING_LENGTH</a>-1, fmt, arg_ptr);
<a name="l00154"></a>00154   va_end( arg_ptr);
<a name="l00155"></a>00155 
<a name="l00156"></a>00156   <a class="code" href="lspg_8c.html#a357d9d98f0b8c9625ccebcebfcdce955" title="Our query queue.">lspg_query_queue</a>[idx].<a class="code" href="structlspgQueryQueueStruct.html#abf8c9c581b38a5e3e269eda69e47de15" title="our queries should all be pretty short as we&amp;#39;ll just be calling functions: fixed...">qs</a>[<a class="code" href="pgpmac_8h.html#a3a8ef1b4b5994d6dd12bf74454ea891b" title="Fixed length postgresql query strings. Queries should all be function calls so this...">LS_PG_QUERY_STRING_LENGTH</a> - 1] = 0;
<a name="l00157"></a>00157   <a class="code" href="lspg_8c.html#a357d9d98f0b8c9625ccebcebfcdce955" title="Our query queue.">lspg_query_queue</a>[idx].<a class="code" href="structlspgQueryQueueStruct.html#a53bac5ae4cab775423940bff5092a831" title="Callback function for when a query returns a result.">onResponse</a> = cb;
<a name="l00158"></a>00158   <a class="code" href="lspg_8c.html#a3cbe7f3161b3c1838ebc56a3bbcfd8a6" title="Next position to add something to the queue.">lspg_query_queue_on</a>++;
<a name="l00159"></a>00159 
<a name="l00160"></a>00160   pthread_kill( <a class="code" href="lspg_8c.html#a04eb0cda0d5e5afeae7c393b51689765" title="our worker thread">lspg_thread</a>, SIGUSR1);
<a name="l00161"></a>00161   pthread_mutex_unlock( &amp;<a class="code" href="lspg_8c.html#a3d49c5147ca0e5634c382ef71c4ae24e" title="keep the queue from getting tangled">pg_queue_mutex</a>);
<a name="l00162"></a>00162 };
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3847589e641f7e16a0cd68ef30e37cca"></a><!-- doxytag: member="lspg.c::lspg_query_reply_next" ref="a3847589e641f7e16a0cd68ef30e37cca" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_query_reply_next </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the oldest item in the queue. </p>
<p>this is called only when there is nothing else to service the reply: this pop does not return anything. We use the ...reply_peek function to return the next item in the reply queue </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00102">102</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00102"></a>00102                              {
<a name="l00103"></a>00103 
<a name="l00104"></a>00104   pthread_mutex_lock( &amp;<a class="code" href="lspg_8c.html#a3d49c5147ca0e5634c382ef71c4ae24e" title="keep the queue from getting tangled">pg_queue_mutex</a>);
<a name="l00105"></a>00105 
<a name="l00106"></a>00106   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a2603b071afdbff7c0924b13de2454264" title="The current item being digested.">lspg_query_queue_reply</a> != <a class="code" href="lspg_8c.html#a3cbe7f3161b3c1838ebc56a3bbcfd8a6" title="Next position to add something to the queue.">lspg_query_queue_on</a>)
<a name="l00107"></a>00107     <a class="code" href="lspg_8c.html#a2603b071afdbff7c0924b13de2454264" title="The current item being digested.">lspg_query_queue_reply</a>++;
<a name="l00108"></a>00108 
<a name="l00109"></a>00109   pthread_mutex_unlock( &amp;<a class="code" href="lspg_8c.html#a3d49c5147ca0e5634c382ef71c4ae24e" title="keep the queue from getting tangled">pg_queue_mutex</a>);
<a name="l00110"></a>00110 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae6bf4f54117bedf903360883bb32699f"></a><!-- doxytag: member="lspg.c::lspg_query_reply_peek" ref="ae6bf4f54117bedf903360883bb32699f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a>* lspg_query_reply_peek </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the next item in the reply queue but don't pop it since we may need it more than once. </p>
<p>Call <a class="el" href="lspg_8c.html#a3847589e641f7e16a0cd68ef30e37cca" title="Remove the oldest item in the queue.">lspg_query_reply_next()</a> when done. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00115">115</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00115"></a>00115                                             {
<a name="l00116"></a>00116   <a class="code" href="structlspgQueryQueueStruct.html" title="Store each query along with it&amp;#39;s callback function.">lspg_query_queue_t</a> *rtn;
<a name="l00117"></a>00117 
<a name="l00118"></a>00118   pthread_mutex_lock( &amp;<a class="code" href="lspg_8c.html#a3d49c5147ca0e5634c382ef71c4ae24e" title="keep the queue from getting tangled">pg_queue_mutex</a>);
<a name="l00119"></a>00119 
<a name="l00120"></a>00120   <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#a2603b071afdbff7c0924b13de2454264" title="The current item being digested.">lspg_query_queue_reply</a> == <a class="code" href="lspg_8c.html#a3cbe7f3161b3c1838ebc56a3bbcfd8a6" title="Next position to add something to the queue.">lspg_query_queue_on</a>)
<a name="l00121"></a>00121     rtn = NULL;
<a name="l00122"></a>00122   <span class="keywordflow">else</span>
<a name="l00123"></a>00123     rtn = &amp;(<a class="code" href="lspg_8c.html#a357d9d98f0b8c9625ccebcebfcdce955" title="Our query queue.">lspg_query_queue</a>[(<a class="code" href="lspg_8c.html#a2603b071afdbff7c0924b13de2454264" title="The current item being digested.">lspg_query_queue_reply</a>) % <a class="code" href="lspg_8c.html#a08fe83fe8226002ee8b80ce0a914fd11" title="Why such a long queue? you might ask.">LS_PG_QUERY_QUEUE_LENGTH</a>]);
<a name="l00124"></a>00124 
<a name="l00125"></a>00125   pthread_mutex_unlock( &amp;<a class="code" href="lspg_8c.html#a3d49c5147ca0e5634c382ef71c4ae24e" title="keep the queue from getting tangled">pg_queue_mutex</a>);
<a name="l00126"></a>00126   <span class="keywordflow">return</span> rtn;
<a name="l00127"></a>00127 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a038c5af23469b789fc1c55d21cb43029"></a><!-- doxytag: member="lspg.c::lspg_receive" ref="a038c5af23469b789fc1c55d21cb43029" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_receive </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive a result of a query. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01016">1016</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01016"></a>01016                     {
<a name="l01017"></a>01017   PGresult *pgr;
<a name="l01018"></a>01018   <a class="code" href="structlspgQueryQueueStruct.html" title="Store each query along with it&amp;#39;s callback function.">lspg_query_queue_t</a> *qqp;
<a name="l01019"></a>01019   <span class="keywordtype">int</span> err;
<a name="l01020"></a>01020 
<a name="l01021"></a>01021   err = PQconsumeInput( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01022"></a>01022   <span class="keywordflow">if</span>( err != 1) {
<a name="l01023"></a>01023     pthread_mutex_lock( &amp;<a class="code" href="pgpmac_8c.html#ad128c64890c7c0d4f836d9ec6e99216a" title="allow more than one thread access to the screen">ncurses_mutex</a>);
<a name="l01024"></a>01024     wprintw( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>, <span class="stringliteral">&quot;\nconsume input failed: %s\n&quot;</span>, PQerrorMessage( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>));
<a name="l01025"></a>01025     wnoutrefresh( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>);
<a name="l01026"></a>01026     wnoutrefresh( <a class="code" href="pgpmac_8c.html#ab0487111dbe3c05d0bd835eb2fb9a3f7" title="place to put the cursor">term_input</a>);
<a name="l01027"></a>01027     doupdate();
<a name="l01028"></a>01028     pthread_mutex_unlock( &amp;<a class="code" href="pgpmac_8c.html#ad128c64890c7c0d4f836d9ec6e99216a" title="allow more than one thread access to the screen">ncurses_mutex</a>);
<a name="l01029"></a>01029     <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#accda8c3a598dc7f5b107b04986d8ab50">LS_PG_STATE_RESET</a>;
<a name="l01030"></a>01030     <span class="keywordflow">return</span>;
<a name="l01031"></a>01031   }
<a name="l01032"></a>01032 
<a name="l01033"></a>01033   <span class="comment">//</span>
<a name="l01034"></a>01034   <span class="comment">// We must call PQgetResult until it returns NULL before sending the next query</span>
<a name="l01035"></a>01035   <span class="comment">// This implies that only one query can ever be active at a time and our queue</span>
<a name="l01036"></a>01036   <span class="comment">// management should be simple</span>
<a name="l01037"></a>01037   <span class="comment">//</span>
<a name="l01038"></a>01038   <span class="comment">// We should be in the LS_PG_STATE_RECV here</span>
<a name="l01039"></a>01039   <span class="comment">//</span>
<a name="l01040"></a>01040 
<a name="l01041"></a>01041   <span class="keywordflow">while</span>( !PQisBusy( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>)) {
<a name="l01042"></a>01042     pgr = PQgetResult( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>);
<a name="l01043"></a>01043     <span class="keywordflow">if</span>( pgr == NULL) {
<a name="l01044"></a>01044       <a class="code" href="lspg_8c.html#a3847589e641f7e16a0cd68ef30e37cca" title="Remove the oldest item in the queue.">lspg_query_reply_next</a>();
<a name="l01045"></a>01045       <span class="comment">//</span>
<a name="l01046"></a>01046       <span class="comment">// we are now done reading the response from the database</span>
<a name="l01047"></a>01047       <span class="comment">//</span>
<a name="l01048"></a>01048       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#aaf1dd8ba4dafb91c296554c4cbf312e3">LS_PG_STATE_IDLE</a>;
<a name="l01049"></a>01049       <span class="keywordflow">break</span>;
<a name="l01050"></a>01050     } <span class="keywordflow">else</span> {
<a name="l01051"></a>01051       ExecStatusType es;
<a name="l01052"></a>01052 
<a name="l01053"></a>01053       qqp = <a class="code" href="lspg_8c.html#ae6bf4f54117bedf903360883bb32699f" title="Return the next item in the reply queue but don&amp;#39;t pop it since we may need it...">lspg_query_reply_peek</a>();
<a name="l01054"></a>01054       es = PQresultStatus( pgr);
<a name="l01055"></a>01055 
<a name="l01056"></a>01056       <span class="keywordflow">if</span>( es != PGRES_COMMAND_OK &amp;&amp; es != PGRES_TUPLES_OK) {
<a name="l01057"></a>01057         <span class="keywordtype">char</span> *emess;
<a name="l01058"></a>01058         emess = PQresultErrorMessage( pgr);
<a name="l01059"></a>01059         <span class="keywordflow">if</span>( emess != NULL &amp;&amp; emess[0] != 0) {
<a name="l01060"></a>01060           pthread_mutex_lock( &amp;<a class="code" href="pgpmac_8c.html#ad128c64890c7c0d4f836d9ec6e99216a" title="allow more than one thread access to the screen">ncurses_mutex</a>);
<a name="l01061"></a>01061           wprintw( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>, <span class="stringliteral">&quot;\nError from query &apos;%s&apos;:\n%s\n&quot;</span>, qqp-&gt;<a class="code" href="structlspgQueryQueueStruct.html#abf8c9c581b38a5e3e269eda69e47de15" title="our queries should all be pretty short as we&amp;#39;ll just be calling functions: fixed...">qs</a>, emess);
<a name="l01062"></a>01062           wnoutrefresh( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>);
<a name="l01063"></a>01063           wnoutrefresh( <a class="code" href="pgpmac_8c.html#ab0487111dbe3c05d0bd835eb2fb9a3f7" title="place to put the cursor">term_input</a>);
<a name="l01064"></a>01064           doupdate();
<a name="l01065"></a>01065           pthread_mutex_unlock( &amp;<a class="code" href="pgpmac_8c.html#ad128c64890c7c0d4f836d9ec6e99216a" title="allow more than one thread access to the screen">ncurses_mutex</a>);
<a name="l01066"></a>01066         }
<a name="l01067"></a>01067       } <span class="keywordflow">else</span> {
<a name="l01068"></a>01068         <span class="comment">//</span>
<a name="l01069"></a>01069         <span class="comment">// Deal with the response</span>
<a name="l01070"></a>01070         <span class="comment">//</span>
<a name="l01071"></a>01071         <span class="comment">// If the response is likely to take awhile we should probably</span>
<a name="l01072"></a>01072         <span class="comment">// add a new state and put something in the main look to run the onResponse</span>
<a name="l01073"></a>01073         <span class="comment">// routine in the main loop.  For now, though, we only expect very brief onResponse routines</span>
<a name="l01074"></a>01074         <span class="comment">//</span>
<a name="l01075"></a>01075         <span class="keywordflow">if</span>( qqp != NULL &amp;&amp; qqp-&gt;<a class="code" href="structlspgQueryQueueStruct.html#a53bac5ae4cab775423940bff5092a831" title="Callback function for when a query returns a result.">onResponse</a> != NULL)
<a name="l01076"></a>01076           qqp-&gt;<a class="code" href="structlspgQueryQueueStruct.html#a53bac5ae4cab775423940bff5092a831" title="Callback function for when a query returns a result.">onResponse</a>( qqp, pgr);
<a name="l01077"></a>01077       }
<a name="l01078"></a>01078       PQclear( pgr);
<a name="l01079"></a>01079     }
<a name="l01080"></a>01080   }
<a name="l01081"></a>01081 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1adfdb5ca9fdb5060849d726bf540117"></a><!-- doxytag: member="lspg.c::lspg_run" ref="a1adfdb5ca9fdb5060849d726bf540117" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_run </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start 'er runnin'. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01461">1461</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01461"></a>01461                 {
<a name="l01462"></a>01462   pthread_create( &amp;<a class="code" href="lspg_8c.html#a04eb0cda0d5e5afeae7c393b51689765" title="our worker thread">lspg_thread</a>, NULL, <a class="code" href="lspg_8c.html#aaf4fadd2943fa3a2ecb5d840e84d68fa" title="The main loop for the lspg thread.">lspg_worker</a>, NULL);
<a name="l01463"></a>01463 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a714b15e117ffe7bfce4f2f2ce4725b0a"></a><!-- doxytag: member="lspg.c::lspg_send_next_query" ref="a714b15e117ffe7bfce4f2f2ce4725b0a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_send_next_query </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>send the next queued query to the DB server </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00959">959</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00959"></a>00959                             {
<a name="l00960"></a>00960   <span class="comment">//</span>
<a name="l00961"></a>00961   <span class="comment">// Normally we should be in the &quot;send&quot; state</span>
<a name="l00962"></a>00962   <span class="comment">// but we can also send if we are servicing</span>
<a name="l00963"></a>00963   <span class="comment">// a reply</span>
<a name="l00964"></a>00964   <span class="comment">//</span>
<a name="l00965"></a>00965 
<a name="l00966"></a>00966   <a class="code" href="structlspgQueryQueueStruct.html" title="Store each query along with it&amp;#39;s callback function.">lspg_query_queue_t</a> *qqp;
<a name="l00967"></a>00967   <span class="keywordtype">int</span> err;
<a name="l00968"></a>00968 
<a name="l00969"></a>00969   qqp = <a class="code" href="lspg_8c.html#ad5f3ec8f197cc330c83dba70f310533c" title="Return the next item in the postgresql queue.">lspg_query_next</a>();
<a name="l00970"></a>00970   <span class="keywordflow">if</span>( qqp == NULL) {
<a name="l00971"></a>00971     <span class="comment">//</span>
<a name="l00972"></a>00972     <span class="comment">// A send without a query?  Should never happen.</span>
<a name="l00973"></a>00973     <span class="comment">// But at least we shouldn&apos;t segfault if it does.</span>
<a name="l00974"></a>00974     <span class="comment">//</span>
<a name="l00975"></a>00975     <span class="keywordflow">return</span>;
<a name="l00976"></a>00976   }
<a name="l00977"></a>00977 
<a name="l00978"></a>00978   <span class="keywordflow">if</span>( qqp-&gt;<a class="code" href="structlspgQueryQueueStruct.html#abf8c9c581b38a5e3e269eda69e47de15" title="our queries should all be pretty short as we&amp;#39;ll just be calling functions: fixed...">qs</a>[0] == 0) {
<a name="l00979"></a>00979     <span class="comment">//</span>
<a name="l00980"></a>00980     <span class="comment">// Do we really have to check this case?</span>
<a name="l00981"></a>00981     <span class="comment">// It would only come up if we stupidly pushed an empty query string</span>
<a name="l00982"></a>00982     <span class="comment">// or ran off the end of the queue</span>
<a name="l00983"></a>00983     <span class="comment">//</span>
<a name="l00984"></a>00984     pthread_mutex_lock( &amp;<a class="code" href="pgpmac_8c.html#ad128c64890c7c0d4f836d9ec6e99216a" title="allow more than one thread access to the screen">ncurses_mutex</a>);
<a name="l00985"></a>00985     wprintw( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>, <span class="stringliteral">&quot;\nPopped empty query string.  Probably bad things are going on.\n&quot;</span>);
<a name="l00986"></a>00986     wnoutrefresh( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>);
<a name="l00987"></a>00987     wnoutrefresh( <a class="code" href="pgpmac_8c.html#ab0487111dbe3c05d0bd835eb2fb9a3f7" title="place to put the cursor">term_input</a>);
<a name="l00988"></a>00988     doupdate();
<a name="l00989"></a>00989     pthread_mutex_unlock( &amp;<a class="code" href="pgpmac_8c.html#ad128c64890c7c0d4f836d9ec6e99216a" title="allow more than one thread access to the screen">ncurses_mutex</a>);
<a name="l00990"></a>00990 
<a name="l00991"></a>00991     <a class="code" href="lspg_8c.html#a3847589e641f7e16a0cd68ef30e37cca" title="Remove the oldest item in the queue.">lspg_query_reply_next</a>();
<a name="l00992"></a>00992     <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#aaf1dd8ba4dafb91c296554c4cbf312e3">LS_PG_STATE_IDLE</a>;
<a name="l00993"></a>00993   } <span class="keywordflow">else</span> {
<a name="l00994"></a>00994     err = PQsendQuery( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>, qqp-&gt;<a class="code" href="structlspgQueryQueueStruct.html#abf8c9c581b38a5e3e269eda69e47de15" title="our queries should all be pretty short as we&amp;#39;ll just be calling functions: fixed...">qs</a>);
<a name="l00995"></a>00995     <span class="keywordflow">if</span>( err == 0) {
<a name="l00996"></a>00996       pthread_mutex_lock( &amp;<a class="code" href="pgpmac_8c.html#ad128c64890c7c0d4f836d9ec6e99216a" title="allow more than one thread access to the screen">ncurses_mutex</a>);
<a name="l00997"></a>00997       wprintw( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>, <span class="stringliteral">&quot;\nquery failed: %s\n&quot;</span>, PQerrorMessage( <a class="code" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3" title="Database connector.">q</a>));
<a name="l00998"></a>00998       wnoutrefresh( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>);
<a name="l00999"></a>00999       wnoutrefresh( <a class="code" href="pgpmac_8c.html#ab0487111dbe3c05d0bd835eb2fb9a3f7" title="place to put the cursor">term_input</a>);
<a name="l01000"></a>01000       doupdate();
<a name="l01001"></a>01001       pthread_mutex_unlock( &amp;<a class="code" href="pgpmac_8c.html#ad128c64890c7c0d4f836d9ec6e99216a" title="allow more than one thread access to the screen">ncurses_mutex</a>);
<a name="l01002"></a>01002 
<a name="l01003"></a>01003       <span class="comment">//</span>
<a name="l01004"></a>01004       <span class="comment">// Don&apos;t wait for a reply, just reset the connection</span>
<a name="l01005"></a>01005       <span class="comment">//</span>
<a name="l01006"></a>01006       <a class="code" href="lspg_8c.html#a3847589e641f7e16a0cd68ef30e37cca" title="Remove the oldest item in the queue.">lspg_query_reply_next</a>();
<a name="l01007"></a>01007       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> == <a class="code" href="lspg_8c.html#accda8c3a598dc7f5b107b04986d8ab50">LS_PG_STATE_RESET</a>;
<a name="l01008"></a>01008     } <span class="keywordflow">else</span> {
<a name="l01009"></a>01009       <a class="code" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1" title="State of the lspg state machine.">ls_pg_state</a> = <a class="code" href="lspg_8c.html#a88a7e80c12fb0449c4b0857a0c7deb21">LS_PG_STATE_SEND_FLUSH</a>;
<a name="l01010"></a>01010     }
<a name="l01011"></a>01011   }
<a name="l01012"></a>01012 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4253474d4dd305aec0afdd5552b3ddd5"></a><!-- doxytag: member="lspg.c::lspg_seq_run_prep_all" ref="a4253474d4dd305aec0afdd5552b3ddd5" args="(long long skey, double kappa, double phi, double cx, double cy, double ax, double ay, double az)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_seq_run_prep_all </td>
          <td>(</td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>skey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>kappa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>az</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convinence function to call seq run prep. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>skey</em>&nbsp;</td><td>px.shots key for this image </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>kappa</em>&nbsp;</td><td>current kappa postion </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>phi</em>&nbsp;</td><td>current phi postition </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cx</em>&nbsp;</td><td>current center table x </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cy</em>&nbsp;</td><td>current center table y </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ax</em>&nbsp;</td><td>current alignment table x </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ay</em>&nbsp;</td><td>current alignment table y </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>az</em>&nbsp;</td><td>current alignment table z </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00839">839</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00848"></a>00848                              {
<a name="l00849"></a>00849   <a class="code" href="lspg_8c.html#af7d6efd861b152a371442791deb42bd3" title="queue up the seq_run_prep query">lspg_seq_run_prep_call</a>( skey, <a class="code" href="lspmac_8c.html#a0be79ccb7ebf3a665248fd856112b9fd" title="Kappa.">kappa</a>, <a class="code" href="lspmac_8c.html#ac8070dc568ad974a3db42b51eca828cc" title="Phi (not data collection axis).">phi</a>, cx, cy, ax, ay, az);
<a name="l00850"></a>00850   <a class="code" href="lspg_8c.html#ac0b01f501322432a8fa37f31898c3499" title="Wait for seq run prep query to return.">lspg_seq_run_prep_wait</a>();
<a name="l00851"></a>00851   <a class="code" href="lspg_8c.html#a472b09ddf716c80207f97e2bb5d37d66" title="Indicate we are done waiting.">lspg_seq_run_prep_done</a>();
<a name="l00852"></a>00852 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af7d6efd861b152a371442791deb42bd3"></a><!-- doxytag: member="lspg.c::lspg_seq_run_prep_call" ref="af7d6efd861b152a371442791deb42bd3" args="(long long skey, double kappa, double phi, double cx, double cy, double ax, double ay, double az)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_seq_run_prep_call </td>
          <td>(</td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>skey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>kappa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>az</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>queue up the seq_run_prep query </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>skey</em>&nbsp;</td><td>px.shots key for this image </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>kappa</em>&nbsp;</td><td>current kappa postion </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>phi</em>&nbsp;</td><td>current phi postition </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cx</em>&nbsp;</td><td>current center table x </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cy</em>&nbsp;</td><td>current center table y </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ax</em>&nbsp;</td><td>current alignment table x </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ay</em>&nbsp;</td><td>current alignment table y </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>az</em>&nbsp;</td><td>current alignment table z </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00805">805</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00814"></a>00814                               {
<a name="l00815"></a>00815   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#ad146cb91b5f7dd8bb283092c28781fe7">mutex</a>));
<a name="l00816"></a>00816   <a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#a42d08888327e9059ddd69ddfec31b8a9">new_value_ready</a> = 0;
<a name="l00817"></a>00817   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#ad146cb91b5f7dd8bb283092c28781fe7">mutex</a>));
<a name="l00818"></a>00818 
<a name="l00819"></a>00819   <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#a11cda12050dc9a86188e15e2155a6013" title="Callback for the seq_run_prep query.">lspg_seq_run_prep_cb</a>, <span class="stringliteral">&quot;SELECT px.seq_run_prep( %lld, %.3f, %.3f, %.3f, %.3f, %.3f, %.3f, %.3f)&quot;</span>,
<a name="l00820"></a>00820                    skey, <a class="code" href="lspmac_8c.html#a0be79ccb7ebf3a665248fd856112b9fd" title="Kappa.">kappa</a>, <a class="code" href="lspmac_8c.html#ac8070dc568ad974a3db42b51eca828cc" title="Phi (not data collection axis).">phi</a>, cx, cy, ax, ay, az);
<a name="l00821"></a>00821 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a11cda12050dc9a86188e15e2155a6013"></a><!-- doxytag: member="lspg.c::lspg_seq_run_prep_cb" ref="a11cda12050dc9a86188e15e2155a6013" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_seq_run_prep_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback for the seq_run_prep query. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>qqp</em>&nbsp;</td><td>The query item that generated this callback </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pgr</em>&nbsp;</td><td>The result of the query </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00793">793</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00796"></a>00796                             {
<a name="l00797"></a>00797   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#ad146cb91b5f7dd8bb283092c28781fe7">mutex</a>));
<a name="l00798"></a>00798   <a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#a42d08888327e9059ddd69ddfec31b8a9">new_value_ready</a> = 1;
<a name="l00799"></a>00799   pthread_cond_signal( &amp;(<a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#acd83ea6994f57377716ff01c8ee7ce43">cond</a>));
<a name="l00800"></a>00800   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#ad146cb91b5f7dd8bb283092c28781fe7">mutex</a>));
<a name="l00801"></a>00801 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a472b09ddf716c80207f97e2bb5d37d66"></a><!-- doxytag: member="lspg.c::lspg_seq_run_prep_done" ref="a472b09ddf716c80207f97e2bb5d37d66" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_seq_run_prep_done </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicate we are done waiting. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00833">833</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00833"></a>00833                               {
<a name="l00834"></a>00834   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#ad146cb91b5f7dd8bb283092c28781fe7">mutex</a>));
<a name="l00835"></a>00835 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a31823ecb2b44d4a6674f804059a27bce"></a><!-- doxytag: member="lspg.c::lspg_seq_run_prep_init" ref="a31823ecb2b44d4a6674f804059a27bce" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_seq_run_prep_init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the data collection object. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00785">785</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00785"></a>00785                               {
<a name="l00786"></a>00786   <a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#a42d08888327e9059ddd69ddfec31b8a9">new_value_ready</a> = 0;
<a name="l00787"></a>00787   pthread_mutex_init( &amp;(<a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#ad146cb91b5f7dd8bb283092c28781fe7">mutex</a>), NULL);
<a name="l00788"></a>00788   pthread_cond_init(  &amp;(<a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#acd83ea6994f57377716ff01c8ee7ce43">cond</a>),  NULL);
<a name="l00789"></a>00789 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac0b01f501322432a8fa37f31898c3499"></a><!-- doxytag: member="lspg.c::lspg_seq_run_prep_wait" ref="ac0b01f501322432a8fa37f31898c3499" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_seq_run_prep_wait </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for seq run prep query to return. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00825">825</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00825"></a>00825                               {
<a name="l00826"></a>00826   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#ad146cb91b5f7dd8bb283092c28781fe7">mutex</a>));
<a name="l00827"></a>00827   <span class="keywordflow">while</span>( <a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#a42d08888327e9059ddd69ddfec31b8a9">new_value_ready</a> == 0)
<a name="l00828"></a>00828     pthread_cond_wait( &amp;(<a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#acd83ea6994f57377716ff01c8ee7ce43">cond</a>), &amp;(<a class="code" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a>.<a class="code" href="structlspg__seq__run__prep__struct.html#ad146cb91b5f7dd8bb283092c28781fe7">mutex</a>));
<a name="l00829"></a>00829 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a049f4422994aa2eb2b841ffb2937f895"></a><!-- doxytag: member="lspg.c::lspg_sig_service" ref="a049f4422994aa2eb2b841ffb2937f895" args="(struct pollfd *evt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_sig_service </td>
          <td>(</td>
          <td class="paramtype">struct pollfd *&nbsp;</td>
          <td class="paramname"> <em>evt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Service a signal Signals here are treated as file descriptors and fits into our poll scheme. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>evt</em>&nbsp;</td><td>The pollfd object that triggered this call </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01087">1087</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01089"></a>01089                         {
<a name="l01090"></a>01090   <span class="keyword">struct </span>signalfd_siginfo fdsi;
<a name="l01091"></a>01091 
<a name="l01092"></a>01092   <span class="comment">//</span>
<a name="l01093"></a>01093   <span class="comment">// Really, we don&apos;t care about the signal,</span>
<a name="l01094"></a>01094   <span class="comment">// it&apos;s just used to drop out of the poll</span>
<a name="l01095"></a>01095   <span class="comment">// function when there is something for us</span>
<a name="l01096"></a>01096   <span class="comment">// to do that didn&apos;t invovle something coming</span>
<a name="l01097"></a>01097   <span class="comment">// from our postgresql server.</span>
<a name="l01098"></a>01098   <span class="comment">//</span>
<a name="l01099"></a>01099   <span class="comment">// This is accompished by the query_push function</span>
<a name="l01100"></a>01100   <span class="comment">// to notify us that a new query is ready.</span>
<a name="l01101"></a>01101   <span class="comment">//</span>
<a name="l01102"></a>01102 
<a name="l01103"></a>01103   read( evt-&gt;fd, &amp;fdsi, <span class="keyword">sizeof</span>( <span class="keyword">struct</span> signalfd_siginfo));
<a name="l01104"></a>01104 
<a name="l01105"></a>01105 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab9780e15924a50b2a5545e10806000b3"></a><!-- doxytag: member="lspg.c::lspg_wait_for_detector_all" ref="ab9780e15924a50b2a5545e10806000b3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_wait_for_detector_all </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Combined call to wait for the detector. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00649">649</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00649"></a>00649                                   {
<a name="l00650"></a>00650   <a class="code" href="lspg_8c.html#a4b5222b859a44eae616804a1e990b86d" title="initiate the wait for detector query">lspg_wait_for_detector_call</a>();
<a name="l00651"></a>00651   <a class="code" href="lspg_8c.html#af094e01be121ce8e14abb679abd17e19" title="Pause the calling thread until the detector is ready Called by the MD2 thread.">lspg_wait_for_detector_wait</a>();
<a name="l00652"></a>00652   <a class="code" href="lspg_8c.html#abb3645dee7c4514b650ab02f27570a69" title="Done waiting for the detector.">lspg_wait_for_detector_done</a>();
<a name="l00653"></a>00653 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4b5222b859a44eae616804a1e990b86d"></a><!-- doxytag: member="lspg.c::lspg_wait_for_detector_call" ref="a4b5222b859a44eae616804a1e990b86d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_wait_for_detector_call </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>initiate the wait for detector query </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00623">623</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00623"></a>00623                                    {
<a name="l00624"></a>00624   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#a958e9fe59e671e61f95c2ce796ba24ce">mutex</a>));
<a name="l00625"></a>00625   <a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#ad950e85c70c4473c5c7c40f8ceeae61d">new_value_ready</a> = 0;
<a name="l00626"></a>00626   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#a958e9fe59e671e61f95c2ce796ba24ce">mutex</a>));
<a name="l00627"></a>00627   
<a name="l00628"></a>00628   <a class="code" href="lspg_8c.html#a0bb9ef42da8fa21c4df48ec384ab69f4" title="Place a query on the queue.">lspg_query_push</a>( <a class="code" href="lspg_8c.html#a5747c519d1aa4c310010a862cae8a823" title="Callback for the wait for detector query.">lspg_wait_for_detector_cb</a>, <span class="stringliteral">&quot;SELECT px.lock_detector_test_block()&quot;</span>);
<a name="l00629"></a>00629 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a5747c519d1aa4c310010a862cae8a823"></a><!-- doxytag: member="lspg.c::lspg_wait_for_detector_cb" ref="a5747c519d1aa4c310010a862cae8a823" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_wait_for_detector_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback for the wait for detector query. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00614">614</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00614"></a>00614                                                                         {
<a name="l00615"></a>00615   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#a958e9fe59e671e61f95c2ce796ba24ce">mutex</a>));
<a name="l00616"></a>00616   <a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#ad950e85c70c4473c5c7c40f8ceeae61d">new_value_ready</a> = 1;
<a name="l00617"></a>00617   pthread_cond_signal(  &amp;(<a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#aa97388f93ca5099196ba0da1e4a5b7bb">cond</a>));
<a name="l00618"></a>00618   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#a958e9fe59e671e61f95c2ce796ba24ce">mutex</a>));
<a name="l00619"></a>00619 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="abb3645dee7c4514b650ab02f27570a69"></a><!-- doxytag: member="lspg.c::lspg_wait_for_detector_done" ref="abb3645dee7c4514b650ab02f27570a69" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_wait_for_detector_done </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Done waiting for the detector. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00642">642</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00642"></a>00642                                    {
<a name="l00643"></a>00643   pthread_mutex_unlock( &amp;(<a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#a958e9fe59e671e61f95c2ce796ba24ce">mutex</a>));
<a name="l00644"></a>00644 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a3517f8fbed91c998f6036284f9bd0c48"></a><!-- doxytag: member="lspg.c::lspg_wait_for_detector_init" ref="a3517f8fbed91c998f6036284f9bd0c48" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_wait_for_detector_init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>initialize the detector timing object </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00606">606</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00606"></a>00606                                    {
<a name="l00607"></a>00607   <a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#ad950e85c70c4473c5c7c40f8ceeae61d">new_value_ready</a> = 0;
<a name="l00608"></a>00608   pthread_mutex_init( &amp;(<a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#a958e9fe59e671e61f95c2ce796ba24ce">mutex</a>), NULL);
<a name="l00609"></a>00609   pthread_cond_init(  &amp;(<a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#aa97388f93ca5099196ba0da1e4a5b7bb">cond</a>), NULL);
<a name="l00610"></a>00610 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af094e01be121ce8e14abb679abd17e19"></a><!-- doxytag: member="lspg.c::lspg_wait_for_detector_wait" ref="af094e01be121ce8e14abb679abd17e19" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_wait_for_detector_wait </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pause the calling thread until the detector is ready Called by the MD2 thread. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00634">634</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00634"></a>00634                                    {
<a name="l00635"></a>00635   pthread_mutex_lock( &amp;(<a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#a958e9fe59e671e61f95c2ce796ba24ce">mutex</a>));
<a name="l00636"></a>00636   <span class="keywordflow">while</span>( <a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#ad950e85c70c4473c5c7c40f8ceeae61d">new_value_ready</a> == 0)
<a name="l00637"></a>00637     pthread_cond_wait( &amp;(<a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#aa97388f93ca5099196ba0da1e4a5b7bb">cond</a>), &amp;(<a class="code" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58" title="Instance of the detector timing object.">lspg_wait_for_detector</a>.<a class="code" href="structlspg__wait__for__detector__struct.html#a958e9fe59e671e61f95c2ce796ba24ce">mutex</a>));
<a name="l00638"></a>00638 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aaf4fadd2943fa3a2ecb5d840e84d68fa"></a><!-- doxytag: member="lspg.c::lspg_worker" ref="aaf4fadd2943fa3a2ecb5d840e84d68fa" args="(void *dummy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* lspg_worker </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dummy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The main loop for the lspg thread. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dummy</em>&nbsp;</td><td>Required by pthreads but unused </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l01366">1366</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01368"></a>01368                     {
<a name="l01369"></a>01369   <span class="keyword">static</span> <span class="keyword">struct </span>pollfd fda[2];  <span class="comment">// 0=signal handler, 1=pg socket</span>
<a name="l01370"></a>01370   <span class="keyword">static</span> <span class="keywordtype">int</span> nfda = 0;
<a name="l01371"></a>01371   <span class="keyword">static</span> sigset_t our_sigset;
<a name="l01372"></a>01372   <span class="keywordtype">int</span> sigfd;
<a name="l01373"></a>01373 
<a name="l01374"></a>01374   sigemptyset( &amp;our_sigset);
<a name="l01375"></a>01375   sigaddset( &amp;our_sigset, SIGUSR1);
<a name="l01376"></a>01376 
<a name="l01377"></a>01377 
<a name="l01378"></a>01378   <span class="comment">//</span>
<a name="l01379"></a>01379   <span class="comment">// block ordinary signal mechanism</span>
<a name="l01380"></a>01380   <span class="comment">//</span>
<a name="l01381"></a>01381   sigprocmask(SIG_BLOCK, &amp;our_sigset, NULL);
<a name="l01382"></a>01382 
<a name="l01383"></a>01383     
<a name="l01384"></a>01384   fda[0].fd = signalfd( -1, &amp;our_sigset, SFD_NONBLOCK);
<a name="l01385"></a>01385   <span class="keywordflow">if</span>( fda[0].fd == -1) {
<a name="l01386"></a>01386     <span class="keywordtype">char</span> *es;
<a name="l01387"></a>01387 
<a name="l01388"></a>01388     es = strerror( errno);
<a name="l01389"></a>01389     pthread_mutex_lock( &amp;<a class="code" href="pgpmac_8c.html#ad128c64890c7c0d4f836d9ec6e99216a" title="allow more than one thread access to the screen">ncurses_mutex</a>);
<a name="l01390"></a>01390     wprintw( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>, <span class="stringliteral">&quot;Signalfd trouble: %s&quot;</span>, es);
<a name="l01391"></a>01391     wnoutrefresh( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>);
<a name="l01392"></a>01392     wnoutrefresh( <a class="code" href="pgpmac_8c.html#ab0487111dbe3c05d0bd835eb2fb9a3f7" title="place to put the cursor">term_input</a>);
<a name="l01393"></a>01393     doupdate();
<a name="l01394"></a>01394     pthread_mutex_unlock( &amp;<a class="code" href="pgpmac_8c.html#ad128c64890c7c0d4f836d9ec6e99216a" title="allow more than one thread access to the screen">ncurses_mutex</a>);
<a name="l01395"></a>01395   }
<a name="l01396"></a>01396   fda[0].events = POLLIN;
<a name="l01397"></a>01397 
<a name="l01398"></a>01398   <span class="comment">//</span>
<a name="l01399"></a>01399   <span class="comment">//  make sure file descriptor is not legal until it&apos;s been conneceted</span>
<a name="l01400"></a>01400   <span class="comment">//</span>
<a name="l01401"></a>01401   <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.fd   = -1;
<a name="l01402"></a>01402 
<a name="l01403"></a>01403 
<a name="l01404"></a>01404   <span class="keywordflow">while</span>( 1) {
<a name="l01405"></a>01405     <span class="keywordtype">int</span> pollrtn;
<a name="l01406"></a>01406     <span class="keywordtype">int</span> poll_timeout_ms;
<a name="l01407"></a>01407 
<a name="l01408"></a>01408     <a class="code" href="lspg_8c.html#ab52a8c8245bf6561f40c0f224fc07ff4" title="Implements our state machine Does not strictly only set the next state as it also...">lspg_next_state</a>();
<a name="l01409"></a>01409 
<a name="l01410"></a>01410     <span class="keywordflow">if</span>( <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.fd == -1) {
<a name="l01411"></a>01411       <span class="comment">//</span>
<a name="l01412"></a>01412       <span class="comment">// Here a connection to the database is not established.</span>
<a name="l01413"></a>01413       <span class="comment">// Periodicaly try again.  Should possibly arrange to reconnect</span>
<a name="l01414"></a>01414       <span class="comment">// to signalfd but that&apos;s unlikely to be nessesary.</span>
<a name="l01415"></a>01415       <span class="comment">//</span>
<a name="l01416"></a>01416       nfda = 1;
<a name="l01417"></a>01417       poll_timeout_ms = 10000;
<a name="l01418"></a>01418       fda[1].revents = 0;
<a name="l01419"></a>01419     } <span class="keywordflow">else</span> {
<a name="l01420"></a>01420       <span class="comment">//</span>
<a name="l01421"></a>01421       <span class="comment">// Arrange to peacfully do nothing until either the pg server sends us something</span>
<a name="l01422"></a>01422       <span class="comment">// or someone pushs something onto our queue</span>
<a name="l01423"></a>01423       <span class="comment">//</span>
<a name="l01424"></a>01424       nfda = 2;
<a name="l01425"></a>01425       fda[1].fd      = <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.fd;
<a name="l01426"></a>01426       fda[1].events  = <a class="code" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d" title="our poll info">lspgfd</a>.events;
<a name="l01427"></a>01427       fda[1].revents = 0;
<a name="l01428"></a>01428       poll_timeout_ms = -1;
<a name="l01429"></a>01429     }
<a name="l01430"></a>01430 
<a name="l01431"></a>01431     pollrtn = poll( fda, nfda, poll_timeout_ms);
<a name="l01432"></a>01432 
<a name="l01433"></a>01433     <span class="keywordflow">if</span>( pollrtn &amp;&amp; fda[0].revents) {
<a name="l01434"></a>01434       <a class="code" href="lspg_8c.html#a049f4422994aa2eb2b841ffb2937f895" title="Service a signal Signals here are treated as file descriptors and fits into our poll...">lspg_sig_service</a>( &amp;(fda[0]));
<a name="l01435"></a>01435       pollrtn--;
<a name="l01436"></a>01436     } 
<a name="l01437"></a>01437     <span class="keywordflow">if</span>( pollrtn &amp;&amp; fda[1].revents) {
<a name="l01438"></a>01438       <a class="code" href="lspg_8c.html#aa8d1fed4b461c2139a21826d524777d5" title="I/O control to/from the postgresql server.">lspg_pg_service</a>( &amp;(fda[1]));
<a name="l01439"></a>01439       pollrtn--;
<a name="l01440"></a>01440     } 
<a name="l01441"></a>01441 
<a name="l01442"></a>01442 
<a name="l01443"></a>01443 
<a name="l01444"></a>01444 
<a name="l01445"></a>01445   }
<a name="l01446"></a>01446 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="af34559ab5624e1e68085dbcd9410c692"></a><!-- doxytag: member="lspg.c::lspg_zoom_lut_cb" ref="af34559ab5624e1e68085dbcd9410c692" args="(lspg_query_queue_t *qqp, PGresult *pgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lspg_zoom_lut_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGresult *&nbsp;</td>
          <td class="paramname"> <em>pgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Zoom motor look up table callback. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>qqp</em>&nbsp;</td><td>the queue item responsible for calling us </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pgr</em>&nbsp;</td><td>The Postgresql result object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00217">217</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00220"></a>00220                         {
<a name="l00221"></a>00221   <span class="keywordtype">int</span> i;
<a name="l00222"></a>00222   
<a name="l00223"></a>00223   pthread_mutex_lock( &amp;(<a class="code" href="lspmac_8c.html#ad53a42cfaa04eff0336a44c8c9986333" title="Optical zoom.">zoom</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a188c5b1e991750ce2ffd53e0192e0907" title="coordinate waiting for motor to be done">mutex</a>));
<a name="l00224"></a>00224 
<a name="l00225"></a>00225   <a class="code" href="lspmac_8c.html#ad53a42cfaa04eff0336a44c8c9986333" title="Optical zoom.">zoom</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a11cbc6f50c150ed446e9a901cf7cc12b" title="length of lut">nlut</a> = PQntuples( pgr)/2;
<a name="l00226"></a>00226   <a class="code" href="lspmac_8c.html#ad53a42cfaa04eff0336a44c8c9986333" title="Optical zoom.">zoom</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a7b43671f7f3e06521f6cf91fb9ac707d" title="lookup table (instead of u2c)">lut</a>  = calloc( 2*<a class="code" href="lspmac_8c.html#ad53a42cfaa04eff0336a44c8c9986333" title="Optical zoom.">zoom</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a11cbc6f50c150ed446e9a901cf7cc12b" title="length of lut">nlut</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00227"></a>00227   <span class="keywordflow">if</span>( <a class="code" href="lspmac_8c.html#ad53a42cfaa04eff0336a44c8c9986333" title="Optical zoom.">zoom</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a7b43671f7f3e06521f6cf91fb9ac707d" title="lookup table (instead of u2c)">lut</a> == NULL) {
<a name="l00228"></a>00228     wprintw( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>, <span class="stringliteral">&quot;\nOut of memmory (lspg_zoom_lut_cb)&quot;</span>);
<a name="l00229"></a>00229     wnoutrefresh( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>);
<a name="l00230"></a>00230     wnoutrefresh( <a class="code" href="pgpmac_8c.html#a65daf0f4a5bc6def23a9df98ff5ca57e" title="place to print stuff out">term_output</a>);
<a name="l00231"></a>00231     doupdate();
<a name="l00232"></a>00232     pthread_mutex_unlock( &amp;(<a class="code" href="lspmac_8c.html#ad53a42cfaa04eff0336a44c8c9986333" title="Optical zoom.">zoom</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a188c5b1e991750ce2ffd53e0192e0907" title="coordinate waiting for motor to be done">mutex</a>));
<a name="l00233"></a>00233     <span class="keywordflow">return</span>;
<a name="l00234"></a>00234   }
<a name="l00235"></a>00235   
<a name="l00236"></a>00236   <span class="keywordflow">for</span>( i=0; i&lt;PQntuples( pgr); i++) {
<a name="l00237"></a>00237     <a class="code" href="lspmac_8c.html#ad53a42cfaa04eff0336a44c8c9986333" title="Optical zoom.">zoom</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a7b43671f7f3e06521f6cf91fb9ac707d" title="lookup table (instead of u2c)">lut</a>[i] = strtod( PQgetvalue( pgr, i, 0), NULL);
<a name="l00238"></a>00238   }
<a name="l00239"></a>00239 
<a name="l00240"></a>00240   pthread_mutex_unlock( &amp;(<a class="code" href="lspmac_8c.html#ad53a42cfaa04eff0336a44c8c9986333" title="Optical zoom.">zoom</a>-&gt;<a class="code" href="structlspmac__motor__struct.html#a188c5b1e991750ce2ffd53e0192e0907" title="coordinate waiting for motor to be done">mutex</a>));
<a name="l00241"></a>00241 
<a name="l00242"></a>00242 }
</pre></div></p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a4937baac0cc78ea306d58b5f027867f1"></a><!-- doxytag: member="lspg.c::ls_pg_state" ref="a4937baac0cc78ea306d58b5f027867f1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="lspg_8c.html#a4937baac0cc78ea306d58b5f027867f1">ls_pg_state</a> = LS_PG_STATE_INIT<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>State of the lspg state machine. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00039">39</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a69ae04978986e6413ca7cefcb692b645"></a><!-- doxytag: member="lspg.c::lspg_connectPoll_response" ref="a69ae04978986e6413ca7cefcb692b645" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostgresPollingStatusType <a class="el" href="lspg_8c.html#a69ae04978986e6413ca7cefcb692b645">lspg_connectPoll_response</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used to determine state while connecting. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00070">70</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="adbf3b3652c6531c3d194320d1abc1c80"></a><!-- doxytag: member="lspg.c::lspg_lock_detector" ref="adbf3b3652c6531c3d194320d1abc1c80" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlspg__lock__detector__struct.html">lspg_lock_detector_t</a> <a class="el" href="lspg_8c.html#adbf3b3652c6531c3d194320d1abc1c80">lspg_lock_detector</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00723">723</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="aaae7ce3ecd7d54a9e46c41d7a742a454"></a><!-- doxytag: member="lspg.c::lspg_lock_diffractometer" ref="aaae7ce3ecd7d54a9e46c41d7a742a454" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlspg__lock__diffractometer__struct.html">lspg_lock_diffractometer_t</a> <a class="el" href="lspg_8c.html#aaae7ce3ecd7d54a9e46c41d7a742a454">lspg_lock_diffractometer</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00664">664</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="ad8d8e2f578ca79189a80c1fd5b60cefd"></a><!-- doxytag: member="lspg.c::lspg_nextshot" ref="ad8d8e2f578ca79189a80c1fd5b60cefd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlspg__nextshot__struct.html">lspg_nextshot_t</a> <a class="el" href="pgpmac_8h.html#ad8d8e2f578ca79189a80c1fd5b60cefd">lspg_nextshot</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the nextshot object </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00073">73</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a357d9d98f0b8c9625ccebcebfcdce955"></a><!-- doxytag: member="lspg.c::lspg_query_queue" ref="a357d9d98f0b8c9625ccebcebfcdce955" args="[LS_PG_QUERY_QUEUE_LENGTH]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlspgQueryQueueStruct.html">lspg_query_queue_t</a> <a class="el" href="lspg_8c.html#a357d9d98f0b8c9625ccebcebfcdce955">lspg_query_queue</a>[LS_PG_QUERY_QUEUE_LENGTH]<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Our query queue. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00062">62</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="aca86bb77d6cecfae9251743f4171bafb"></a><!-- doxytag: member="lspg.c::lspg_query_queue_off" ref="aca86bb77d6cecfae9251743f4171bafb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="lspg_8c.html#aca86bb77d6cecfae9251743f4171bafb">lspg_query_queue_off</a> = 0<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The last item still being used (on == off means nothing in queue). </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00064">64</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3cbe7f3161b3c1838ebc56a3bbcfd8a6"></a><!-- doxytag: member="lspg.c::lspg_query_queue_on" ref="a3cbe7f3161b3c1838ebc56a3bbcfd8a6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="lspg_8c.html#a3cbe7f3161b3c1838ebc56a3bbcfd8a6">lspg_query_queue_on</a> = 0<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Next position to add something to the queue. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00063">63</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a2603b071afdbff7c0924b13de2454264"></a><!-- doxytag: member="lspg.c::lspg_query_queue_reply" ref="a2603b071afdbff7c0924b13de2454264" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="lspg_8c.html#a2603b071afdbff7c0924b13de2454264">lspg_query_queue_reply</a> = 0<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The current item being digested. </p>
<p>Normally off &lt;= reply &lt;= on. Corner case of queue wrap arround works because we only increment and compare for equality. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00065">65</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a06c5a937e41a6c706a247777642ec1fb"></a><!-- doxytag: member="lspg.c::lspg_resetPoll_response" ref="a06c5a937e41a6c706a247777642ec1fb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostgresPollingStatusType <a class="el" href="lspg_8c.html#a06c5a937e41a6c706a247777642ec1fb">lspg_resetPoll_response</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used to determine state while reconnecting. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00071">71</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a1b0d9fc30bcea6905b075d2362149172"></a><!-- doxytag: member="lspg.c::lspg_seq_run_prep" ref="a1b0d9fc30bcea6905b075d2362149172" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlspg__seq__run__prep__struct.html">lspg_seq_run_prep_t</a> <a class="el" href="lspg_8c.html#a1b0d9fc30bcea6905b075d2362149172">lspg_seq_run_prep</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00781">781</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a04eb0cda0d5e5afeae7c393b51689765"></a><!-- doxytag: member="lspg.c::lspg_thread" ref="a04eb0cda0d5e5afeae7c393b51689765" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_t <a class="el" href="lspg_8c.html#a04eb0cda0d5e5afeae7c393b51689765">lspg_thread</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>our worker thread </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00041">41</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a0dfc8d0410cd2d7f7da7a70d3ef88e58"></a><!-- doxytag: member="lspg.c::lspg_wait_for_detector" ref="a0dfc8d0410cd2d7f7da7a70d3ef88e58" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlspg__wait__for__detector__struct.html">lspg_wait_for_detector_t</a> <a class="el" href="lspg_8c.html#a0dfc8d0410cd2d7f7da7a70d3ef88e58">lspg_wait_for_detector</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Instance of the detector timing object. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00602">602</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="af3f897b8ffa020ca54289bc5b28cb64d"></a><!-- doxytag: member="lspg.c::lspgfd" ref="af3f897b8ffa020ca54289bc5b28cb64d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct pollfd <a class="el" href="lspg_8c.html#af3f897b8ffa020ca54289bc5b28cb64d">lspgfd</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>our poll info </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00043">43</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3d49c5147ca0e5634c382ef71c4ae24e"></a><!-- doxytag: member="lspg.c::pg_queue_mutex" ref="a3d49c5147ca0e5634c382ef71c4ae24e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_mutex_t <a class="el" href="lspg_8c.html#a3d49c5147ca0e5634c382ef71c4ae24e">pg_queue_mutex</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>keep the queue from getting tangled </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00042">42</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a9012783dbbadf652a81649a289697cf3"></a><!-- doxytag: member="lspg.c::q" ref="a9012783dbbadf652a81649a289697cf3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PGconn* <a class="el" href="lspg_8c.html#a9012783dbbadf652a81649a289697cf3">q</a> = NULL<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Database connector. </p>

<p>Definition at line <a class="el" href="lspg_8c_source.html#l00069">69</a> of file <a class="el" href="lspg_8c_source.html">lspg.c</a>.</p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 12 Oct 2012 for LS-CAT PGPMAC by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
