.TH "lspmac.c" 3 "Thu Jun 19 2014" "LS-CAT PGPMAC" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lspmac.c \- 
.PP
Routines concerned with communication with PMAC\&.  

.SH SYNOPSIS
.br
.PP
\fC#include 'pgpmac\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBmd2StatusStruct\fP"
.br
.RI "\fIThe block of memory retrieved in a status request\&. \fP"
.ti -1c
.RI "struct \fBlspmac_ascii_buffers_struct\fP"
.br
.ti -1c
.RI "struct \fBlspmac_dpascii_queue_struct\fP"
.br
.ti -1c
.RI "struct \fBlspmac_combined_move_struct\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBLS_PMAC_STATE_RESET\fP   -1"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_DETACHED\fP   0"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_IDLE\fP   1"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_SC\fP   2"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_WACK_NFR\fP   3"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_WACK_CC\fP   4"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_WACK\fP   5"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_GMR\fP   6"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_CR\fP   7"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_RR\fP   8"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_WACK_RR\fP   9"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_GB\fP   10"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_WCR\fP   11"
.br
.ti -1c
.RI "#define \fBLS_PMAC_STATE_WGB\fP   12"
.br
.ti -1c
.RI "#define \fBLSPMAC_MAX_MOTORS\fP   48"
.br
.ti -1c
.RI "#define \fBLSPMAC_PRESET_REGEX\fP   '(\&.*\\\\\&.%s\\\\\&.presets)\\\\\&.([0-9]+)\\\\\&.(name|position)'"
.br
.RI "\fIRegex to pick out preset name and corresponding position\&. \fP"
.ti -1c
.RI "#define \fBPMACPORT\fP   1025"
.br
.RI "\fIThe PMAC (only) listens on this port\&. \fP"
.ti -1c
.RI "#define \fBpmac_cmd_size\fP   8"
.br
.RI "\fIPMAC command size in bytes\&. \fP"
.ti -1c
.RI "#define \fBVR_UPLOAD\fP   0xc0"
.br
.ti -1c
.RI "#define \fBVR_DOWNLOAD\fP   0x40"
.br
.ti -1c
.RI "#define \fBVR_PMAC_SENDLINE\fP   0xb0"
.br
.ti -1c
.RI "#define \fBVR_PMAC_GETLINE\fP   0xb1"
.br
.ti -1c
.RI "#define \fBVR_PMAC_FLUSH\fP   0xb3"
.br
.ti -1c
.RI "#define \fBVR_PMAC_GETMEM\fP   0xb4"
.br
.ti -1c
.RI "#define \fBVR_PMAC_SETMEM\fP   0xb5"
.br
.ti -1c
.RI "#define \fBVR_PMAC_SENDCTRLCHAR\fP   0xb6"
.br
.ti -1c
.RI "#define \fBVR_PMAC_SETBIT\fP   0xba"
.br
.ti -1c
.RI "#define \fBVR_PMAC_SETBITS\fP   0xbb"
.br
.ti -1c
.RI "#define \fBVR_PMAC_PORT\fP   0xbe"
.br
.ti -1c
.RI "#define \fBVR_PMAC_GETRESPONSE\fP   0xbf"
.br
.ti -1c
.RI "#define \fBVR_PMAC_READREADY\fP   0xc2"
.br
.ti -1c
.RI "#define \fBVR_CTRL_RESPONSE\fP   0xc4"
.br
.ti -1c
.RI "#define \fBVR_PMAC_GETBUFFER\fP   0xc5"
.br
.ti -1c
.RI "#define \fBVR_PMAC_WRITEBUFFER\fP   0xc6"
.br
.ti -1c
.RI "#define \fBVR_PMAC_WRITEERROR\fP   0xc7"
.br
.ti -1c
.RI "#define \fBVR_FWDOWNLOAD\fP   0xcb"
.br
.ti -1c
.RI "#define \fBVR_IPADDRESS\fP   0xe0"
.br
.ti -1c
.RI "#define \fBPMAC_MIN_CMD_TIME\fP   10000\&.0"
.br
.RI "\fIMinimum time between commands to the pmac\&. \fP"
.ti -1c
.RI "#define \fBPMAC_CMD_QUEUE_LENGTH\fP   2048"
.br
.RI "\fISize of the PMAC command queue\&. \fP"
.ti -1c
.RI "#define \fBLSPMAC_DPASCII_QUEUE_LENGTH\fP   1024"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBmd2StatusStruct\fP \fBmd2_status_t\fP"
.br
.RI "\fIThe block of memory retrieved in a status request\&. \fP"
.ti -1c
.RI "typedef struct 
.br
\fBlspmac_ascii_buffers_struct\fP \fBlspmac_ascii_buffers_t\fP"
.br
.ti -1c
.RI "typedef struct 
.br
\fBlspmac_dpascii_queue_struct\fP \fBlspmac_dpascii_queue_t\fP"
.br
.ti -1c
.RI "typedef struct 
.br
\fBlspmac_combined_move_struct\fP \fBlspmac_combined_move_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBlspmac_get_ascii\fP (char *)"
.br
.RI "\fIForward declarateion\&. \fP"
.ti -1c
.RI "double \fBlspmac_lut\fP (int nlut, double *lut, double x)"
.br
.RI "\fILook up table support for motor positions (think x=zoom, y=light intensity) use a lookup table to find the 'counts' to move the motor to the requested position The look up table is a simple one dimensional array with the x values as even indicies and the y values as odd indices\&. \fP"
.ti -1c
.RI "double \fBlspmac_rlut\fP (int nlut, double *lut, double y)"
.br
.ti -1c
.RI "void \fBhex_dump\fP (int n, unsigned char *s)"
.br
.RI "\fIPrints a hex dump of the given data\&. \fP"
.ti -1c
.RI "char * \fBcleanstr\fP (char *s)"
.br
.RI "\fIReplace \\r with \\n in null terminated string and print result to terminal\&. \fP"
.ti -1c
.RI "void \fBlsConnect\fP (char *ipaddr)"
.br
.RI "\fIConnect to the PMAC socket\&. \fP"
.ti -1c
.RI "void \fBlspmac_reset_queue\fP ()"
.br
.RI "\fIClear the queue as part of PMAC reinitialization\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_push_queue\fP (\fBpmac_cmd_queue_t\fP *cmd)"
.br
.RI "\fIPut a new command on the queue\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_pop_queue\fP ()"
.br
.RI "\fIRemove the oldest queue item\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_pop_reply\fP ()"
.br
.RI "\fIRemove the next command queue item that is waiting for a reply\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_send_command\fP (int rqType, int rq, int wValue, int wIndex, int wLength, char *data, void(*responseCB)(\fBpmac_cmd_queue_t\fP *, int, char *), int no_reply, char *event)"
.br
.RI "\fICompose a packet and send it to the PMAC\&. \fP"
.ti -1c
.RI "void \fBlspmac_SockFlush\fP ()"
.br
.RI "\fIReset the PMAC socket from the PMAC side\&. \fP"
.ti -1c
.RI "void \fBlspmac_Reset\fP ()"
.br
.RI "\fIClear the queue and put the PMAC into a known state\&. \fP"
.ti -1c
.RI "void \fBlspmac_Error\fP (char *buff)"
.br
.RI "\fIThe service routing detected an error condition\&. \fP"
.ti -1c
.RI "void \fBlspmac_Service\fP (struct pollfd *evt)"
.br
.RI "\fIService routine for packet coming from the PMAC\&. \fP"
.ti -1c
.RI "void \fBlspmac_GetShortReplyCB\fP (\fBpmac_cmd_queue_t\fP *cmd, int nreceived, char *buff)"
.br
.RI "\fIReceive a reply that does not require multiple buffers\&. \fP"
.ti -1c
.RI "void \fBlspmac_SendControlReplyPrintCB\fP (\fBpmac_cmd_queue_t\fP *cmd, int nreceived, char *buff)"
.br
.RI "\fIReceive a reply to a control character Print a 'printable' version of the character to the terminal Followed by a hex dump of the response\&. \fP"
.ti -1c
.RI "void \fBlspmac_GetmemReplyCB\fP (\fBpmac_cmd_queue_t\fP *cmd, int nreceived, char *buff)"
.br
.RI "\fIService a reply to the getmem command\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_SockGetmem\fP (int offset, int nbytes)"
.br
.RI "\fIRequest a chunk of memory to be returned\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_SockSendline\fP (char *event, char *fmt,\&.\&.\&.)"
.br
.RI "\fISend a one line command\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_SockSendline_nr\fP (char *event, char *fmt,\&.\&.\&.)"
.br
.RI "\fISend a command and ignore the response\&. \fP"
.ti -1c
.RI "\fBpmac_cmd_queue_t\fP * \fBlspmac_SockSendControlCharPrint\fP (char *event, char c)"
.br
.RI "\fISend a control character\&. \fP"
.ti -1c
.RI "void \fBlspmac_Getmem\fP ()"
.br
.RI "\fIRequest a block of double buffer memory\&. \fP"
.ti -1c
.RI "void \fBlspmac_bo_read\fP (\fBlspmac_motor_t\fP *mp)"
.br
.RI "\fIRead the state of a binary i/o motor This is the read method for the binary i/o motor class\&. \fP"
.ti -1c
.RI "void \fBlspmac_dac_read\fP (\fBlspmac_motor_t\fP *mp)"
.br
.RI "\fIRead a DAC motor position\&. \fP"
.ti -1c
.RI "void \fBlspmac_shutter_read\fP (\fBlspmac_motor_t\fP *mp)"
.br
.RI "\fIFast shutter read routine The shutter is mildly complicated in that we need to take into account the fact that the shutter can open and close again between status updates\&. \fP"
.ti -1c
.RI "void \fBlspmac_home1_queue\fP (\fBlspmac_motor_t\fP *mp)"
.br
.RI "\fIHome the motor\&. \fP"
.ti -1c
.RI "void \fBlspmac_home2_queue\fP (\fBlspmac_motor_t\fP *mp)"
.br
.RI "\fISecond stage of homing\&. \fP"
.ti -1c
.RI "double \fBlspmac_getPosition\fP (\fBlspmac_motor_t\fP *mp)"
.br
.RI "\fIget the motor position (with locking) \fP"
.ti -1c
.RI "void \fBlspmac_pmacmotor_read\fP (\fBlspmac_motor_t\fP *mp)"
.br
.RI "\fIRead the position and status of a normal PMAC motor\&. \fP"
.ti -1c
.RI "int \fBlspmac_getBIPosition\fP (\fBlspmac_bi_t\fP *bip)"
.br
.RI "\fIget binary input value \fP"
.ti -1c
.RI "void \fBlspmac_get_status_cb\fP (\fBpmac_cmd_queue_t\fP *cmd, int nreceived, char *buff)"
.br
.RI "\fIService routing for status upate This updates positions and status information\&. \fP"
.ti -1c
.RI "void \fBlspmac_get_status\fP ()"
.br
.RI "\fIRequest a status update from the PMAC\&. \fP"
.ti -1c
.RI "void \fBlspmac_more_ascii_cb\fP (\fBpmac_cmd_queue_t\fP *cmd, int nreceived, char *buff)"
.br
.RI "\fIwe are expecting more characters from the DPRAM ASCII interface \fP"
.ti -1c
.RI "void \fBlspmac_get_ascii_cb\fP (\fBpmac_cmd_queue_t\fP *cmd, int nreceived, char *buff)"
.br
.RI "\fIservice the ascii buffer request response \fP"
.ti -1c
.RI "void \fBlspmac_asciicmdCB\fP (\fBpmac_cmd_queue_t\fP *cmd, int nreceived, char *buf)"
.br
.RI "\fIPMAC has received our ascii command request Now see when it is ready for the next one\&. \fP"
.ti -1c
.RI "void \fBlspmac_SockSendDPline\fP (char *event, char *fmt,\&.\&.\&.)"
.br
.RI "\fIprepare (queue up) a line to send the dpram ascii command interface \fP"
.ti -1c
.RI "void \fBlspmac_request_control_response_cb\fP (char *event)"
.br
.ti -1c
.RI "void \fBlspmac_SockSendDPControlCharCB\fP (\fBpmac_cmd_queue_t\fP *cmd, int nreceived, char *buf)"
.br
.ti -1c
.RI "void \fBlspmac_SockSendDPControlChar\fP (char *event, char c)"
.br
.RI "\fIuse dpram ascii interface to send a control character \fP"
.ti -1c
.RI "void \fBlspmac_SockSendDPqueue\fP ()"
.br
.ti -1c
.RI "void \fBlspmac_abort\fP ()"
.br
.RI "\fIabort motion and try to recover \fP"
.ti -1c
.RI "void \fBlspmac_GetAllIVarsCB\fP (\fBpmac_cmd_queue_t\fP *cmd, int nreceived, char *buff)"
.br
.RI "\fIReceive the values of all the I variables Update our Postgresql database with the results\&. \fP"
.ti -1c
.RI "void \fBlspmac_GetAllIVars\fP ()"
.br
.RI "\fIRequest the values of all the I variables\&. \fP"
.ti -1c
.RI "void \fBlspmac_GetAllMVarsCB\fP (\fBpmac_cmd_queue_t\fP *cmd, int nreceived, char *buff)"
.br
.RI "\fIReceive the values of all the M variables Update our database with the results\&. \fP"
.ti -1c
.RI "void \fBlspmac_GetAllMVars\fP ()"
.br
.RI "\fIRequest the values of all the M variables\&. \fP"
.ti -1c
.RI "void \fBlspmac_sendcmd_nocb\fP (char *fmt,\&.\&.\&.)"
.br
.RI "\fISend a command that does not need to deal with the reply\&. \fP"
.ti -1c
.RI "void \fBlspmac_sendcmd\fP (char *event, void(*responseCB)(\fBpmac_cmd_queue_t\fP *, int, char *), char *fmt,\&.\&.\&.)"
.br
.RI "\fIPMAC command with call back\&. \fP"
.ti -1c
.RI "void \fBlspmac_next_state\fP ()"
.br
.RI "\fIState machine logic\&. \fP"
.ti -1c
.RI "void * \fBlspmac_worker\fP (void *dummy)"
.br
.RI "\fIOur lspmac worker thread\&. \fP"
.ti -1c
.RI "int \fBlspmac_movedac_queue\fP (\fBlspmac_motor_t\fP *mp, double requested_position)"
.br
.RI "\fIMove method for dac motor objects (ie, lights) \fP"
.ti -1c
.RI "int \fBlspmac_movezoom_queue\fP (\fBlspmac_motor_t\fP *mp, double requested_position)"
.br
.RI "\fIMove method for the zoom motor\&. \fP"
.ti -1c
.RI "int \fBlspmac_move_preset_queue\fP (\fBlspmac_motor_t\fP *mp, char *preset_name)"
.br
.RI "\fIMove a given motor to one of its preset positions\&. \fP"
.ti -1c
.RI "int \fBlspmac_test_preset\fP (\fBlspmac_motor_t\fP *mp, char *preset_name, double tolerance)"
.br
.RI "\fIsee if the motor is within tolerance of the preset 1 means yes, it is 0 mean no it isn't or that the preset was not found \fP"
.ti -1c
.RI "int \fBlspmac_moveabs_fshut_queue\fP (\fBlspmac_motor_t\fP *mp, double requested_position)"
.br
.RI "\fIMove method for the fast shutter\&. \fP"
.ti -1c
.RI "int \fBlspmac_moveabs_bo_queue\fP (\fBlspmac_motor_t\fP *mp, double requested_position)"
.br
.RI "\fIMove method for binary i/o motor objects\&. \fP"
.ti -1c
.RI "void \fBlspmac_moveabs_timed_queue\fP (\fBlspmac_motor_t\fP *mp, double start, double delta, double time)"
.br
.RI "\fItimed motor move \fP"
.ti -1c
.RI "int \fBlspmac_moveabs_frontlight_oo_queue\fP (\fBlspmac_motor_t\fP *mp, double pos)"
.br
.RI "\fI'move' frontlight on/off \fP"
.ti -1c
.RI "int \fBlspmac_moveabs_flight_factor_queue\fP (\fBlspmac_motor_t\fP *mp, double pos)"
.br
.ti -1c
.RI "int \fBlspmac_moveabs_blight_factor_queue\fP (\fBlspmac_motor_t\fP *mp, double pos)"
.br
.ti -1c
.RI "void \fBlspmac_video_rotate\fP (double secs)"
.br
.RI "\fISpecial motion program to collect centering video\&. \fP"
.ti -1c
.RI "int \fBlspmac_set_motion_flags\fP (int *mmaskp, \fBlspmac_motor_t\fP *mp_1,\&.\&.\&.)"
.br
.RI "\fISet the coordinate system motion flags (m5075) for the null terminated list of motors that we are planning on running a motion program with\&. \fP"
.ti -1c
.RI "int \fBlspmac_est_move_time\fP (double *est_time, int *mmaskp, \fBlspmac_motor_t\fP *mp_1, int jog_1, char *preset_1, double end_point_1,\&.\&.\&.)"
.br
.RI "\fIMove the motors and estimate the time it'll take to finish the job\&. \fP"
.ti -1c
.RI "int \fBlspmac_est_move_time_wait\fP (double move_time, int cmask, \fBlspmac_motor_t\fP *mp_1,\&.\&.\&.)"
.br
.RI "\fIwait for motion to stop returns non-zero if the wait timed out \fP"
.ti -1c
.RI "int \fBlspmac_move_or_jog_abs_queue\fP (\fBlspmac_motor_t\fP *mp, double requested_position, int use_jog)"
.br
.RI "\fIMove method for normal stepper and servo motor objects Returns non-zero on abort, zero if OK\&. \fP"
.ti -1c
.RI "int \fBlspmac_move_or_jog_preset_queue\fP (\fBlspmac_motor_t\fP *mp, char *preset, int use_jog)"
.br
.RI "\fImove using a preset value returns 0 on success, non-zero on error \fP"
.ti -1c
.RI "int \fBlspmac_moveabs_queue\fP (\fBlspmac_motor_t\fP *mp, double requested_position)"
.br
.RI "\fIUse coordinate system motion program, if available, to move motor to requested position\&. \fP"
.ti -1c
.RI "int \fBlspmac_jogabs_queue\fP (\fBlspmac_motor_t\fP *mp, double requested_position)"
.br
.RI "\fIUse jog to move motor to requested position\&. \fP"
.ti -1c
.RI "int \fBlspmac_moveabs_wait\fP (\fBlspmac_motor_t\fP *mp, double timeout_secs)"
.br
.RI "\fIWait for motor to finish moving\&. \fP"
.ti -1c
.RI "void \fB_lspmac_motor_init\fP (\fBlspmac_motor_t\fP *d, char *name)"
.br
.RI "\fIHelper funciton for the init calls\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBlspmac_motor_init\fP (\fBlspmac_motor_t\fP *d, int wy, int wx, int *posp, int *stat1p, int *stat2p, char *wtitle, char *name, int(*moveAbs)(\fBlspmac_motor_t\fP *, double), int(*jogAbs)(\fBlspmac_motor_t\fP *, double))"
.br
.RI "\fIInitialize a pmac stepper or servo motor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBlspmac_fshut_init\fP (\fBlspmac_motor_t\fP *d)"
.br
.RI "\fIInitalize the fast shutter motor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBlspmac_bo_init\fP (\fBlspmac_motor_t\fP *d, char *name, char *write_fmt, int *read_ptr, int read_mask)"
.br
.RI "\fIInitialize binary i/o motor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBlspmac_dac_init\fP (\fBlspmac_motor_t\fP *d, int *posp, char *mvar, char *name, int(*moveAbs)(\fBlspmac_motor_t\fP *, double))"
.br
.RI "\fIInitialize DAC motor Note that some motors require further initialization from a database query\&. \fP"
.ti -1c
.RI "void \fBlspmac_soft_motor_read\fP (\fBlspmac_motor_t\fP *p)"
.br
.RI "\fIDummy routine to read a soft motor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBlspmac_soft_motor_init\fP (\fBlspmac_motor_t\fP *d, char *name, int(*moveAbs)(\fBlspmac_motor_t\fP *, double))"
.br
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBlspmac_bi_init\fP (\fBlspmac_bi_t\fP *d, char *name, int *ptr, int mask, char *onEvent, char *offEvent, char *onStatus, char *offStatus)"
.br
.RI "\fIInitialize binary input\&. \fP"
.ti -1c
.RI "void \fBlspmac_full_card_reset_cb\fP (char *event)"
.br
.RI "\fIreset and resetart \fP"
.ti -1c
.RI "void \fBlspmac_init\fP (int ivarsflag, int mvarsflag)"
.br
.RI "\fIInitialize this module\&. \fP"
.ti -1c
.RI "void \fBlspmac_cryoSwitchChanged_cb\fP (char *event)"
.br
.ti -1c
.RI "void \fBlspmac_scint_maybe_turn_on_dryer_cb\fP (char *event)"
.br
.RI "\fIMaybe start drying off the scintilator\&. \fP"
.ti -1c
.RI "void \fBlspmac_scint_maybe_turn_off_dryer_cb\fP (char *event)"
.br
.RI "\fIMaybe stop drying off the scintilator\&. \fP"
.ti -1c
.RI "void \fBlspmac_backLight_up_cb\fP (char *event)"
.br
.RI "\fITurn on the backlight whenever it goes up\&. \fP"
.ti -1c
.RI "void \fBlspmac_backLight_down_cb\fP (char *event)"
.br
.RI "\fITurn off the backlight whenever it goes down\&. \fP"
.ti -1c
.RI "void \fBlspmac_light_zoom_cb\fP (char *event)"
.br
.RI "\fISet the backlight intensity whenever the zoom is changed (and the backlight is up) \fP"
.ti -1c
.RI "void \fBlspmac_quitting_cb\fP (char *event)"
.br
.RI "\fIprepare to exit program in a couple of seconds \fP"
.ti -1c
.RI "void \fBlspmac_scint_maybe_move_sample_cb\fP (char *event)"
.br
.RI "\fIPerhaps we need to move the sample out of the way\&. \fP"
.ti -1c
.RI "void \fBlspmac_scint_maybe_return_sample_cb\fP (char *event)"
.br
.RI "\fIPerhaps we need to return the sample to the beam\&. \fP"
.ti -1c
.RI "void \fBlspmac_scint_dried_cb\fP (char *event)"
.br
.RI "\fITurn off the dryer\&. \fP"
.ti -1c
.RI "void \fBlspmac_zoom_lut_setup\fP ()"
.br
.RI "\fISet up lookup table for zoom\&. \fP"
.ti -1c
.RI "void \fBlspmac_flight_lut_setup\fP ()"
.br
.RI "\fISet up lookup table for flight\&. \fP"
.ti -1c
.RI "void \fBlspmac_blight_lut_setup\fP ()"
.br
.RI "\fISet up lookup table for blight\&. \fP"
.ti -1c
.RI "void \fBlspmac_fscint_lut_setup\fP ()"
.br
.RI "\fISet up lookup table for fscint\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBlspmac_find_motor_by_name\fP (char *name)"
.br
.ti -1c
.RI "void \fBlspmac_command_done_cb\fP (char *event)"
.br
.ti -1c
.RI "void \fBlspmac_spin\fP (\fBlspmac_motor_t\fP *mp)"
.br
.ti -1c
.RI "pthread_t * \fBlspmac_run\fP ()"
.br
.RI "\fIStart up the lspmac thread\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static int \fBls_pmac_state\fP = \fBLS_PMAC_STATE_DETACHED\fP"
.br
.RI "\fICurrent state of the PMAC communications state machine\&. \fP"
.ti -1c
.RI "static int \fBlspmac_running\fP = 1"
.br
.RI "\fIexit worker thread when zero \fP"
.ti -1c
.RI "int \fBlspmac_shutter_state\fP"
.br
.RI "\fIState of the shutter, used to detect changes\&. \fP"
.ti -1c
.RI "int \fBlspmac_shutter_has_opened\fP"
.br
.RI "\fIIndicates that the shutter had opened, perhaps briefly even if the state did not change\&. \fP"
.ti -1c
.RI "pthread_mutex_t \fBlspmac_shutter_mutex\fP"
.br
.RI "\fICoordinates threads reading shutter status\&. \fP"
.ti -1c
.RI "pthread_cond_t \fBlspmac_shutter_cond\fP"
.br
.RI "\fIAllows waiting for the shutter status to change\&. \fP"
.ti -1c
.RI "pthread_mutex_t \fBlspmac_moving_mutex\fP"
.br
.RI "\fICoordinate moving motors between threads\&. \fP"
.ti -1c
.RI "pthread_cond_t \fBlspmac_moving_cond\fP"
.br
.RI "\fIWait for motor(s) to finish moving condition\&. \fP"
.ti -1c
.RI "int \fBlspmac_moving_flags\fP"
.br
.RI "\fIFlag used to implement motor moving condition\&. \fP"
.ti -1c
.RI "static uint16_t \fBlspmac_control_char\fP = 0"
.br
.RI "\fIThe control character we've sent\&. \fP"
.ti -1c
.RI "static pthread_mutex_t \fBlspmac_ascii_mutex\fP"
.br
.RI "\fIKeep too many processes from sending commands at once\&. \fP"
.ti -1c
.RI "static int \fBlspmac_ascii_busy\fP = 0"
.br
.RI "\fIflag for condition to wait for \fP"
.ti -1c
.RI "static int \fBomega_zero_search\fP = 0"
.br
.RI "\fIIndicate we'd really like to know when omega crosses zero\&. \fP"
.ti -1c
.RI "static double \fBomega_zero_velocity\fP = 0"
.br
.RI "\fIrate (cnts/sec) that omega was traveling when it crossed zero \fP"
.ti -1c
.RI "struct timespec \fBomega_zero_time\fP"
.br
.RI "\fITime we believe that omega crossed zero\&. \fP"
.ti -1c
.RI "static struct timespec \fBlspmac_status_time\fP"
.br
.RI "\fITime the status was read\&. \fP"
.ti -1c
.RI "static struct timespec \fBlspmac_status_last_time\fP"
.br
.RI "\fITime the status was read\&. \fP"
.ti -1c
.RI "static pthread_t \fBpmac_thread\fP"
.br
.RI "\fIour thread to manage access and communication to the pmac \fP"
.ti -1c
.RI "pthread_mutex_t \fBpmac_queue_mutex\fP"
.br
.RI "\fImanage access to the pmac command queue \fP"
.ti -1c
.RI "pthread_cond_t \fBpmac_queue_cond\fP"
.br
.RI "\fIwait for a command to be sent to PMAC before continuing \fP"
.ti -1c
.RI "static struct pollfd \fBpmacfd\fP"
.br
.RI "\fIour poll structure \fP"
.ti -1c
.RI "static int \fBgetivars\fP = 0"
.br
.RI "\fIflag set at initialization to send i vars to db \fP"
.ti -1c
.RI "static int \fBgetmvars\fP = 0"
.br
.RI "\fIflag set at initialization to send m vars to db \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP \fBlspmac_bis\fP [32]"
.br
.RI "\fIarray of binary inputs \fP"
.ti -1c
.RI "int \fBlspmac_nbis\fP = 0"
.br
.RI "\fInumber of active binary inputs \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP \fBlspmac_motors\fP [\fBLSPMAC_MAX_MOTORS\fP]"
.br
.RI "\fIAll our motors\&. \fP"
.ti -1c
.RI "int \fBlspmac_nmotors\fP = 0"
.br
.RI "\fIThe number of motors we manage\&. \fP"
.ti -1c
.RI "struct hsearch_data \fBmotors_ht\fP"
.br
.RI "\fIA hash table to find motors by name\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBomega\fP"
.br
.RI "\fIMD2 omega axis (the air bearing) \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBalignx\fP"
.br
.RI "\fIAlignment stage X\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBaligny\fP"
.br
.RI "\fIAlignment stage Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBalignz\fP"
.br
.RI "\fIAlignment stage X\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBanal\fP"
.br
.RI "\fIPolaroid analyzer motor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBzoom\fP"
.br
.RI "\fIOptical zoom\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBapery\fP"
.br
.RI "\fIAperture Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBaperz\fP"
.br
.RI "\fIAperture Z\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcapy\fP"
.br
.RI "\fICapillary Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcapz\fP"
.br
.RI "\fICapillary Z\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBscint\fP"
.br
.RI "\fIScintillator Z\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcenx\fP"
.br
.RI "\fICentering Table X\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBceny\fP"
.br
.RI "\fICentering Table Y\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBkappa\fP"
.br
.RI "\fIKappa\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBphi\fP"
.br
.RI "\fIPhi (not data collection axis) \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBfshut\fP"
.br
.RI "\fIFast shutter\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBflight\fP"
.br
.RI "\fIFront Light DAC\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBblight\fP"
.br
.RI "\fIBack Light DAC\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBfscint\fP"
.br
.RI "\fIScintillator Piezo DAC\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBsmart_mag_oo\fP"
.br
.RI "\fISmart Magnet on/off\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBblight_ud\fP"
.br
.RI "\fIBack light Up/Down actuator\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBcryo\fP"
.br
.RI "\fIMove the cryostream towards or away from the crystal\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBdryer\fP"
.br
.RI "\fIblow air on the scintilator to dry it off \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBfluo\fP"
.br
.RI "\fIMove the fluorescence detector in/out\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBflight_oo\fP"
.br
.RI "\fITurn front light on/off\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBblight_f\fP"
.br
.RI "\fIBack light scale factor\&. \fP"
.ti -1c
.RI "\fBlspmac_motor_t\fP * \fBflight_f\fP"
.br
.RI "\fIFront light scale factor\&. \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBlp_air\fP"
.br
.RI "\fILow pressure air OK\&. \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBhp_air\fP"
.br
.RI "\fIHigh pressure air OK\&. \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBcryo_switch\fP"
.br
.RI "\fIthat little toggle switch for the cryo \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBblight_down\fP"
.br
.RI "\fIBacklight is down\&. \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBblight_up\fP"
.br
.RI "\fIBacklight is up\&. \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBcryo_back\fP"
.br
.RI "\fIcryo is in the back position \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBfluor_back\fP"
.br
.RI "\fIfluor is in the back position \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBsample_detected\fP"
.br
.RI "\fIsmart magnet detected sample \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBetel_ready\fP"
.br
.RI "\fIETEL is ready\&. \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBetel_on\fP"
.br
.RI "\fIETEL is on\&. \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBetel_init_ok\fP"
.br
.RI "\fIETEL initialized OK\&. \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBminikappa_ok\fP"
.br
.RI "\fIMinikappa is OK (whatever that means) \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBsmart_mag_on\fP"
.br
.RI "\fIsmart magnet is on \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBarm_parked\fP"
.br
.RI "\fI(whose arm? parked where?) \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBshutter_open\fP"
.br
.RI "\fIshutter is open (note in pmc says this is a slow input) \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBsmart_mag_err\fP"
.br
.RI "\fIsmart magnet error (coil broken perhaps) \fP"
.ti -1c
.RI "\fBlspmac_bi_t\fP * \fBsmart_mag_off\fP"
.br
.RI "\fIsmart magnet is off \fP"
.ti -1c
.RI "static unsigned char \fBdbmem\fP [64 *1024]"
.br
.RI "\fIdouble buffered memory \fP"
.ti -1c
.RI "static int \fBdbmemIn\fP = 0"
.br
.RI "\fInext location \fP"
.ti -1c
.RI "static struct timeval 
.br
pmac_time_sent \fBnow\fP"
.br
.RI "\fIused to ensure we do not send commands to the pmac too often\&. Only needed for non-DB commands\&. \fP"
.ti -1c
.RI "static \fBpmac_cmd_t\fP \fBrr_cmd\fP"
.br
.ti -1c
.RI "static \fBpmac_cmd_t\fP \fBgb_cmd\fP"
.br
.ti -1c
.RI "static \fBpmac_cmd_t\fP \fBcr_cmd\fP"
.br
.RI "\fIcommands to send out 'readready', 'getbuffer', 'controlresponse' (initialized in main) \fP"
.ti -1c
.RI "static \fBpmac_cmd_queue_t\fP \fBethCmdQueue\fP [\fBPMAC_CMD_QUEUE_LENGTH\fP]"
.br
.RI "\fIPMAC command queue\&. \fP"
.ti -1c
.RI "static unsigned int \fBethCmdOn\fP = 0"
.br
.RI "\fIpoints to next empty PMAC command queue position \fP"
.ti -1c
.RI "static unsigned int \fBethCmdOff\fP = 0"
.br
.RI "\fIpoints to current command (or none if == ethCmdOn) \fP"
.ti -1c
.RI "static unsigned int \fBethCmdReply\fP = 0"
.br
.RI "\fIUsed like ethCmdOff only to deal with the pmac reply to a command\&. \fP"
.ti -1c
.RI "static char * \fBpmac_error_strs\fP []"
.br
.RI "\fIDecode the errors perhaps returned by the PMAC\&. \fP"
.ti -1c
.RI "static \fBmd2_status_t\fP \fBmd2_status\fP"
.br
.RI "\fIBuffer for MD2 Status\&. \fP"
.ti -1c
.RI "pthread_mutex_t \fBmd2_status_mutex\fP"
.br
.RI "\fISynchronize reading/writting status buffer\&. \fP"
.ti -1c
.RI "static \fBlspmac_ascii_buffers_t\fP \fBlspmac_ascii_buffers\fP"
.br
.ti -1c
.RI "pthread_mutex_t \fBlspmac_ascii_buffers_mutex\fP"
.br
.ti -1c
.RI "static \fBlspmac_dpascii_queue_t\fP \fBlspmac_dpascii_queue\fP [\fBLSPMAC_DPASCII_QUEUE_LENGTH\fP]"
.br
.ti -1c
.RI "static uint32_t \fBlspmac_dpascii_on\fP = 0"
.br
.ti -1c
.RI "static uint32_t \fBlspmac_dpascii_off\fP = 0"
.br
.in -1c
.SH "Detailed Description"
.PP 
Routines concerned with communication with PMAC\&. 

Test suite for the pgpmac routines\&.
.PP
.PP
.nf
\date 2012 – 2013
\author Keith Brister
\copyright All Rights Reserved
.fi
.PP
.PP
This is a state machine (surprise!)
.PP
Lacking is support for writingbuffer, control writing and reading, as well as double buffered memory It looks like several different methods of managing PMAC communications are possible\&. Here is set up a queue of outgoing commands and deal completely with the result before sending the next\&. A full handshake of acknowledgements and 'readready' is expected\&.
.PP
Most of these states are to deal with the 'serial-port' style of communications\&. Things are surprisingly simple for the double buffer ascii and control character methods\&.
.PP
.PP
.nf
.fi
.PP
.PP
.PP
.nf
 State    Description
  -1      Reset the connection
   0      Detached: need to connect to tcp port
   1      Idle (waiting for a command to send to the pmac)
   2      Send command
   3      Waiting for command acknowledgement (no further response expected)
   4      Waiting for control character acknowledgement (further response expected)
   5      Waiting for command acknowledgement (further response expected)
   6      Waiting for get memory response
   7      Send controlresponse
   8      Send readready
   9      Waiting for acknowledgement of 'readready'
  10      Send readbuffer
  11      Waiting for control response
  12      Waiting for readbuffer response
.fi
.PP
.PP
.PP
.nf
.fi
.PP
.PP
\fBDate:\fP
.RS 4
2013 
.RE
.PP
\fBAuthor:\fP
.RS 4
Keith Brister 
.RE
.PP
\fBCopyright:\fP
.RS 4
All Rights Reserved
.RE
.PP
A place to put unit tests\&. 
.PP
Definition in file \fBlspmac\&.c\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define LS_PMAC_STATE_CR   7"

.PP
Definition at line 52 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_DETACHED   0"

.PP
Definition at line 45 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_GB   10"

.PP
Definition at line 55 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_GMR   6"

.PP
Definition at line 51 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_IDLE   1"

.PP
Definition at line 46 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_RESET   -1"

.PP
Definition at line 44 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_RR   8"

.PP
Definition at line 53 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_SC   2"

.PP
Definition at line 47 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_WACK   5"

.PP
Definition at line 50 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_WACK_CC   4"

.PP
Definition at line 49 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_WACK_NFR   3"

.PP
Definition at line 48 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_WACK_RR   9"

.PP
Definition at line 54 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_WCR   11"

.PP
Definition at line 56 of file lspmac\&.c\&.
.SS "#define LS_PMAC_STATE_WGB   12"

.PP
Definition at line 57 of file lspmac\&.c\&.
.SS "#define LSPMAC_DPASCII_QUEUE_LENGTH   1024"

.PP
Definition at line 368 of file lspmac\&.c\&.
.SS "#define LSPMAC_MAX_MOTORS   48"

.PP
Definition at line 95 of file lspmac\&.c\&.
.SS "#define LSPMAC_PRESET_REGEX   '(\&.*\\\\\&.%s\\\\\&.presets)\\\\\&.([0-9]+)\\\\\&.(name|position)'"

.PP
Regex to pick out preset name and corresponding position\&. 
.PP
Definition at line 151 of file lspmac\&.c\&.
.SS "#define PMAC_CMD_QUEUE_LENGTH   2048"

.PP
Size of the PMAC command queue\&. 
.PP
Definition at line 195 of file lspmac\&.c\&.
.SS "#define pmac_cmd_size   8"

.PP
PMAC command size in bytes\&. 
.PP
Definition at line 161 of file lspmac\&.c\&.
.SS "#define PMAC_MIN_CMD_TIME   10000\&.0"

.PP
Minimum time between commands to the pmac\&. 
.PP
Definition at line 191 of file lspmac\&.c\&.
.SS "#define PMACPORT   1025"

.PP
The PMAC (only) listens on this port\&. 
.PP
Definition at line 155 of file lspmac\&.c\&.
.SS "#define VR_CTRL_RESPONSE   0xc4"

.PP
Definition at line 177 of file lspmac\&.c\&.
.SS "#define VR_DOWNLOAD   0x40"

.PP
Definition at line 164 of file lspmac\&.c\&.
.SS "#define VR_FWDOWNLOAD   0xcb"

.PP
Definition at line 181 of file lspmac\&.c\&.
.SS "#define VR_IPADDRESS   0xe0"

.PP
Definition at line 182 of file lspmac\&.c\&.
.SS "#define VR_PMAC_FLUSH   0xb3"

.PP
Definition at line 168 of file lspmac\&.c\&.
.SS "#define VR_PMAC_GETBUFFER   0xc5"

.PP
Definition at line 178 of file lspmac\&.c\&.
.SS "#define VR_PMAC_GETLINE   0xb1"

.PP
Definition at line 167 of file lspmac\&.c\&.
.SS "#define VR_PMAC_GETMEM   0xb4"

.PP
Definition at line 169 of file lspmac\&.c\&.
.SS "#define VR_PMAC_GETRESPONSE   0xbf"

.PP
Definition at line 175 of file lspmac\&.c\&.
.SS "#define VR_PMAC_PORT   0xbe"

.PP
Definition at line 174 of file lspmac\&.c\&.
.SS "#define VR_PMAC_READREADY   0xc2"

.PP
Definition at line 176 of file lspmac\&.c\&.
.SS "#define VR_PMAC_SENDCTRLCHAR   0xb6"

.PP
Definition at line 171 of file lspmac\&.c\&.
.SS "#define VR_PMAC_SENDLINE   0xb0"

.PP
Definition at line 166 of file lspmac\&.c\&.
.SS "#define VR_PMAC_SETBIT   0xba"

.PP
Definition at line 172 of file lspmac\&.c\&.
.SS "#define VR_PMAC_SETBITS   0xbb"

.PP
Definition at line 173 of file lspmac\&.c\&.
.SS "#define VR_PMAC_SETMEM   0xb5"

.PP
Definition at line 170 of file lspmac\&.c\&.
.SS "#define VR_PMAC_WRITEBUFFER   0xc6"

.PP
Definition at line 179 of file lspmac\&.c\&.
.SS "#define VR_PMAC_WRITEERROR   0xc7"

.PP
Definition at line 180 of file lspmac\&.c\&.
.SS "#define VR_UPLOAD   0xc0"

.PP
Definition at line 163 of file lspmac\&.c\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBlspmac_ascii_buffers_struct\fP  \fBlspmac_ascii_buffers_t\fP"

.SS "typedef struct \fBlspmac_combined_move_struct\fP  \fBlspmac_combined_move_t\fP"

.SS "typedef struct \fBlspmac_dpascii_queue_struct\fP  \fBlspmac_dpascii_queue_t\fP"

.SS "typedef struct \fBmd2StatusStruct\fP  \fBmd2_status_t\fP"

.PP
The block of memory retrieved in a status request\&. 
.SH "Function Documentation"
.PP 
.SS "void _lspmac_motor_init (\fBlspmac_motor_t\fP *d, char *name)"

.PP
Helper funciton for the init calls\&. 
.PP
Definition at line 3626 of file lspmac\&.c\&.
.PP
.nf
                                                        {
  pthread_mutexattr_t mutex_initializer;
  // Use recursive mutexs
  //
  pthread_mutexattr_init( &mutex_initializer);
  pthread_mutexattr_settype( &mutex_initializer, PTHREAD_MUTEX_RECURSIVE);

  lspmac_nmotors++;

  pthread_mutex_init( &(d->mutex), &mutex_initializer);
  pthread_cond_init(  &(d->cond), NULL);

  d->magic               = LSPMAC_MAGIC_NUMBER;
  d->name                = strdup(name);
  d->active              = lsredis_get_obj( '%s\&.active',     d->name);
  d->active_init         = lsredis_get_obj( '%s\&.active_init',        d->name);
  d->axis                = lsredis_get_obj( '%s\&.axis',               d->name);
  d->coord_num           = lsredis_get_obj( '%s\&.coord_num',         d->name);
  d->home                = lsredis_get_obj( '%s\&.home',               d->name);
  d->home_group          = lsredis_get_obj( '%s\&.homeGroup',         d->name);
  d->in_position_band    = lsredis_get_obj( '%s\&.in_position_band',  d->name);
  d->inactive_init       = lsredis_get_obj( '%s\&.inactive_init',      d->name);
  d->redis_fmt           = lsredis_get_obj( '%s\&.format',            d->name);
  d->max_accel           = lsredis_get_obj( '%s\&.max_accel',         d->name);
  d->max_speed           = lsredis_get_obj( '%s\&.max_speed',         d->name);
  d->max_pos             = lsredis_get_obj( '%s\&.maxPosition',       d->name);
  d->min_pos             = lsredis_get_obj( '%s\&.minPosition',       d->name);
  d->motor_num           = lsredis_get_obj( '%s\&.motor_num',         d->name);
  d->neg_limit_hit       = lsredis_get_obj( '%s\&.negLimitSet',       d->name);
  d->neutral_pos         = lsredis_get_obj( '%s\&.neutralPosition',   d->name);
  d->redis_position      = lsredis_get_obj( '%s\&.position',          d->name);
  d->pos_limit_hit       = lsredis_get_obj( '%s\&.posLimitSet',       d->name);
  d->precision           = lsredis_get_obj( '%s\&.precision',         d->name);
  d->printf_fmt          = lsredis_get_obj( '%s\&.printf',            d->name);
  d->status_str          = lsredis_get_obj( '%s\&.status_str',        d->name);
  d->u2c                 = lsredis_get_obj( '%s\&.u2c',               d->name);
  d->unit                = lsredis_get_obj( '%s\&.unit',              d->name);
  d->update_resolution   = lsredis_get_obj( '%s\&.update_resolution', d->name);
  d->lut                 = NULL;
  d->nlut                = 0;
  d->homing              = 0;
  d->dac_mvar            = NULL;
  d->actual_pos_cnts_p   = NULL;
  d->status1_p           = NULL;
  d->status2_p           = NULL;
  d->win                 = NULL;
  d->read                = NULL;
  d->reported_position   = INFINITY;
  d->reported_pg_position= INFINITY;

  lsevents_preregister_event( '%s queued', d->name);
  lsevents_preregister_event( '%s command accepted', d->name);

  lsredis_load_presets( d->name);
}
.fi
.SS "char* cleanstr (char *s)"

.PP
Replace \\r with \\n in null terminated string and print result to terminal\&. Needed to turn PMAC messages into something printable\&. \fBParameters:\fP
.RS 4
\fIs\fP String to print to terminal\&. 
.RE
.PP

.PP
Definition at line 554 of file lspmac\&.c\&.
.PP
.nf
                {
  char t[256];
  int i;

  t[0] = 0;
  for( i=0; i<strlen( s) && i < sizeof( t); i++) {
    if( s[i] == '\r')
      t[i] = '\n';
    else
      t[i] = s[i];
  }
  t[i] = 0;
  return strdup( s);
}
.fi
.SS "void hex_dump (intn, unsigned char *s)"

.PP
Prints a hex dump of the given data\&. Used to debug packet data\&. \fBParameters:\fP
.RS 4
\fIn\fP Number of bytes passed in s 
.br
\fIs\fP Data to dump 
.RE
.PP

.PP
Definition at line 527 of file lspmac\&.c\&.
.PP
.nf
                {

  int i;        // row counter
  int j;        // column counter
  unsigned char outs[128], outs1[4];

  for( i=0; n > 0; i++) {

    sprintf( (char *)outs, '%04d: ', 16*i);
    for( j=0; j<16 && n > 0; j++) {
      if( j==8)
        strcat( (char *)outs, '  ');
      sprintf( (char *)outs1, ' %02x',  *(s + 16*i + j));
      strcat( (char *)outs, (char *)outs1);
      n--;
    }
    lslogging_log_message( 'hex_dump: %s', outs);
  }
}
.fi
.SS "void lsConnect (char *ipaddr)"

.PP
Connect to the PMAC socket\&. Establish or reestablish communications\&. \fBParameters:\fP
.RS 4
\fIipaddr\fP String representation of the IP address (dot quad or FQN) 
.RE
.PP

.PP
Definition at line 575 of file lspmac\&.c\&.
.PP
.nf
                 {
  int psock;                    // our socket: value stored in pmacfda\&.fd
  int err;                      // error code from some system calls
  struct sockaddr_in *addrP;    // our address structure to connect to
  struct addrinfo ai_hints;     // required for getaddrinfo
  struct addrinfo *ai_resultP;  // linked list of address structures (we'll always pick the first)

  pmacfd\&.fd     = -1;
  pmacfd\&.events = 0;

  // Initial buffer(s)
  memset( &ai_hints,  0, sizeof( ai_hints));

  ai_hints\&.ai_family   = AF_INET;
  ai_hints\&.ai_socktype = SOCK_STREAM;


  //
  // get address
  //
  err = getaddrinfo( ipaddr, NULL, &ai_hints, &ai_resultP);
  if( err != 0) {

    lslogging_log_message( 'Could not find address: %s', gai_strerror( err));

    return;
  }


  addrP = (struct sockaddr_in *)ai_resultP->ai_addr;
  addrP->sin_port = htons( PMACPORT);


  psock = socket( PF_INET, SOCK_STREAM, 0);
  if( psock == -1) {
    lslogging_log_message( 'Could not create socket');
    return;
  }

  err = connect( psock, (const struct sockaddr *)addrP, sizeof( *addrP));
  if( err != 0) {
    lslogging_log_message( 'Could not connect socket: %s', strerror( errno));
    return;
  }

  ls_pmac_state = LS_PMAC_STATE_IDLE;
  pmacfd\&.fd     = psock;
  pmacfd\&.events = POLLIN;

}
.fi
.SS "void lspmac_abort ()"

.PP
abort motion and try to recover 
.PP
Definition at line 2127 of file lspmac\&.c\&.
.PP
.nf
                    {
  //
  // Stop everything!  (consider ^O instead of ^A)
  //
  lspmac_SockSendDPControlChar( 'Abort Request', 0x01);

  //
  // and reset motion flag
  //
  lspmac_SockSendDPline( 'Reset', '%s', 'M5075=0');

}
.fi
.SS "void lspmac_asciicmdCB (\fBpmac_cmd_queue_t\fP *cmd, intnreceived, char *buf)"

.PP
PMAC has received our ascii command request Now see when it is ready for the next one\&. 
.PP
Definition at line 2041 of file lspmac\&.c\&.
.PP
.nf
                                                                         {
  lspmac_get_ascii( cmd->event);
}
.fi
.SS "void lspmac_backLight_down_cb (char *event)"

.PP
Turn off the backlight whenever it goes down\&. \fBParameters:\fP
.RS 4
\fIevent\fP Name of the event that called us 
.RE
.PP

.PP
Definition at line 4113 of file lspmac\&.c\&.
.PP
.nf
                                            {
  blight->moveAbs( blight, 0\&.0);
}
.fi
.SS "void lspmac_backLight_up_cb (char *event)"

.PP
Turn on the backlight whenever it goes up\&. \fBParameters:\fP
.RS 4
\fIevent\fP Name of the event that called us 
.RE
.PP

.PP
Definition at line 4106 of file lspmac\&.c\&.
.PP
.nf
                                          {
  blight->moveAbs( blight, (int)(lspmac_getPosition( zoom)));
}
.fi
.SS "\fBlspmac_bi_t\fP* lspmac_bi_init (\fBlspmac_bi_t\fP *d, char *name, int *ptr, intmask, char *onEvent, char *offEvent, char *onStatus, char *offStatus)"

.PP
Initialize binary input\&. 
.PP
Definition at line 3815 of file lspmac\&.c\&.
.PP
.nf
                                                                                                                                             {
  lspmac_nbis++;
  pthread_mutex_init( &(d->mutex), NULL);
  d->name           = strdup( name);
  d->ptr            = ptr;
  d->mask           = mask;
  d->changeEventOn  = strdup( onEvent);
  d->changeEventOff = strdup( offEvent);
  d->onStatus       = strdup( onStatus);
  d->offStatus      = strdup( offStatus);
  d->first_time     = 1;
  d->status_str     = lsredis_get_obj( '%s\&.status_str', d->name);

  lsevents_preregister_event( '%s', d->changeEventOn);
  lsevents_preregister_event( '%s', d->changeEventOff);

  return d;
}
.fi
.SS "void lspmac_blight_lut_setup ()"

.PP
Set up lookup table for blight\&. 
.PP
Definition at line 4306 of file lspmac\&.c\&.
.PP
.nf
                               {
  int i;
  lsredis_obj_t *p;

  pthread_mutex_lock( &blight->mutex);

  blight->nlut = 11;
  blight->lut = calloc( 2 * blight->nlut, sizeof( double));
  if( blight->lut == NULL) {
    lslogging_log_message( 'lspmac_blight_lut_setup: out of memory');
    exit( -1);
  }

  blight->lut[0] = 0;
  blight->lut[1] = 0;

  for( i=1; i<blight->nlut; i++) {
    p = lsredis_get_obj( 'cam\&.zoom\&.%d\&.LightIntensity', i);
    if( p==NULL || strlen( lsredis_getstr(p)) == 0) {
      free( blight->lut);
      blight->lut = NULL;
      blight->nlut = 0;
      pthread_mutex_unlock( &blight->mutex);
      lslogging_log_message( 'lspmac_blight_lut_setup: cannot find MotorPosition element for cam\&.blight level %d', i);
      return;
    }
    blight->lut[2*i]   = i;
    blight->lut[2*i+1] = 18500\&.0 * lsredis_getd( p) / 100\&.0;

  }
  for( i=0; i<blight->nlut; i++) {
    lslogging_log_message( 'lspmac_blight_lut_setup:  i: %d  x: %f  y: %f  y(lut): %f  x(rlut): %f',
                           i, blight->lut[2*i], blight->lut[2*i+1],
                           lspmac_lut( blight->nlut, blight->lut, blight->lut[2*i]),
                           lspmac_rlut( blight->nlut, blight->lut, blight->lut[2*i+1])
                           );
  }
  pthread_mutex_unlock( &blight->mutex);
}
.fi
.SS "\fBlspmac_motor_t\fP* lspmac_bo_init (\fBlspmac_motor_t\fP *d, char *name, char *write_fmt, int *read_ptr, intread_mask)"

.PP
Initialize binary i/o motor\&. \fBParameters:\fP
.RS 4
\fId\fP Our uninitialized motor object 
.br
\fIname\fP Name of motor to coordinate with DB 
.br
\fIwrite_fmt\fP Format string used to generate PMAC command to move motor 
.br
\fIread_ptr\fP Pointer to byte in md2_status to find position 
.br
\fIread_mask\fP Bitmask to find position in *read_ptr 
.RE
.PP

.PP
Definition at line 3744 of file lspmac\&.c\&.
.PP
.nf
                                  {

  _lspmac_motor_init( d, name);

  d->moveAbs           = lspmac_moveabs_bo_queue;
  d->jogAbs            = lspmac_moveabs_bo_queue;
  d->read              = lspmac_bo_read;
  d->write_fmt         = strdup( write_fmt);
  d->read_ptr          = read_ptr;
  d->read_mask         = read_mask;

  lsevents_preregister_event( '%s 1', d->name);
  lsevents_preregister_event( '%s 0', d->name);
  return d;
}
.fi
.SS "void lspmac_bo_read (\fBlspmac_motor_t\fP *mp)"

.PP
Read the state of a binary i/o motor This is the read method for the binary i/o motor class\&. \fBParameters:\fP
.RS 4
\fImp\fP The motor 
.RE
.PP

.PP
Definition at line 1153 of file lspmac\&.c\&.
.PP
.nf
                      {
  int pos, changed;
  char *fmt;

  pthread_mutex_lock( &(mp->mutex));

  pos = (*(mp->read_ptr) & mp->read_mask) == 0 ? 0 : 1;

  changed = pos != mp->position;
  mp->position = pos;

  if( changed) {
    mp->motion_seen  = 1;
    mp->not_done     = 0;
    mp->command_sent = 1;
    pthread_cond_signal( &(mp->cond));
    lsevents_send_event( '%s Moving', mp->name);
    lsevents_send_event( '%s %d', mp->name, pos);
    lsevents_send_event( '%s In Position', mp->name);
  }

  if( mp->reported_position != mp->position) {
    fmt = lsredis_getstr(mp->redis_fmt);
    lsredis_setstr( mp->redis_position, fmt, mp->position);
    lsredis_setstr( mp->status_str, '%s', mp->position ? 'On' : 'Off');
    free(fmt);
    mp->reported_position = mp->position;
  }

  pthread_mutex_unlock( &(mp->mutex));
}
.fi
.SS "void lspmac_command_done_cb (char *event)"

.PP
Definition at line 4384 of file lspmac\&.c\&.
.PP
.nf
                                          {
  int i;
  char s[32];
  lspmac_motor_t *mp;

  s[0] = 0;
  for( i=0; i<sizeof(s)-1 && event[i]; i++) {
    s[i] = 0;
    if( event[i] == ' ')
      break;
    s[i] = event[i];
  }

  mp = lspmac_find_motor_by_name( s);

  if( mp == NULL)
    return;

  pthread_mutex_lock( &(mp->mutex));

  mp->command_sent = 1;

  pthread_cond_signal( &(mp->cond));
  pthread_mutex_unlock( &(mp->mutex));

  return;
}
.fi
.SS "void lspmac_cryoSwitchChanged_cb (char *event)"

.PP
Definition at line 4036 of file lspmac\&.c\&.
.PP
.nf
                                               {
  int pos;

  pthread_mutex_lock( &(cryo->mutex));
  pos = cryo->position;
  pthread_mutex_unlock( &(cryo->mutex));

  cryo->moveAbs( cryo, pos ? 0\&.0 : 1\&.0);
}
.fi
.SS "\fBlspmac_motor_t\fP* lspmac_dac_init (\fBlspmac_motor_t\fP *d, int *posp, char *mvar, char *name, int(*)(\fBlspmac_motor_t\fP *, double)moveAbs)"

.PP
Initialize DAC motor Note that some motors require further initialization from a database query\&. For this reason this initialzation code must be run before the database queue is allowed to be processed\&. \fBParameters:\fP
.RS 4
\fId\fP Returns the (almost) initialized motor object [in,out] unitintialized motor 
.br
\fIposp\fP Location of current position 
.br
\fImvar\fP M variable, ie, 'M1200' 
.br
\fIname\fP name to coordinate with DB 
.br
\fImoveAbs\fP Method to use to move this motor 
.RE
.PP

.PP
Definition at line 3773 of file lspmac\&.c\&.
.PP
.nf
                                  {

  _lspmac_motor_init( d, name);
  d->moveAbs           = moveAbs;
  d->jogAbs            = moveAbs;
  d->read              = lspmac_dac_read;
  d->actual_pos_cnts_p = posp;
  d->dac_mvar          = strdup(mvar);

  return d;
}
.fi
.SS "void lspmac_dac_read (\fBlspmac_motor_t\fP *mp)"

.PP
Read a DAC motor position\&. \fBParameters:\fP
.RS 4
\fImp\fP The motor 
.RE
.PP

.PP
Definition at line 1189 of file lspmac\&.c\&.
.PP
.nf
                       {
  double u2c;
  char *fmt;

  pthread_mutex_lock( &(mp->mutex));
  mp->actual_pos_cnts = *mp->actual_pos_cnts_p;
  u2c = lsredis_getd( mp->u2c);

  if( mp->nlut >0 && mp->lut != NULL) {
    if( u2c == 0\&.0)
      u2c = 1\&.0;
    mp->position = lspmac_rlut( mp->nlut, mp->lut, mp->actual_pos_cnts/u2c);
  } else {
    if( u2c != 0\&.0) {
      mp->position = mp->actual_pos_cnts / u2c;
    } else {
      mp->position = mp->actual_pos_cnts;
    }
  }

  if( fabs(mp->reported_position - mp->position) >= lsredis_getd(mp->update_resolution)) {
    fmt = lsredis_getstr(mp->redis_fmt);
    lsredis_setstr( mp->redis_position, fmt, mp->position);
    free(fmt);
    mp->reported_position = mp->position;
  }

  pthread_mutex_unlock( &(mp->mutex));
}
.fi
.SS "void lspmac_Error (char *buff)"

.PP
The service routing detected an error condition\&. Scan the response buffer for an error code and print it out\&. \fBParameters:\fP
.RS 4
\fIbuff\fP Buffer returned by PMAC perhaps containing a NULL terminated message\&. 
.RE
.PP

.PP
Definition at line 784 of file lspmac\&.c\&.
.PP
.nf
                    {
  int err;
  //
  // assume buff points to a 1400 byte array of stuff read from the pmac
  //

  if( buff[0] == 7 && buff[1] == 'E' && buff[2] == 'R' && buff[3] == 'R') {
    buff[7] = 0;  // For null termination
    err = atoi( &(buff[4]));
    if( err > 0 && err < 20) {
      lslogging_log_message( pmac_error_strs[err]);
    }
  }
  lspmac_Reset();
}
.fi
.SS "int lspmac_est_move_time (double *est_time, int *mmaskp, \fBlspmac_motor_t\fP *mp_1, intjog_1, char *preset_1, doubleend_point_1, \&.\&.\&.)"

.PP
Move the motors and estimate the time it'll take to finish the job\&. Returns the estimate time and the coordinate system mask to wait for 
.PP
\fBParameters:\fP
.RS 4
\fIest_time\fP Returns number of seconds we estimate the move(s) will take 
.br
\fImmaskp\fP Mask of coordinate systems we are trying to move, excluding jogs\&. Used to wait for motions to complete 
.br
\fImp_1\fP Pointer to first motor 
.br
\fIjog_1\fP 1 to force a jog, 0 to try a motion program DO NOT MIX JOGS AND MOTION PROGRAMS IN THE SAME COORDINATE SYSTEM! 
.br
\fIpreset_1\fP Name of preset we'd like to move to or NULL if end_point_1 should be used instead 
.br
\fIend_point_1\fP End point for the first motor\&. Ignored if preset_1 is non null and identifies a valid preset for this motor 
.br
\fI\&.\&.\&.\fP Perhaps more quads of motors, jog flags, preset names, and end points\&. End is a NULL motor pointer MUST END ARG LIST WITH NULL 
.RE
.PP
< units to counts
.PP
< The total distance we need to go
.PP
< Our maximum velocity
.PP
< Our maximum acceleration
.PP
< Total time for this motor
.PP
< coordinate system motion flags 
.PP
Definition at line 2852 of file lspmac\&.c\&.
.PP
.nf
                                                                                                                                   {
  static char axes[] = 'XYZUVWABC';
  int qs[9];
  lspmac_combined_move_t motions[32];
  char s[256];
  int foundone;
  int moving_flags;
  struct timespec timeout;
  int j;
  va_list arg_ptr;
  lspmac_motor_t *mp;
  double ep, maybe_ep;
  char *ps;
  double
    min_pos,
    max_pos,
    neutral_pos,
    u2c,                
    D,                  
    V,                  
    A,                  
    Tt;                 
  int err;
  int jog;
  int i;
  uint32_t m5075;               

  // reset our coordinate flags and command strings
  //
  for( i=0; i<32; i++) {
    motions[i]\&.moveme = 0;
  }
  m5075  = 0;
  if( mmaskp != NULL)
    *mmaskp = 0;

  //
  // Initialze first iteration
  //
  *est_time = 0\&.0;
  mp  = mp_1;
  ps  = preset_1;
  ep  = end_point_1;
  jog = jog_1;

  va_start( arg_ptr, end_point_1);
  while( 1) {
    /*
     *    :                  |       Constant       |
     *    :                  |<---   Velocity   --->|
     *    :                  |       Time (Ct)      |
     *  V :                   ----------------------              ---------
     *  e :                 /                        \               ^
     *  l :                /                          \              |
     *  o :               /                            \             |
     *  c :              /                              \            V
     *  i :             /                                \           |
     *  t :            /                                  \          |
     *  y :___________/\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\_________v___________
     *                |      |         Time              
     *                |      |
     *             -->|      |<-- Acceleration Time  (At)
     *                |
     *                |<-----    Total  Time (Tt)  ------->|
     *
     *      Assumption 1: We can replace S curve acceleration with linear acceleration
     *      for the purposes of distance and time calculations for the timeout
     *      period that we are attempting to calculate here\&.
     *
     *      Ct  = Constant Velocity Time\&.  The time spent at constant velocity\&.
     *
     *      At  = Acceleration Time\&.  Time spent accelerating at either end of the ramp, that is,
     *      1/2 the total time spent accelerating and decelerating\&.
     *
     *      D   = the total distance we need to travel
     *
     *      V   = constant velocity\&.  Here we use the motor's maximum velocity\&.
     *
     *      A   = the motor acceleration, Here it's the maximum acceleration\&.
     *
     *      V = A * At   
     *
     *      or  At = V/A
     *
     *      The Total Time (Tt) is
     *
     *      Tt = Ct + 2 * At
     *
     *
     *
     *      If we had infinite acceleration the total time would be D/V\&.  To account for finite acceleration we just need to
     *      adjust this for the average velocity while accelerating (0\&.5 V)\&.  This neatly adds a single V/A term:
     *
     *      (1)     Tt = D/V  + V/A
     *
     *      When the distance is short, we need a different calculation:
     *
     *      D = 0\&.5 * A * T1^2  + 0\&.5 * A * T2^2  (T1 = acceleration time and T2 = deceleration time)
     *
     *      or, since total time  Tt = T1 + T2 and T1 = T2,
     *
     *      D = A * (0\&.5*Tt)^2
     *
     *      or
     *      
     *      (2)    Tt = 2 * sqrt( D/A)
     *
     *
     *      When we accelerate to the maximum speed the time it takes is V/A so the distance we travel (Da) is
     *
     *      Da = 0\&.5 * A * (V/A)^2
     *
     *      or
     *
     *      Da = 0\&.5 * V^2 / A
     *
     *      So when D > 2 * Da, or
     *
     *      D > V^2 / A
     *         
     *      we need to use equation (1) otherwise we need to use equation (2)
     *
     */

    if( mp->magic != LSPMAC_MAGIC_NUMBER) {
      lslogging_log_message( 'lspmac_est_move_time: WARNING: bad motor structure\&.  Check that your motor list is NULL terminated\&.');
      break;
    }


    //lslogging_log_message( 'lspmac_est_move_time: find motor %s, jog %d, preset %s, endpoint %f',
    //mp->name, jog, ps == NULL ? 'NULL' : ps, ep);

    Tt = 0\&.0;
    if( mp != NULL && mp->max_speed != NULL && mp->max_accel != NULL && mp->u2c != NULL) {

      //
      // get the real endpoint if a preset was mentioned
      //
      if( ps != NULL && *ps != 0) {
        err = lsredis_find_preset( mp->name, ps, &maybe_ep);
        if( err != 0)
          ep = maybe_ep;
      }

      u2c = lsredis_getd( mp->u2c);

      //
      // For look up tables user units are (or should be) counts and u2c should be 1
      //
      if( mp->nlut > 0 && mp->lut != NULL) {
        u2c = 1\&.0;
        D = lspmac_lut( mp->nlut, mp->lut, ep) - lspmac_lut( mp->nlut, mp->lut, lspmac_getPosition( mp));
      } else {
        D = ep - lspmac_getPosition( mp);                               // User units
      }

      V = lsredis_getd( mp->max_speed) / u2c * 1000\&.;            // User units per second
      A = lsredis_getd( mp->max_accel) / u2c * 1000\&. * 1000;     // User units per second per second


      neutral_pos = lsredis_getd( mp->neutral_pos);
      min_pos     = lsredis_getd( mp->min_pos) - neutral_pos;
      max_pos     = lsredis_getd( mp->max_pos) - neutral_pos;

      if( ep < min_pos || ep > max_pos) {
        lslogging_log_message( 'lspmac_est_move_time: Motor %s Requested position %f out of range: min=%f, max=%f', mp->name, ep, min_pos, max_pos);
        lsevents_send_event( '%s Move Aborted', mp->name);
        return 1;
      }

      mp->requested_position = ep;
      mp->requested_pos_cnts = u2c * (mp->requested_position + neutral_pos);


      //
      // Don't bother with motors without velocity or acceleration defined
      //
      if( V > 0\&.0 && A > 0\&.0) {
        if( fabs(D) > V*V/A) {
          //
          // Normal ramp up, constant velocity, and ramp down
          //
          Tt = fabs(D)/V + V/A;
        } else {
          //
          // Never reach constantant velocity, just ramp up a bit and back down
          //
          Tt = 2\&.0 * sqrt( fabs(D)/A);
        }

        lslogging_log_message( 'lspmac_est_move_time: Motor: %s  D: %f  VV/A: %f  Tt: %f', mp->name, D, V*V/A, Tt);
      }  else {
        //
        // TODO: insert move time based for DAC or BO motor like objects;
        // For now assume 100 msec;
        //
        Tt = 0\&.1;
      }

      // Perhaps flag a coordinate system
      //
      // We can move a motor that's not in a coordinate system but we cannot move a motor that is but does not
      // have an axis defined if we are also moving one that does\&.  It's a limitation, I guess\&.
      //
      if( jog != 1 &&
          mp->coord_num != NULL && lsredis_getl( mp->coord_num) > 0 && lsredis_getl( mp->coord_num) <= 16 &&
          mp->motor_num != NULL && lsredis_getl( mp->motor_num) > 0 && mp->axis != NULL && lsredis_getc( mp->axis) != 0) {
        int axis;
        int motor_num;

        motor_num = lsredis_getl( mp->motor_num);

        axis = lsredis_getc( mp->axis);
        for( j=0; j<sizeof(axes); j++) {
          if( axis == axes[j])
            break;
        }

        if( j < sizeof( axes)) {
          //
          // Store the motion request for a normal PMAC motor
          //
          int cn;
          int in_position_band;

          cn = lsredis_getl( mp->coord_num);
          in_position_band = lsredis_getl( mp->in_position_band);

          motions[motor_num - 1]\&.coord_num = cn;
          motions[motor_num - 1]\&.axis      = j;
          motions[motor_num - 1]\&.Delta     = D * u2c;
          //
          // Don't ask to run a motion program if we are already where we want to be
          //
          // Deadband is 10 counts except for zoom which is 100\&.
          // We use Ixx28 In-Position Band which has units of 1/16 count
          //
          //
          if( abs(motions[motor_num - 1]\&.Delta)*16 >= in_position_band) {
            m5075 |= (1 << (cn - 1));
            motions[motor_num - 1]\&.moveme    = 1;
          }       
          lslogging_log_message( 'lspmac_est_move_time: moveme=%d  motor '%s' motions index=%d coord_num=%d axis=%d Delta=%d   m5075=%u',
                                 motions[motor_num-1]\&.moveme,  mp->name, motor_num -1, motions[motor_num-1]\&.coord_num, motions[motor_num-1]\&.axis, motions[motor_num-1]\&.Delta,
                                 m5075);
        }
      } else {
        //
        // Here we are dealing with a DAC or BO motor or just want to jog\&.
        //
        if( mp->jogAbs( mp, ep)) {
          lslogging_log_message( 'lspmac_est_move_time: motor %s failed to queue move of distance %f from %f', mp->name, D, lspmac_getPosition(mp));
          lsevents_send_event( 'Move Aborted');
          return 1;
        }
      }
      //
      // Update the estimated time
      //
      *est_time = *est_time < Tt ? Tt : *est_time;
      
      lslogging_log_message( 'lspmac_est_move_time: est_time=%f', *est_time);

    }


    mp = va_arg( arg_ptr, lspmac_motor_t *);
    if( mp == NULL)
      break;

    jog = va_arg( arg_ptr, int);
    ps  = va_arg( arg_ptr, char *);
    ep  = va_arg( arg_ptr, double);

  }
  va_end( arg_ptr);

  
  // Set the motion program flags
  //
  if( m5075 != 0) {
    if( mmaskp != NULL)
      *mmaskp |= m5075; // Tell the caller about our new mask

    
    pthread_mutex_lock( &lspmac_moving_mutex);
    moving_flags = lspmac_moving_flags;
    pthread_mutex_unlock( &lspmac_moving_mutex);

    if( (moving_flags & m5075) != m5075) {
      lspmac_SockSendDPline( NULL, 'M5075=(M5075 | %d)', m5075);
    

      pthread_mutex_lock( &lspmac_moving_mutex);
      clock_gettime( CLOCK_REALTIME, &timeout);
      //
      timeout\&.tv_sec += 2;       // 2 seconds should be more than enough time to set the flags
      err = 0;
      while( err == 0 && ((lspmac_moving_flags & m5075) != m5075))
        err = pthread_cond_timedwait( &lspmac_moving_cond, &lspmac_moving_mutex, &timeout);
      moving_flags = lspmac_moving_flags;
      pthread_mutex_unlock( &lspmac_moving_mutex);
    
      if( ((moving_flags & m5075) != m5075) && err == ETIMEDOUT) {
        lslogging_log_message( 'lspmac_est_move_time: Timed out waiting for moving flags\&.  lspmac_moving_flags = 0x%0x, looking for 0x%0x  test exp: 0x%0x  test: %d',
                               moving_flags, m5075, (moving_flags & m5075), (moving_flags & m5075) != m5075);
        lsevents_send_event( 'Combined Move Aborted');
        return 1;
      }
    }
  }


  for( i=1; i<=16; i++) {
    //
    // Loop over coordinate systems
    //
    foundone = 0;
    
    for( j=0; j<9; j++)
      qs[j] = 0;
    
    for( j=0; j<31; j++) {
      //
      // Loop over motors
      //
      if( motions[j]\&.moveme && motions[j]\&.coord_num == i) {
        if( abs(motions[j]\&.Delta) > 0) {
          qs[(int)(motions[j]\&.axis)] = motions[j]\&.Delta;
          foundone=1;
        }
      }
    }
    
    if( foundone) {
      sprintf( s, '&%d Q40=%d Q41=%d Q42=%d Q43=%d Q44=%d Q45=%d Q46=%d Q47=%d Q48=%d Q49=%\&.1f Q100=%d B180R',
               i, qs[0], qs[1], qs[2], qs[3], qs[4], qs[5], qs[6], qs[7], qs[8], *est_time * 1000\&., 1 << (i-1));
      
      lspmac_SockSendDPline( NULL, s);
      
    }
  }
  return 0;
}
.fi
.SS "int lspmac_est_move_time_wait (doublemove_time, intcmask, \fBlspmac_motor_t\fP *mp_1, \&.\&.\&.)"

.PP
wait for motion to stop returns non-zero if the wait timed out \fBParameters:\fP
.RS 4
\fImove_time\fP The time out in seconds 
.br
\fIcmask\fP A coordinate system mask to wait for 
.br
\fImp_1\fP NULL terminated list of individual motors to wait for
.RE
.PP
Both values are returned from lspmac_est_move_time 
.PP
Definition at line 3207 of file lspmac\&.c\&.
.PP
.nf
                                                                                       {
  int err;
  double isecs, fsecs;
  struct timespec timeout;
  va_list arg_ptr;
  lspmac_motor_t *mp;

  clock_gettime( CLOCK_REALTIME, &timeout);
  fsecs = modf( move_time, &isecs);
  timeout\&.tv_sec  += (long)floor(isecs);
  timeout\&.tv_nsec += (long)floor(fsecs * 1\&.e9);
  timeout\&.tv_sec  += timeout\&.tv_nsec / 1000000000;
  timeout\&.tv_nsec %= 1000000000;

  err = 0;
  pthread_mutex_lock( &lspmac_moving_mutex);
  while( err == 0 && (lspmac_moving_flags & cmask) != 0)
    err = pthread_cond_timedwait( &lspmac_moving_cond, &lspmac_moving_mutex, &timeout);
  pthread_mutex_unlock( &lspmac_moving_mutex);

  if( err != 0) {
    if( err == ETIMEDOUT) {
      lslogging_log_message( 'lstest_lspmac_est_move_time_wait: timed out waiting %f seconds, cmask = 0x%0x', move_time, cmask);
    }
    lspmac_abort();
    return 1;
  }

  va_start( arg_ptr, mp_1);
  for( mp = mp_1; mp != NULL; mp = va_arg( arg_ptr, lspmac_motor_t *)) {
    if( mp->magic != LSPMAC_MAGIC_NUMBER) {
      lslogging_log_message( 'lspmac_est_move_time_wait: WARNING: motor list must be NULL terminated\&.  Check your call to lspmac_est_move_time_wait\&.');
    }

    if( lspmac_moveabs_wait( mp, move_time)) {
      lslogging_log_message( 'lspmac_est_move_time_wait: timed out waiting %f seconds for motor %s', move_time, mp->name);
      return 1;
    }
  }
  va_end( arg_ptr);

  return 0;
}
.fi
.SS "\fBlspmac_motor_t\fP* lspmac_find_motor_by_name (char *name)"

.PP
Definition at line 4367 of file lspmac\&.c\&.
.PP
.nf
                                                       {
  lspmac_motor_t *rtn;
  ENTRY entry_in, *entry_outp;
  int err;
  
  entry_in\&.key  = name;
  entry_in\&.data = NULL;
  err = hsearch_r( entry_in, FIND, &entry_outp, &motors_ht);
  if( err == 0) {
    lslogging_log_message( 'lspmac_find_motor_by_name: hsearch_r failed for motor '%s': %s', name, strerror( errno));
    return NULL;
  }    
  rtn = entry_outp->data;

  return rtn;
}
.fi
.SS "void lspmac_flight_lut_setup ()"

.PP
Set up lookup table for flight\&. 
.PP
Definition at line 4273 of file lspmac\&.c\&.
.PP
.nf
                               {
  int i;
  lsredis_obj_t *p;

  pthread_mutex_lock( &flight->mutex);

  flight->nlut = 11;
  flight->lut = calloc( 2 * flight->nlut, sizeof( double));
  if( flight->lut == NULL) {
    lslogging_log_message( 'lspmac_flight_lut_setup: out of memory');
    exit( -1);
  }

  flight->lut[0] = 0;
  flight->lut[1] = 0;
  for( i=1; i < flight->nlut; i++) {
    p = lsredis_get_obj( 'cam\&.zoom\&.%d\&.FrontLightIntensity', i);
    if( p==NULL || strlen( lsredis_getstr(p)) == 0) {
      free( flight->lut);
      flight->lut  = NULL;
      flight->nlut = 0;
      pthread_mutex_unlock( &flight->mutex);
      lslogging_log_message( 'lspmac_flight_lut_setup: cannot find MotorPosition element for cam\&.flight level %d', i);
      return;
    }
    flight->lut[2*i]   = i;
    flight->lut[2*i+1] = 32767\&.0 * lsredis_getd( p) / 100\&.0;
  }
  pthread_mutex_unlock( &flight->mutex);
}
.fi
.SS "void lspmac_fscint_lut_setup ()"

.PP
Set up lookup table for fscint\&. 
.PP
Definition at line 4348 of file lspmac\&.c\&.
.PP
.nf
                               {
  int i;

  pthread_mutex_lock( &fscint->mutex);

  fscint->nlut = 101;
  fscint->lut = calloc( 2 * fscint->nlut, sizeof( double));
  if( fscint->lut == NULL) {
    lslogging_log_message( 'lspmac_fscint_lut_setup: out of memory');
    exit( -1);
  }

  for( i=0; i<fscint->nlut; i++) {
    fscint->lut[2*i] = i;
    fscint->lut[2*i+1] = 320\&.0 * i;
  }
  pthread_mutex_unlock( &fscint->mutex);
}
.fi
.SS "\fBlspmac_motor_t\fP* lspmac_fshut_init (\fBlspmac_motor_t\fP *d)"

.PP
Initalize the fast shutter motor\&. \fBParameters:\fP
.RS 4
\fId\fP Our uninitialized motor object 
.RE
.PP

.PP
Definition at line 3727 of file lspmac\&.c\&.
.PP
.nf
                                    {

  _lspmac_motor_init( d, 'fastShutter');

  d->moveAbs           = lspmac_moveabs_fshut_queue;
  d->jogAbs            = lspmac_moveabs_fshut_queue;
  d->read              = lspmac_shutter_read;

  return d;
}
.fi
.SS "void lspmac_full_card_reset_cb (char *event)"

.PP
reset and resetart 
.PP
Definition at line 3836 of file lspmac\&.c\&.
.PP
.nf
                                             {
  lspmac_running = 0;
  pthread_join( pmac_thread, NULL);
  pthread_mutex_lock( &pmac_queue_mutex);
  
  ethCmdOn    = 0;
  ethCmdOff   = 0;
  ethCmdReply = 0;

  lspmac_running = 1;
  ls_pmac_state = LS_PMAC_STATE_DETACHED;

  pthread_mutex_unlock( &pmac_queue_mutex);

  lspmac_init( 0, 0);
  lspmac_run();
}
.fi
.SS "void lspmac_get_ascii (char *event)"

.PP
Forward declarateion\&. Request the ascii buffers from the PMAC\&. 
.PP
Definition at line 2033 of file lspmac\&.c\&.
.PP
.nf
                                    {
  lspmac_send_command( VR_UPLOAD, VR_PMAC_GETMEM, 0x0e9c, 0, sizeof(lspmac_ascii_buffers_t), NULL, lspmac_get_ascii_cb, 0, event);
}
.fi
.SS "void lspmac_get_ascii_cb (\fBpmac_cmd_queue_t\fP *cmd, intnreceived, char *buff)"

.PP
service the ascii buffer request response 
.PP
Definition at line 1919 of file lspmac\&.c\&.
.PP
.nf
                                                                            {
  uint32_t clrdata;
  int need_more;

  need_more = 0;
  pthread_mutex_lock( &lspmac_ascii_mutex);
  memcpy( &lspmac_ascii_buffers, buff, sizeof(lspmac_ascii_buffers));


  //
  // The response is not ready yet
  // This will be an infinite loop if we queue a command that does not
  // produce a response\&.
  //
  // Quoted comments below from Delta Tau 'Turbo PMAC User Manual 9/12/2008, page 422'
  //
  // '1\&.  Wait for the Host-Input Control Word at 0x0F40 (Y:$063D0) to become greater than 0, indicating
  // that a response line is ready\&.'
  //
  if( lspmac_ascii_buffers\&.response_buf == 0) {
    need_more = 1;
  } else {
    if( (lspmac_ascii_buffers\&.response_buf & 0x8000) != 0) {
      char bcd1, bcd2, bcd3;
      int errcode;
      // Error response
      //
      // '2\&.  Interpret the value in this register to determine what
      // type of response is present\&. If Bit 15 is 1, Turbo PMAC is
      // reporting an error in the command, and there is no response
      // other than this word\&. In this case, Bits 0 – 11 encode the
      // error number for the command as 3 BCD digits\&.'
      //
      need_more = 0;
      bcd1 = lspmac_ascii_buffers\&.response_buf  & 0x000f;
      bcd2 = (lspmac_ascii_buffers\&.response_buf & 0x00f0) >> 4;
      bcd3 = (lspmac_ascii_buffers\&.response_buf & 0x0f00) >> 8;
      errcode = (bcd3 * 10 + bcd2) * 10 + bcd1;
      
      if( errcode >= sizeof( pmac_error_strs)/sizeof( *pmac_error_strs))
        errcode = 0;
      lslogging_log_message( 'lspmac_get_ascii_cb: Error returned for %s: %s', lspmac_ascii_buffers\&.command_str, pmac_error_strs[errcode]);
      //
      // Command not allowed during program execution\&.
      //
      // Requeue it;
      if( errcode == 1) {
        lspmac_dpascii_off--;
      }
    } else {
      //
      // '3\&.  Read the response string starting at 0x0F44
      // (Y:$0603D1)\&. Two 8-bit characters are packed into each 16-bit
      // word; the first character is placed into the low
      // byte\&. Subsequent characters are placed into consecutive
      // higher addresses, two per 16-bit word\&. (In byte addressing,
      // each character is read from an address one higher than the
      // preceding character\&.) Up to 255 characters can be sent in a
      // single response line\&. The string is terminated with the NULL
      // character (byte value 0), convenient for C-style string
      // handling\&. For Pascal-style string handling, the register at
      // 0x0F42 (X:$0603D0) contains the number of characters in the
      // string (plus one)\&.'
      //
      
      if( cmd->event != NULL && strncmp( cmd->event, 'Control-', 8) == 0) {
        lslogging_log_message( '%s: %s', cmd->event, lspmac_ascii_buffers\&.response_str);
        need_more = 0;
      } else {  
        if( lspmac_ascii_buffers\&.response_n > 1)
          lslogging_log_message( 'lspmac_get_ascii_cb: '%s'   '%s'', lspmac_ascii_buffers\&.command_str, lspmac_ascii_buffers\&.response_str);
        else
          lslogging_log_message( 'lspmac_get_ascii_cb: '%s'   responded', lspmac_ascii_buffers\&.command_str);

        //
        // 5\&.  'If Bits 0 – 7 of the Host-Input Control Word had
        // contained the value $0D (13 decimal, “CR”), this was not the
        // last line in the response, and steps 1 – 4 should be
        // repeated\&. If they had contained the value $06 (6 decimal,
        // “ACK”), this was the last line in the response\&.'
        //
        if( (lspmac_ascii_buffers\&.response_buf & 0x00ff) == 0x0d) {
          need_more = 1;
        } else {
          need_more = 0;
        
          if( cmd->event != NULL && *(cmd->event) != 0)
            lsevents_send_event( '%s command accepted', cmd->event);
        }
      }
    } 
  }

  pthread_mutex_unlock( &lspmac_ascii_mutex);

  //
  // Reset the buffer flags and, perhaps, requeue a request
  //
  // '4\&.  Clear the Host-Input Control Word at 0x0F40 (Y:$063D0)
  // to 0\&. Turbo PMAC will not send another response line until it sees
  // this register set to 0\&.'
  //
  clrdata = 0;          // set the control word to zero

  if( need_more) {
    lspmac_send_command( VR_UPLOAD, VR_PMAC_SETMEM, 0x0f40, 0, 4, (char *)&clrdata, lspmac_more_ascii_cb, 1, NULL);
  } else {
    lspmac_send_command( VR_UPLOAD, VR_PMAC_SETMEM, 0x0f40, 0, 4, (char *)&clrdata, NULL, 1, NULL);
    lspmac_ascii_busy = 0;
  }
}
.fi
.SS "void lspmac_get_status ()"

.PP
Request a status update from the PMAC\&. 
.PP
Definition at line 1907 of file lspmac\&.c\&.
.PP
.nf
                         {
  lspmac_send_command( VR_UPLOAD, VR_PMAC_GETMEM, 0x400, 0, sizeof(md2_status_t), NULL, lspmac_get_status_cb, 0, NULL);
}
.fi
.SS "void lspmac_get_status_cb (\fBpmac_cmd_queue_t\fP *cmd, intnreceived, char *buff)"

.PP
Service routing for status upate This updates positions and status information\&. \fBParameters:\fP
.RS 4
\fIcmd\fP The command that generated this reply 
.br
\fInreceived\fP Number of bytes received 
.br
\fIbuff\fP The Big Byte Buffer 
.RE
.PP

.PP
Definition at line 1673 of file lspmac\&.c\&.
.PP
.nf
                            {
  #ifdef SHOW_RATE
  static struct timespec ts1;
  static struct timespec ts2;
  static int cnt = 0;
  #endif

  int i;
  lspmac_bi_t    *bp;

  clock_gettime( CLOCK_REALTIME, &lspmac_status_time);

  #ifdef SHOW_RATE
  if( cnt == 0) {
    clock_gettime( CLOCK_REALTIME, &ts1);
  }
  #endif

  pthread_mutex_lock( &md2_status_mutex);
  memcpy( &md2_status, buff, sizeof(md2_status));
  //
  // Note that we are the only thread that writes to md2_status
  // so we no longer need the lock to read\&.  Other threads must
  // lock the mutex to read md2_status\&.
  //
  pthread_mutex_unlock( &md2_status_mutex);


  //
  // track the coordinate system moving flags
  //
  pthread_mutex_lock( &lspmac_moving_mutex);
  if( md2_status\&.moving_flags != lspmac_moving_flags) {
    int mask;

    lslogging_log_message( 'lspmac_get_status_cb: new moving flag: %0x', md2_status\&.moving_flags);
    mask = 1;
    for( i=1; i<=16; i++, mask <<= 1) {
      if( ((lspmac_moving_flags & mask) != 0) && ((md2_status\&.moving_flags & mask) == 0)) {
        // Falling edge: send event
        lsevents_send_event( 'Coordsys %d Stopped', i);
      }
    }
    lspmac_moving_flags = md2_status\&.moving_flags;
    pthread_cond_signal( &lspmac_moving_cond);
  }
  pthread_mutex_unlock( &lspmac_moving_mutex);


  //
  // Read the motor positions
  //
  for( i=0; i<lspmac_nmotors; i++) {
    lspmac_motors[i]\&.read(&(lspmac_motors[i]));
  }

  //
  // Read the binary inputs and perhaps send an event
  //
  for( i=0; i<lspmac_nbis; i++) {
    bp = &(lspmac_bis[i]);
    
    pthread_mutex_lock( &(bp->mutex));

    bp->position = (*(bp->ptr) & bp->mask) == 0 ? 0 : 1;

    if( bp->first_time) {
      bp->first_time = 0;
      if( bp->position==1 && bp->changeEventOn != NULL && bp->changeEventOn[0] != 0) {
        lsevents_send_event( lspmac_bis[i]\&.changeEventOn);
        lsredis_setstr( bp->status_str, bp->onStatus);
      }
      if( bp->position==0 && bp->changeEventOff != NULL && bp->changeEventOff[0] != 0) {
        lsevents_send_event( lspmac_bis[i]\&.changeEventOff);
        lsredis_setstr( bp->status_str, bp->offStatus);
      }
    } else {
      if( bp->position != bp->previous) {
        if( bp->position==1 && bp->changeEventOn != NULL && bp->changeEventOn[0] != 0) {
          lsevents_send_event( lspmac_bis[i]\&.changeEventOn);
          lsredis_setstr( bp->status_str, bp->onStatus);
        }
        if(bp->position==0 && bp->changeEventOff != NULL && bp->changeEventOff[0] != 0) {
          lsevents_send_event( lspmac_bis[i]\&.changeEventOff);
          lsredis_setstr( bp->status_str, bp->offStatus);
        }
      }
    }
    bp->previous = bp->position;
    pthread_mutex_unlock( &(bp->mutex));
  }

  pthread_mutex_lock( &ncurses_mutex);

  // acc11c_1   INPUTS
  // mask  bit
  // 0x01  0    M1000   Air pressure OK
  // 0x02  1    M1001   Air bearing OK
  // 0x04  2    M1002   Cryo switch
  // 0x08  3    M1003   Backlight Down
  // 0x10  4    M1004   Backlight Up
  // 0x20  5
  // 0x40  6    M1006   Cryo is back

  //
  // acc11c_2   INPUTS
  // mask  bit
  // 0x01  0    M1008   Fluor Dector back
  // 0x02  1    M1009   Sample Detected
  // 0x04  2    M1020   {SC load request}
  // 0x08  3    M1021   {SC move cryo back request}
  // 0x10  4    M1022   {SC sample magnet control}
  // 0x20  5    M1013   Etel Ready
  // 0x40  6    M1014   Etel On
  // 0x80  7    M1015   Etel Init OK

  if( md2_status\&.acc11c_2 & 0x01) {
    mvwprintw( term_status2, 3, 10, '%*s', -8, 'Fluor Out');
  } else {
    mvwprintw( term_status2, 3, 10, '%*s', -8, 'Fluor In');
  }

  if( md2_status\&.acc11c_5 & 0x08) {
    mvwprintw( term_status2, 4, 1, '%*s', -(LS_DISPLAY_WINDOW_WIDTH-2), 'Dryer On');
  } else {
    mvwprintw( term_status2, 4, 1, '%*s', -(LS_DISPLAY_WINDOW_WIDTH-2), 'Dryer Off');
  }
  if( md2_status\&.acc11c_2 & 0x02) {
    mvwprintw( term_status2, 2, 1, '%*s', -(LS_DISPLAY_WINDOW_WIDTH-2), 'Cap Dectected');
  } else {
    mvwprintw( term_status2, 2, 1, '%*s', -(LS_DISPLAY_WINDOW_WIDTH-2), 'Cap Not Dectected');
  }
  wnoutrefresh( term_status2);


  // acc11c_3   INPUTS
  // mask  bit
  // 0x01  0    M1025   Minikappa OK
  // 0x02  1    M1023   {SC unload request}
  // 0x04  2    M1024   Smartmagnet is on (note in pmc saying this is not used in VB interface)
  // 0x08  3    M1027   Arm Parked
  // 0x10  4    M1031   Smartmagnet error (coil is broken)
  // 0x20  5
  // 0x40  6
  // 0x80  7
  // 0x100 8    M1048   Shutter is open (note in pmc says: slow input !!!)

  // acc11c_4   INPUTS
  // mask  bit
  // 0x01  0    M1031   {laser mirror is back}
  // 0x02  1    M1032   {laser PSS OK}
  // 0x04  2    M1033   {laser shutter open}

  


  // acc11c_5   OUTPUTS
  // mask  bit
  // 0x01  0    M1100   Mag Off
  // 0x02  1    M1191   Condenser Out
  // 0x04  2    M1102   Cryo Back
  // 0x08  3    M1103   Dryer On
  // 0x10  4    M1104   FluoDet Out
  // 0x20  5    M1105   {smartmagnet on/off: note in pmc says this is not used}
  // 0x40  6    M1106   1=SmartMag, 0=Permanent Mag
  //

  if( md2_status\&.acc11c_5 & 0x04)
    mvwprintw( term_status2, 3, 1, '%*s', -8, 'Cryo Out');
  else
    mvwprintw( term_status2, 3, 1, '%*s', -8, 'Cryo In ');

  // acc11c_6   OUTPUTS
  // mask   bit
  // 0x0001   0 M1040   {SC Sample transfer is on}
  // 0x0002   1
  // 0x0004   2
  // 0x0008   3
  // 0x0010   4
  // 0x0020   5
  // 0x0040   6
  // 0x0080   7 M1115   Etel Enable
  // 0x0100   8 M1124   Fast Shutter Enable
  // 0x0200   9 M1125   Fast Shutter Manual Enable
  // 0x0400  10 M1126   Fast Shutter On
  // 0x0800  11  
  // 0x1000  12 M1128   ADC1 gain bit 0
  // 0x2000  13 M1129   ADC1 gain bit 1
  // 0x4000  14 M1130   ADC2 gain bit 0
  // 0x8000  15 M1131   ADC2 gain bit 1
  //

  if( md2_status\&.acc11c_5 & 0x02) {
    mvwprintw( term_status,  3, 1, '%*s', -(LS_DISPLAY_WINDOW_WIDTH-2), 'Backlight Up');
  } else {
    mvwprintw( term_status,  3, 1, '%*s', -(LS_DISPLAY_WINDOW_WIDTH-2), 'Backlight Down');
  }
  mvwprintw( term_status, 4, 1, 'Front: %*u', LS_DISPLAY_WINDOW_WIDTH-2-8, (int)flight->position);
  mvwprintw( term_status, 5, 1, 'Back: %*u', LS_DISPLAY_WINDOW_WIDTH-2-7,  (int)blight->position);
  mvwprintw( term_status, 6, 1, 'Piezo: %*u', LS_DISPLAY_WINDOW_WIDTH-2-8, (int)fscint->position);
  wnoutrefresh( term_status);

  wnoutrefresh( term_input);
  doupdate();
  pthread_mutex_unlock( &ncurses_mutex);

  #ifdef SHOW_RATE
  if( ++cnt % 1000 == 0) {
    long diff_sec;
    long diff_nsec;

    clock_gettime( CLOCK_REALTIME, &ts2);

    diff_sec  = ts2\&.tv_sec  - ts1\&.tv_sec;
    diff_nsec = ts2\&.tv_nsec - ts1\&.tv_nsec;

    if( diff_nsec < 0) {
      diff_nsec += 1000000000;
      diff_sec--;
    }

    lslogging_log_message( 'Refresh Rate: %0\&.1f Hz', (double)cnt / (diff_sec + diff_nsec/1000000000\&.));

    cnt = 0;
  }
  #endif
}
.fi
.SS "void lspmac_GetAllIVars ()"

.PP
Request the values of all the I variables\&. 
.PP
Definition at line 2162 of file lspmac\&.c\&.
.PP
.nf
                          {
  static char *cmds = 'I0\&.\&.8191';
  lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDLINE, 0, 0, strlen( cmds), cmds, lspmac_GetAllIVarsCB, 0, NULL);
}
.fi
.SS "void lspmac_GetAllIVarsCB (\fBpmac_cmd_queue_t\fP *cmd, intnreceived, char *buff)"

.PP
Receive the values of all the I variables Update our Postgresql database with the results\&. \fBParameters:\fP
.RS 4
\fIcmd\fP The command that gave this response 
.br
\fInreceived\fP Number of bytes received 
.br
\fIbuff\fP The byte buffer 
.RE
.PP

.PP
Definition at line 2145 of file lspmac\&.c\&.
.PP
.nf
                            {
  static char qs[LS_PG_QUERY_STRING_LENGTH];
  char *sp;
  int i;
  for( i=0, sp=strtok(buff, '\r'); sp != NULL; sp=strtok( NULL, '\r'), i++) {
    snprintf( qs, sizeof( qs)-1, 'SELECT pmac\&.md2_ivar_set( %d, '%s')', i, sp);
    qs[sizeof( qs)-1]=0;
    lspg_query_push( NULL, NULL, qs);
  }
}
.fi
.SS "void lspmac_GetAllMVars ()"

.PP
Request the values of all the M variables\&. 
.PP
Definition at line 2187 of file lspmac\&.c\&.
.PP
.nf
                          {
  static char *cmds = 'M0\&.\&.8191->';
  lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDLINE, 0, 0, strlen( cmds), cmds, lspmac_GetAllMVarsCB, 0, NULL);
}
.fi
.SS "void lspmac_GetAllMVarsCB (\fBpmac_cmd_queue_t\fP *cmd, intnreceived, char *buff)"

.PP
Receive the values of all the M variables Update our database with the results\&. \fBParameters:\fP
.RS 4
\fIcmd\fP The command that started this 
.br
\fInreceived\fP Number of bytes received 
.br
\fIbuff\fP Our byte buffer 
.RE
.PP

.PP
Definition at line 2170 of file lspmac\&.c\&.
.PP
.nf
                            {
  static char qs[LS_PG_QUERY_STRING_LENGTH];
  char *sp;
  int i;
  for( i=0, sp=strtok(buff, '\r'); sp != NULL; sp=strtok( NULL, '\r'), i++) {
    snprintf( qs, sizeof( qs)-1, 'SELECT pmac\&.md2_mvar_set( %d, '%s')', i, sp);
    qs[sizeof( qs)-1]=0;
    lspg_query_push( NULL, NULL, qs);
  }
}
.fi
.SS "int lspmac_getBIPosition (\fBlspmac_bi_t\fP *bip)"

.PP
get binary input value 
.PP
Definition at line 1661 of file lspmac\&.c\&.
.PP
.nf
                                            {
  int rtn;
  pthread_mutex_lock( &bip->mutex);
  rtn = bip->position;
  pthread_mutex_unlock( &bip->mutex);
  return rtn;
}
.fi
.SS "void lspmac_Getmem ()"

.PP
Request a block of double buffer memory\&. 
.PP
Definition at line 1144 of file lspmac\&.c\&.
.PP
.nf
                     {
  int nbytes;
  nbytes = (dbmemIn + 1400 > sizeof( dbmem)) ? sizeof( dbmem) - dbmemIn : 1400;
  lspmac_SockGetmem( dbmemIn, nbytes);
}
.fi
.SS "void lspmac_GetmemReplyCB (\fBpmac_cmd_queue_t\fP *cmd, intnreceived, char *buff)"

.PP
Service a reply to the getmem command\&. \fBParameters:\fP
.RS 4
\fIcmd\fP Queue item this is a reply to 
.br
\fInreceived\fP Number of bytes received 
.br
\fIbuff\fP Buffer of bytes recieved 
.RE
.PP

.PP
Definition at line 1068 of file lspmac\&.c\&.
.PP
.nf
                                                                             {

  memcpy( &(dbmem[ntohs(cmd->pcmd\&.wValue)]), buff, nreceived);

  dbmemIn += nreceived;
  if( dbmemIn >= sizeof( dbmem)) {
    dbmemIn = 0;
  }
}
.fi
.SS "double lspmac_getPosition (\fBlspmac_motor_t\fP *mp)"

.PP
get the motor position (with locking) \fBParameters:\fP
.RS 4
\fImp\fP the motor object 
.RE
.PP

.PP
Definition at line 1413 of file lspmac\&.c\&.
.PP
.nf
                                               {
  double rtn;
  pthread_mutex_lock( &(mp->mutex));
  rtn = mp->position;
  pthread_mutex_unlock( &(mp->mutex));
  return rtn;
}
.fi
.SS "void lspmac_GetShortReplyCB (\fBpmac_cmd_queue_t\fP *cmd, intnreceived, char *buff)"

.PP
Receive a reply that does not require multiple buffers\&. \fBParameters:\fP
.RS 4
\fIcmd\fP Queue item this is a reply to 
.br
\fInreceived\fP Number of bytes received 
.br
\fIbuff\fP The buffer of bytes 
.RE
.PP

.PP
Definition at line 1008 of file lspmac\&.c\&.
.PP
.nf
                              {

  char *sp;     // pointer to the command this is a reply to
  char *tmp;

  if( nreceived < 1400)
    buff[nreceived]=0;

  sp = (char *)(cmd->pcmd\&.bData);

  if( *buff == 0) {
    lslogging_log_message( '%s', sp);
  } else {
    tmp = cleanstr( buff);
    lslogging_log_message( '%s: %s', sp, tmp);
    free( tmp);
  }

  memset( cmd->pcmd\&.bData, 0, sizeof( cmd->pcmd\&.bData));
}
.fi
.SS "void lspmac_home1_queue (\fBlspmac_motor_t\fP *mp)"

.PP
Home the motor\&. \fBParameters:\fP
.RS 4
\fImp\fP motor we are concerned about 
.RE
.PP

.PP
Definition at line 1272 of file lspmac\&.c\&.
.PP
.nf
                          {
  int i;
  int nogo;
  int motor_num;
  int coord_num;
  int home_group;
  char **home;
  lspmac_motor_t *m2;

  pthread_mutex_lock( &(mp->mutex));

  // We've already been called\&.  Don't home again until
  // we're finish with the last time\&.
  //
  if( mp->homing) {
    pthread_mutex_unlock( &(mp->mutex));
    return;
  }    


  motor_num  = lsredis_getl( mp->motor_num);
  coord_num  = lsredis_getl( mp->coord_num);
  home       = lsredis_get_string_array( mp->home);
  home_group = lsredis_getl( mp->home_group);
  
  // Each of the motors should have this defined
  // but let's not seg fault if home is missing
  //
  if( home == NULL || *home == NULL) {
    //
    // Note we are already initialized
    // so if we are here there is something wrong\&.
    //
    lslogging_log_message( 'lspmac_home1_queue: null or empty home strings for motor %s', mp->name);
    pthread_mutex_unlock( &(mp->mutex));
    return;
  }

  //
  // Don't go on if any other motors in this coordinate system are homing or if any motors in a lower home_group are not homed
  // It's possible to write the homing program to home all the motors in the coordinate
  // system at the pmac level\&.  TODO  (hint hint)
  //
  nogo = 0;
  for( i=0; i<lspmac_nmotors; i++) {
    m2 = &(lspmac_motors[i]);
    if( m2 == mp || !lsredis_getb(m2->active))
      continue;
    if( lsredis_getl(m2->coord_num) == coord_num) {
      // only let one motor at a time home  in a given coordinate system
      //
      if( m2->homing)
        nogo = 1;
    } else {
      if( lsredis_getl( m2->home_group) < home_group) {
        pthread_mutex_lock( &(m2->mutex));
        //
        //  Don't go on if
        //
        // we are homing or ( not in position       while     in open loop)
        //
        if( m2->homing || (((m2->status2 & 0x01)==0) && ((m2->status1 & 0x040000) != 0)))
          nogo = 1;
        pthread_mutex_unlock( &(m2->mutex));
      }
    }
    if( nogo) {
      pthread_mutex_unlock( &(mp->mutex));
      return;
    }
  }
  mp->homing   = 1;
  lslogging_log_message( '%s homing = %d', mp->name, mp->homing);
  mp->not_done = 1;     // set up waiting for cond
  mp->motion_seen = 0;
  // This opens the control loop\&.
  // The status routine should notice this and the fact that
  // the homing flag is set and call on the home2 routine
  //
  // Only send the open loop command if we are not in
  // open loop mode already\&.  This test might prevent a race condition
  // where we've already moved the home2 routine (and queue the homing program motion)
  // before the open loop command is dequeued and acted on\&.
  //
  if( ~(mp->status1) & 0x040000) {
    lspmac_SockSendDPline( mp->name, '#%d$*', motor_num);
  }

  pthread_mutex_unlock( &(mp->mutex));

  lsevents_send_event( '%s Homing', mp->name);
}
.fi
.SS "void lspmac_home2_queue (\fBlspmac_motor_t\fP *mp)"

.PP
Second stage of homing\&. \fBParameters:\fP
.RS 4
\fImp\fP motor we are concerned about 
.RE
.PP

.PP
Definition at line 1370 of file lspmac\&.c\&.
.PP
.nf
                          {

  char **spp;
  char **home;

  //
  // At this point we are in open loop\&.
  // Run the motor specific commands
  //

  pthread_mutex_lock( &(mp->mutex));

  home = lsredis_get_string_array( mp->home);

  //
  // We don't have any motors that have a null home text array so 
  // there is currently no need to worry about this case other than
  // not to seg fault
  //
  // Also, Only go on if the first homing phase has been started
  //
  if( home == NULL || mp->homing != 1) {
    pthread_mutex_unlock( &(mp->mutex));
    return;
  }

  for( spp = home; *spp != NULL; spp++) {

    lslogging_log_message( 'home2 is queuing '%s'\n', *spp);

    lspmac_SockSendDPline( mp->name, *spp);
  }

  mp->homing = 2;
  lslogging_log_message( '%s homing = %d', mp->name, mp->homing);
  pthread_mutex_unlock( &(mp->mutex));
}
.fi
.SS "void lspmac_init (intivarsflag, intmvarsflag)"

.PP
Initialize this module\&. \fBParameters:\fP
.RS 4
\fIivarsflag\fP Set global flag to harvest i variables 
.br
\fImvarsflag\fP Set global flag to harvest m variables 
.RE
.PP

.PP
Definition at line 3857 of file lspmac\&.c\&.
.PP
.nf
                   {
  static int first_time = 1;
  int i;
  int err;
  ENTRY entry_in, *entry_outp;
  md2_status_t *p;
  pthread_mutexattr_t mutex_initializer;

  if( first_time) {
    // Set our global harvest flags
    getivars = ivarsflag;
    getmvars = mvarsflag;

    // Use recursive mutexs
    //
    pthread_mutexattr_init( &mutex_initializer);
    pthread_mutexattr_settype( &mutex_initializer, PTHREAD_MUTEX_RECURSIVE);

    // All important status mutex
    pthread_mutex_init( &md2_status_mutex, &mutex_initializer);

    //
    // Initialize the motor objects
    //

    p = &md2_status;

    omega  = lspmac_motor_init( &(lspmac_motors[ 0]), 0, 0, &p->omega_act_pos,     &p->omega_status_1,     &p->omega_status_2,     'Omega   #1 &1 X', 'omega',       lspmac_moveabs_queue, lspmac_jogabs_queue);
    alignx = lspmac_motor_init( &(lspmac_motors[ 1]), 0, 1, &p->alignx_act_pos,    &p->alignx_status_1,    &p->alignx_status_2,    'Align X #2 &3 X', 'align\&.x',     lspmac_moveabs_queue, lspmac_jogabs_queue);
    aligny = lspmac_motor_init( &(lspmac_motors[ 2]), 0, 2, &p->aligny_act_pos,    &p->aligny_status_1,    &p->aligny_status_2,    'Align Y #3 &3 Y', 'align\&.y',     lspmac_moveabs_queue, lspmac_jogabs_queue);
    alignz = lspmac_motor_init( &(lspmac_motors[ 3]), 0, 3, &p->alignz_act_pos,    &p->alignz_status_1,    &p->alignz_status_2,    'Align Z #4 &3 Z', 'align\&.z',     lspmac_moveabs_queue, lspmac_jogabs_queue);
    anal   = lspmac_motor_init( &(lspmac_motors[ 4]), 0, 4, &p->analyzer_act_pos,  &p->analyzer_status_1,  &p->analyzer_status_2,  'Anal    #5',      'lightPolar',  lspmac_moveabs_queue, lspmac_jogabs_queue);
    zoom   = lspmac_motor_init( &(lspmac_motors[ 5]), 1, 0, &p->zoom_act_pos,      &p->zoom_status_1,      &p->zoom_status_2,      'Zoom    #6 &4 Z', 'cam\&.zoom',    lspmac_movezoom_queue, lspmac_movezoom_queue);
    apery  = lspmac_motor_init( &(lspmac_motors[ 6]), 1, 1, &p->aperturey_act_pos, &p->aperturey_status_1, &p->aperturey_status_2, 'Aper Y  #7 &5 Y', 'appy',        lspmac_moveabs_queue, lspmac_jogabs_queue);
    aperz  = lspmac_motor_init( &(lspmac_motors[ 7]), 1, 2, &p->aperturez_act_pos, &p->aperturez_status_1, &p->aperturez_status_2, 'Aper Z  #8 &5 Z', 'appz',        lspmac_moveabs_queue, lspmac_jogabs_queue);
    capy   = lspmac_motor_init( &(lspmac_motors[ 8]), 1, 3, &p->capy_act_pos,      &p->capy_status_1,      &p->capy_status_2,      'Cap Y   #9 &5 U', 'capy',        lspmac_moveabs_queue, lspmac_jogabs_queue);
    capz   = lspmac_motor_init( &(lspmac_motors[ 9]), 1, 4, &p->capz_act_pos,      &p->capz_status_1,      &p->capz_status_2,      'Cap Z  #10 &5 V', 'capz',        lspmac_moveabs_queue, lspmac_jogabs_queue);
    scint  = lspmac_motor_init( &(lspmac_motors[10]), 2, 0, &p->scint_act_pos,     &p->scint_status_1,     &p->scint_status_2,     'Scin Z #11 &5 W', 'scint',       lspmac_moveabs_queue, lspmac_jogabs_queue);
    cenx   = lspmac_motor_init( &(lspmac_motors[11]), 2, 1, &p->centerx_act_pos,   &p->centerx_status_1,   &p->centerx_status_2,   'Cen X  #17 &2 X', 'centering\&.x', lspmac_moveabs_queue, lspmac_jogabs_queue);
    ceny   = lspmac_motor_init( &(lspmac_motors[12]), 2, 2, &p->centery_act_pos,   &p->centery_status_1,   &p->centery_status_2,   'Cen Y  #18 &2 Y', 'centering\&.y', lspmac_moveabs_queue, lspmac_jogabs_queue);
    kappa  = lspmac_motor_init( &(lspmac_motors[13]), 2, 3, &p->kappa_act_pos,     &p->kappa_status_1,     &p->kappa_status_2,     'Kappa  #19 &7 X', 'kappa',       lspmac_moveabs_queue, lspmac_jogabs_queue);
    phi    = lspmac_motor_init( &(lspmac_motors[14]), 2, 4, &p->phi_act_pos,       &p->phi_status_1,       &p->phi_status_2,       'Phi    #20 &7 Y', 'phi',         lspmac_moveabs_queue, lspmac_jogabs_queue);

    fshut  = lspmac_fshut_init( &(lspmac_motors[15]));
    flight = lspmac_dac_init( &(lspmac_motors[16]), &p->front_dac,   'M1200', 'frontLight\&.intensity', lspmac_movedac_queue);
    blight = lspmac_dac_init( &(lspmac_motors[17]), &p->back_dac,    'M1201', 'backLight\&.intensity',  lspmac_movedac_queue);
    fscint = lspmac_dac_init( &(lspmac_motors[18]), &p->scint_piezo, 'M1203', 'scint\&.focus',          lspmac_movedac_queue);

    smart_mag_oo  = lspmac_bo_init( &(lspmac_motors[19]), 'smartMagnet','M1100=%d', &(md2_status\&.acc11c_5), 0x01);
    blight_ud     = lspmac_bo_init( &(lspmac_motors[20]), 'backLight',  'M1101=%d', &(md2_status\&.acc11c_5), 0x02);
    cryo          = lspmac_bo_init( &(lspmac_motors[21]), 'cryo',       'M1102=%d', &(md2_status\&.acc11c_5), 0x04);
    dryer         = lspmac_bo_init( &(lspmac_motors[22]), 'dryer',      'M1103=%d', &(md2_status\&.acc11c_5), 0x08);
    fluo          = lspmac_bo_init( &(lspmac_motors[23]), 'fluo',       'M1104=%d', &(md2_status\&.acc11c_5), 0x10);
    flight_oo     = lspmac_soft_motor_init( &(lspmac_motors[24]), 'frontLight',        lspmac_moveabs_frontlight_oo_queue);
    blight_f      = lspmac_soft_motor_init( &(lspmac_motors[25]), 'backLight\&.factor',  lspmac_moveabs_blight_factor_queue);
    flight_f      = lspmac_soft_motor_init( &(lspmac_motors[26]), 'frontLight\&.factor', lspmac_moveabs_flight_factor_queue);

    lp_air          = lspmac_bi_init( &(lspmac_bis[ 0]), 'lowpressureair',   &(md2_status\&.acc11c_1),  0x01, 'Low Pressure Air OK',  'Low Pressure Air Failed',  'OK',      'Failed');
    hp_air          = lspmac_bi_init( &(lspmac_bis[ 1]), 'highpressureair',  &(md2_status\&.acc11c_1),  0x02, 'High Pressure Air OK', 'High Pressure Air Failed', 'OK',      'Failed');
    cryo_switch     = lspmac_bi_init( &(lspmac_bis[ 2]), 'cryoswitch',       &(md2_status\&.acc11c_1),  0x04, 'CryoSwitchChanged',    'CryoSwitchChanged',        'On',      'Off');
    blight_down     = lspmac_bi_init( &(lspmac_bis[ 3]), 'backLightDown',    &(md2_status\&.acc11c_1),  0x08, 'Backlight Down',       'Backlight Not Down',       'Down',    'Not Down');
    blight_up       = lspmac_bi_init( &(lspmac_bis[ 4]), 'backLightUp',      &(md2_status\&.acc11c_1),  0x10, 'Backlight Up',         'Backlight Not Up',         'Up',      'Not Up');
    cryo_back       = lspmac_bi_init( &(lspmac_bis[ 5]), 'cryoBack',         &(md2_status\&.acc11c_1),  0x40, 'Cryo Back',            'Cryo Not Back',            'Back',    'Not Back');
    fluor_back      = lspmac_bi_init( &(lspmac_bis[ 6]), 'detectorParked',   &(md2_status\&.acc11c_2),  0x01, 'Fluor\&. Det\&. Parked',   'Fluor\&. Det\&. Not Parked',   'Parked',  'Not Parked');
    sample_detected = lspmac_bi_init( &(lspmac_bis[ 7]), 'sampleDetector',   &(md2_status\&.acc11c_2),  0x02, 'SamplePresent',        'SampleAbsent',             'Present', 'Absent' );
    etel_ready      = lspmac_bi_init( &(lspmac_bis[ 8]), 'etelReady',        &(md2_status\&.acc11c_2),  0x20, 'ETEL Ready',           'ETEL Not Ready',           'Ready',   'Not Ready');
    etel_on         = lspmac_bi_init( &(lspmac_bis[ 9]), 'etelOn',           &(md2_status\&.acc11c_2),  0x40, 'ETEL On',              'ETEL Off',                 'On',      'Off');
    etel_init_ok    = lspmac_bi_init( &(lspmac_bis[10]), 'etelOk',           &(md2_status\&.acc11c_2),  0x80, 'ETEL Init OK',         'ETEL Init Not OK',         'OK',      'Not OK');
    minikappa_ok    = lspmac_bi_init( &(lspmac_bis[11]), 'miniKappaOk',      &(md2_status\&.acc11c_3),  0x01, 'Minikappa OK',         'Minikappa Not OK',         'OK',      'Not OK');
    smart_mag_on    = lspmac_bi_init( &(lspmac_bis[12]), 'smartMagnetOn',    &(md2_status\&.acc11c_3),  0x04, 'Smart Magnet On',      'Smart Magnet Not On',      'On',      'Not On');
    arm_parked      = lspmac_bi_init( &(lspmac_bis[13]), 'armParked',        &(md2_status\&.acc11c_3),  0x08, 'Arm Parked',           'Arm Not Parked',           'Parked',  'Not Parked');
    smart_mag_err   = lspmac_bi_init( &(lspmac_bis[14]), 'smartMagnetError', &(md2_status\&.acc11c_3),  0x10, 'Smart Magnet Error',   'Smart Magnet OK',          'Error',   'OK');
    shutter_open    = lspmac_bi_init( &(lspmac_bis[15]), 'shutterOpen',      &(md2_status\&.acc11c_3), 0x100, 'Shutter Open',         'Shutter Not Open',         'Open',    'Not Open');
    smart_mag_off   = lspmac_bi_init( &(lspmac_bis[16]), 'smartMagnetOff',   &(md2_status\&.acc11c_5),  0x01, 'Smart Magnet Off',     'Smart Magnet Not Off',     'Off',     'Not Off');
  


    // Set up hash table
    //
    err = hcreate_r( LSPMAC_MAX_MOTORS * 2, &motors_ht);
    if( err == 0) {
      lslogging_log_message( 'lspmac_init: hcreate_r failed: '%s'', strerror( errno));
      exit( -1);
    }
    for( i=0; i<lspmac_nmotors; i++) {
      entry_in\&.key   = lspmac_motors[i]\&.name;
      entry_in\&.data  = &(lspmac_motors[i]);
      err = hsearch_r( entry_in, ENTER, &entry_outp, &motors_ht);
      if( err == 0) {
        lslogging_log_message( 'lspmac_init: hsearch_r failed for motor %s: '%s'', lspmac_motors[i]\&.name, strerror( errno));
        exit( -1);
      }
    }



    //
    // Initialize several commands that get called, perhaps, alot
    //
    rr_cmd\&.RequestType = VR_UPLOAD;
    rr_cmd\&.Request     = VR_PMAC_READREADY;
    rr_cmd\&.wValue      = 0;
    rr_cmd\&.wIndex      = 0;
    rr_cmd\&.wLength     = htons(2);
    memset( rr_cmd\&.bData, 0, sizeof(rr_cmd\&.bData));

    gb_cmd\&.RequestType = VR_UPLOAD;
    gb_cmd\&.Request     = VR_PMAC_GETBUFFER;
    gb_cmd\&.wValue      = 0;
    gb_cmd\&.wIndex      = 0;
    gb_cmd\&.wLength     = htons(1400);
    memset( gb_cmd\&.bData, 0, sizeof(gb_cmd\&.bData));

    cr_cmd\&.RequestType = VR_UPLOAD;
    cr_cmd\&.Request     = VR_CTRL_RESPONSE;
    cr_cmd\&.wValue      = 0;
    cr_cmd\&.wIndex      = 0;
    cr_cmd\&.wLength     = htons(1400);
    memset( cr_cmd\&.bData, 0, sizeof(cr_cmd\&.bData));

    //
    // Initialize some mutexs and conditions
    //

    pthread_mutex_init( &pmac_queue_mutex, &mutex_initializer);
    pthread_cond_init(  &pmac_queue_cond, NULL);

    lspmac_shutter_state = 0;                           // assume the shutter is now closed: not a big deal if we are wrong
    pthread_mutex_init( &lspmac_shutter_mutex, &mutex_initializer);
    pthread_cond_init(  &lspmac_shutter_cond, NULL);
    pmacfd\&.fd = -1;

    pthread_mutex_init( &lspmac_moving_mutex, &mutex_initializer);
    pthread_cond_init(  &lspmac_moving_cond, NULL);

    pthread_mutex_init( &lspmac_ascii_mutex, &mutex_initializer);

    pthread_mutex_init( &lspmac_ascii_buffers_mutex, &mutex_initializer);

    lsevents_preregister_event( 'omega crossed zero');
    lsevents_preregister_event( 'Move Aborted');
    lsevents_preregister_event( 'Combined Move Aborted');
    lsevents_preregister_event( 'Abort Request queued');
    lsevents_preregister_event( 'Abort Request accepted');
    lsevents_preregister_event( 'Reset queued');
    lsevents_preregister_event( 'Reset command accepted');
  

    for( i=1; i<=16; i++) {
      lsevents_preregister_event( 'Coordsys %d Stopped', i);
    }
    first_time = 0;
  }
  //
  // clear the ascii communications buffers
  //
  {
    uint32_t cc;
    cc = 0;
    lspmac_send_command( VR_UPLOAD, VR_PMAC_SETMEM, 0x0e9e, 0, 4, (char *)&cc, NULL, 1, NULL);

    cc = 0x18;
    lspmac_send_command( VR_UPLOAD, VR_PMAC_SETMEM, 0x0e9e, 0, 4, (char *)&cc, NULL, 1, NULL);
  }

  lspmac_SockSendDPline( NULL, 'I5=0');                 // disable plcc's
  lspmac_SockSendDPline( NULL, 'P2100=0');              // Don't let plcc0 control the shutter
  lspmac_SockSendDPline( NULL, 'I36=1');                // Don't let ^A put a disabled motor into closed loop mode
  lspmac_SockSendDPline( NULL, 'ENABLE PLCC 0,2');      // use plcc0 (Probably not needed but allows easy reset with M2000=0) plcc2 is ours used to fill db memory with status
  lspmac_SockSendDPline( NULL, 'DISABLE PLCC 1');       // Don't use plcc 1, it's embl's status routine for old md2 code
  lspmac_SockSendDPline( NULL, 'I5=3');                 // allow the enabled plcc's to run


}
.fi
.SS "int lspmac_jogabs_queue (\fBlspmac_motor_t\fP *mp, doublerequested_position)"

.PP
Use jog to move motor to requested position\&. \fBParameters:\fP
.RS 4
\fImp\fP The motor to move 
.br
\fIrequested_position\fP Where to move it 
.RE
.PP

.PP
Definition at line 3536 of file lspmac\&.c\&.
.PP
.nf
                            {
  
  return lspmac_move_or_jog_abs_queue( mp, requested_position, 1);
}
.fi
.SS "void lspmac_light_zoom_cb (char *event)"

.PP
Set the backlight intensity whenever the zoom is changed (and the backlight is up) \fBParameters:\fP
.RS 4
\fIevent\fP Name of the event that calledus 
.RE
.PP

.PP
Definition at line 4120 of file lspmac\&.c\&.
.PP
.nf
                                        {
  int z;

  pthread_mutex_lock( &zoom->mutex);
  z = zoom->requested_position;
  pthread_mutex_unlock( &zoom->mutex);

  lslogging_log_message( 'lspmac_light_zoom_cb: zoom = %d', z);

  if( lspmac_getPosition( flight_oo) != 0\&.0) {
    flight->moveAbs( flight, (double)z);
    } else {
      flight->moveAbs( flight, 0\&.0);
    }
  if( lspmac_getPosition( blight_ud) != 0\&.0) {
    blight->moveAbs( blight, (double)z);
  } else {
    blight->moveAbs( blight, 0\&.0);
  }
}
.fi
.SS "double lspmac_lut (intnlut, double *lut, doublex)"

.PP
Look up table support for motor positions (think x=zoom, y=light intensity) use a lookup table to find the 'counts' to move the motor to the requested position The look up table is a simple one dimensional array with the x values as even indicies and the y values as odd indices\&. Returns: y value \fBParameters:\fP
.RS 4
\fInlut\fP number of entries in lookup table 
.br
\fIlut\fP The lookup table: even indicies are the x values, odd are the y's 
.br
\fIx\fP The x value we are looking up\&. 
.RE
.PP

.PP
Definition at line 395 of file lspmac\&.c\&.
.PP
.nf
                    {
  int i, foundone;
  double m;
  double y1, y2, x1, x2, y;

  foundone = 0;
  if( lut != NULL && nlut > 1) {
    for( i=0; i < 2*nlut; i += 2) {
      x1 = lut[i];
      y1 = lut[i+1];
      if( i < 2*nlut - 2) {
        x2 = lut[i+2];
        y2 = lut[i+3];
      }

      //
      // First one too big?  Use the y value of the first element
      //
      if( i == 0 && x1 > x) {
        y = y1;
        foundone = 1;
        break;
      }

      //
      // Look for equality
      //
      if( x1 == x) {
        y = y1;
        foundone = 1;
        break;
      }

      //
      // Maybe interpolate
      //
      if( (i < 2*nlut-2) && x < x2) {
        m = (y2 - y1) / (x2 - x1);
        y = m*(x - x1) + y1;
        foundone = 1;
        break;
      }
    }
    if( foundone == 0) {
      // must be bigger than the last entry
      //
      //
      y = lut[2*(nlut-1) + 1];
    }
    return y;
  }
  return 0\&.0;
}
.fi
.SS "void lspmac_more_ascii_cb (\fBpmac_cmd_queue_t\fP *cmd, intnreceived, char *buff)"

.PP
we are expecting more characters from the DPRAM ASCII interface 
.PP
Definition at line 1913 of file lspmac\&.c\&.
.PP
.nf
                                                                             {
  lspmac_get_ascii( cmd->event);
}
.fi
.SS "\fBlspmac_motor_t\fP* lspmac_motor_init (\fBlspmac_motor_t\fP *d, intwy, intwx, int *posp, int *stat1p, int *stat2p, char *wtitle, char *name, int(*)(\fBlspmac_motor_t\fP *, double)moveAbs, int(*)(\fBlspmac_motor_t\fP *, double)jogAbs)"

.PP
Initialize a pmac stepper or servo motor\&. \fBParameters:\fP
.RS 4
\fId\fP An uninitialize motor object 
.br
\fIwy\fP Curses status window row index 
.br
\fIwx\fP Curses status window column index 
.br
\fIposp\fP Pointer to position status 
.br
\fIstat1p\fP Pointer to 1st status word 
.br
\fIstat2p\fP Pointer to 2nd status word 
.br
\fIwtitle\fP Title for this motor (to display) 
.br
\fIname\fP This motor's name 
.br
\fImoveAbs\fP Method to use to move this motor (motion program preferred) 
.br
\fIjogAbs\fP Method to use to jog this motor (jog preferred) 
.RE
.PP

.PP
Definition at line 3685 of file lspmac\&.c\&.
.PP
.nf
                                    {

  _lspmac_motor_init( d, name);

  d->moveAbs             = moveAbs;
  d->jogAbs              = jogAbs;
  d->read                = lspmac_pmacmotor_read;
  d->actual_pos_cnts_p   = posp;
  d->status1_p           = stat1p;
  d->status2_p           = stat2p;

  d->win = newwin( LS_DISPLAY_WINDOW_HEIGHT, LS_DISPLAY_WINDOW_WIDTH, wy*LS_DISPLAY_WINDOW_HEIGHT, wx*LS_DISPLAY_WINDOW_WIDTH);

  pthread_mutex_lock( &ncurses_mutex);
  box( d->win, 0, 0);
  mvwprintw( d->win, 1, 1, '%s', wtitle);
  wnoutrefresh( d->win);
  pthread_mutex_unlock( &ncurses_mutex);

  lsevents_preregister_event( '%s Homing',       d->name);
  lsevents_preregister_event( '%s Homed',        d->name);
  lsevents_preregister_event( '%s Moving',       d->name);
  lsevents_preregister_event( '%s In Position',  d->name);
  lsevents_preregister_event( '%s Move Aborted', d->name);


  return d;
}
.fi
.SS "int lspmac_move_or_jog_abs_queue (\fBlspmac_motor_t\fP *mp, doublerequested_position, intuse_jog)"

.PP
Move method for normal stepper and servo motor objects Returns non-zero on abort, zero if OK\&. < format string for coordinate system move
.PP
< coordinate system bit
.PP
< the requested position in units of 'counts'
.PP
< motor and coordinate system;
.PP
< 0= don't use this motor, 1= do use it
.PP
< our axis \fBParameters:\fP
.RS 4
\fImp\fP The motor to move 
.br
\fIrequested_position\fP Where to move it 
.br
\fIuse_jog\fP 1 to force jog, 0 for motion prog 
.RE
.PP

.PP
Definition at line 3258 of file lspmac\&.c\&.
.PP
.nf
                                   {
  char *fmt;                    
  int q100;                     
  int requested_pos_cnts;       
  int coord_num, motor_num;     
  int active;                   
  char *axis;                   
  double u2c;
  double neutral_pos;
  double min_pos, max_pos;
  int pos_limit_hit, neg_limit_hit, in_position_band;
  struct timespec timeout, now;
  int err;

  pthread_mutex_lock( &(mp->mutex));

  active           = lsredis_getb(   mp->active);
  u2c              = lsredis_getd(   mp->u2c);
  motor_num        = lsredis_getl(   mp->motor_num);
  coord_num        = lsredis_getl(   mp->coord_num);
  axis             = lsredis_getstr( mp->axis);
  neutral_pos      = lsredis_getd(   mp->neutral_pos);
  min_pos          = lsredis_getd(   mp->min_pos) - neutral_pos;
  max_pos          = lsredis_getd(   mp->max_pos) - neutral_pos;
  pos_limit_hit    = lsredis_getd(   mp->pos_limit_hit);
  neg_limit_hit    = lsredis_getd(   mp->neg_limit_hit);
  in_position_band = lsredis_getl(   mp->in_position_band);

  if( u2c == 0\&.0 || requested_position < min_pos || requested_position > max_pos) {
    //
    // Shouldn't try moving a motor that's in trouble
    //
    pthread_mutex_unlock( &(mp->mutex));
    lslogging_log_message( 'lspmac_move_or_jog_abs_queue: %s  u2c=%f  requested position=%f  min allowed=%f  max allowed=%f', mp->name, u2c, requested_position, min_pos, max_pos);
    lsevents_send_event( '%s Move Aborted', mp->name);
    return 1;
  }

  if( active != 1) {
    //
    // Don't really move this motor
    // although it's not an error to try
    // This is here since we want to check the soft limits (above) but ignore the hard limits (below)
    // We'll fake the move\&.
    //
    mp->requested_position = requested_position;
    if( mp->nlut > 0 && mp->lut != NULL) {
      mp->requested_pos_cnts = lspmac_lut( mp->nlut, mp->lut, requested_position);
    } else {
      mp->requested_pos_cnts = u2c * (requested_position + neutral_pos);
    }
    requested_pos_cnts = mp->requested_pos_cnts;

    mp->not_done     = 1;
    mp->motion_seen  = 0;
    mp->command_sent = 0;

    lsevents_send_event( '%s Moving', mp->name);

    mp->not_done     = 0;
    mp->motion_seen  = 1;
    mp->command_sent = 1;

    mp->position = requested_position;
    mp->actual_pos_cnts = requested_pos_cnts;

    pthread_mutex_unlock( &(mp->mutex));

    lsevents_send_event( '%s In Position', mp->name);
    return 0;

  }


  if( (neg_limit_hit && (requested_position < mp->position)) || (pos_limit_hit && (requested_position > mp->position))) {
    pthread_mutex_unlock( &(mp->mutex));
    lslogging_log_message( 'lspmac_move_or_jog_abs_queue: %s Moving wrong way on limit: requested position=%f  current position=%f  low limit=%d high limit=%d',
                           mp->name, requested_position, mp->position, neg_limit_hit, pos_limit_hit);
    lsevents_send_event( '%s Move Aborted', mp->name);
    return 2;
  }


  mp->requested_position = requested_position;
  if( mp->nlut > 0 && mp->lut != NULL) {
    mp->requested_pos_cnts = lspmac_lut( mp->nlut, mp->lut, requested_position);
  } else {
    mp->requested_pos_cnts = u2c * (requested_position + neutral_pos);
  }
  requested_pos_cnts = mp->requested_pos_cnts;

  //
  // Bluff if we are already there
  //
  if( (abs( requested_pos_cnts - mp->actual_pos_cnts) * 16 < in_position_band)) {
    //
    // Lie and say we moved even though we didn't\&.  Who will know? We are within the deadband or not active\&.
    //
    mp->not_done     = 1;
    mp->motion_seen  = 0;
    mp->command_sent = 0;

    lsevents_send_event( '%s Moving', mp->name);

    mp->not_done     = 0;
    mp->motion_seen  = 1;
    mp->command_sent = 1;
    
    pthread_mutex_unlock( &(mp->mutex));

    lsevents_send_event( '%s In Position', mp->name);
    return 0;
  }

  mp->not_done     = 1;
  mp->motion_seen  = 0;
  mp->command_sent = 0;


  if( use_jog || axis == NULL || *axis == 0) {
    use_jog = 1;
  } else {
    use_jog = 0;
    q100 = 1 << (coord_num -1);
  }


  pthread_mutex_unlock( &(mp->mutex));

  if( !use_jog) {
    //
    // Make sure the coordinate system is not moving something, wait if it is
    //
    pthread_mutex_lock( &lspmac_moving_mutex);

    clock_gettime( CLOCK_REALTIME, &now);
    //
    // TODO: Have all moves estimate how long they'll take and use that here
    //
    timeout\&.tv_sec  = now\&.tv_sec + 60\&.0;           // a long timeout, but we might really be moving something that takes this long (or longer)
    timeout\&.tv_nsec = now\&.tv_nsec;

    err = 0;
    while( err == 0 &&  (lspmac_moving_flags & q100) != 0)
      err = pthread_cond_timedwait( &lspmac_moving_cond, &lspmac_moving_mutex, &timeout);
    
    pthread_mutex_unlock( &lspmac_moving_mutex);

    if( err == ETIMEDOUT) {
      lslogging_log_message( 'lspmac_move_or_jog_abs_queue: Timed Out\&.  lspmac_moving_flags = %0x', lspmac_moving_flags);
      lsevents_send_event( '%s Move Aborted', mp->name);
      return 1;
    }

    //
    // Set the 'we are moving this coordinate system' flag
    //
    lspmac_SockSendDPline( NULL, 'M5075=(M5075 | %d)', q100);
    
    switch( *axis) {
    case 'A':
      fmt = '&%d Q16=%d Q100=%d B146R';
      break;

    case 'B':
      fmt = '&%d Q17=%d Q100=%d B147R';
      break;

    case 'C':
      fmt = '&%d Q18=%d Q100=%d B148R';
      break;
    case 'X':
      fmt = '&%d Q10=%d Q100=%d B140R';
      break;

    case 'Y':
      fmt = '&%d Q11=%d Q100=%d B141R';
      break;

    case 'Z':
      fmt = '&%d Q12=%d Q100=%d B142R';
      break;

    case 'U':
      fmt = '&%d Q13=%d Q100=%d B143R';
      break;

    case 'V':
      fmt = '&%d Q14=%d Q100=%d B144R';
      break;

    case 'W':
      fmt = '&%d Q15=%d Q100=%d B145R';
      break;
    }

    //
    // Make sure the flag has been seen
    //

    clock_gettime( CLOCK_REALTIME, &now);
    timeout\&.tv_sec  = now\&.tv_sec + 4\&.0;            // also a long timeout\&.  This should really only take a few milliseconds on a slow day
    timeout\&.tv_nsec = now\&.tv_nsec;

    pthread_mutex_lock( &lspmac_moving_mutex);

    err = 0;
    while( err == 0 && (lspmac_moving_flags & q100) == 0)
      err = pthread_cond_timedwait( &lspmac_moving_cond, &lspmac_moving_mutex, &timeout);
    pthread_mutex_unlock( &lspmac_moving_mutex);

    if( err == ETIMEDOUT) {
      lslogging_log_message( 'lspmac_move_or_jog_abs_queue: Did not see flag propagate\&.  Move aborted\&.');
      lsevents_send_event( '%s Move Aborted', mp->name);
      return 1;
    }
  }

  pthread_mutex_lock( &(mp->mutex));
  if( use_jog) {
    lslogging_log_message( 'Jogging %s: #%d j=%d', mp->name, motor_num, requested_pos_cnts);
    lspmac_SockSendDPline( mp->name, '#%d j=%d', motor_num, requested_pos_cnts);
  } else {
    lspmac_SockSendDPline( mp->name, fmt, coord_num, requested_pos_cnts, q100);
  }
  pthread_mutex_unlock( &(mp->mutex));

  free( axis);

  return 0;
}
.fi
.SS "int lspmac_move_or_jog_preset_queue (\fBlspmac_motor_t\fP *mp, char *preset, intuse_jog)"

.PP
move using a preset value returns 0 on success, non-zero on error \fBParameters:\fP
.RS 4
\fImp\fP Our motor 
.br
\fIpreset\fP the name of the preset 
.br
\fIuse_jog\fP [in[ 1 to force jog, 0 to try motion prog 
.RE
.PP

.PP
Definition at line 3497 of file lspmac\&.c\&.
.PP
.nf
                                       {
  double pos;
  int err;
  int rtn;

  if( preset == NULL || *preset == 0) {
    lsevents_send_event( '%s Move Aborted', mp->name);
    return 0;
  }

  err = lsredis_find_preset( mp->name, preset, &pos);

  if( err != 0)
    rtn = lspmac_move_or_jog_abs_queue( mp, pos, use_jog);
  else {
    lsevents_send_event( '%s Move Aborted', mp->name);
    rtn = 1;
  }
  return rtn;
}
.fi
.SS "int lspmac_move_preset_queue (\fBlspmac_motor_t\fP *mp, char *preset_name)"

.PP
Move a given motor to one of its preset positions\&. No movement if the preset is not found\&. 
.PP
\fBParameters:\fP
.RS 4
\fImp\fP lspmac motor pointer 
.br
\fIpreset_name\fP Name of the preset to use 
.RE
.PP

.PP
Definition at line 2496 of file lspmac\&.c\&.
.PP
.nf
                                                                     {
  double pos;
  int err;

  //lslogging_log_message( 'lspmac_move_preset_queue: Called with motor %s and preset named '%s'', mp->name, preset_name);

  err = lsredis_find_preset( mp->name, preset_name, &pos);
  if( err == 0)
    return 1;

  err = mp->jogAbs( mp, pos);
  if( !err)
    lslogging_log_message( 'lspmac_move_preset_queue: moving %s to preset '%s' (%f)', mp->name, preset_name, pos);
  //
  // the abort event should have been sent in moveAbs
  //
  return err;
}
.fi
.SS "int lspmac_moveabs_blight_factor_queue (\fBlspmac_motor_t\fP *mp, doublepos)"

.PP
Definition at line 2704 of file lspmac\&.c\&.
.PP
.nf
                                                                        {
  char *fmt;

  if( pos >= 60 && pos <= 140) {
    pthread_mutex_lock( &(mp->mutex));
    *mp->actual_pos_cnts_p = pos;
    mp->position =           pos;
    pthread_mutex_unlock( &(mp->mutex));

    pthread_mutex_lock( &(blight->mutex));
    fmt = lsredis_getstr( blight->redis_fmt);
    lsredis_setstr( blight->u2c, fmt, pos / 100\&.0);
    free( fmt);
    pthread_mutex_unlock( &(blight->mutex));

    blight->moveAbs( blight, lspmac_getPosition( zoom));
  }

  return 0;
}
.fi
.SS "int lspmac_moveabs_bo_queue (\fBlspmac_motor_t\fP *mp, doublerequested_position)"

.PP
Move method for binary i/o motor objects\&. \fBParameters:\fP
.RS 4
\fImp\fP A binary i/o motor object 
.br
\fIrequested_position\fP a 1 or a 0 request to move 
.RE
.PP

.PP
Definition at line 2570 of file lspmac\&.c\&.
.PP
.nf
                                {


  pthread_mutex_lock( &(mp->mutex));
  mp->requested_position = requested_position == 0\&.0 ? 0\&.0 : 1\&.0;
  mp->requested_pos_cnts = requested_position == 0\&.0 ? 0 : 1;

  if( mp->requested_position == mp->position) {
    //
    // No real move requested
    //
    mp->not_done     = 0;
    mp->motion_seen  = 1;
    mp->command_sent = 1;
    lsevents_send_event( '%s Moving', mp->name);
    lsevents_send_event( '%s In Position', mp->name);

  } else {
    //
    // Go ahead and send the request
    //
    mp->not_done     = 1;
    mp->motion_seen  = 0;
    mp->command_sent = 0;
    lspmac_SockSendDPline( mp->name, mp->write_fmt, mp->requested_pos_cnts);
  }

  pthread_mutex_unlock( &(mp->mutex));
  return 0;
}
.fi
.SS "int lspmac_moveabs_flight_factor_queue (\fBlspmac_motor_t\fP *mp, doublepos)"

.PP
Definition at line 2681 of file lspmac\&.c\&.
.PP
.nf
                                                                        {
  char *fmt;

  if( pos >= 60 && pos <= 140) {
    pthread_mutex_lock( &(mp->mutex));
    *mp->actual_pos_cnts_p = pos;
    mp->position =           pos;
    pthread_mutex_unlock( &(mp->mutex));

    pthread_mutex_lock( &(flight->mutex));

    fmt = lsredis_getstr( flight->redis_fmt);
    lsredis_setstr( flight->u2c, fmt, pos / 100\&.0);
    free( fmt);

    pthread_mutex_unlock( &(flight->mutex));

    flight->moveAbs( flight, lspmac_getPosition( zoom));
    return 0;
  }
  return 1;
}
.fi
.SS "int lspmac_moveabs_frontlight_oo_queue (\fBlspmac_motor_t\fP *mp, doublepos)"

.PP
'move' frontlight on/off 
.PP
Definition at line 2668 of file lspmac\&.c\&.
.PP
.nf
                                                                        {
  pthread_mutex_lock( &(mp->mutex));
  *mp->actual_pos_cnts_p = pos;
  mp->position =           pos;
  pthread_mutex_unlock( &(mp->mutex));
  if( pos == 0\&.0) {
    flight->moveAbs( flight, 0\&.0);
  } else {
    flight->moveAbs( flight, lspmac_getPosition( zoom));
  }
  return 0;
}
.fi
.SS "int lspmac_moveabs_fshut_queue (\fBlspmac_motor_t\fP *mp, doublerequested_position)"

.PP
Move method for the fast shutter\&. Slightly more complicated than a binary io as some flags need to be set up\&. \fBParameters:\fP
.RS 4
\fImp\fP The fast shutter motor instance 
.br
\fIrequested_position\fP 1 (open) or 0 (close), really 
.RE
.PP

.PP
Definition at line 2540 of file lspmac\&.c\&.
.PP
.nf
                                  {
  pthread_mutex_lock( &(mp->mutex));

  mp->requested_position = requested_position;
  mp->not_done    = 1;
  mp->motion_seen = 0;
  mp->requested_pos_cnts = requested_position;
  if( requested_position != 0) {
    //
   // ScanEnable=0, ManualEnable=1, ManualOn=1
    //
    lspmac_SockSendDPline( mp->name, 'M1124=0 M1125=1 M1126=1');
  } else {
    //
    // ManualOn=0, ManualEnable=0, ScanEnable=0
    //
    lspmac_SockSendDPline( mp->name, 'M1126=0 M1125=0 M1124=0');
  }

  pthread_mutex_unlock( &(mp->mutex));

  return 0;

}
.fi
.SS "int lspmac_moveabs_queue (\fBlspmac_motor_t\fP *mp, doublerequested_position)"

.PP
Use coordinate system motion program, if available, to move motor to requested position\&. \fBParameters:\fP
.RS 4
\fImp\fP The motor to move 
.br
\fIrequested_position\fP Where to move it 
.RE
.PP

.PP
Definition at line 3525 of file lspmac\&.c\&.
.PP
.nf
                            {
  
  return lspmac_move_or_jog_abs_queue( mp, requested_position, 0);
}
.fi
.SS "void lspmac_moveabs_timed_queue (\fBlspmac_motor_t\fP *mp, doublestart, doubledelta, doubletime)"

.PP
timed motor move \fBParameters:\fP
.RS 4
\fImp\fP Our motor object 
.br
\fIstart\fP Beginning of motion 
.br
\fIdelta\fP Distance to move 
.br
\fItime\fP to move it in (secs) 
.RE
.PP
< Flags needed for wait routine 
.PP
Definition at line 2611 of file lspmac\&.c\&.
.PP
.nf
                                  {
  // 240                LS-CAT Timed X move
  //            Q10    = Starting X value (cnts)
  //            Q11    = Delta X value   (cnts)
  //            Q12    = Time to run between the two points (mSec)
  //            Q13    = Acceleration time (msecs)
  //            Q100   = 1 << (coord sys no - 1)

  int q10;       // Starting value (counts)
  int q11;       // Delta (counts)
  int q12;       // Time to run (msecs)
  int q13;       // Acceleration time (msecs)
  int q100;      // 1 << (coord sys no - 1)
  int coord_num; // our coordinate number
  double u2c;
  double neutral_pos;
  double max_accel;

  pthread_mutex_lock( &(mp->mutex));

  u2c         = lsredis_getd( mp->u2c);
  max_accel   = lsredis_getd( mp->max_accel);
  coord_num   = lsredis_getl( mp->coord_num);
  neutral_pos = lsredis_getd( mp->neutral_pos);

  if( u2c == 0\&.0 || time <= 0\&.0 || max_accel <= 0\&.0) {
    //
    // Shouldn't try moving a motor that has bad motion parameters
    //
    pthread_mutex_unlock( &(mp->mutex));
    return;
  }

  mp->not_done    = 1;          
  mp->motion_seen = 0;

  mp->requested_position = start + delta;
  mp->requested_pos_cnts = u2c * (mp->requested_position + neutral_pos);
  q10 = mp->requested_pos_cnts;
  q11 = u2c * delta;
  q12 = 1000 * time;
  q13 = q11 / q12 / max_accel;
  q100 = 1 << (coord_num - 1);
  pthread_mutex_unlock( &(mp->mutex));

  pthread_mutex_lock( &(mp->mutex));
  lspmac_SockSendDPline( mp->name, '&%d Q10=%d Q11=%d Q12=%d Q13=%d Q100=%d B240R', coord_num, q10, q11, q12, q13, q100);
  pthread_mutex_unlock( &(mp->mutex));
}
.fi
.SS "int lspmac_moveabs_wait (\fBlspmac_motor_t\fP *mp, doubletimeout_secs)"

.PP
Wait for motor to finish moving\&. Assume motion already queued, now just wait
.PP
\fBParameters:\fP
.RS 4
\fImp\fP The motor object to wait for 
.br
\fItimeout_secs\fP The number of seconds to wait for\&. Fractional values fine\&. 
.RE
.PP

.PP
Definition at line 3551 of file lspmac\&.c\&.
.PP
.nf
                                                                  {
  struct timespec timeout, now;
  double isecs, fsecs;
  int err;

  //
  // Copy the queue item for the most recent move request
  //
  clock_gettime( CLOCK_REALTIME, &now);

  fsecs = modf( timeout_secs, &isecs);

  timeout\&.tv_sec  = now\&.tv_sec  + (long)floor( isecs);
  timeout\&.tv_nsec = now\&.tv_nsec + (long)floor( fsecs * 1\&.0e9);
  
  timeout\&.tv_sec  += timeout\&.tv_nsec / 1000000000;
  timeout\&.tv_nsec %= 1000000000;

  err = 0;
  pthread_mutex_lock( &(mp->mutex));
  
  while( err == 0 && mp->command_sent == 0)
    err = pthread_cond_timedwait( &mp->cond, &mp->mutex, &timeout);
  pthread_mutex_unlock( &(mp->mutex));
  if( err != 0) {
    if( err != ETIMEDOUT) {
      lslogging_log_message( 'lspmac_moveabs_wait: unexpected error from timedwait %d  tv_sec %ld   tv_nsec %ld', err, timeout\&.tv_sec, timeout\&.tv_nsec);
    }
    return 1;
  }

  //
  // wait for the motion to have started
  // This will time out if the motion ends before we can read the status back
  // hence the added complication of time stamp of the sent packet\&.

  err = 0;
  pthread_mutex_lock( &(mp->mutex));
  while( err == 0 && mp->motion_seen == 0)
    err = pthread_cond_timedwait( &(mp->cond), &(mp->mutex), &timeout);
  
  if( err != 0) {
    if( err != ETIMEDOUT) {
      lslogging_log_message( 'lspmac_moveabs_wait: unexpected error from timedwait: %d  tv_sec %ld   tv_nsec %ld', err, timeout\&.tv_sec, timeout\&.tv_nsec);
    }
    pthread_mutex_unlock( &(mp->mutex));
    return 1;
  }

  //
  // wait for the motion that we know has started to finish
  //
  err = 0;
  while( err == 0 && mp->not_done)
    err = pthread_cond_timedwait( &(mp->cond), &(mp->mutex), &timeout);

  
  if( err != 0) {
    if( err != ETIMEDOUT) {
      lslogging_log_message( 'lspmac_moveabs_wait: unexpected error from timedwait: %d  tv_sec %ld   tv_nsec %ld', err, timeout\&.tv_sec, timeout\&.tv_nsec);
    }
    pthread_mutex_unlock( &(mp->mutex));
    return 1;
  }

  //
  // if return code was not 0 then we know we shouldn't wait for not_done flag\&.
  // In this case the motion ended before we read the status registers
  //
  pthread_mutex_unlock( &(mp->mutex));
  return 0;
}
.fi
.SS "int lspmac_movedac_queue (\fBlspmac_motor_t\fP *mp, doublerequested_position)"

.PP
Move method for dac motor objects (ie, lights) \fBParameters:\fP
.RS 4
\fImp\fP Our motor 
.br
\fIrequested_position\fP Desired x postion (look up and send y position) 
.RE
.PP

.PP
Definition at line 2406 of file lspmac\&.c\&.
.PP
.nf
                            {
  double u2c;

  pthread_mutex_lock( &(mp->mutex));

  u2c = lsredis_getd( mp->u2c);
  mp->requested_position = requested_position;

  if( mp->nlut > 0 && mp->lut != NULL) {
    //
    // u2c scales the lookup table value
    //
    mp->requested_pos_cnts = u2c * lspmac_lut( mp->nlut, mp->lut, requested_position);

    lslogging_log_message( 'lspmac_movedac_queue: motor %s requested position %f  requested counts %d  u2c %f',
                           mp->name, mp->requested_position, mp->requested_pos_cnts, u2c);

    mp->not_done    = 1;
    mp->motion_seen = 0;

    lspmac_SockSendDPline( mp->name, '%s=%d', mp->dac_mvar, mp->requested_pos_cnts);
  }

  pthread_mutex_unlock( &(mp->mutex));
  return 0;
}
.fi
.SS "int lspmac_movezoom_queue (\fBlspmac_motor_t\fP *mp, doublerequested_position)"

.PP
Move method for the zoom motor\&. \fBParameters:\fP
.RS 4
\fImp\fP the zoom motor 
.br
\fIrequested_position\fP our desired zoom 
.RE
.PP

.PP
Definition at line 2439 of file lspmac\&.c\&.
.PP
.nf
                             {
  int motor_num;
  int in_position_band;

  //lslogging_log_message( 'lspmac_movezoom_queue: Here I am');
  pthread_mutex_lock( &(mp->mutex));

  motor_num        = lsredis_getl( mp->motor_num);
  in_position_band = lsredis_getl( mp->in_position_band);

  mp->requested_position = requested_position;

  if( mp->nlut > 0 && mp->lut != NULL) {
    mp->requested_pos_cnts = lspmac_lut( mp->nlut, mp->lut, requested_position);

    if( abs( mp->requested_pos_cnts - mp->actual_pos_cnts) * 16 <= in_position_band) {
      lslogging_log_message( 'lspmac_movezoom_queue: Faking move');
      //
      // fake the move
      //
      mp->not_done     = 1;
      mp->motion_seen  = 0;
      mp->command_sent = 1;
      pthread_mutex_unlock( &(mp->mutex));
      lsevents_send_event( '%s Moving', mp->name);

      //
      // Perhaps give someone else a chance to process the move
      //
      pthread_mutex_lock( &(mp->mutex));
      mp->not_done     = 0;
      mp->motion_seen  = 1;
      mp->command_sent = 1;
      pthread_mutex_unlock( &(mp->mutex));
      lsevents_send_event( '%s In Position', mp->name);
      return 0;
    }

    mp->not_done     = 1;
    mp->motion_seen  = 0;
    mp->command_sent = 0;
    
    lspmac_SockSendDPline( mp->name, '#%d j=%d', motor_num, mp->requested_pos_cnts);
  }
  pthread_mutex_unlock( &(mp->mutex));
  //lslogging_log_message( 'lspmac_movezoom_queue: There you were');
  return 0;
}
.fi
.SS "void lspmac_next_state ()"

.PP
State machine logic\&. Given the current state, generate the next one 
.PP
Definition at line 2236 of file lspmac\&.c\&.
.PP
.nf
                         {


  //
  // Connect to the pmac and perhaps initialize it\&.
  // OK, this is slightly more than just the state
  // machine logic\&.\&.\&.
  //
  if( ls_pmac_state == LS_PMAC_STATE_DETACHED) {
    //
    // TODO (eventually)
    // This ip address wont change in a single PMAC installation
    // We'll need to audit the code if we decide to implement
    // multiple PMACs so might as well wait til then\&.
    //
    lsConnect( '192\&.6\&.94\&.5');

    //
    // If the connect was successful we can proceed with the initialization
    //
    if( ls_pmac_state != LS_PMAC_STATE_DETACHED) {
      lspmac_SockFlush();
      
      //
      // Harvest the I and M variables in case we need them
      // one day\&.
      //
      if( getmvars) {
        lspmac_GetAllMVars();
        getmvars = 0;
      }
      
      if( getivars) {
        lspmac_GetAllIVars();
        getivars = 0;
      }
    }
  }

  //
  // Check the command queue and perhaps go to the 'Send Command' state\&.
  //
  if( ls_pmac_state == LS_PMAC_STATE_IDLE) {
    int goodtogo;
    goodtogo = 0;
    pthread_mutex_lock( &lspmac_ascii_mutex);
    if( lspmac_ascii_busy==0 && lspmac_dpascii_on != lspmac_dpascii_off)
      goodtogo = 1;
    pthread_mutex_unlock( &lspmac_ascii_mutex);
    if( goodtogo)
      lspmac_SockSendDPqueue();
  }

  if( ls_pmac_state == LS_PMAC_STATE_IDLE && ethCmdOn != ethCmdOff)
    ls_pmac_state = LS_PMAC_STATE_SC;


  //
  // Set the events flag
  // to tell poll what we are waiting for\&.
  //
  switch( ls_pmac_state) {
  case LS_PMAC_STATE_DETACHED:
    //
    // there shouldn't be a valid fd, so ignore the events
    //
    pmacfd\&.events = 0;
    break;

  case LS_PMAC_STATE_IDLE:
    if( ethCmdOn == ethCmdOff) {
      //
      // Anytime we are idle we want to
      // get the status of the PMAC
      //

      lspmac_get_status();
    }



  //
  // These states require that we listen for packets
  //
  case LS_PMAC_STATE_WACK_NFR:
  case LS_PMAC_STATE_WACK:
  case LS_PMAC_STATE_WACK_CC:
  case LS_PMAC_STATE_WACK_RR:
  case LS_PMAC_STATE_WCR:
  case LS_PMAC_STATE_WGB:
  case LS_PMAC_STATE_GMR:
    pmacfd\&.events = POLLIN;
    break;
    
  //
  // These states require that we send packets out\&.
  //
  case LS_PMAC_STATE_SC:
  case LS_PMAC_STATE_CR:
  case LS_PMAC_STATE_RR:
  case LS_PMAC_STATE_GB:
    //
    // Sad fact: PMAC will fail to process commands if we send them too quickly\&.
    // We deal with that by waiting a tad before we let poll tell us the PMAC socket is ready to write\&.
    //
    gettimeofday( &now, NULL);
    if(  ((now\&.tv_sec * 1000000\&. + now\&.tv_usec) - (pmac_time_sent\&.tv_sec * 1000000\&. + pmac_time_sent\&.tv_usec)) < PMAC_MIN_CMD_TIME) {
      pmacfd\&.events = 0;
    } else {
      pmacfd\&.events = POLLOUT;
    }
    break;
  }
}
.fi
.SS "void lspmac_pmacmotor_read (\fBlspmac_motor_t\fP *mp)"

.PP
Read the position and status of a normal PMAC motor\&. \fBParameters:\fP
.RS 4
\fImp\fP Our motor 
.RE
.PP

.PP
Definition at line 1424 of file lspmac\&.c\&.
.PP
.nf
                             {
  char s[512], *sp;
  int homing1, homing2;
  double u2c;
  double neutral_pos;
  int motor_num;
  char *fmt;
  int status_changed;


  if( lsredis_getb( mp->active) != 1)
    return;

  pthread_mutex_lock( &(mp->mutex));

  //
  // if this time and last time were both 'in position'
  // and the position changed significantly then log the event
  //
  // On E omega has been observed to change by 0x10000 on its own
  // with no real motion\&.
  //
  if( mp->status2 & 1 && mp->status2 == *mp->status2_p && abs( mp->actual_pos_cnts - *mp->actual_pos_cnts_p) > 256) {
    //    lslogging_log_message( 'Instantaneous change: %s old status1: %0x, new status1: %0x, old status2: %0x, new status2: %0x, old cnts: %0x, new cnts: %0x',
    //                             mp->name, mp->status1, *mp->status1_p, mp->status2, *mp->status2_p, mp->actual_pos_cnts, *mp->actual_pos_cnts_p);

    //
    // At this point we'll just log the event and return
    // There is no reason to believe the change is real\&.
    //
    // There is a non-zero probability that the first value is the bad one and any value afterwards will be taken as
    // wrong\&.  Homing (or moving) the motor should fix this\&.  There is a non-zero probably that it can happen
    // two or more times in a row after moving\&.
    //
    // TODO: account for the case where mp->actual_pos_cnts is the bad value\&.
    //
    // TODO: Is this a problem when the motor is moving?  Can we detect it?
    //
    // TODO: Think of the correct change value here (currently 256) that works for all motors
    // or have this value configurable
    //
    pthread_mutex_unlock( &(mp->mutex));
    return;
  }


  // Send an event if inPosition has changed
  //
  if( (mp->status2 & 0x000001) != (*mp->status2_p & 0x000001)) {
    lsevents_send_event( '%s %s', mp->name, (*mp->status2_p & 0x000001) ? 'In Position' : 'Moving');
  }

  // Get some values we might need later
  //
  u2c         = lsredis_getd( mp->u2c);
  motor_num   = lsredis_getl( mp->motor_num);
  neutral_pos = lsredis_getd( mp->neutral_pos);

  //
  // maybe look for omega zero crossing
  // 
  if( motor_num == 1 && omega_zero_search && *mp->actual_pos_cnts_p >=0 && mp->actual_pos_cnts < 0) {
    int secs, nsecs;

    if( omega_zero_velocity > 0\&.0) {
      secs = *mp->actual_pos_cnts_p / omega_zero_velocity;
      nsecs = (*mp->actual_pos_cnts_p / omega_zero_velocity - secs) * 1000000000;


      omega_zero_time\&.tv_sec = lspmac_status_time\&.tv_sec  - secs;
      omega_zero_time\&.tv_nsec= lspmac_status_time\&.tv_nsec;
      if( omega_zero_time\&.tv_nsec < nsecs) {
        omega_zero_time\&.tv_sec  -= 1;
        omega_zero_time\&.tv_nsec += 1000000000;
      }
      omega_zero_time\&.tv_nsec -= nsecs;

      lsevents_send_event( 'omega crossed zero');
      lslogging_log_message('lspmac_pmacmotor_read: omega zero secs %d  nsecs %d ozt\&.tv_sec %ld  ozt\&.tv_nsec  %ld, motor cnts %d',
                            secs, nsecs, omega_zero_time\&.tv_sec, omega_zero_time\&.tv_nsec, *mp->actual_pos_cnts_p);
    }
    omega_zero_search = 0;
  }


  // Make local copies so we can inspect them in other threads
  // without having to grab the status mutex
  //
  if( mp->status1 != *mp->status1_p || mp->status2 != *mp->status2_p) {
    mp->status1 = *mp->status1_p;
    mp->status2 = *mp->status2_p;
    status_changed = 1;
  } else {
    status_changed = 0;
  }
  mp->actual_pos_cnts = *mp->actual_pos_cnts_p;

  //
  // See if we are done moving, ie, in position
  //
  if( mp->status2 & 0x000001) {
    if( mp->not_done) {
      mp->not_done = 0;
      pthread_cond_signal( &(mp->cond));
    }
  } else if( mp->not_done == 0) {
    mp->not_done = 1;
  }

  // See if the motor is moving
  //
  //                move timer                  homing
  //                  123456                    123456
  if( mp->status1 & 0x020000 || mp->status1 & 0x000400) {
    if( mp->motion_seen == 0) {
      mp->motion_seen = 1;
      pthread_cond_signal( &(mp->cond));
    }
  }

  pthread_mutex_lock( &ncurses_mutex);
  mvwprintw( mp->win, 2, 1, '%*s', LS_DISPLAY_WINDOW_WIDTH-2, ' ');
  mvwprintw( mp->win, 2, 1, '%*d cts', LS_DISPLAY_WINDOW_WIDTH-6, mp->actual_pos_cnts);
  mvwprintw( mp->win, 3, 1, '%*s', LS_DISPLAY_WINDOW_WIDTH-2, ' ');
  pthread_mutex_unlock( &ncurses_mutex);

  if( mp->nlut >0 && mp->lut != NULL) {
    mp->position = lspmac_rlut( mp->nlut, mp->lut, mp->actual_pos_cnts);
  } else {
    if( u2c != 0\&.0) {
      mp->position = ((mp->actual_pos_cnts / u2c) - neutral_pos);
    } else {
      mp->position = mp->actual_pos_cnts;
    }
  }

  if( status_changed || fabs(mp->reported_position - mp->position) >= lsredis_getd(mp->update_resolution)) {
    fmt = lsredis_getstr(mp->redis_fmt);
    lsredis_setstr( mp->redis_position, fmt, mp->position);
    free(fmt);
    mp->reported_position = mp->position;
  }

  fmt = lsredis_getstr( mp->printf_fmt);
  snprintf( s, sizeof(s)-1, fmt, 8, mp->position);
  s[sizeof(s)-1] = 0;
  free( fmt);

  //
  // indicate limit problems
  //
  lsredis_setstr( mp->pos_limit_hit, mp->status1 & 0x200000 ? '1' : '0');
  lsredis_setstr( mp->neg_limit_hit, mp->status1 & 0x400000 ? '1' : '0');



  // set flag if we are not homed
  homing1 = 0;
  //                        ~(homed flag)
  if( mp->homing == 0  && (~mp->status2 & 0x000400) != 0) {
    homing1 = 1;
  }

  // set flag if we are homing and in open loop
  homing2 = 0;
  //                         open loop
  if( mp->homing == 1 && (mp->status1 & 0x040000) != 0) {
    homing2 = 1;
  }
  // maybe reset homing flag
  //                        homed flag                       in position flag
  if( (mp->homing == 2) && ((mp->status2 & 0x000400) != 0) && ((mp->status2 & 0x000001) != 0)) {
    mp->homing = 0;
    lsevents_send_event( '%s Homed', mp->name);
    lslogging_log_message( '%s homing = %d', mp->name, mp->homing);
  }

  pthread_mutex_lock( &ncurses_mutex);
  s[sizeof(s)-1] = 0;
  mvwprintw( mp->win, 3, 1, '%*s', LS_DISPLAY_WINDOW_WIDTH-6, s);

  if( status_changed) {
    mvwprintw( mp->win, 4, 1, '%*x', LS_DISPLAY_WINDOW_WIDTH-2, mp->status1);
    mvwprintw( mp->win, 5, 1, '%*x', LS_DISPLAY_WINDOW_WIDTH-2, mp->status2);
    sp = '';
    if( mp->status2 & 0x000002)
      sp = 'Following Warning';
    else if( mp->status2 & 0x000004)
      sp = 'Following Error';
    else if( mp->status2 & 0x000020)
      sp = 'I2T Amp Fault';
    else if( mp->status2 & 0x000008)
      sp = 'Amp\&. Fault';
    else if( mp->status2 & 0x000800)
      sp = 'Stopped on Limit';
    else if( mp->status1 & 0x040000)
      sp = 'Open Loop';
    else if( ~(mp->status1) & 0x080000)
      sp = 'Motor Disabled';
    else if( mp->status1 & 0x000400)
      sp = 'Homing';
    else if( (mp->status1 & 0x600000) == 0x600000)
      sp = 'Both Limits Tripped';
    else if( mp->status1 & 0x200000)
      sp = 'Positive Limit';
    else if( mp->status1 & 0x400000)
      sp = 'Negative Limit';
    else if( ~(mp->status2) & 0x000400)
      sp = 'Not Homed';
    else if( mp->status1 & 0x020000)
      sp = 'Moving';
    else if( mp->status2 & 0x000001)
      sp = 'In Position';

    mvwprintw( mp->win, 6, 1, '%*s', LS_DISPLAY_WINDOW_WIDTH-2, sp);
  
    lsredis_setstr( mp->status_str, sp);
  }
  wnoutrefresh( mp->win);
  pthread_mutex_unlock( &ncurses_mutex);

  pthread_mutex_unlock( &(mp->mutex));

  if( homing1)
    lspmac_home1_queue( mp);

  if( homing2)
    lspmac_home2_queue( mp);

  lspmac_status_last_time\&.tv_sec  = lspmac_status_time\&.tv_sec;
  lspmac_status_last_time\&.tv_nsec = lspmac_status_time\&.tv_nsec;
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_pop_queue ()"

.PP
Remove the oldest queue item\&. Used to send command to PMAC\&. Note that there is a separate reply index to ensure we've know to what command a reply is refering\&. Returns the item\&. 
.PP
Definition at line 669 of file lspmac\&.c\&.
.PP
.nf
                                     {
  pmac_cmd_queue_t *rtn;

  pthread_mutex_lock( &pmac_queue_mutex);

  if( ethCmdOn == ethCmdOff)
    rtn = NULL;
  else {
    rtn = &(ethCmdQueue[(ethCmdOff++) % PMAC_CMD_QUEUE_LENGTH]);
    clock_gettime( CLOCK_REALTIME, &(rtn->time_sent));
  }
  pthread_mutex_unlock( &pmac_queue_mutex);
  return rtn;
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_pop_reply ()"

.PP
Remove the next command queue item that is waiting for a reply\&. We always need a reply to know we are done with a given command\&. Returns the item\&. 
.PP
Definition at line 689 of file lspmac\&.c\&.
.PP
.nf
                                     {
  pmac_cmd_queue_t *rtn;

  pthread_mutex_lock( &pmac_queue_mutex);

  if( ethCmdOn == ethCmdReply)
    rtn = NULL;
  else
    rtn = &(ethCmdQueue[(ethCmdReply++) % PMAC_CMD_QUEUE_LENGTH]);

  pthread_mutex_unlock( &pmac_queue_mutex);
  return rtn;
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_push_queue (\fBpmac_cmd_queue_t\fP *cmd)"

.PP
Put a new command on the queue\&. Pointer is returned so caller can evaluate the time command was actually sent\&. \fBParameters:\fP
.RS 4
\fIcmd\fP Command to send to the PMAC 
.RE
.PP

.PP
Definition at line 645 of file lspmac\&.c\&.
.PP
.nf
                                      {
  pmac_cmd_queue_t *rtn;

  pthread_mutex_lock( &pmac_queue_mutex);
  rtn = &(ethCmdQueue[(ethCmdOn++) % PMAC_CMD_QUEUE_LENGTH]);
  memcpy( rtn, cmd, sizeof( pmac_cmd_queue_t));
  rtn->time_sent\&.tv_sec  = 0;
  rtn->time_sent\&.tv_nsec = 0;
  pthread_cond_signal( &pmac_queue_cond);
  pthread_mutex_unlock( &pmac_queue_mutex);

  return rtn;
}
.fi
.SS "void lspmac_quitting_cb (char *event)"

.PP
prepare to exit program in a couple of seconds 
.PP
Definition at line 4143 of file lspmac\&.c\&.
.PP
.nf
                                      {
  double move_time;
  int mmask;

  pgpmac_request_stay_of_execution( 1);
  fshut->moveAbs( fshut, 0\&.0);
  dryer->moveAbs( dryer, 0\&.0);
  
  lspmac_est_move_time( &move_time, &mmask,
                        aperz,  1, 'Cover', 0\&.0,
                        capz,   1, 'Cover', 0\&.0,
                        scint,  1, 'Cover', 0\&.0,
                        blight, 1,  NULL,   0\&.0,
                        flight, 1,  NULL,   0\&.0,
                        NULL);
  
  pgpmac_request_stay_of_execution( ((int)move_time) + 2);
  
}
.fi
.SS "void lspmac_request_control_response_cb (char *event)"

.PP
Definition at line 2067 of file lspmac\&.c\&.
.PP
.nf
                                                      {
  static char s[32];
  int i;

  for( i=0; i<31 && event[i] != 0; i++) {
    s[i] = 0;
    if( event[i] == ' ')
      break;
    s[i] = event[i];
  }
  s[i] = 0;
  lspmac_get_ascii( s);

}
.fi
.SS "void lspmac_Reset ()"

.PP
Clear the queue and put the PMAC into a known state\&. 
.PP
Definition at line 768 of file lspmac\&.c\&.
.PP
.nf
                    {
  ls_pmac_state = LS_PMAC_STATE_IDLE;

  // clear queue
  ethCmdReply = ethCmdOn;
  ethCmdOff   = ethCmdOn;

  lspmac_SockFlush();
}
.fi
.SS "void lspmac_reset_queue ()"

.PP
Clear the queue as part of PMAC reinitialization\&. 
.PP
Definition at line 632 of file lspmac\&.c\&.
.PP
.nf
                          {
  pthread_mutex_lock( &pmac_queue_mutex);
  ethCmdOn    = 0;
  ethCmdOff   = 0;
  ethCmdReply = 0;
  pthread_mutex_unlock( &pmac_queue_mutex);
}
.fi
.SS "double lspmac_rlut (intnlut, double *lut, doubley)"
\fBParameters:\fP
.RS 4
\fInlut\fP number of entries in lookup table 
.br
\fIlut\fP our lookup table 
.br
\fIy\fP the y value for which we need an x 
.RE
.PP

.PP
Definition at line 453 of file lspmac\&.c\&.
.PP
.nf
                     {
  int i, foundone, up;
  double m;
  double y1, y2, x1, x2, x;

  foundone = 0;
  if( lut != NULL && nlut > 1) {

    //
    // are the table values going up or down?
    //
    if( lut[1] < lut[2*nlut-1])
      up = 1;
    else
      up = 0;

    //
    // Linear search
    //
    for( i=0; i < 2*nlut; i += 2) {
      x1 = lut[i];
      y1 = lut[i+1];
      if( i < 2*nlut - 2) {
        x2 = lut[i+2];
        y2 = lut[i+3];
      }
      //
      // see if y is before the beginning of the table
      //
      if( i==0 && ( up ? y1 > y : y1 < y)) {
        x = x1;
        foundone = 1;
        break;
      }
      //
      // Did we, perhaps, nail it?
      //
      if( y1 == y) {
        x = x1;
        foundone = 1;
        break;
      }

      //
      // Interpolate between the two values (if we've not bumped our heads on the end of the table)
      //
      if( (i < 2*nlut-2) && (up ? y < y2 : y > y2)) {
        m = (x2 - x1) / (y2 - y1);
        x = m * (y - y1) + x1;
        foundone = 1;
        break;
      }
    }
    //
    // y is off the charts: just use the last value
    //
    if( foundone == 0 ) {
      x = lut[2*(nlut-1)];
    }
    return x;
  }
  return 0\&.0;
}
.fi
.SS "pthread_t* lspmac_run ()"

.PP
Start up the lspmac thread\&. 
.PP
Definition at line 4426 of file lspmac\&.c\&.
.PP
.nf
                        {
  static int first_time = 1;
  char **inits;
  lspmac_motor_t *mp;
  char evts[64];
  int i;
  int active;
  int motor_num;

  pthread_create( &pmac_thread, NULL, lspmac_worker, NULL);
  lsevents_send_event( 'LSPMAC Initializing');

  if( first_time) {
    first_time = 0;
    lsevents_add_listener( '^CryoSwitchChanged$',        lspmac_cryoSwitchChanged_cb);
    lsevents_add_listener( '^scint In Position$',        lspmac_scint_maybe_turn_on_dryer_cb);
    lsevents_add_listener( '^scint Moving$',             lspmac_scint_maybe_turn_off_dryer_cb);
    lsevents_add_listener( '^scintDried$',               lspmac_scint_dried_cb);
    lsevents_add_listener( '^backLight 1$' ,           lspmac_backLight_up_cb);
    lsevents_add_listener( '^backLight 0$' ,           lspmac_backLight_down_cb);
    lsevents_add_listener( '^cam\&.zoom Moving$',          lspmac_light_zoom_cb);
    //    lsevents_add_listener( '^Quitting Program$',         lspmac_quitting_cb);
    lsevents_add_listener( '^Control-[BCFGV] accepted$', lspmac_request_control_response_cb);
    lsevents_add_listener( '^Full Card Reset$',          lspmac_full_card_reset_cb);

    if( pgpmac_use_autoscint) {
      lsevents_add_listener( '^scint In Position$',        lspmac_scint_maybe_return_sample_cb);
      lsevents_add_listener( '^scint Moving$',             lspmac_scint_maybe_move_sample_cb);
    }

    for( i=0; i<lspmac_nmotors; i++) {
      snprintf( evts, sizeof( evts)-1, '^%s command accepted$', lspmac_motors[i]\&.name);
      evts[sizeof(evts)-1] = 0;
      lsevents_add_listener( evts, lspmac_command_done_cb);
    }



    lspmac_zoom_lut_setup();
    lspmac_flight_lut_setup();
    lspmac_blight_lut_setup();
    lspmac_fscint_lut_setup();
  }

  //
  // Clear the command interfaces
  //
  // lspmac_SockSendControlCharPrint( 'Control-X', '\x18'); // why does this kill the initialzation?

  {
    uint32_t cc;
    cc = 0;
    lspmac_send_command( VR_UPLOAD, VR_PMAC_SETMEM, 0x0e9e, 0, 4, (char *)&cc, NULL, 1, NULL);

    cc = 0x18;
    lspmac_send_command( VR_UPLOAD, VR_PMAC_SETMEM, 0x0e9e, 0, 4, (char *)&cc, NULL, 1, NULL);
  }

  //
  // Initialize the pmac's support for each motor
  // (ie, set the various flag for when a motor is active or not)
  //
  for( i=0; i<lspmac_nmotors; i++) {
    mp        = &(lspmac_motors[i]);
    active    = lsredis_getb( mp->active);
    motor_num = lsredis_getl( mp->motor_num);

    if( motor_num >= 1 && motor_num <= 32) {
      
      //
      // Set the PMAC to be consistant with redis
      //
      lspmac_SockSendDPline( NULL, 'I%d16=%f I%d17=%f I%d28=%d', motor_num, lsredis_getd( mp->max_speed), motor_num, lsredis_getd( mp->max_accel), motor_num, lsredis_getl( mp->in_position_band));
    }    

    // if there is a problem with 'active' then don't do anything
    // On the other hand, various combinations of yes/no true/fals 1/0 should work
    //
    switch( active) {
    case 1:
      inits = lsredis_get_string_array( mp->active_init);
      break;

    case 0:
      inits = lsredis_get_string_array( mp->inactive_init);
      break;

    default:
      lslogging_log_message( 'lspmac_run: motor %s is neither active nor inactive (!?)', mp->name);
      inits = NULL;
    }
    if( inits != NULL) {
      while( *inits != NULL) {
        lspmac_SockSendDPline( NULL, *inits);
        inits++;
      }
    }
  }

  


  lsevents_send_event( 'LSPMAC Done Initializing');
  return &pmac_thread;
}
.fi
.SS "void lspmac_scint_dried_cb (char *event)"

.PP
Turn off the dryer\&. \fBParameters:\fP
.RS 4
\fIevent\fP required by protocol 
.RE
.PP

.PP
Definition at line 4231 of file lspmac\&.c\&.
.PP
.nf
                                         {
  lslogging_log_message( 'lspmac_scint_dried_cb: Stopping dryer');
  dryer->moveAbs( dryer, 0\&.0);
}
.fi
.SS "void lspmac_scint_maybe_move_sample_cb (char *event)"

.PP
Perhaps we need to move the sample out of the way\&. 
.PP
Definition at line 4165 of file lspmac\&.c\&.
.PP
.nf
                                                     {
  static int trigger = 1;
  double scint_target;
  int err;
  double move_time;
  int mmask;

  pthread_mutex_lock( &scint->mutex);
  scint_target = scint->requested_position;
  pthread_mutex_unlock( &scint->mutex);
  
  // This should be pretty conservative since the out position is around 80
  //
  if( scint_target > 10\&.0) {
    if( trigger) {
      mmask = 0;
      err = lspmac_est_move_time( &move_time, &mmask,
                                  alignx, 0, 'Back', -2\&.0,
                                  aligny, 0, 'Back',  1\&.0,
                                  alignz, 0, 'Back',  1\&.0,
                                  NULL);
      if( err) {
        lspmac_abort();
        lsevents_send_event( 'Move Aborted');
        lslogging_log_message( 'lspmac_scint_maybe_move_sample_cb: Failed move request, aborting motion to keep scint from hitting sample');
      }    
      trigger = 0;
    }
  } else {
    trigger = 1;
  }
}
.fi
.SS "void lspmac_scint_maybe_return_sample_cb (char *event)"

.PP
Perhaps we need to return the sample to the beam\&. 
.PP
Definition at line 4200 of file lspmac\&.c\&.
.PP
.nf
                                                       {
  static int trigger = 1;
  double scint_target;
  double move_time;
  int mmask;

  pthread_mutex_lock( &scint->mutex);
  scint_target = scint->requested_position;
  pthread_mutex_unlock( &scint->mutex);
  
  // This should be pretty conservative since the out position is around 80
  //
  if( scint_target < 10\&.0) {
    if( trigger) {
      mmask = 0;
      lspmac_est_move_time( &move_time, &mmask,
                            alignx, 0, 'Beam',  0\&.0,
                            aligny, 0, 'Beam',  0\&.0,
                            alignz, 0, 'Beam',  0\&.0,
                            NULL);
      trigger = 0;
    }
  } else {
    trigger = 1;
  }
}
.fi
.SS "void lspmac_scint_maybe_turn_off_dryer_cb (char *event)"

.PP
Maybe stop drying off the scintilator\&. \fBParameters:\fP
.RS 4
\fIevent\fP required by protocol 
.RE
.PP

.PP
Definition at line 4086 of file lspmac\&.c\&.
.PP
.nf
                                                        {
  double pos;

  //
  // See if the dryer is on
  //
  pos = lspmac_getPosition( dryer);

  if( pos == 0\&.0)
    return;

  dryer->moveAbs( dryer, 0\&.0);
  
  lstimer_unset_timer( 'scintDried');

}
.fi
.SS "void lspmac_scint_maybe_turn_on_dryer_cb (char *event)"

.PP
Maybe start drying off the scintilator\&. \fBParameters:\fP
.RS 4
\fIevent\fP required by protocol 
.RE
.PP

.PP
Definition at line 4049 of file lspmac\&.c\&.
.PP
.nf
                                                       {
  static int trigger = 0;
  double pos;
  double cover;
  int err;

  pthread_mutex_lock( &(scint->mutex));
  pos = scint->position;
  pthread_mutex_unlock( &(scint->mutex));

  if( pos > 20\&.0) {
    trigger = 1;
    return;
  }

  if( trigger == 0) {
    return;
  }

  err = lsredis_find_preset( scint->name, 'Cover', &cover);

  lslogging_log_message( 'lspmac_scint_inPosition_cb: pos %f, cover %f, diff %f, err %d', pos, cover, fabs( pos-cover), err);

  if( err == 0)
    return;

  if( fabs( pos - cover) <= 0\&.1) {
    dryer->moveAbs( dryer, 1\&.0);
    lslogging_log_message( 'lspmac_scint_inPosition_cb: Starting dryer');
    lstimer_set_timer( 'scintDried', 1, 120, 0);
    trigger = 0;
  }
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_send_command (intrqType, intrq, intwValue, intwIndex, intwLength, char *data, void(*)(\fBpmac_cmd_queue_t\fP *, int, char *)responseCB, intno_reply, char *event)"

.PP
Compose a packet and send it to the PMAC\&. This is the meat of the PMAC communications routines\&. The queued command is returned\&. \fBParameters:\fP
.RS 4
\fIrqType\fP VR_UPLOAD or VR_DOWNLOAD 
.br
\fIrq\fP PMAC command (see PMAC User Manual 
.br
\fIwValue\fP Command argument 1 
.br
\fIwIndex\fP Command argument 2 
.br
\fIwLength\fP Length of data array 
.br
\fIdata\fP Data array (or NULL) 
.br
\fIresponseCB\fP Function to call when a response is read from the PMAC 
.br
\fIno_reply\fP Flag, non-zero means no reply is expected 
.br
\fIevent\fP base name for events 
.RE
.PP

.PP
Definition at line 707 of file lspmac\&.c\&.
.PP
.nf
                                        {
  static pmac_cmd_queue_t cmd;

  cmd\&.pcmd\&.RequestType = rqType;
  cmd\&.pcmd\&.Request     = rq;
  cmd\&.pcmd\&.wValue      = htons(wValue);
  cmd\&.pcmd\&.wIndex      = htons(wIndex);
  cmd\&.pcmd\&.wLength     = htons(wLength);
  cmd\&.onResponse       = responseCB;
  cmd\&.no_reply          = no_reply;
  cmd\&.event            = event;

  //
  // Setting the message buff bData requires a bit more care to avoid over filling it
  // or sending garbage in the unused bytes\&.
  //

  if( wLength > sizeof( cmd\&.pcmd\&.bData)) {
    //
    // Bad things happen if we do not catch this case\&.
    //
    lslogging_log_message( 'Message Length %d longer than maximum of %ld, aborting', wLength, sizeof( cmd\&.pcmd\&.bData));
    exit( -1);
  }
  if( data == NULL) {
    memset( cmd\&.pcmd\&.bData, 0, sizeof( cmd\&.pcmd\&.bData));
  } else {
    //
    // This could leave bData non-null terminated\&.  I do not know if this is a problem\&.
    //
    if( wLength > 0)
      memcpy( cmd\&.pcmd\&.bData, data, wLength);
    if( wLength < sizeof( cmd\&.pcmd\&.bData))
      memset( cmd\&.pcmd\&.bData + wLength, 0, sizeof( cmd\&.pcmd\&.bData) - wLength);
  }

  return lspmac_push_queue( &cmd);
}
.fi
.SS "void lspmac_sendcmd (char *event, void(*)(\fBpmac_cmd_queue_t\fP *, int, char *)responseCB, char *fmt, \&.\&.\&.)"

.PP
PMAC command with call back\&. \fBParameters:\fP
.RS 4
\fIevent\fP base name for events 
.br
\fIresponseCB\fP our callback routine 
.br
\fIfmt\fP printf style format string 
.RE
.PP

.PP
Definition at line 2215 of file lspmac\&.c\&.
.PP
.nf
                          {
  static char tmps[1024];
  va_list arg_ptr;

  va_start( arg_ptr, fmt);
  vsnprintf( tmps, sizeof(tmps)-1, fmt, arg_ptr);
  tmps[sizeof(tmps)-1]=0;
  va_end( arg_ptr);

  lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDLINE, 0, 0, strlen(tmps), tmps, responseCB, 0, event);
}
.fi
.SS "void lspmac_sendcmd_nocb (char *fmt, \&.\&.\&.)"

.PP
Send a command that does not need to deal with the reply\&. \fBParameters:\fP
.RS 4
\fIfmt\fP A printf style format string 
.RE
.PP

.PP
Definition at line 2196 of file lspmac\&.c\&.
.PP
.nf
                           {
  static char tmps[1024];
  va_list arg_ptr;

  va_start( arg_ptr, fmt);
  vsnprintf( tmps, sizeof(tmps)-1, fmt, arg_ptr);
  tmps[sizeof(tmps)-1]=0;
  va_end( arg_ptr);

  lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDLINE, 0, 0, strlen(tmps), tmps, NULL, 0, NULL);
}
.fi
.SS "void lspmac_SendControlReplyPrintCB (\fBpmac_cmd_queue_t\fP *cmd, intnreceived, char *buff)"

.PP
Receive a reply to a control character Print a 'printable' version of the character to the terminal Followed by a hex dump of the response\&. \fBParameters:\fP
.RS 4
\fIcmd\fP Queue item this is a reply to 
.br
\fInreceived\fP Number of bytes received 
.br
\fIbuff\fP Buffer of bytes received 
.RE
.PP

.PP
Definition at line 1037 of file lspmac\&.c\&.
.PP
.nf
                                      {
  
  char *sp;
  int i;

  sp = calloc( nreceived+1, 1);
  for( i=0; i<nreceived; i++) {
    if( buff[i] == 0)
      break;
    if( isascii(buff[i]) && !iscntrl(buff[i]))
      sp[i] = buff[i];
    else
      sp[i] = ' ';
  }
  sp[i] = 0;

  lslogging_log_message( 'control-%c: %s', '@'+ ntohs(cmd->pcmd\&.wValue), sp);
  free( sp);
}
.fi
.SS "void lspmac_Service (struct pollfd *evt)"

.PP
Service routine for packet coming from the PMAC\&. All communications is asynchronous so this is the only place incomming packets are handled \fBParameters:\fP
.RS 4
\fIevt\fP pollfd object returned by poll 
.RE
.PP

.PP
Definition at line 808 of file lspmac\&.c\&.
.PP
.nf
                      {
  static char *receiveBuffer = NULL;    // the buffer inwhich to stick our incomming characters
  static int receiveBufferSize = 0;             // size of receiveBuffer
  static int receiveBufferIn = 0;               // next location to write to in receiveBuffer
  pmac_cmd_queue_t *cmd;                        // maybe the command we are servicing
  ssize_t nsent, nread;                         // nbytes dealt with
  int i;                                        // loop counter
  int foundEOCR;                                // end of command response flag

  if( evt->revents & (POLLERR | POLLHUP | POLLNVAL)) {
    if( evt->fd != -1) {
      close( evt->fd);
      evt->fd = -1;
    }
    ls_pmac_state = LS_PMAC_STATE_DETACHED;
    return;
  }


  if( evt->revents & POLLOUT) {

    switch( ls_pmac_state) {
    case LS_PMAC_STATE_DETACHED:
      break;
    case LS_PMAC_STATE_IDLE:
      break;

    case LS_PMAC_STATE_SC:
      cmd = lspmac_pop_queue();
      if( cmd == NULL)
        return;

      if( cmd->pcmd\&.Request == VR_PMAC_GETMEM) {
        nsent = send( evt->fd, cmd, pmac_cmd_size, 0);
        if( nsent != pmac_cmd_size) {
          lslogging_log_message( 'Could only send %d of %d bytes\&.\&.\&.\&.Not good\&.', (int)nsent, (int)(pmac_cmd_size));
        }
      } else {
        nsent = send( evt->fd, cmd, pmac_cmd_size + ntohs(cmd->pcmd\&.wLength), 0);
        gettimeofday( &pmac_time_sent, NULL);
        if( nsent != pmac_cmd_size + ntohs(cmd->pcmd\&.wLength)) {
          lslogging_log_message( 'Could only send %d of %d bytes\&.\&.\&.\&.Not good\&.', (int)nsent, (int)(pmac_cmd_size + ntohs(cmd->pcmd\&.wLength)));
        }
      }

      if( cmd->pcmd\&.Request == VR_PMAC_SENDCTRLCHAR)
        ls_pmac_state = LS_PMAC_STATE_WACK_CC;
      else if( cmd->pcmd\&.Request == VR_CTRL_RESPONSE)
        ls_pmac_state = LS_PMAC_STATE_IDLE;
      else if( cmd->pcmd\&.Request == VR_PMAC_GETMEM)
        ls_pmac_state = LS_PMAC_STATE_GMR;
      else if( cmd->no_reply == 0)
        ls_pmac_state = LS_PMAC_STATE_WACK;
      else
        ls_pmac_state = LS_PMAC_STATE_WACK_NFR;
      break;

    case LS_PMAC_STATE_CR:
      /*
      switch( lspmac_control_char) {
      case 0x0002:      // Control-B    Report status word for 8 motors
      case 0x0003:      // Control-C    Report all coordinate system status words
      case 0x0006:      // Control-F    Report following errors for 8 motors
      case 0x0010:      // Control-P    Report positions for 8 motors
      case 0x0016:      // Control-V    Report velocity on 8 motors
      default:
        cr_cmd\&.wValue = htons(lspmac_control_char);
        cr_cmd\&.wLength = htons( 1400);
        nsent = send( evt->fd, &cr_cmd, pmac_cmd_size, 0);
        gettimeofday( &pmac_time_sent, NULL);
        ls_pmac_state = LS_PMAC_STATE_WCR;
        break;
      default:
        ls_pmac_state = LS_PMAC_STATE_IDLE;
      }
        */
      break;

    case LS_PMAC_STATE_RR:
      nsent = send( evt->fd, &rr_cmd, pmac_cmd_size, 0);
      gettimeofday( &pmac_time_sent, NULL);
      ls_pmac_state = LS_PMAC_STATE_WACK_RR;
      break;

    case LS_PMAC_STATE_GB:
      nsent = send( evt->fd, &gb_cmd, pmac_cmd_size, 0);
      gettimeofday( &pmac_time_sent, NULL);
      ls_pmac_state = LS_PMAC_STATE_WGB;
      break;
    }
  }

  if( evt->revents & POLLIN) {

    if( receiveBufferSize - receiveBufferIn < 1400) {
      char *newbuff;

      receiveBufferSize += 1400;
      newbuff = calloc( receiveBufferSize, sizeof( unsigned char));
      if( newbuff == NULL) {
        lslogging_log_message( 'lspmac_Service: Out of memory');
        exit( -1);
      }
      if( receiveBuffer != NULL) {
        memcpy( newbuff, receiveBuffer, receiveBufferIn);
        free(receiveBuffer);
      }
      receiveBuffer = newbuff;
    }

    nread = read( evt->fd, receiveBuffer + receiveBufferIn, 1400);

    foundEOCR = 0;
    if( ls_pmac_state == LS_PMAC_STATE_GMR) {
      //
      // get memory returns binary stuff, don't try to parse it
      //
      receiveBufferIn += nread;
    } else {
      //
      // other commands end in 6 if OK, 7 if not
      //
      for( i=receiveBufferIn; i<receiveBufferIn+nread; i++) {
        if( receiveBuffer[i] == 7) {
          //
          // Error condition
          //
          lspmac_Error( &(receiveBuffer[i]));
          receiveBufferIn = 0;
          return;
        }
        if( receiveBuffer[i] == 6) {
          //
          // End of command response
          //
          foundEOCR = 1;
          receiveBuffer[i] = 0;
          break;
        }
      }
      receiveBufferIn = i;
    }

    cmd = NULL;

    switch( ls_pmac_state) {
    case LS_PMAC_STATE_WACK_NFR:
      receiveBuffer[--receiveBufferIn] = 0;
      cmd = lspmac_pop_reply();
      ls_pmac_state = LS_PMAC_STATE_IDLE;
      break;
    case LS_PMAC_STATE_WACK:
      receiveBuffer[--receiveBufferIn] = 0;
      ls_pmac_state = LS_PMAC_STATE_RR;
      break;
    case LS_PMAC_STATE_WACK_CC:
      receiveBuffer[--receiveBufferIn] = 0;
      ls_pmac_state = LS_PMAC_STATE_CR;
      break;
    case LS_PMAC_STATE_WACK_RR:
      receiveBufferIn -= 2;
      if( receiveBuffer[receiveBufferIn])
        ls_pmac_state = LS_PMAC_STATE_GB;
      else
        ls_pmac_state = LS_PMAC_STATE_RR;
      receiveBuffer[receiveBufferIn] = 0;
      break;
    case LS_PMAC_STATE_GMR:
      cmd = lspmac_pop_reply();
      ls_pmac_state = LS_PMAC_STATE_IDLE;
      break;

    case LS_PMAC_STATE_WCR:
      cmd = lspmac_pop_reply();
      ls_pmac_state = LS_PMAC_STATE_IDLE;
      break;
    case LS_PMAC_STATE_WGB:
      if( foundEOCR) {
        cmd = lspmac_pop_reply();
        ls_pmac_state = LS_PMAC_STATE_IDLE;
      } else {
        ls_pmac_state = LS_PMAC_STATE_RR;
      }
      break;
    }


    if( cmd != NULL && cmd->onResponse != NULL) {
      cmd->onResponse( cmd, receiveBufferIn, receiveBuffer);
      receiveBufferIn = 0;
    }
  }
}
.fi
.SS "int lspmac_set_motion_flags (int *mmaskp, \fBlspmac_motor_t\fP *mp_1, \&.\&.\&.)"

.PP
Set the coordinate system motion flags (m5075) for the null terminated list of motors that we are planning on running a motion program with\&. Note that lspmac_est_move_time already takes care of this, use when calling a motion program directly
.PP
\fBParameters:\fP
.RS 4
\fImmaskp\fP Returned value of the mask generated\&. Ignored if null\&. 
.br
\fImp_1\fP start of null terminated list of motors\&. 
.RE
.PP

.PP
Definition at line 2766 of file lspmac\&.c\&.
.PP
.nf
                                                                     {
  va_list arg_ptr;
  struct timespec timeout;
  int err;
  int cn;
  int need_flag;
  lspmac_motor_t *mp;
  int mmask;

  mmask = 0;
  if( mmaskp != NULL)
    *mmaskp = 0;

  if( mp_1==NULL)
    return 0;
  
  
  //
  // add the coordinate system flags to mmask
  //
  va_start( arg_ptr, mp_1);
  for( mp = mp_1; mp!=NULL; mp = va_arg( arg_ptr, lspmac_motor_t *)) {
    if( mp->magic != LSPMAC_MAGIC_NUMBER) {
      lslogging_log_message( 'lspmac_set_motion_flags: WARNING: motor list must be NULL terminated\&.  Check your call to lspmac_set_motion_flags\&.');
      break;
    }
    cn = lsredis_getl( mp->coord_num);
    if( cn < 1 || cn > 16)
      continue;
    
    mmask |= 1 << (cn - 1);
  }
  va_end( arg_ptr);

  if( mmaskp != NULL)
    *mmaskp = mmask;
    
  //
  // It could be the flag is already what we want\&.  We might set up a race condition if we
  // try to set it again\&.  (so don't)
  //
  pthread_mutex_lock( &lspmac_moving_mutex);

  if( (lspmac_moving_flags & mmask) != 0)
    need_flag = 0;
  else
    need_flag = 1;
  
  pthread_mutex_unlock( &lspmac_moving_mutex);

  if( !need_flag)
    return 0;
  
  //
  // Set m5075 and make sure it propagates
  //
  lspmac_SockSendDPline( NULL, 'M5075=(M5075 | %d)', mmask);
  clock_gettime( CLOCK_REALTIME, &timeout);
  timeout\&.tv_sec += 2;

  err = 0;
  pthread_mutex_lock( &lspmac_moving_mutex);
  while( err == 0 && (lspmac_moving_flags & mmask) != mmask)
    err = pthread_cond_timedwait( &lspmac_moving_cond, &lspmac_moving_mutex, &timeout);

  pthread_mutex_unlock( &lspmac_moving_mutex);
  
  if( err == ETIMEDOUT) {
    lslogging_log_message( 'lspmac_set_motion_flags: timed out waiting for motion %d flag to be set', mmask);
    return 1;
  }
  return 0;
}
.fi
.SS "void lspmac_shutter_read (\fBlspmac_motor_t\fP *mp)"

.PP
Fast shutter read routine The shutter is mildly complicated in that we need to take into account the fact that the shutter can open and close again between status updates\&. This means that we need to rely on a PCL program running in the PMAC to monitor the shutter state and let us know that this has happened\&. \fBParameters:\fP
.RS 4
\fImp\fP The motor object associated with the fast shutter 
.RE
.PP

.PP
Definition at line 1227 of file lspmac\&.c\&.
.PP
.nf
                           {
  char *fmt;
  //
  // track the shutter state and signal if it has changed
  //
  pthread_mutex_lock( &lspmac_shutter_mutex);
  if( md2_status\&.fs_has_opened && !lspmac_shutter_has_opened && !md2_status\&.fs_is_open) {
    //
    // Here the shutter opened and closed again before we got the memo
    // Treat it as a shutter closed event
    //
    pthread_cond_signal( &lspmac_shutter_cond);
  }
  lspmac_shutter_has_opened = md2_status\&.fs_has_opened;

  if( lspmac_shutter_state !=  md2_status\&.fs_is_open) {
    lspmac_shutter_state = md2_status\&.fs_is_open;
    pthread_cond_signal( &lspmac_shutter_cond);
  }

  pthread_mutex_lock( &ncurses_mutex);
  if( md2_status\&.fs_is_open) {
    mvwprintw( term_status2, 1, 1, 'Shutter Open  ');
    mp->position = 1;
  } else {
    mvwprintw( term_status2, 1, 1, 'Shutter Closed');
    mp->position = 0;
  }
  pthread_mutex_unlock( &ncurses_mutex);

  if( fshut->reported_position != fshut->position) {
    fmt = lsredis_getstr( fshut->redis_fmt);
    lsredis_setstr( fshut->redis_position, fmt, fshut->position);
    lsredis_setstr( fshut->status_str, '%s', fshut->reported_position == 0 ? 'Open' : 'Closed');
    free(fmt);
    fshut->reported_position = fshut->position;
  }

  pthread_mutex_unlock( &lspmac_shutter_mutex);
}
.fi
.SS "void lspmac_SockFlush ()"

.PP
Reset the PMAC socket from the PMAC side\&. Puts the PMAC into a known communications state 
.PP
Definition at line 761 of file lspmac\&.c\&.
.PP
.nf
                        {
  lspmac_send_command( VR_DOWNLOAD, VR_PMAC_FLUSH, 0, 0, 0, NULL, NULL, 1, NULL);
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_SockGetmem (intoffset, intnbytes)"

.PP
Request a chunk of memory to be returned\&. \fBParameters:\fP
.RS 4
\fIoffset\fP Offset in PMAC Double Buffer 
.br
\fInbytes\fP Number of bytes to request 
.RE
.PP

.PP
Definition at line 1080 of file lspmac\&.c\&.
.PP
.nf
                                       {
  return lspmac_send_command( VR_UPLOAD,   VR_PMAC_GETMEM, offset, 0, nbytes, NULL, lspmac_GetmemReplyCB, 0, NULL);
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_SockSendControlCharPrint (char *event, charc)"

.PP
Send a control character\&. \fBParameters:\fP
.RS 4
\fIevent\fP base name for events 
.br
\fIc\fP The control character to send 
.RE
.PP

.PP
Definition at line 1133 of file lspmac\&.c\&.
.PP
.nf
                                                    {
  lspmac_control_char = c;
  //  return lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDCTRLCHAR, c, 0, 1400, NULL, lspmac_SendControlReplyPrintCB, 0, event);
  return lspmac_send_command( VR_UPLOAD, VR_CTRL_RESPONSE, c, 0, 1400, NULL, lspmac_SendControlReplyPrintCB, 0, event);
}
.fi
.SS "void lspmac_SockSendDPControlChar (char *event, charc)"

.PP
use dpram ascii interface to send a control character 
.PP
Definition at line 2090 of file lspmac\&.c\&.
.PP
.nf
                                                        {
  uint16_t buff;

  buff = 0x07 & c;
  lspmac_send_command( VR_UPLOAD, VR_PMAC_SETMEM, 0x0e9e, 0, 2, (char *)&buff, lspmac_SockSendDPControlCharCB, 1, event);
  if( event != NULL)
    lsevents_send_event( '%s queued', event);
}
.fi
.SS "void lspmac_SockSendDPControlCharCB (\fBpmac_cmd_queue_t\fP *cmd, intnreceived, char *buf)"

.PP
Definition at line 2083 of file lspmac\&.c\&.
.PP
.nf
                                                                                      {
  if( cmd->event != NULL && *(cmd->event))
    lsevents_send_event( '%s accepted', cmd->event);
}
.fi
.SS "void lspmac_SockSendDPline (char *event, char *fmt, \&.\&.\&.)"

.PP
prepare (queue up) a line to send the dpram ascii command interface 
.PP
Definition at line 2047 of file lspmac\&.c\&.
.PP
.nf
                                                         {
  va_list arg_ptr;
  uint32_t index;
  char *pl;
  
  pthread_mutex_lock( &lspmac_ascii_mutex);
  index = lspmac_dpascii_on++ % LSPMAC_DPASCII_QUEUE_LENGTH;

  pl = lspmac_dpascii_queue[index]\&.pl;

  va_start( arg_ptr, fmt);
  vsnprintf( pl, 159, fmt, arg_ptr);
  pl[159] = 0;
  va_end( arg_ptr);

  lspmac_dpascii_queue[index]\&.event = event;

  pthread_mutex_unlock( &lspmac_ascii_mutex);
}
.fi
.SS "void lspmac_SockSendDPqueue ()"

.PP
Definition at line 2100 of file lspmac\&.c\&.
.PP
.nf
                              {
  lspmac_dpascii_queue_t *qp;
  uint32_t mask;
  uint32_t clrdata;

  pthread_mutex_lock( &lspmac_ascii_mutex);
  qp = &(lspmac_dpascii_queue[(lspmac_dpascii_off++) % LSPMAC_DPASCII_QUEUE_LENGTH]);
  lspmac_ascii_busy = 1;
  pthread_mutex_unlock( &lspmac_ascii_mutex);

  lslogging_log_message( 'lspmac_SockSendDPqueue: %s', qp->pl);

  clrdata = 0;          // set the control word to zero
  lspmac_send_command( VR_UPLOAD, VR_PMAC_SETMEM, 0x0f40, 0, 4, (char *)&clrdata, NULL, 1, NULL);
  lspmac_send_command( VR_UPLOAD, VR_PMAC_SETMEM, 0x0e9c, 0, 4, (char *)&clrdata, NULL, 1, NULL);

  lspmac_send_command( VR_UPLOAD, VR_PMAC_SETMEM, 0x0ea0, 0, strlen(qp->pl)+1, qp->pl, NULL, 1, NULL);

  mask = 0x0001;
  lspmac_send_command( VR_UPLOAD, VR_PMAC_SETBIT, 0x0e9c, 1, sizeof( mask), (char *)&mask,lspmac_asciicmdCB, 1, qp->event);

  if( qp->event != NULL && *(qp->event) != 0)
    lsevents_send_event( '%s queued', qp->event);
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_SockSendline (char *event, char *fmt, \&.\&.\&.)"

.PP
Send a one line command\&. Uses printf style arguments\&. \fBParameters:\fP
.RS 4
\fIevent\fP base name for events 
.br
\fIfmt\fP Printf style format string 
.RE
.PP

.PP
Definition at line 1090 of file lspmac\&.c\&.
.PP
.nf
                                         {
  va_list arg_ptr;
  char payload[1400];

  va_start( arg_ptr, fmt);
  vsnprintf( payload, sizeof(payload)-1, fmt, arg_ptr);
  payload[ sizeof(payload)-1] = 0;
  va_end( arg_ptr);

  lslogging_log_message( '%s', payload);

  return lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDLINE, 0, 0, strlen( payload), payload, lspmac_GetShortReplyCB, 0, event);
}
.fi
.SS "\fBpmac_cmd_queue_t\fP* lspmac_SockSendline_nr (char *event, char *fmt, \&.\&.\&.)"

.PP
Send a command and ignore the response\&. \fBParameters:\fP
.RS 4
\fIevent\fP base name for events 
.br
\fIfmt\fP Printf style format string 
.RE
.PP

.PP
Definition at line 1113 of file lspmac\&.c\&.
.PP
.nf
                                           {
  va_list arg_ptr;
  char s[512];

  va_start( arg_ptr, fmt);
  vsnprintf( s, sizeof(s)-1, fmt, arg_ptr);
  s[sizeof(s)-1] = 0;
  va_end( arg_ptr);

  lslogging_log_message( s);

  return lspmac_send_command( VR_DOWNLOAD, VR_PMAC_SENDLINE, 0, 0, strlen( s), s, NULL, 1, event);
}
.fi
.SS "\fBlspmac_motor_t\fP* lspmac_soft_motor_init (\fBlspmac_motor_t\fP *d, char *name, int(*)(\fBlspmac_motor_t\fP *, double)moveAbs)"

.PP
Definition at line 3799 of file lspmac\&.c\&.
.PP
.nf
                                                                                                                 {

  _lspmac_motor_init( d, name);

  d->moveAbs      = moveAbs;
  d->jogAbs       = moveAbs;
  d->read         = lspmac_soft_motor_read;
  d->actual_pos_cnts_p = calloc( sizeof(int), 1);
  *d->actual_pos_cnts_p = 0;

  return d;
}
.fi
.SS "void lspmac_soft_motor_read (\fBlspmac_motor_t\fP *p)"

.PP
Dummy routine to read a soft motor\&. 
.PP
Definition at line 3794 of file lspmac\&.c\&.
.PP
.nf
                                                {

}
.fi
.SS "void lspmac_spin (\fBlspmac_motor_t\fP *mp)"

.PP
Definition at line 4414 of file lspmac\&.c\&.
.PP
.nf
                                      {
  if( strcmp( mp->name, 'omega')==0) {
    lspmac_SockSendDPline( NULL, '&%d', lsredis_getl( mp->coord_num));
    lspmac_SockSendDPline( NULL, '#%d', lsredis_getl( mp->motor_num));
    lspmac_SockSendDPline( NULL, 'j+');
  }
  return;
}
.fi
.SS "int lspmac_test_preset (\fBlspmac_motor_t\fP *mp, char *preset_name, doubletolerance)"

.PP
see if the motor is within tolerance of the preset 1 means yes, it is 0 mean no it isn't or that the preset was not found 
.PP
Definition at line 2519 of file lspmac\&.c\&.
.PP
.nf
                                                                                 {
  double preset_position;
  int err;

  err = lsredis_find_preset( mp->name, preset_name, &preset_position);
  if( err == 0)
    return 0;

  if( fabs( preset_position - lspmac_getPosition( mp)) <= tolerance)
    return 1;

  return 0;
}
.fi
.SS "void lspmac_video_rotate (doublesecs)"

.PP
Special motion program to collect centering video\&. 
.PP
Definition at line 2728 of file lspmac\&.c\&.
.PP
.nf
                                       {
  double q10;           // starting position (counts)
  double q11;           // delta counts
  double q12;           // milliseconds to run over delta
  
  double u2c;
  double neutral_pos;

  if( secs <= 0\&.0)
    return;

  omega_zero_search = 1;

  pthread_mutex_lock( &(omega->mutex));
  u2c         = lsredis_getd( omega->u2c);
  neutral_pos = lsredis_getd( omega->neutral_pos);

  q10 = neutral_pos * u2c;
  q11 = 360\&.0 * u2c;
  q12 = 1000 * secs;
  

  omega_zero_velocity = 360\&.0 * u2c / secs;      // counts/second to back calculate zero crossing time

  lspmac_SockSendDPline( omega->name, '&1 Q10=%\&.1f Q11=%\&.1f Q12=%\&.1f Q13=(I117) Q14=(I116) B240R', q10, q11, q12);
  pthread_mutex_unlock( &(omega->mutex));
}
.fi
.SS "void* lspmac_worker (void *dummy)"

.PP
Our lspmac worker thread\&. \fBParameters:\fP
.RS 4
\fIdummy\fP Unused but required by pthread library 
.RE
.PP

.PP
Definition at line 2354 of file lspmac\&.c\&.
.PP
.nf
                      {
  static int disconnected_notify = 0;
  static int old_state;

  old_state = ls_pmac_state;
  while( lspmac_running) {
    int pollrtn;

    lspmac_next_state();

    if( ls_pmac_state != old_state) {
      //lslogging_log_message( 'lspmac_worker: state = %d', ls_pmac_state);
      old_state = ls_pmac_state;
    }

    if( pmacfd\&.fd == -1) {
      if( disconnected_notify == 0)
        lslogging_log_message( 'lspmac_worker: PMAC not connected');
      disconnected_notify = 1;
      //
      // At this point we assume we became disconnected due to something like a hard boot of the MD2 PMAC
      // and hence the entire system needs reinitialization\&.
      //
      // It's possible to put in a test here (perhaps using I65) to see if we in fact suffered a reset
      // and need to clear the queue, reinitialize, etc\&.  Or if it was just a networking glitch and do not
      // need to clear the queue and should instead just charge ahead\&.
      //
      lspmac_reset_queue();
      sleep( 10);
      //
      // This just puts us into a holding pattern until the pmac becomes connected again
      //
      continue;
    }
    disconnected_notify = 0;

    pollrtn = poll( &pmacfd, 1, 10);
    if( pollrtn) {
      lspmac_Service( &pmacfd);
    }
  }
  pthread_exit( NULL);
}
.fi
.SS "void lspmac_zoom_lut_setup ()"

.PP
Set up lookup table for zoom\&. 
.PP
Definition at line 4239 of file lspmac\&.c\&.
.PP
.nf
                             {
  int i;
  lsredis_obj_t *p;
  double neutral_pos;

  neutral_pos = lsredis_getd( zoom->neutral_pos);

  pthread_mutex_lock( &zoom->mutex);

  zoom->nlut = 10;
  zoom->lut = calloc( 2 * zoom->nlut, sizeof( double));
  if( zoom->lut == NULL) {
    lslogging_log_message( 'lspmac_zoom_lut_setup: out of memory');
    exit( -1);
  }

  for( i=0; i < zoom->nlut; i++) {
    p = lsredis_get_obj( 'cam\&.zoom\&.%d\&.MotorPosition', i+1);
    if( p==NULL || strlen( lsredis_getstr(p)) == 0) {
      free( zoom->lut);
      zoom->lut  = NULL;
      zoom->nlut = 0;
      pthread_mutex_unlock( &zoom->mutex);
      lslogging_log_message( 'lspmac_zoom_lut_setup: cannot find MotorPosition element for cam\&.zoom level %d', i+1);
      return;
    }
    zoom->lut[2*i]   = i+1;
    zoom->lut[2*i+1] = lsredis_getd( p);// + neutral_pos;
  }
  pthread_mutex_unlock( &zoom->mutex);
}
.fi
.SH "Variable Documentation"
.PP 
.SS "\fBlspmac_motor_t\fP* alignx"

.PP
Alignment stage X\&. 
.PP
Definition at line 101 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* aligny"

.PP
Alignment stage Y\&. 
.PP
Definition at line 102 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* alignz"

.PP
Alignment stage X\&. 
.PP
Definition at line 103 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* anal"

.PP
Polaroid analyzer motor\&. 
.PP
Definition at line 104 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* apery"

.PP
Aperture Y\&. 
.PP
Definition at line 106 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* aperz"

.PP
Aperture Z\&. 
.PP
Definition at line 107 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* arm_parked"

.PP
(whose arm? parked where?) 
.PP
Definition at line 144 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* blight"

.PP
Back Light DAC\&. 
.PP
Definition at line 118 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* blight_down"

.PP
Backlight is down\&. 
.PP
Definition at line 134 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* blight_f"

.PP
Back light scale factor\&. 
.PP
Definition at line 127 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* blight_ud"

.PP
Back light Up/Down actuator\&. 
.PP
Definition at line 122 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* blight_up"

.PP
Backlight is up\&. 
.PP
Definition at line 135 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* capy"

.PP
Capillary Y\&. 
.PP
Definition at line 108 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* capz"

.PP
Capillary Z\&. 
.PP
Definition at line 109 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* cenx"

.PP
Centering Table X\&. 
.PP
Definition at line 111 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* ceny"

.PP
Centering Table Y\&. 
.PP
Definition at line 112 of file lspmac\&.c\&.
.SS "\fBpmac_cmd_t\fP cr_cmd\fC [static]\fP"

.PP
commands to send out 'readready', 'getbuffer', 'controlresponse' (initialized in main) 
.PP
Definition at line 196 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* cryo"

.PP
Move the cryostream towards or away from the crystal\&. 
.PP
Definition at line 123 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* cryo_back"

.PP
cryo is in the back position 
.PP
Definition at line 136 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* cryo_switch"

.PP
that little toggle switch for the cryo 
.PP
Definition at line 133 of file lspmac\&.c\&.
.SS "unsigned char dbmem[64 *1024]\fC [static]\fP"

.PP
double buffered memory 
.PP
Definition at line 185 of file lspmac\&.c\&.
.SS "int dbmemIn = 0\fC [static]\fP"

.PP
next location 
.PP
Definition at line 186 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* dryer"

.PP
blow air on the scintilator to dry it off 
.PP
Definition at line 124 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* etel_init_ok"

.PP
ETEL initialized OK\&. 
.PP
Definition at line 141 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* etel_on"

.PP
ETEL is on\&. 
.PP
Definition at line 140 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* etel_ready"

.PP
ETEL is ready\&. 
.PP
Definition at line 139 of file lspmac\&.c\&.
.SS "unsigned int ethCmdOff = 0\fC [static]\fP"

.PP
points to current command (or none if == ethCmdOn) 
.PP
Definition at line 199 of file lspmac\&.c\&.
.SS "unsigned int ethCmdOn = 0\fC [static]\fP"

.PP
points to next empty PMAC command queue position 
.PP
Definition at line 198 of file lspmac\&.c\&.
.SS "\fBpmac_cmd_queue_t\fP ethCmdQueue[\fBPMAC_CMD_QUEUE_LENGTH\fP]\fC [static]\fP"

.PP
PMAC command queue\&. 
.PP
Definition at line 197 of file lspmac\&.c\&.
.SS "unsigned int ethCmdReply = 0\fC [static]\fP"

.PP
Used like ethCmdOff only to deal with the pmac reply to a command\&. 
.PP
Definition at line 200 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* flight"

.PP
Front Light DAC\&. 
.PP
Definition at line 117 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* flight_f"

.PP
Front light scale factor\&. 
.PP
Definition at line 128 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* flight_oo"

.PP
Turn front light on/off\&. 
.PP
Definition at line 126 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* fluo"

.PP
Move the fluorescence detector in/out\&. 
.PP
Definition at line 125 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* fluor_back"

.PP
fluor is in the back position 
.PP
Definition at line 137 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* fscint"

.PP
Scintillator Piezo DAC\&. 
.PP
Definition at line 119 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* fshut"

.PP
Fast shutter\&. 
.PP
Definition at line 116 of file lspmac\&.c\&.
.SS "\fBpmac_cmd_t\fP gb_cmd\fC [static]\fP"

.PP
Definition at line 196 of file lspmac\&.c\&.
.SS "int getivars = 0\fC [static]\fP"

.PP
flag set at initialization to send i vars to db 
.PP
Definition at line 89 of file lspmac\&.c\&.
.SS "int getmvars = 0\fC [static]\fP"

.PP
flag set at initialization to send m vars to db 
.PP
Definition at line 90 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* hp_air"

.PP
High pressure air OK\&. 
.PP
Definition at line 132 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* kappa"

.PP
Kappa\&. 
.PP
Definition at line 113 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* lp_air"

.PP
Low pressure air OK\&. 
.PP
Definition at line 131 of file lspmac\&.c\&.
.SS "int ls_pmac_state = \fBLS_PMAC_STATE_DETACHED\fP\fC [static]\fP"

.PP
Current state of the PMAC communications state machine\&. 
.PP
Definition at line 58 of file lspmac\&.c\&.
.SS "\fBlspmac_ascii_buffers_t\fP lspmac_ascii_buffers\fC [static]\fP"

.PP
Definition at line 365 of file lspmac\&.c\&.
.SS "pthread_mutex_t lspmac_ascii_buffers_mutex"

.PP
Definition at line 366 of file lspmac\&.c\&.
.SS "int lspmac_ascii_busy = 0\fC [static]\fP"

.PP
flag for condition to wait for 
.PP
Definition at line 76 of file lspmac\&.c\&.
.SS "pthread_mutex_t lspmac_ascii_mutex\fC [static]\fP"

.PP
Keep too many processes from sending commands at once\&. 
.PP
Definition at line 75 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP lspmac_bis[32]"

.PP
array of binary inputs 
.PP
Definition at line 92 of file lspmac\&.c\&.
.SS "uint16_t lspmac_control_char = 0\fC [static]\fP"

.PP
The control character we've sent\&. 
.PP
Definition at line 73 of file lspmac\&.c\&.
.SS "uint32_t lspmac_dpascii_off = 0\fC [static]\fP"

.PP
Definition at line 376 of file lspmac\&.c\&.
.SS "uint32_t lspmac_dpascii_on = 0\fC [static]\fP"

.PP
Definition at line 375 of file lspmac\&.c\&.
.SS "\fBlspmac_dpascii_queue_t\fP lspmac_dpascii_queue[\fBLSPMAC_DPASCII_QUEUE_LENGTH\fP]\fC [static]\fP"

.PP
Definition at line 374 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP lspmac_motors[\fBLSPMAC_MAX_MOTORS\fP]"

.PP
All our motors\&. 
.PP
Definition at line 96 of file lspmac\&.c\&.
.SS "pthread_cond_t lspmac_moving_cond"

.PP
Wait for motor(s) to finish moving condition\&. 
.PP
Definition at line 70 of file lspmac\&.c\&.
.SS "int lspmac_moving_flags"

.PP
Flag used to implement motor moving condition\&. 
.PP
Definition at line 71 of file lspmac\&.c\&.
.SS "pthread_mutex_t lspmac_moving_mutex"

.PP
Coordinate moving motors between threads\&. 
.PP
Definition at line 69 of file lspmac\&.c\&.
.SS "int lspmac_nbis = 0"

.PP
number of active binary inputs 
.PP
Definition at line 93 of file lspmac\&.c\&.
.SS "int lspmac_nmotors = 0"

.PP
The number of motors we manage\&. 
.PP
Definition at line 97 of file lspmac\&.c\&.
.SS "int lspmac_running = 1\fC [static]\fP"

.PP
exit worker thread when zero 
.PP
Definition at line 64 of file lspmac\&.c\&.
.SS "pthread_cond_t lspmac_shutter_cond"

.PP
Allows waiting for the shutter status to change\&. 
.PP
Definition at line 68 of file lspmac\&.c\&.
.SS "int lspmac_shutter_has_opened"

.PP
Indicates that the shutter had opened, perhaps briefly even if the state did not change\&. 
.PP
Definition at line 66 of file lspmac\&.c\&.
.SS "pthread_mutex_t lspmac_shutter_mutex"

.PP
Coordinates threads reading shutter status\&. 
.PP
Definition at line 67 of file lspmac\&.c\&.
.SS "int lspmac_shutter_state"

.PP
State of the shutter, used to detect changes\&. 
.PP
Definition at line 65 of file lspmac\&.c\&.
.SS "struct timespec lspmac_status_last_time\fC [static]\fP"

.PP
Time the status was read\&. 
.PP
Definition at line 82 of file lspmac\&.c\&.
.SS "struct timespec lspmac_status_time\fC [static]\fP"

.PP
Time the status was read\&. 
.PP
Definition at line 81 of file lspmac\&.c\&.
.SS "\fBmd2_status_t\fP md2_status\fC [static]\fP"

.PP
Buffer for MD2 Status\&. 
.PP
Definition at line 351 of file lspmac\&.c\&.
.SS "pthread_mutex_t md2_status_mutex"

.PP
Synchronize reading/writting status buffer\&. 
.PP
Definition at line 352 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* minikappa_ok"

.PP
Minikappa is OK (whatever that means) 
.PP
Definition at line 142 of file lspmac\&.c\&.
.SS "struct hsearch_data motors_ht"

.PP
A hash table to find motors by name\&. 
.PP
Definition at line 98 of file lspmac\&.c\&.
.SS "struct timeval pmac_time_sent now\fC [static]\fP"

.PP
used to ensure we do not send commands to the pmac too often\&. Only needed for non-DB commands\&. 
.PP
Definition at line 192 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* omega"

.PP
MD2 omega axis (the air bearing) 
.PP
Definition at line 100 of file lspmac\&.c\&.
.SS "int omega_zero_search = 0\fC [static]\fP"

.PP
Indicate we'd really like to know when omega crosses zero\&. 
.PP
Definition at line 78 of file lspmac\&.c\&.
.SS "struct timespec omega_zero_time"

.PP
Time we believe that omega crossed zero\&. 
.PP
Definition at line 80 of file lspmac\&.c\&.
.SS "double omega_zero_velocity = 0\fC [static]\fP"

.PP
rate (cnts/sec) that omega was traveling when it crossed zero 
.PP
Definition at line 79 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* phi"

.PP
Phi (not data collection axis) 
.PP
Definition at line 114 of file lspmac\&.c\&.
.SS "char* pmac_error_strs[]\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= {
  'ERR000: Unknown error',
  'ERR001: Command not allowed during program execution',
  'ERR002: Password error',
  'ERR003: Data error or unrecognized command',
  'ERR004: Illegal character',
  'ERR005: Command not allowed unless buffer is open',
  'ERR006: No room in buffer for command',
  'ERR007: Buffer already in use',
  'ERR008: MACRO auziliary communication error',
  'ERR009: Program structure error (e\&.g\&. ENDIF without IF)',
  'ERR010: Both overtravel limits set for a motor in the C\&.S\&.',
  'ERR011: Previous move not completed',
  'ERR012: A motor in the coordinate system is open-loop',
  'ERR013: A motor in the coordinate system is not activated',
  'ERR014: No motors in the coordinate system',
  'ERR015: Not pointer to valid program buffer',
  'ERR016: Running improperly structure program (e\&.g\&. missing ENDWHILE)',
  'ERR017: Trying to resume after H or Q with motors out of stopped position',
  'ERR018: Attempt to perform phase reference during move, move during phase reference, or enabling with phase clock error',
  'ERR019: Illegal position-chage command while moves stored in CCBUFFER',
  'ERR020: FSAVE issued on Turbo PMAC with incompatible flash memory',
  'ERR021: FSAVE issued while clearing old flash memory sector',
  'ERR022: FREAD attempted but the flash memory is bad'
}
.fi
.PP
Decode the errors perhaps returned by the PMAC\&. 
.PP
Definition at line 203 of file lspmac\&.c\&.
.SS "pthread_cond_t pmac_queue_cond"

.PP
wait for a command to be sent to PMAC before continuing 
.PP
Definition at line 86 of file lspmac\&.c\&.
.SS "pthread_mutex_t pmac_queue_mutex"

.PP
manage access to the pmac command queue 
.PP
Definition at line 85 of file lspmac\&.c\&.
.SS "pthread_t pmac_thread\fC [static]\fP"

.PP
our thread to manage access and communication to the pmac 
.PP
Definition at line 84 of file lspmac\&.c\&.
.SS "struct pollfd pmacfd\fC [static]\fP"

.PP
our poll structure 
.PP
Definition at line 87 of file lspmac\&.c\&.
.SS "\fBpmac_cmd_t\fP rr_cmd\fC [static]\fP"

.PP
Definition at line 196 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* sample_detected"

.PP
smart magnet detected sample 
.PP
Definition at line 138 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* scint"

.PP
Scintillator Z\&. 
.PP
Definition at line 110 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* shutter_open"

.PP
shutter is open (note in pmc says this is a slow input) 
.PP
Definition at line 145 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* smart_mag_err"

.PP
smart magnet error (coil broken perhaps) 
.PP
Definition at line 146 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* smart_mag_off"

.PP
smart magnet is off 
.PP
Definition at line 147 of file lspmac\&.c\&.
.SS "\fBlspmac_bi_t\fP* smart_mag_on"

.PP
smart magnet is on 
.PP
Definition at line 143 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* smart_mag_oo"

.PP
Smart Magnet on/off\&. 
.PP
Definition at line 121 of file lspmac\&.c\&.
.SS "\fBlspmac_motor_t\fP* zoom"

.PP
Optical zoom\&. 
.PP
Definition at line 105 of file lspmac\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for LS-CAT PGPMAC from the source code\&.
